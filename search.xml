<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>两只金乌 （3更）</title>
      <link href="/2020/10/08/essay-%E4%B8%A4%E5%8F%AA%E9%87%91%E4%B9%8C/"/>
      <url>/2020/10/08/essay-%E4%B8%A4%E5%8F%AA%E9%87%91%E4%B9%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　相传在盘古开天辟地后不久，天地间仍处在某种混沌，在这漫长的时间中诞生的是一种金色的鸟，它被人们称为金乌。</p><p>　　　　——《華嵇纪-卷三》</p><a id="more"></a><h2 id="金乌-（一）"><a href="#金乌-（一）" class="headerlink" title="金乌 （一）"></a>金乌 （一）</h2><p>　　“金乌”是我在乡下采风的时候，偶然从小镇里的一个当铺的老板那听来的事情。他显然不是很清楚金乌具体是什么，只是神神叨叨地说这是一种不可靠近的神鸟，通体金色，凡靠近之物均不可逃脱灰飞烟灭的命运。看着他一脸的严肃，这毫无疑问勾起了我的好奇心，开始在坊间搜索关于这个“金乌”的故事。我发现这里的像我这样的年轻人，大都不太知道这个事情；但老人们或多或少都听过这个故事。他们对于这个事情的表述没能更加详细，只是慢慢得知了所谓“金乌”可能是复数的存在，甚至可能是一个“种族”，如果我们能这样称呼。</p><p>　　这样无谓的搜索持续了约莫两周的时间，也接近了我采风得到的假期的时间的尾声。尽管期间一直在这周围打探“金乌”的故事，但总归觉得这还是在迷雾里的一个东西，是一个比传说更为难以信任的东西。但我相信所谓传说皆具有某种源头，而这个源头就是我感兴趣的东西。抱着最后的期待，我走进了当地的图书馆的古籍区，打算在这里碰碰运气。</p><p>　　正当我搜索到一部叫做《華嵇纪》的时候，我突然产生了某种灵感，笃定这本就是我一直在寻找的东西了。我顺着他的编号朝着书架上寻去的时候，却发现这本书不在架上。它被借走了？我很失望地回到检索处。这些小挫折难以击败我这样折腾的人，于是我开始不依不饶地询问检索处的工作人员，连珠炮地询问着，“这本书现在在哪里？”，“哪里有它的副本或者有谁知道这本书情况？”等等的问题。工作人员陷入了某种茫然，慌乱地回答着：“它不在书架上吗？”，“哦哦，我不清楚它的情况，但我认为图书管理员或许知道”。然后我追问道，“那图书管理员现在在哪呢？”。工作人员便又开始吱吱唔唔了。</p><p>　　尽管工作人员的无用超出了我的想象，但还是给我指出了一个方向，“在那边有个小梯子，那个梯子一直往上，通向一个小阁楼间。阁楼间里是我们图书管理员的办公室，你去那里问问。”这是我知道的一切新鲜的信息了。</p><p>　　尽管不怀什么期待，我还是爬上了这个梯子，见到了一个空空的小房间——里面空无一人。这是一个非常非常小的房间，四处的装潢也是崭新的，仿佛家具是刚刚才被搬放至此，没有任何沾上的灰尘，这对一个阁楼来说简直难以置信。这里摆放的东西也让我认识到这里的工作人员很快会回来。于是我暂时离开了图书馆，到了对面的一家面馆，打算随便吃点什么。但这里的人山人海的吃饭场景让我食欲全无。匆匆吃完，发现现在还没到图书馆上班的时间，不得不在旁边的一家小茶馆里面整理这段时间采风的成果。然而由于我过于执着于金乌，自己的工作进展反而是一筹莫展，觉得这次的采风终归是失败了。</p><p>　　对自己的工作感到失望之后，我再一次回到了那个阁楼里的小房间。“不，我不知道有这本书。哦，或许说我听说过，但不详细了解。”，“不，我不是古籍区的管理员，我是图书馆的管理员。”，“你不该来找我，你应该去三楼的那个总管理部。他们或许会知道。”然后我得知了如何到达图书馆三楼——这实在是非常费劲的一条路。</p><p>　　在我找到他们所指的总管理部的房间时（事实上，我在中间绕了很多很多的路，三楼有非常繁复的办公室设置，每一次我敲开一扇门，都会有一个铁板一样的脸出现告诉我，“对，我们是总管理部，但不我们不负责你希望询问的内容。不是我们这里，你应该去检索处问清楚。”），我第一次感到如释重负。</p><p>　　“请问，我在找一本叫做《華嵇纪》的古籍，请问你们知道这本书现在在哪里吗？检索处告诉我这本书并没有被借阅，但……”我试图组织我的语言。“但它不在这里对吧？”管理人员看着我。“对，我想……”我注意到他直愣愣地看着我，但还是不得不接下去，“我想知道这本书在哪里，我想立刻借阅它。对，我想立刻借阅它，我赶时间。”</p><p>　　他看了我好一阵子，好像仔细的考究着我的眼睛和鼻子的位置是否正确一样最终得到了准确的结果一般，终于开口了。“你的情况我清楚了。你希望立刻借走一本没有被标注为借出的书，或者他的副本……”此刻他桌上的电铃响了，然后他结束了到嘴边的言论，说了句失陪然后快步离开了办公室。我窘迫地站在那里。</p><p>　　大概一刻钟后，管理人员回到了办公室，在自己的椅子里坐下，在文件里一阵翻找之后，“对的，对的。我知道了，我今天早上刚刚收到一份整理的古籍清单。清单显示你要的那本书，在一楼小梯子通往的阁楼里存放着。不过那本书非常破败了，你可能看不到它。如果你想看到这本书，你需要找那里的管理员。”“可是我刚刚从那里过来”，我小声抗议。“如果可以”，管理人员看着我，“你能告诉我你找那本书做什么？我看过那本书，或许还记得什么。”我感到我露出了一个吃惊的表情。“真的？那太好了，我在找关于‘金乌’的事情，请问您知道吗？”“对，我知道，那个‘金乌’。”</p><h2 id="金乌-（二）"><a href="#金乌-（二）" class="headerlink" title="金乌 （二）"></a>金乌 （二）</h2><p>　　“如果我没记错的话”，他说了这句话后停了下来，开始在文件堆里翻找着什么东西，尽管我们都知道他翻找的动作并不会帮助他回答这个问题。“《華嵇纪》里确实有着关于‘金乌’的记录，但还是不甚详细。有这么一句话，‘相传在盘古开天辟地后不久，天地间仍处在某种混沌，在这漫长的时间中诞生的是一种金色的鸟，它被人们称为金乌。’我记得很清楚。”</p><p>　　我草草地在笔记本上记下这句话，这基本上是这段时间最为切实、明确的进步了，但还是，存在于语言这种转瞬即逝的载体之中，甚至我连自己是否有一部分字没听清而理解错误都全然不清。就在我这样思考的时候，声音在这个房间中的混响也结束了，于是我不得不重复一遍他的话以得到确认。他点了点头，同时示意自己也不记得更多的细节了。“总之你可以去一楼阁楼拿到那本书，如果一切顺利的话，它应该在那里。”</p><p>　　事情发展至此，我不敢认为关于“金乌”，我能从这本书里找到更多的细节，于是我点了点头，对他表示感谢，然后离开了。但我很快意识到，在这个小镇里，对金乌感兴趣的不止我一个。</p><p>　　在我的上次徒劳的搜索后的两天的早晨，我所居住的宾馆前台告诉我有一位女士曾经给我打过电话，关于“金乌”的事情。我很激动地记下那个电话号码，向宾馆道谢后匆匆忙忙走到外面的电话亭，拨下那个号码。不一会，我听到听筒里传来一个女性的声音，“请问您是那天搜索那个‘金乌’的先生吗？”“是的是的，请问女士是？”</p><p>　　我明显感觉到对方有些许迟疑，但还是立刻答道，“我也是搜索‘金乌’的人之一，我在小镇的图书馆里和检索处询问一本叫做《華嵇纪》的时候，检索处工作人员告诉我，就在两天前有位先生也问过这部书的事情，她给了我一个电话，于是我迟疑地打了过来，发现接电话的是宾馆的前台……所以……”听到对方这样说，我不免失望——这意味着对方知道的信息应该不比我更多。我把我收集到的信息一五一十地告诉了她。“这样吧，我希望再去一次图书馆。我想自己找到那本古籍看看。”我感到些许无奈，但还是只能回答说，“好，我也打算这样做来着。不然就明天吧？”然后是一些琐碎的约定。</p><p>　　第二天，早晨八点半的时候，我在图书馆的门口看见了一位端庄的女性，相当文质彬彬。既然是追踪“金乌”的人，自然是一个研究传说或者民俗之类的学者了（除了我这种仅仅出于游手好闲性质的）。我向她挥了挥手，示意她我就是那个搜索金乌的先生。</p><p>　　“哦，早。”“嗯，早。”套路的见面礼结束后，还是有些许尴尬。“那我们进去吧？”在进去的过程中，我再一次简单地向她说了一遍自己那天在图书馆里的糟糕经历。这一次我有了明确的目的地，那个曾向我背诵过《華嵇纪》内容的管理人员。我直觉地知道这是位某种意义上的“该书籍”的最高管理者。</p><p>　　因为我已经来过了三层的总管理部，这一次我很快找到了这个地方，见到了上一次的那个管理人员。我示意让女士先进去说明来意，自己也紧跟着进去了。管理人员的回复和之前并没有什么差异，依然是让我们去一楼阁楼间找图书管理员。但我们不依不饶地问了许久，管理人员表示自己在下午会给我们一个回复，关于那本古籍现在在哪里、是否可借阅这种种问题都会一一告知我们。我们心满意足地离开了三楼总管理部。</p><p>　　“现在我们去哪里？去一楼阁楼吗？说不定能直接看到《華嵇纪》。”我点头表示同意。不久后我们站在了一楼阁楼间的地板上。这里的一尘不染等等特点完全如同上次，这一次书籍管理员正坐在我们进门正对的那个办公桌上。上面的台灯发出橙黄色的光线，让整个房间的整洁呈现出了一种奇特的氛围。“嗯……那个……”站在我身旁的女士打算开口，“我们是来询问关于《華嵇纪》的事情的。总管理部的人说，这部书现在正在你们这里，请问我们能看一下吗？我们只对这本书的一部分感兴趣。”“啊，很遗憾！我们并不知道这本书在哪里，正像我们之前告诉过你们的这样。这样的书籍不会经过我们管理员之手，而是直接交给古籍管理员。”“但我们怎么找到这个古籍管理员？”“这个我也告诉过你们了。”图书管理员很不悦地看着我们两个。</p><p>　　很快图书管理员似乎看出她的态度太强硬，便补上了几句。大概是说她确实不知道情况，这些书不经由她们之手，我们找到古籍管理员一定能要到这本书云云的话。并且对总管理部管理人员记忆的段落表示不予评论，“我没看过这本书，它压根没到我的手上。”然后又紧接着说，建议我们不要接着找这本书给图书馆带来麻烦云云的话，又表示那本书没有什么价值云云。我们简单地堆笑应付了一下就离开了。</p><p>　　“我查找了这里的所有文件，关于那本《華嵇纪》的。”管理人员转动着他的小转椅，“记录这有关它信息的，有且仅有我说的那个关于古籍的清单，除此之外，我找到了一些专家。他们有的肯定地表示我的回忆是精确的，但这本书恐怕已经不容易找到了。它或许作为重点的保护对象保护起来了。”我们正想追问更多的细节，但管理人员露出某种无可奉告的神情，把我们请出了总管理部。</p><p>　　这个时候我才突然想起，“你是为什么需要找到这部书？”这位动人的女士回答道，“我是研究民俗的学者。我在研究中发现在一系列讨论宇宙生成的传说记载中，都提到了一个名为‘金乌’的生物，他们表示，这种生物在传说中的地位不可动摇。但是在我查找一切关于‘金乌’的论证之后，发现他们不可避免地引用了这本名为《華嵇纪》的古籍。然而我跑遍了大半个都城，都没找到这部神秘的古籍，我一直追踪至此，找到了关于它的些许线索终于也在这里断掉了。”</p><p>　　她停止了讲述看着我，似乎想听听我寻找金乌的理由。面对这样认真的学者，我对自己的画家身份感到羞愧，也耻于告诉这位博学的女士自己仅仅是处于好奇才这样大费周折的，于是我尴尬地笑了笑，没有出声。</p><h2 id="《華嵇纪-卷三》"><a href="#《華嵇纪-卷三》" class="headerlink" title="《華嵇纪-卷三》"></a>《華嵇纪-卷三》</h2><p>　　相传在盘古开天辟地后不久，天地间仍处在某种混沌，在这漫长的时间中诞生的是一种金色的鸟，它被人们称为金乌。</p><p>　　金乌通体金黄，部分呈现赤红色，故也名赤金乌。金乌呈现鸟的形态，有宽阔的双翅，展翅可包揽视线中的全部天空。其全身仿佛被火焰包裹，以致耀眼夺目，人类不可长久直视。观看过久者眼睛会呈现异变，留下黑癍，之后该人若观察其余物体，皆会看见一淡黄色重影，并呈现出金乌的轮廓。</p><p>　　金乌每日自阴影处起飞，连续飞翔一日到阴影处停歇，凡飞过之处，皆一片光明灿烂。传说，金乌非晨起松枝所挂之露珠不饮，非夜雨后拔起之笋不食。后来，金乌渐渐隐去了踪迹，声称自己看见过金乌的人也明显变少。为铭记这种神鸟，世人为太阳起别名为金乌。（灯徽氏作。）</p><h2 id="现代的金乌（一）"><a href="#现代的金乌（一）" class="headerlink" title="现代的金乌（一）"></a>现代的金乌（一）</h2><p>　　由于各种寻找的尝试我都碰了壁，再加上自己的假期也已经在不知不觉中用尽，不得不起了归意。“这个传说虽然是从这里被我发现的，却不意味着这个传说只有这里才有。”我一边把我这几日的衣服收进包裹里一边这样想。我走到旅馆的柜台，把这几日的旅费和伙食费一并结了，突然起意想要给那位女士打一个电话。后来想想还是算了，就借旅馆的信纸随随便便写了些告辞的文字，放进了旅馆门口的邮筒然后就离开了。</p><p>　　后面回到了自己的寓所，却总是记挂着那个叫做“金乌”的生物。我尝试找了不少当地的民俗学家、民族学家，但也只能说是一无所获。有的民俗学家能说出《華嵇纪》的名字，而其他的则都摇头表示从未听闻。经过几日的折腾，虽然绘制的作品还在缓慢地推进，但心思总不在上面。每次画上几笔，便觉得索然无味，想要拿起画板就砸下去。想着“今天就到这里吧”，就掷下了笔，接着苦恼“金乌”的事情了。</p><p>　　反复苦恼了几日，一日在外出觅食途中偶然发现散落在地上的报纸。报纸上用那种廉价的纸印着夸张的大号字写成的夸张的标题。我拾起这个报纸，报纸名为《日新日报（娱乐版）》。反复翻了几次。这个报纸的报社（日新报社）是当地非常有名的一家民营企业，除了专门刊登国际或者全国要闻的核心报纸，还有许多八卦花边、娱乐活动的周边报纸。我手上的这份《娱乐版》便是报道娱乐周边的小报。大标题是某某马术比赛，哪位哪位和哪匹哪匹又夺冠了。我随便翻了翻，寻人启事、招聘岗位、治疗脚气的广告什么的，真的是应有尽有。我想了想，带着报纸回到了画室，试探性地给报社打了一个电话，问了问刊登小边角启事的要求和酬金等等。心里盘算了一下，便联系报社，打算在该报的小角落连续登个一周的广告。</p><p>　　”先生们好，鄙人系某某画社画师，日前打算以本地传说为题绘制大型主题作品。但在‘金乌’这一主题上缺乏素材。望知情人士将信息材料邮寄给本人，经验证后将重金回报。“后面是我的地址、联系方式种种。带着这个短讯造访了报社，将之交给了报社之后，我并不期望能获得什么新信息，还是就回到画室接着开始自己不安稳的创作。</p><p>　　报纸所说的”以本地传说为题“这个，其实并不是胡诌的，也的确是我目前正在从事的创作。我本次前去采风也是希望搜集这方面的线索。然而七色鹿、玉蟾蜍此类，比起这神秘的”金乌“都突然间黯然失色，也不怪我看着空白的画布灵感顿失。看着满屋子混乱不堪的景象，我才反应过来，我现在还饿着肚子。</p><h2 id="现代的金乌（二）"><a href="#现代的金乌（二）" class="headerlink" title="现代的金乌（二）"></a>现代的金乌（二）</h2><p>　　伸伸懒腰，打算出去溜达一下。我习惯性地走到楼下的收信箱，打开收信箱的盖子，抖出一大堆信件。里面多是各地画展的过时的邀约等等，夹杂着一些通过不正常方式塞进我信箱的糟糕小广告。我把这些信件摞在一起，在桌上震了震，让它们看起来规整了一点，便准备扔到最近的垃圾箱里。</p><p>　　这个时候，一个包裹的有点凸起的信件吸引了我的注意力。这封信件不像那些喷着怪异味道香水的邀请函或者小广告，只是在信封上写着收件人的姓名和地址。我把这封信挑了出来揣在了衣兜里，把别的都扔进了垃圾箱，然后开始信步四处溜达。</p><p>　　回到画室，刚刚坐下准备泡杯热茶，才想起包里还装了一封奇怪的来信。我把它从衣兜里掏出来，平展在画桌上，起身去泡了杯热茶。</p><p>　　“画家先生敬启。”</p><p>　　这恭恭敬敬的样子，和这种看起来不太精致的包装，恐怕是哪里的穷酸书生吧。我用裁纸刀划开了信件表面，看见了里面的东西。是一根不明所以的黑色羽毛和一封有着清秀字体的书信。书信写得密密麻麻，显得非常缺少纸张的样子，但是在这众多的字迹里，我抓住了这样一个词：“金乌”。难道说，这个羽毛……？！我搁下了自己的水杯，迫不及待地抓起这封信，全然不顾这封信究竟是从哪里来的、为什么会寄给我，开始了阅读。</p><p>　　（事实上，我收到这封信的时候，已经是我在报纸上刊登启事后的一个多月了。尽管对“金乌”的好奇未减，但是出于养家糊口，我不得不把自己的精力重新集中到自己的传说主题的画作上。画作的进展异常地顺利，让我渐渐忘了我在报纸上登过启事这门子事——这个事实还是在我读完这封信件，正意犹未尽的时候突然想起的。）</p><p>　　以下是我收到的信件的原文，我承诺信件的内容没有经过任何修改，一字一句甚至连一个标点都没有被擅自动过，除了我隐去了信件寄件人及其朋友的姓名，用张三李四这样的名字代替了。</p><h2 id="来信（一）"><a href="#来信（一）" class="headerlink" title="来信（一）"></a>来信（一）</h2><p>画家先生敬启，</p><p>　　抱歉贸然给您寄来此信。鄙人深知这已经是您在《日新日报》上刊登征集信息启事的三周后了。近日您未继续在该报纸上刊广告，鄙人以为您或已经完成了创作，或因没有足够信息而未能继续创作。（鄙人真诚希望事情正如前者发展。）</p><p>　　正如前文所言，鄙人此番来信，是为画家先生提供些许关于“金乌”的信息。您也不需要给什么回报，如若能助力您作出名画，鄙人便已心满意足。</p><p>　　余下不表，鄙人不止在书中见到的“金乌”一词，而是自己亲眼看过几次。此事回忆起来，已是三四年前的事情。那时间，鄙人费尽心力准备某书塾的考核，成年累月翻阅经书。然枯燥之至，每过几日，必得起身，至林木葱郁之处放松身心。其间某日，艳阳高照，恍惚间，天地昏黑，轰响阵阵；狂风大作，芳草皆俯伏，盖一大鸟自云间飞过。鄙人见识短浅，竟一时愣在原地。待大鸟飞过，轰鸣渐消，鄙人方得回神。其势惊天动地，仿佛书中所述“金乌”，然并非金色，而是通身玄黑。</p><p>　　鄙人深觉惊骇，便连连造访此地。后又见得几次大鸟。数次后，鄙人以为，大鸟于太阳升起后数时后飞起，太阳落下前数时飞回。其与《華嵇纪》中所记相差甚大，其虽声势浩大，然无令人顶礼膜拜之气质，与鄙人所想象神鸟相差甚远。尔后几日，鄙人虽仍定期造访该地，但无缘再见到真身。然而，鄙人对此大鸟乃金乌这一观点深信不疑。</p><p>　　画家先生必嗤笑鄙人所见绝非金乌。先生请想，书中所记金乌距今已不知多少时日，其岂能千百年间丝毫不变，从未演进？金乌记述渐少，并非金乌隐其身遁其形，只因其演进变化，肉眼凡胎不能辨识之，而神鸟岂需隐身遁形！且以其遮天蔽日、芳草失色之形态，不做他想。</p><p>　　随信附有鄙人经过多次探访在博物馆中找到的类似“金乌”羽毛样式的样本，但颜色和大小与鄙人所见相差甚远，仅供您参考。此外在另一个包裹中是鄙人在金乌驶过地点拾到的一小片黑鳞，鄙人猜测此为金乌的爪上遗落，故也随信寄送。然黑鳞不能放入此信封，遂将其单独包装在另一信封中一同寄送。</p><p>顺颂时祺，</p><p>张三</p><h2 id="现代的金乌（三）"><a href="#现代的金乌（三）" class="headerlink" title="现代的金乌（三）"></a>现代的金乌（三）</h2><p>　　我看完这封信不禁哑然失笑——这不是现在时髦的所谓”飞行器“这样的东西吗？这终究是个每日读书读蠢了的书呆子罢了，出去散步竟然以为自己见到了什么不得了的东西。这个所谓金乌羽毛的东西，不就是类似螺旋桨的翼片这样的东西吗？实在是有点可笑了。想到这里，便也觉得自己也是值得笑话的角色。哪里有金乌这样的东西呢？居然还在最开始对那根羽毛产生了这样的无端的猜测。算了吧，让那”金乌“去吧。我把这个之前备受我期待的信件和那根黑色的羽毛揉在一起，丢到了我的废纸篓里，想到他提及的”黑鳞“，应该是早早就被我扔到收信箱旁边的垃圾箱里了。</p><p>　　抿了口桌上的热茶，我接着完成我的画作。<br>　　<br>　　这个事件之后，我对金乌的兴趣顿时减了大半；加上工作缠身，又任何搜索金乌的进展都碰了壁，完全没有任何推进。就算是我这样游手好闲的角色，也终于奈何不了这个神秘的传说，只得作罢。往后我的工作波澜不惊，金乌也完全从我的生活中淡去。几个月后我从那个小镇的博物馆那收到了一封明信片，意思是那边收进了一批古籍，诚邀热心读者前往云云。至于这是怎么回事我也不知道了。</p><h2 id="墙上的金乌（一）"><a href="#墙上的金乌（一）" class="headerlink" title="墙上的金乌（一）"></a>墙上的金乌（一）</h2><p>　　像往常一样，我坐在自己的画布前。然而我画室的样子已经完全不同，我用自己主题展赚到的一点钱，在原来城市的隔壁购置了一个新的画室：这个画室临海，其余两面为山。这里虽然看起来偏僻，但是去最近的城市还算方便。但由于不在城市里的缘故，前来拜访的客人还是少了许多，我也幸得个清闲。为了这里的美景，我特意凿通了一面墙，改造成了大玻璃，这样能一览外面的美丽风光，顺便也让画室看起来宽敞了很多。不知道是因为周围环境变化了的缘故还是什么，一时间灵感如喷泉般涌出，所以我也能全身心地投入在创作中。</p><p>　　在我搬了新家后约莫两三个月的某日早晨，我还在叠放被子的时候，听见一阵沉稳有力的敲门声。这个地方、这个点，不太会有人来的。“画家先生，”我听见门外有个浑厚的男声在喊，“麻烦您开下门。”行吧。“好，这就来。”我把刚要叠好的被子就扔在那，带上卧室的门，走到了客厅旁的玄关。我打开门，还没来得及询问对方是谁就注意到了对方的穿着。</p><p>　　门外站着可能有一米九的壮汉，全身站得笔直，穿着浅蓝色的笔挺制服，腰上跨了一个四方形的小包，带着令人愉悦的笑容。这是民警的制服，虽说谈不上熟悉，但还是能一眼认出来。我在那里愣了一小会，“请进，请进，民警先生。”对方鞠了一小躬表示回应，然后走到了客厅的沙发旁边。我示意他先坐，然后自己去厨房准备一些红茶。一会后，我回到客厅。“请问民警先生来鄙人的小画室做什么？”我一边将茶杯递给他。这位熟练地把杯子接过去，喝了一小口，然后把杯子放了下来，前屈自己的身子看着我，“先生，您知不知道那个叫做‘金乌’的盗贼？”</p><h2 id="墙上的金乌（二）"><a href="#墙上的金乌（二）" class="headerlink" title="墙上的金乌（二）"></a>墙上的金乌（二）</h2><p>　　我迅速回想起了半年前的报纸，当时铺天盖地地报道着“金乌”的“光荣事迹”，几乎这附近的所有博物馆都曾被他光顾过，然而每次都能逃脱。我当时也产生了一点小兴趣——那已经是我停止调查“金乌”后的一年多了。这个“金乌”之所以被称为金乌，是因为他的每一次偷盗的展品的现场墙壁都会抄录同一段话，这也就是我曾经记下的《華嵇纪》的那一段对于金乌的表述。尽管莫名奇妙，但这个盗贼还是被民间用“金乌”称呼。<br>　　<br>　　由于警察一时间的束手无策，加上政府的高额悬赏，当时还掀起了一阵“金乌学“研究的热潮，希望从这个角度揣摩这个高调的盗贼的意图。然而线索并没有比我自己搜寻的时候多出什么，“金乌学”研究爱好者没多久就销声匿迹了。后面关于”金乌“的报道也日益减少了。我揣摩警察局顾着脸面，把一些”金乌“案件藏了起来，或者塞给了别的连环案件，避免被民众指责为无能。我很早就注意到了这个盗贼，并开始了调查。但是如同我搜索那本古籍一般，我完全找不着这个盗贼的线索。这也难怪，若我能找到，警察也就真是吃白饭的了。</p><p>　　回过神来，我注意到了正端详着我的民警。不过，民警拜访我做什么？</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode模板</title>
      <link href="/2020/10/03/tech-VSC-VSCode%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/10/03/tech-VSC-VSCode%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Snippets 即快速地插入代码片段的方法。可以通过快捷键或者自动补全生效。这里简单地记叙一下在 VsCode 下使用 Snippets 的方法，以防后日遗忘。</p><a id="more"></a><h3 id="如何配置？"><a href="#如何配置？" class="headerlink" title="如何配置？"></a>如何配置？</h3><p>Snippets 对于不同类别的文件可以使用不同的配置文件。例如对于 Markdown 来说，可以通过选择<code>File -&gt; Preferences -&gt; User Snippets</code>路径进入指令栏，输入 Markdown 进入相应的配置文件。当然也可以通过在命令栏输入<code>preferences: snippets</code>进入。<br>简单的配置文件如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">"newblog": &#123;</span><br><span class="line">"prefix": "nb",</span><br><span class="line">"body": [</span><br><span class="line">"---",</span><br><span class="line">"title: $1 ",</span><br><span class="line">"date: 2020- $2 13:53:09",</span><br><span class="line">"layout: page",</span><br><span class="line">"toc: true",</span><br><span class="line">"mathjax: true",</span><br><span class="line">"tags: [ $3 ]",</span><br><span class="line">"categories: [ $&#123;4|随笔, 技巧, 学科|&#125; ]",</span><br><span class="line">"---",</span><br><span class="line"><span class="string">"&lt;!--more--&gt; $0 "</span></span><br><span class="line">],</span><br><span class="line">"description": "create a new blog"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里的<code>prefix</code>便是触发 Snippets 的前置。Body 是主体，其中<code>$0</code>表示光标出现的位置。</p><p><strong>特殊之处</strong></p><ul><li>多光标可以通过<code>$1</code>，<code>$2</code>等表示，其表示先后到达的顺序，可以通过 Tab 键到达下一个光标位置完成修改。</li><li>同时也可以设置<code>${1|A, B|}</code>，获得到达具体位置之后的选项。</li><li>此外可以绑定变量、设置多光标等等，这里暂时用不到故忽略。</li></ul><p>除此之外，我偶然发现了一个可以添加当前时间地点的参数设定的方法，将上面的设定改写为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"newblog": &#123;</span><br><span class="line">"prefix": "nb",</span><br><span class="line">"body": [</span><br><span class="line">"---",</span><br><span class="line">"title: $TM_FILENAME_BASE ",</span><br><span class="line">"date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",</span><br><span class="line">"toc: true",</span><br><span class="line">"mathjax: true",</span><br><span class="line">"tags: [ $1 ]",</span><br><span class="line">"categories: [ $&#123;2|随笔,技巧,学科,学术|&#125; ]",</span><br><span class="line">"---",</span><br><span class="line"><span class="string">"&lt;!--more--&gt; $0 "</span></span><br><span class="line">],</span><br><span class="line">"description": "create a new blog"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这个修改的版本可以自动读出当前该文件的名字（去除尾缀）作为 Blog 的标题，读出当前的时间。基本上可以完全懒人操作了。更多的设定参考链接 <a href="https://www.clloz.com/programming/assorted/2020/09/14/vscode-snippet/" target="_blank" rel="noopener">如何使用Snippets</a></p><p>以本文为例，获得的结果为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">VSCode模板</span> </span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="number">-10</span><span class="number">-03</span> <span class="number">20</span><span class="string">:13:50</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[</span> <span class="string">]</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">[]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Smart-Suggestion"><a href="#Smart-Suggestion" class="headerlink" title="Smart Suggestion"></a>Smart Suggestion</h3><p>不知为何，Markdown 默认是不支持自动调起 VSCode Suggestion 的。解决方法有 2：</p><ol><li>在 Shortcuts 中找到 <code>Trigger Suggestion</code>，通过快捷键手动调起。</li><li>手动地将该设定添加到<code>settings.json</code>中：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"[markdown]": &#123;</span><br><span class="line">    "editor.quickSuggestions": &#123;</span><br><span class="line">      "other": true,</span><br><span class="line">      "comments": false,</span><br><span class="line">      "strings": false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样就没有遗憾了。该方法参见链接 <a href="https://deepns.github.io/tech/enable-quick-suggestions-for-markdown-in-vscode/" target="_blank" rel="noopener">Enable quick suggestions for Markdown in VS Code</a> 。</p><p>更多详情参见：<a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets" target="_blank" rel="noopener">Vscode官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> 脚本工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go常用语法</title>
      <link href="/2020/10/03/tech-Go%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/10/03/tech-Go%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>开始正式学习 Go，参考该网站 <a href="https://tour.golang.org/welcome/5" target="_blank" rel="noopener">link</a>。</p><a id="more"></a>  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 C 语言，Go 程序通过调起各种包(Packages)运行，在 Import 中是调起的其他包的路径。除此之外，Go 默认也是从 main 开始运行，所以 main 函数仍然是不可缺少的。</p><p>为引入这些包，需要这样写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"main"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Export"><a href="#Export" class="headerlink" title="Export"></a>Export</h3><p>在 Go 中，大写字母开头的值是视为 Exported 的，可以为外界调用，反之则不是。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如在下述的程序中，<code>math.pi</code>就是不可调用的，并得到这样的报错：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./prog.go:<span class="number">9</span>:<span class="number">14</span>: cannot <span class="built_in">ref</span>er to unexported name math.pi</span><br><span class="line">./prog.go:<span class="number">9</span>:<span class="number">14</span>: undefined: math.pi</span><br></pre></td></tr></table></figure><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>函数定义基本和 C 语法相同，但仍存在一些差异：例如他的形参数据类型放置在形参名字后面，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，当连续多个形参使用相同的数据类型时，可以省略除了该序列中最后一个外的所有数据类型声明，例如上面的例子可以重写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义多返回值的函数也是可以的，形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，可以在函数头上声明返回的值的 name，从而在 return 语句时不加强调。然而这种方法并未得到提倡，因为在很长的函数中，似乎可读性并不强。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数应当返回（7,10），即（x,y）对应的值。</p><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>使用 var 语句声明变量。声明的方法如同函数形参，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且参数是可以定义在 package level 的，即上例中的 c, python…除了简单的声明变量，还可以初始化，变量的数据类型和初始化的数据相关。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br><span class="line">c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br></pre></td></tr></table></figure><p>如果未显式地声明，而仅仅是使用 var 定义，则同时定义不同的数据类型是可以接受的。此外可以使用<code>:=</code>代替这种情况。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">int8</span> <span class="keyword">int16</span> <span class="keyword">int32</span> <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> ...</span><br><span class="line"><span class="keyword">byte</span></span><br><span class="line"><span class="keyword">rune</span> (<span class="keyword">int32</span>)</span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure><p>这些数据类型没有初始化时，会被赋给 0 值，如<code>int</code>对应 0,<code>srting</code>对应空字符串。</p><p><strong>类型转换</strong></p><p>类型转换使用<code>a = T(b)</code>完成，如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure><p>在 Go 中，类型转换是<strong>必须</strong>显式声明的。</p><p><strong>常量</strong></p><p>常量的声明和普通变量相同，但是需要在开头加上一个 const。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><p>需要注意的是，常量不可以使用<code>:=</code>定义。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针的形式和 C 相似，都是通过<code>*T</code>表示。定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> *p <span class="keyword">int</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">p = &amp;i</span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>取地址方法及取值方法也和 C 相同。</p><h3 id="Struct-语句"><a href="#Struct-语句" class="headerlink" title="Struct 语句"></a>Struct 语句</h3><p>声明一个新类型方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">x := v.X</span><br></pre></td></tr></table></figure><p>struct 中的值可以用<code>.</code>获得。也可以通过指针的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v := Vertex(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p := &amp;v</span><br><span class="line">p.X = <span class="number">1e9</span></span><br></pre></td></tr></table></figure><p>理论上需要通过<code>(*p).X</code>访问 X 值，然而 Go 允许，仅仅使用<code>p.X</code>直接对其进行访问。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">"hello"</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure><p>Go 通过这种方式来定义数组。他的访问和赋值都和 C 相同。Array 的长度是固定的，不可以在运行过程中修改的。在上述例子中存在一个类似 C 的初始化方法，在这个初始化中，尽管声明了 6 个整形的空间，但仅仅给了 5 个初始值，则最后的一个元素会被初始化为 0。</p><p><strong>Slide</strong></p><p>与之相关的是一个特殊的数据结构 Slide：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>这个的表现和 C 语言是完全一样的，然而和预期不同的是，这个 Slide 并不储存数据，而是仅仅类似于地址和指针一样的东西。对于 Slide 的更改会导致对于其截取的原数组的更改，并且其他包含相同元素的 Slide 也会立刻应用这些更改（因为他们只是取地址）。</p><p>对于 Slide 的元素截取和 Python 一样，可以使用<code>:</code>符号表示截取范围。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:]</span><br></pre></td></tr></table></figure><p>以上四种表达是等价的。Slide 存在 length 和 capacity 两个变量。前者为 Slide 包含的元素数量，后者为 Slide 所指向的 Array，从 Slide 包含的第一个元素开始计算的元素数。这两个值分别可以通过函数<code>len()</code>及<code>cap()</code>获取。</p><p>特殊的是，我们可以 extend Slide 的范围。对于以下的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line">s = s[:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>其并不是在 Slide s 中重新获得新的 Slide，而是在完成一次 Re-sldie。即<code>s = s[:4]</code>语句是针对最开始的长度为 6 的数组进行的。这仅仅发生在，数组的长度右端超过了 Slide 的长度并小于 Slide 的容量时才会发生，称为 Extend。</p><p><strong>Nil Slide</strong></p><p>空数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"nil!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Append</strong></p><p>类似 Python 的 list，Go 提供了一个可变长的数组。这个数组在元素超出容量时会自动再分配一个空间，然后返回的地址指向一个新的数组。其使用如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// append works on nil slices.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The slice grows as needed.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can add more than one element at a time.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Range</strong></p><p>类似 Python 的，他的 For 循环也可使用 Range 操作。Range 在每一个迭代返回一个计数器和一个对象对应的值。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">"2**%d = %d\n"</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不希望获得对应的值，则可以使用<code>_</code>代替位置。如果只希望使用 index，则只显式地记下一个值即可。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 的 0 值为<code>nil</code>，一个 nil 的 Map 既没有 key 也不能增加新的 key。Map 可以使用 make 函数初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br></pre></td></tr></table></figure><p>其中，string 是键值，Vertex 是 Map 指向的对象。Map 的访问是通过键值访问的，这个设定与 C 及 Python 都一致。下面是一个更完整的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">m[<span class="string">"Bell Labs"</span>] = Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m[<span class="string">"Bell Labs"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Map 还可以如此初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">"Bell Labs"</span>: Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"Google"</span>: Vertex&#123;</span><br><span class="line"><span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者干脆省略 Vertex 声明，改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">"Bell Labs"</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line"><span class="string">"Google"</span>: &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对 Map 的其他操作</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, key) <span class="comment">// 从字典m中删去Key及其对应的值。</span></span><br><span class="line">elem, ok := m[key] </span><br><span class="line"><span class="comment">// 如果ok == true，则字典m中存在键值key；</span></span><br><span class="line"><span class="comment">// 反之则不存在，并返回0值elem</span></span><br></pre></td></tr></table></figure><h3 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum += x</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos, neg := adder(), adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pos(i),</span><br><span class="line">neg(<span class="number">-2</span>*i),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子里，函数 adder()相当于一个“函数模型”，调用这个模型获得的是一个函数的实体即 pos, neg。而这个 sum 是这个函数模型实体的参数，所以会逐渐累加，其效果如同 C 中的 static 变量。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="For-语句"><a href="#For-语句" class="headerlink" title="For 语句"></a>For 语句</h3><p>Go 仅含有这样一种循环语句。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和 C 的语法非常像。同样的，如果不需要这三要素中的某一部分，可以完全空出来，如同 C 的操作。如上第二个或第三个 For 循环。而在 Go 中，并没有专门的 While 语句，有上述第三种 For 循环代替。</p><p>更直接的，如果希望写出一个死循环，则可以如此写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="If-语句"><a href="#If-语句" class="headerlink" title="If 语句"></a>If 语句</h3><p>和 For 语句一样，成分不需要使用括号包含。但是大括号是需要的，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 For 语句，If 语句可以在条件前增加一个初始化语句。该初始化语句的内容，在后面大括号范围内有效。例如下面的写法是有效的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%g"</span>, v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Switch-语句"><a href="#Switch-语句" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><p>Switch 语句和 C 语言相似，然而，Go 的 Switch 语句不会运行后面所有的部分，而仅仅运行满足条件的语句。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// freebsd, openbsd,</span></span><br><span class="line"><span class="comment">// plan9, windows...</span></span><br><span class="line">fmt.Printf(<span class="string">"%s.\n"</span>, os)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的程序仅会运行其中的一项，而非所有。同时这个初始化语句和 If 语句相同，是可以省略的。与 C 不同的是，这里的 Case 语句不需要是 Const，同时也不需要是整型。同时，Switch 是从上往下执行的，他会在任何一个满足条件的 Case 中停下并不再考察后面的 Case。</p><p>特殊的，我们可以声明一个不带有条件的 Switch 语句。此时，这个 Switch 语句的含义是传递一个 True 值。然而我们在 Case 的声明时，仅需要返回 true 或者 false 即可。换句话说，我们可以将其作为一个 if-then-else 的链使用。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good morning!"</span>)</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good afternoon."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good evening."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Defer-语句"><a href="#Defer-语句" class="headerlink" title="Defer 语句"></a>Defer 语句</h3><p>Defer 语句会暂停现在的所有执行，直到它环境里的其他语句执行结束后才会执行（即一个栈）。并且按照后定义的 Defer 先执行的顺序执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"!!"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上式的输出为<code>hello \n !! \n world</code>。</p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>Go 没有类，但是可以在类上定义方法。这类方法的定义和其他函数有些许不同，需要在<code>func</code>关键词到方法名间增加一个 receiver。形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也能为仅仅数据类型构造 Methods，然而它不能为其他 package 里的数据类型如此操作，或者对内建数据类型数次操作。如需要针对内建数据类型，则需要重定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，使用这样的 Receiver，不能对其含有的值进行操作。在我们需要操作其内容的时候，我们需要使用指针的 Receiver，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>对于 Methods 来说，使用实体或者指向实体的指针操作实体中的参数都是可以的。</p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface 一种特殊的数据类型，它是一系列 Methods 签名的集合。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex implements Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In the following line, v is a Vertex (not *Vertex)</span></span><br><span class="line"><span class="comment">// and does NOT implement Abser.</span></span><br><span class="line"><span class="comment">// a = v</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们说一个 Type 实现了一个 Interface，如果它存在 Interface 中声明的函数的实现。这个实现不需要显式地声明，他们的名称相同即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method means type T implements the interface I,</span></span><br><span class="line"><span class="comment">// but we don't need to explicitly declare that it does so.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">"hello"</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述例子中，存在 Interface I，Type T。其中 T 实现了 Methods M，则可以说是 Type T 实现了 Interface I。这样的 Interface 让实现和使用解耦，我们只需要关心 Interface 或者其实现，而不需要两者兼顾。</p><p>从更根本的眼光来看，Interface 是一个元组：<code>(value, type)</code>。它保存一个类型及其对应的值。对 Interface 调用一个 Method，相当于调用其代表的 type 对应的 Method。</p><p><strong>关于 nil 值</strong></p><p>存在这样的情况：Interface 对应的值不存在。但是这种情况的 Interface 并不为空，其保存了对应的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"&lt;nil&gt;"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">i = t</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">"hello"</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，t 并没有被初始化，所以对应的值是 nil 的（因为它甚至只是一个指针。）。而若去掉代码<code>i = t</code>，则 Interface i 就是一个空 Interface，此时调用<code>M()</code>就会报错。</p><p><strong>关于空 Interface</strong></p><p>对于没有声明 Methods 的 Interface 被称为“Empty Interface”。这样的 Interface 可以指向任何一个数据类型。这样的情况被用在处理不确定数据类型的时候。</p><p><strong>关于 Interface 的 Type</strong></p><p>我们有的时候需要知道 Interface 指向的 Type 是什么，此时我们这样调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></table></figure><p>如果 Type T 和 Interface i 的值完全相同，则会返回 i 对应的实体。如果类型不同则会报错。为了得知类型的同时不 raise error，我们采用下面的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure><p>如果 ok 为真，则意味着两种数据类型相同，并返回值 t；若为 false，则数据类型不同，且会返回 T 的 0 值。在这个设定下，我们可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">"Twice %v is %v\n"</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%q is %v bytes long\n"</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"I don't know about type %T!\n"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个语句比较 v 的类型。</p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Error 是一类内建的 Interface。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的函数都会返回一个 error 值，若 error 值等于 nil，则表示成功运行。他可以像上述代码的后半部分那样使用。</p><h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><h3 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h3><p>一个 Goroutines 是 Go 驱动的一个线程。以下语句会调起一个新线程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> f(x, y, z)</span><br></pre></td></tr></table></figure><p>f, x, y, z 的检验都是发现在当前的 goroutine 的，而调起的新函数则会运行在一个新的 goroutine 中。不同的 goroutine 运行在一个相同的地址空间中，所以他们的值是共享的。</p><h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>Channels 是一种类型相关的导管。我们可以通过这个东西接受或者发送值，通过运算符：<code>&lt;-</code>。类似下面的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// Send v to channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// Receive from ch, and</span></span><br><span class="line">           <span class="comment">// assign value to v.</span></span><br></pre></td></tr></table></figure><p>Channels 的定义方法和 Map 及 Slide 类似，需要借助 make 函数，定义方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>默认的情况下，这两个操作都会阻塞当前的 Channels。这样可以完成同步，并不需要显式地锁住线程。下面是一个示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Buffered Channels</strong></p><p>Channels 可以存在 Buffer。通过下面的定义方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>以上定义了 100 个 Buffer。Send 命令会 Block 仅有可能为 Buffer 已满；Receive 命令会 Block 仅有可能为 Buffer 为空。这两种情况会导致死锁错误。</p><p><strong>close</strong></p><p>Send 的过程中，可以主动关闭 Channel，即不再发送数据；Receive 可以检验某个 Channel 是否被关闭。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">v, ok := &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，Close 在这里不是必要的，除非 Receiver 需要明确地知道数据发送已经结束并终结进程。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>失衡的贝多芬</title>
      <link href="/2020/09/23/essay-music-%E5%A4%B1%E8%A1%A1%E7%9A%84%E8%B4%9D%E5%A4%9A%E8%8A%AC/"/>
      <url>/2020/09/23/essay-music-%E5%A4%B1%E8%A1%A1%E7%9A%84%E8%B4%9D%E5%A4%9A%E8%8A%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>回到上海再一次第一次进入东方艺术中心，已是近一年之后。曲目是贝多芬《第二交响曲》及《第五交响曲》。指挥家非常年轻，作为小泽征尔的弟子，表现值得期待。乐团也是未曾感受过的乐团。</p><blockquote><p>地点：上海东方艺术中心<br>指挥：俞璐<br>乐团：宁波交响乐团<br>座位：乐池正前方偏音乐厅后部<br>开始前的食物：KFC虾堡套餐</p></blockquote><a id="more"></a>  <h2 id="曲目及演绎"><a href="#曲目及演绎" class="headerlink" title="曲目及演绎"></a>曲目及演绎</h2><h3 id="《第二交响曲》"><a href="#《第二交响曲》" class="headerlink" title="《第二交响曲》"></a>《第二交响曲》</h3>    <div id="aplayer-PouYQTWr" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="550607355" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p><strong>简评</strong></p><p>No.2 并不是经常见到的一个表演曲目，一方面它自身不是非常具有特色，另一方面也是它代表着贝多芬第一时期的末端，仍然带着莫扎特的影子。</p><p>作为 D 大调的作品，整部作品四个乐章，无一不呈现出明朗积极的特征。这可能也是本次音乐会被命名为《命运与希望》（命运自然是指 No.5）的重要原因。但是这部作品呈现出了单调的、一味的积极情绪，使人并不觉得特别审美，而是有一种淡淡的困意（也和本人对这部作品并没有非常了解有关）。</p><p>整个作品的展开完全在意料之中，抒情的部分也显得不够吸引人，唯一能给人留下深刻印象的是第四乐章的第一主题，明亮且有趣，但也仅此而已了。正如前文所言，整部作品透露出浓厚的莫扎特风味，也是贝多芬第一时期的象征。</p><p>需要注意的一点是，其中第一乐章的一个乐段，在 No.9 再一次忠实地再一次出现，这肯定是贝多芬有意之举。至于这两部作品是如何连接在一起的，待考。</p><p><strong>演绎</strong></p><p>这部作品的演绎也中规中矩，没有特别可以拿出来说道的地方。干净利落，毫不拖沓。</p><h3 id="《第五交响曲》"><a href="#《第五交响曲》" class="headerlink" title="《第五交响曲》"></a>《第五交响曲》</h3>    <div id="aplayer-uYHqnIFo" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="459860068" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>第五交响曲又名命运交响曲，由于过于出名，甚至于烂俗，以致在国内几乎见不到现场的演出，演出次数更是远远赶不上不那么出圈的 No.7 &amp; No.8。这是一个相当悖论的事情。</p><p><strong>简评</strong></p><p>回到作品本身。作品呈现出明显的斗争性，第一乐章那个著名的动机，似幽灵般围绕整部作品：随着作品的推进，这个著名的动机，逐渐从一种激烈的忧郁，变成激昂的四连音，象征着某种胜利的转变。</p><p>但是这个胜利是在第三乐章发生的，第一乐章是完全的失败。“命运”的强力，将故事的主人公击倒在地，并以主人公的完全失败作结。随后进入了多愁善感的第二乐章。尽管第二乐章伊始保留着某种抒情的特征，但在后半部分，再一次呈现出了强的斗争性，然而在现在占据上风的却是某种光辉的胜利。但我们并没有得到结论，在斗争中进入了第三乐章。</p><p>第三乐章前几个小节的静谧氛围逐渐被到来的斗争逼近;随着逼近的斗争声愈加明显，我们发现这是变奏的第一乐章中所谓“命运”的动机，然而此时它不再阴郁，而是光辉、明朗，具备帝王版的威严。这是最后一次斗争，在第三乐章结束时已然奠定了局面，最后我们迎来了伟大的第四乐章。</p><p>第四乐章高昂，绝对的积极，不留余地。第三乐章和第四乐章的紧密链接让这种明亮的印象更加令人深刻——命运毫无喘息机会！大概是这样的感受。这样的胜利比 No.2 的积极和 No.9 妥协式的胜利更加积极，是纯粹得令人感动的氛围。罕见的作品。</p><p><strong>演绎</strong></p><p>演绎仍然具有相当的水准。美中不足的是其中的短笛，总是比正常的音高高出一小截，而又由于短笛所在的高频段异常抓耳，第四乐章短笛的每次进入都严重分散了我的注意力。音过高的短笛呈现出一种飘忽不定的声线，致使发声也不清晰。</p><p>其次是小号的处理。在第二乐章小号声音过大——在同时奏响的时刻，小号几乎盖住了所有的弦乐组，迫使听众丢掉了大部分细节。所幸小号在声音大的同时没有破音，令人感动。</p><p>圆号发挥非常出色，音色动人圆润，实在惊艳。在整场演出中不抢眼，但是以自身的过硬实力将自己的部分发挥到了最好。以及巴松也可圈可点，尽管在高音区发挥略有失常（一方面是巴松本来不擅长高音的原因），其余部分富有弹性的声音具有相当的美感。</p><h3 id="安可"><a href="#安可" class="headerlink" title="安可"></a>安可</h3><p>本场演出没有安可。</p><h2 id="总评"><a href="#总评" class="headerlink" title="总评"></a>总评</h2><p>总而言之是值回票价的演出。俞璐指挥的演绎可圈可点。或许师承小泽征尔的缘故，其具有相当丰富的肢体语言。在指挥的同时，动作幅度剧烈，但是富有美感，有一定观赏性。No.5 的一部分处理让整体显得不太匀称，在某些时刻有被少部分乐器带偏的感觉，但基本上维持了高水准的演绎。</p><p>两部作品我个人还是更喜欢烂俗的 No.5，No.2 由于过于明亮让我有点吃不消……</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本次的安可并没有如同预期一般出现，而是出现了俞璐的一段致辞。俞璐简单地描述了一下自己对于贝多芬的仰慕之情，并且说了一下疫情下古典乐的现状。最后吐露了一个宏伟的计划：在五天之内演出贝多芬的九部交响曲。这应当是中国古典乐从未有过的盛况。</p><p>赖于宁波市政府的赞助及 Bilibili 的支持，这样的行动才能发起。俞璐特别感谢了 Bilibili 的赞助。对于古典乐爱好者，这肯定是一个非常令人激动的信号：这个小众的群体也开始进入群众的视野。</p><p>在每次音乐会结束后回寝室的路上，一票乐迷总会各抒己见。再一次感受到自己肖斯塔听得太少了……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elementary OS双系统安装</title>
      <link href="/2020/09/22/tech-linux-Linux%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/09/22/tech-linux-Linux%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center><img src="/images/screenshot/home.png" width="80%" height="80%" /></center><p>这两日心血来潮给副系统装上了 Elementary OS。这一路配置相当地顺利，除了最后的一步。这里记录一下配置的过程及一些细节问题。</p><a id="more"></a>  <h2 id="录制DD盘"><a href="#录制DD盘" class="headerlink" title="录制DD盘"></a>录制DD盘</h2><p>这次安装的是<a href="https://elementary.io" target="_blank" rel="noopener">Elementary OS 5.1</a>，基于 Ubuntu 18.04 的发行版。在原系统下，上官网拿到了 ISO 之后就可以利用<a href="https://rufus.ie" target="_blank" rel="noopener">rufus</a>将 ISO 烧制到 USB 中。这个也是安装双系统的常用软件了。将 ISO 读出后，选择 DD 模式烧制。烧制结束后准备工作结束。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>安装系统过程非常流畅。插上烧制好的 USB，重启进入 USB 启动。可能这里会进入 Grub，而不是进入 USB。此时需要进入 Grub 中的 Configuration 将 USB 调整为最高优先级，然后重启。</p><p>重启后会进入 Elementary 的安装引导。这一路没有特别需要注意的。最后需要提及的是关于分区部分。Elementary 自动识别出了之前在我的电脑上存在的 Ubuntu 19.04，于是默认选项是在该分区上使用新的系统对其进行覆盖。如果是新的双系统的话会需要重新选择分区。</p><p>到目前为止都是非常顺畅。（请不要连接 WiFi，之后会有时间更新镜像后再 update。）</p><h2 id="进入系统"><a href="#进入系统" class="headerlink" title="进入系统"></a>进入系统</h2><p>作为 Surface Book，安装双系统（或者说 Linux）系统，不能够开箱即用，有三个问题需要解决：</p><ol><li>Linux 会在后台挂起一个不知何物的进程，这个进程会始终占用 90%左右的 CPU。</li><li>Linux 无法自动地在集成显卡和独立显卡间切换，导致耗电极快。</li><li>由于 Surface 的高分屏，Grub 界面字体非常小（尽管 Elementary 内部的分辨率是完全正常的，包括登录界面。）</li></ol><p>为了方便，请现在这个时刻安装一个 vim 吧，后面会用上的。由于 vim 体积不大，完全可以先把换源的事情放在后面，基础设定要紧。</p><h3 id="更换Kernel"><a href="#更换Kernel" class="headerlink" title="更换Kernel"></a>更换Kernel</h3><p>为解决第一个问题，需要更换 GitHub 上大神完成且预编的<a href="https://github.com/linux-surface/linux-surface" target="_blank" rel="noopener">Linux Kernel</a>。找到 Release，获取其中的三个内核文件并安装。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dpkg</span> -i <span class="regexp">*.deb</span></span><br></pre></td></tr></table></figure><p>这样三个内核文件就安装好了。此时重启，在 Grub 界面中找到 Advanced Configuration 并选择 Surface Kernel 即可。</p><p>这个步骤真的是被坑了很久才摸清楚的处理办法。对于其他的 Linux 来说，这个方法也是完全可以使用的。这个 Kernel 理论上提供了对于触摸屏、物理按键，甚至热插拔的特性，但大神预编的版本并不包含触摸屏功能。（但谁会想在 Linux 下拥有触摸屏呢……）所以预编的版本完全没有问题。</p><p>自此那个恼人的后台在重启后就不会出现了。</p><h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><p>这是选择 Ubuntu based Linux 的主要原因。之前使用 Manjaro 的时候，会发现这个步骤非常困难，但在 Ubuntu 下完全可以接受了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ubuntu-drivers <span class="built_in">auto</span>install</span><br></pre></td></tr></table></figure><p>默认的显卡驱动完全没有问题。上述命令运行结束后，显卡驱动就安装结束。为了完全切换为核显，需要先重启（否则软件内部是一片空白）。重启后，打开这个软件的 GUI 界面就正常了，切换一次设定，将之改为核显驱动，随后重启。双显卡问题就此解决。</p><p>这个也是血泪教训。尽管网路上的冲浪人士宣称 Manjaro 或者 Arch 拥有更加方便的驱动配置，但对于我来说不是这样的。</p><h3 id="Grub修改"><a href="#Grub修改" class="headerlink" title="Grub修改"></a>Grub修改</h3><p>Grub 修改完全可以和 Grub theme 的切换一起来完成了。先在<a href="https://www.gnome-look.org/browse/cat/109/order/latest/" target="_blank" rel="noopener">Gnome的主题站</a>上找到合适的 Grub 主题。我这次选择的是这个：<a href="https://www.gnome-look.org/p/1397139/" target="_blank" rel="noopener">Linux Mind</a>。说实话不好看，但是也懒得接着找了。</p><p>将下载好的主题包解压，把他移动到一个特定的位置。为了方便我们先创建一个新的文件夹：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">mkdir</span> /<span class="keyword">boot</span>/grub/themes</span><br></pre></td></tr></table></figure><p>然后把解压后的文件夹移入这个文件夹。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp 主题包名 <span class="regexp">/boot/g</span>rub<span class="regexp">/themes/</span></span><br></pre></td></tr></table></figure><p>然后修改配置文件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/grub.d/<span class="number">00</span>_header</span><br></pre></td></tr></table></figure><p>在最开始的注视内容之后添加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">GRUB_THEME</span>=<span class="string">"/boot/grub/themes/主题包名/theme.txt"</span></span><br><span class="line"><span class="attr">GRUB_GFXMODE</span>=<span class="string">"3000x2000x32"</span></span><br></pre></td></tr></table></figure><p><code>3000x2999</code>是 Surface 的分辨率。这样修改结束后，主题和分辨率就都调整好了。然后更新 Grub 配置文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo update-grub</span></span><br></pre></td></tr></table></figure><p>更新结束后重启。这一个步骤就完成了。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>但现在距离一个好用的系统还有不少的步骤……比如好用的浏览器，舒适的输入法等等。在这些开始之前需要先更换镜像。</p><h3 id="apt换源"><a href="#apt换源" class="headerlink" title="apt换源"></a>apt换源</h3><p>进入文件：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vim</span> /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure><p>如果担心的话可以先做一个备份。然后用下面的内容替代该文件所有内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#清华源</span><br><span class="line"># 默认注释了源码镜像以提高 apt <span class="keyword">update</span> 速度，如有需要可自行取消注释</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-security main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>保存退出就结束了。然后运行一下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> upgrade</span><br></pre></td></tr></table></figure><p>镜像工作至此结束。</p><h3 id="更换输入法"><a href="#更换输入法" class="headerlink" title="更换输入法"></a>更换输入法</h3><p>类似 VS Code 或者 Vivaldi 啥的都非常简单，故不赘述。这里说一下输入法的问题。原配的 IBus 在 Ubuntu 下是能用的，但不知为何在 Elementary 下不能正常使用了。正好，那我换成 Fcitx 好咯。</p><p><strong>注意</strong>：这里遇到了目前位置最为严重的 Bug。在执行这个操作以前，我可以进入”语言及区域“中的”键盘设定“处调整快捷键，但在该操作结束以后，该设定不再能被打开，并且在装回 iBus 后仍然处于不能使用状态。</p><p>Anyway，输入还是重要的，所以为了避免冲突，卸载 iBus，然后下载 Fcitx。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> fcitx fcitx-sunpinyin</span><br></pre></td></tr></table></figure><p>为了使用 Fcitx，这俩就够了。后面一个软件提供中文输入支持。</p><p>输入<code>im-config</code>设定 fcitx 为默认输入法，注销系统然后登入。</p><p>此时在 Application 处搜索 Fcitx Configuration（注意，这个需要搜索，它不会出现在目录中。），然后设定 Sunpinyin 的相关设定。此时即使选择了双拼，但输入的时候看起来仍然是全拼。这个 bug 重启之后就解决了。</p><p>然后是一些微调工作，比如将字体设定为 20 等等。</p><h3 id="Grub-customizer"><a href="#Grub-customizer" class="headerlink" title="Grub customizer"></a>Grub customizer</h3><p>尽管我们已经成功地调整了 Grub 的分辨率以及 Theme，但目前 Grub menu 非常地令人难受。为了仅保留我们需要的选项，grub customizer 作为一个 GUI 工具是一个方便的选择。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> add-apt-repository </span>ppa:danielrichter2007/grub-customizer</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install grub-customizer</span><br></pre></td></tr></table></figure><p>后面的事情就比较直接了。</p><h3 id="Fish-shell"><a href="#Fish-shell" class="headerlink" title="Fish shell"></a>Fish shell</h3><p>这个安装过很多次，应当轻车熟路了。</p><p>首先上<a href="http://fishshell.com" target="_blank" rel="noopener">官网</a>添加 ppa。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">add</span>-repository <span class="keyword">pp</span><span class="variable">a:fish</span>-<span class="keyword">shell</span>/release-<span class="number">3</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> install fish</span><br></pre></td></tr></table></figure><p>安装结束后将 fish 设为默认：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s <span class="regexp">/usr/</span>bin<span class="regexp">/fish</span></span><br></pre></td></tr></table></figure><p>然后 Shell 默认会调起 fish，之后可以使用 bash 暂时回到默认的 shell。</p><p>最后修改 fish 的 greeting messege：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> -U <span class="comment">fish_greeting</span> <span class="comment">"Bonjour! Joseph..."</span></span><br></pre></td></tr></table></figure><p>Fish 的设置结束。更多设置，使用<code>fish_config</code>查看。</p><p><strong>修改 ls 颜色</strong></p><p>此外，由于 Terminal 默认的<code>ls</code>颜色比较难以接受，所以需要手动修改。而 fish 的方法和主流不太相同，这里做一下记录。</p><p>首先需要获得系统的配色方案，在此基础上修改：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">dircolors -p &gt; <span class="string">.dircolors</span></span><br></pre></td></tr></table></figure><p>这样配色方案就存放在文件<code>.dircolors</code>中，对这个文件进行修改即可。规则不一一列举，参见文后链接。为了让这个配色方案在 fish 中生效，需要修改 fish 的设定文件。该文件位置在：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.<span class="built_in">config</span>/fish/<span class="built_in">config</span>.fish</span><br></pre></td></tr></table></figure><p>在该文件中添加：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span> (dircolors ~<span class="regexp">/.dircolors | head -n 1 | sed 's/</span>^LS_COLORS=<span class="regexp">/set -x LS_COLORS /</span>;<span class="regexp">s/;$//</span><span class="string">')</span></span><br></pre></td></tr></table></figure><p>添加结束后重启 terminal 就可以了。</p><h3 id="Autojump"><a href="#Autojump" class="headerlink" title="Autojump"></a>Autojump</h3><p>安装结束 Fish 之后，我们就可以开始配置 Autojump 了，虽然简单，但很有帮助。直接使用 apt 安装 Autojump 是不可以的。需要这样处理：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/wting/autojump.git</span><br><span class="line"><span class="keyword">cd</span> autojump</span><br><span class="line">./install.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p>然后打开文件：<code>~/.config/fish/config.fish</code>，在其中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">    <span class="built_in">set</span> --<span class="built_in">local</span> AUTOJUMP_PATH <span class="variable">$HOME</span>/.autojump/share/autojump/autojump.fish</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -e <span class="variable">$AUTOJUMP_PATH</span></span><br><span class="line">        <span class="built_in">source</span> <span class="variable">$AUTOJUMP_PATH</span></span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后关闭 Shell 再打开，设定就结束了。</p><h3 id="按键重映射"><a href="#按键重映射" class="headerlink" title="按键重映射"></a>按键重映射</h3><p>按键重映射主要是为了让 Win 键代替右 Alt 键，让他发挥一点点小作用。这里需要用到工具 xmodmap。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">xmodmap</span> -e <span class="string">"remove mod1 = Alt_R"</span></span><br><span class="line">xmodmap -e <span class="string">"add mod4 = Alt_R"</span></span><br></pre></td></tr></table></figure><p>其中<code>mod1</code>代指 Alt 键，<code>mod4</code>代指 Super 键。具体的名称可以在后面链接中找到。但是这两个命令是临时的，在系统重启后就会消失。为了避免这个问题，我们需要设定开机自启。开机自启的方法很多，但是众多尝试都失败了。</p><p>这里记录的方法依赖 Gnome 的设定。在 Application 中添加一个用来替换按键的脚本，然后就可以开机后运行了。</p><h2 id="WeChat-amp-QQ"><a href="#WeChat-amp-QQ" class="headerlink" title="WeChat &amp; QQ"></a>WeChat &amp; QQ</h2><p>有的时候这俩软件还是相当必要的。这两个软件都需要 Wine 进行驱动。为了安装这两个软件，我们需要相当繁琐的设定。</p><h3 id="安装Wine"><a href="#安装Wine" class="headerlink" title="安装Wine"></a>安装Wine</h3><p>先添加仓库：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O- http<span class="variable">s:</span>//deepin-wine.i-<span class="keyword">m</span>.dev/setup.<span class="keyword">sh</span> | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>然后安装对应的软件，表格如下：</p><div class="table-container"><table><thead><tr><th>应用</th><th>包名</th></tr></thead><tbody><tr><td>TIM</td><td>deepin.com.qq.office</td></tr><tr><td>QQ</td><td>deepin.com.qq.im</td></tr><tr><td>WeChat</td><td>deepin.com.wechat</td></tr></tbody></table></div><p>使用以下语句安装：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">apt-get</span> <span class="selector-tag">install</span> <span class="selector-tag">deepin</span><span class="selector-class">.com</span><span class="selector-class">.wechat</span></span><br></pre></td></tr></table></figure><p>至此，两个软件都可以正常地运行，但存在三个问题：</p><ol><li>字体由于分辨率奇小无比。</li><li>中文无法正常显示（因为我习惯用英文系统）。</li><li>输入框字体不能正常显示（事实证明，这个原因和 2 中原因不一样。）</li></ol><h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p>为了修正分辨率，我们需要 Wine 主体，但我们还没有安装。</p><p>在安装好了 Wine 之后，我们就开始解决乱码问题。打开<code>/opt/deepinwine/tools/run.sh</code>和<code>/opt/deepinwine/tools/run_v2.sh</code>两个文件;将其中的<code>WINE_CMD=&quot;deepin-wine&quot;</code>改为<code>WINE_CMD=&quot;LC_ALL=zh_CN.UTF-8 deepin-wine&quot;</code>。这样就解决了中文乱码。</p><p>事实上，将系统改为中文也能够解决这个问题，但，嗯……还是英文更好看一些。（以及一些翻译不合理以及不完全的位置让人觉得有点难受。）</p><h3 id="输入框问题"><a href="#输入框问题" class="headerlink" title="输入框问题"></a>输入框问题</h3><p>即使解决了上述问题，微信的输入框仍然处于乱码的状态，这是由于缺少字体。为了解决这个问题，我们将 Windows 中的字体移植到 wine 容器中的 Fonts 文件夹中，这样这个问题就解决了。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>以微信为例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">env</span> WINEPREFIX=<span class="string">"<span class="variable">$HOME</span>/.deepinwine/Deepin-WeChat"</span> winecfg</span><br></pre></td></tr></table></figure><p>会打开一个 GUI 界面用以调整屏幕分辨率。该分辨率需要针对不同的软件分别设置。该数值调整为 192 较为合适。</p><p><strong>注意</strong>：这个步骤应当先打开一次软件，待 Wine 容器初始化之后再进行，而不是在安装了软件之后立刻进行，否则不会有任何变化。</p><p>至此微信和 QQ 的安装工作结束。但是目前没有完成系统托盘的修改。目前两个软件的小托盘图标会独立显示出来，这个问题放在以后调整吧。</p><h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>Elementary 是优雅的，令人爱不释手的。在体验了一天的情况下，并没有出现令人难以理解、严重的 bug。其自带的日历、邮箱软件都充满了优雅的味道。整体的动画流畅舒适，快捷键分布自然高效。毫无疑问，这是一个满足了我目前基本需求的系统，我也愿意在短期内尝试将其作为主力使用去感受一下它的魅力。</p><center><img src="/images/screenshot/apps.png" width="100%" height="100%" /></center><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/w84963568/article/details/78884003" target="_blank" rel="noopener">更换Grub主题</a></li><li><a href="https://www.cnblogs.com/Briddle-ch/p/13369274.html" target="_blank" rel="noopener">在Ubuntu 18.04中安装Wine QQ、微信、TIM</a></li><li><a href="https://blog.csdn.net/yhuiqq788/article/details/104211021" target="_blank" rel="noopener">Wine不能正常显示中文</a></li><li><a href="https://stackoverflow.com/questions/13995857/suppress-or-customize-intro-message-in-fish-shell" target="_blank" rel="noopener">fish修改Greeting</a></li><li><a href="https://www.jianshu.com/p/c405db78091c" target="_blank" rel="noopener">Wine分辨率调整</a></li><li><a href="https://codeyarns.github.io/tech/2014-02-27-how-to-install-autojump-for-fish.html" target="_blank" rel="noopener">Autojump安装配置</a></li><li><a href="https://www.cnblogs.com/yinheyi/p/10146900.html" target="_blank" rel="noopener">xmodmap按键重映射</a></li><li><a href="https://blog.csdn.net/u013045749/article/details/53576868" target="_blank" rel="noopener">Ubuntu ls更改配色方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论告别之声</title>
      <link href="/2020/09/20/essay-music-%E5%91%8A%E5%88%AB/"/>
      <url>/2020/09/20/essay-music-%E5%91%8A%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-bTLYspOE" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1418922883" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>　　这里原来是大三下半学期（即网课期间）完成的通识课《音乐美学与实践》的期末论文。但是又想到可能以后会对部分音乐做一个评价/体会，所以考虑把这一篇抬过来做一个开头（因为里面确实包含了我对部分作品的真实感受及评价）。个人虽然是一个古典音乐的爱好者，但和门外汉并没有多少的区别，评价方法也是完全主观的（甚至不严谨的）。至于本篇中频繁提到的《马九》有幸听过现场，奈何时间久远，现在希望再回忆起细节实在是不太现实的事情。但这也是音乐的特征之一吧。总之，请将该文当作一篇完全不专业的随笔观看。（本篇中提到的作品不会附上链接，有兴趣者请自行搜索。）</p><a id="more"></a>  <p>【摘要】略</p><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>　　在文学研究中，形式与内容尽管纠缠不清，但仍能一定程度地区分开二者特点，文学中作家意义的表达更依赖于内容；而在音乐中，“乐音的内容就是乐音的运动形式” ，其形式和内涵具有先天的一致性，于是将一切的内涵都赋给其形式的音乐艺术实践成为可能，例如巴赫所作的《赋格的艺术》。但与之相对的，以舒伯特的《鳟鱼》为代表，也存在大量具有明确主题的音乐实践。<br>　　如同中国诗歌常常以“告别”作为主题，音乐也是如此。但是与中国诗歌相差甚远的是，音乐中的“告别”往往不拘束于一个特定的人，甚至不存在一个告别的具体对象，这与音乐本身高度抽象、形式美的特征是分离不开的，因而借助音乐实践对告别场景的建立也具有模糊性。而这种模糊性也使得我们讨论的“告别之声”具备独特内涵，自然也拥有讨论的价值。根据“告别”的形式与对象的不同，这个主题可以产生多样且复杂的变化。同时，“告别”这一主题也经常和“死亡省思”，“时代变迁”等等主题存在内在关联。<br>　　“告别之声”在这里特别指：借助音乐这个特殊体裁表达某种告别情愫的形式。事实上，在音乐研究中存在与之相对应的“告别叙事”（Farewell Story）这个固定的提法，并且已经发展出了独特的内核和理解，该提法在马勒作品研究中常见 。不过我们避免这个音乐分析上的固有词汇，从更直观的角度进行理解。在本文中，我们将结合对应的音乐实例，讨论音乐中埋藏的告别之声。</p><h3 id="二、告别的形式与内涵"><a href="#二、告别的形式与内涵" class="headerlink" title="二、告别的形式与内涵"></a>二、告别的形式与内涵</h3><h4 id="（一）告别的形式特征"><a href="#（一）告别的形式特征" class="headerlink" title="（一）告别的形式特征"></a>（一）告别的形式特征</h4><p>　　尽管在之前对于“告别之声”的指代进行了简单的表述，但是显得空泛而抽象，所以我们需要先更具体地确定“告别之声”指代的是哪一种音乐实践。正如前文所说，这个主题具备相当的复杂性和抽象性，使我们难以找到一个合适的范例作为出发点。所以在讨论更复杂的“告别”的内涵前，我们先试图从形式的角度理解“告别之声”，以这个为切入点再进入音乐的更深内涵理解。这里我们将分析三部不同的作品，试图找到“告别”形式上的规律。</p><h5 id="海顿《升f小调第四十五号交响曲》"><a href="#海顿《升f小调第四十五号交响曲》" class="headerlink" title="海顿《升f小调第四十五号交响曲》"></a>海顿《升f小调第四十五号交响曲》</h5><p>　　这部作品第四乐章具有“典型”的形式上的“告别”意味：其中演奏人员变少、乐器逐渐离场、演奏强度渐弱等等设计，从形式上完成了“告别”意义的表达。这里的告别对象是观众，随着整个华丽繁复的部分慢慢进入两把小提琴的演奏时，整部作品结束。这里的告别相当具象化，指“物理意义上”的告别，即将告别的意义全盘交付给形式，因此也容易被理解。而我们所希望找到的告别则是更抽象、模糊的一种音乐实践。</p><h5 id="贝多芬《降-E-大调第二十六钢琴奏鸣曲》"><a href="#贝多芬《降-E-大调第二十六钢琴奏鸣曲》" class="headerlink" title="贝多芬《降 E 大调第二十六钢琴奏鸣曲》"></a>贝多芬《降 E 大调第二十六钢琴奏鸣曲》</h5><p>　　这部作品被贝多芬分乐章地标上了题目，分别为“告别”、“缺席”、“重逢”，并且贝多芬将之题词献给自己的赞助人鲁道夫大公 ，是典型的主题音乐。所以我们可以把它当作一个相当不错的关照对象。遵循音乐速度的线索，我们可以找到一个值得关注的关键点：对于一部奏鸣曲而言，第一乐章往往采用快板，而贝多芬反常地使用了从柔板到快板的结构，而其余两个乐章则保持了传统的速度规范：“缺席”乐章维持了较慢的速度，渲染出一种忧郁悲伤的氛围；而“重逢”乐章则是速度陡升，呈现出了明显的明朗愉悦。</p><h5 id="马勒《第九交响曲》"><a href="#马勒《第九交响曲》" class="headerlink" title="马勒《第九交响曲》"></a>马勒《第九交响曲》</h5><p>　　承接上面的分析，贝多芬的这部钢琴奏鸣曲还有一个值得注意的部分：在该奏鸣曲中前三个音符作为动机，被标注为“Lebewohl” ，这一动机在马勒《第九交响曲》中被再次使用，于是我们也可以从形式的角度简单地分析一下马勒的这部作品。其前三乐章作为谐谑曲或者回旋曲这样的曲式，都以相当快的速度前进，特别到了第三乐章的前半部分，几近脱缰的野马，铜管喧天；却在第四乐章突然戛然而止，将话语权交给了温柔的弦乐组，进入了作品的尾声。交响曲中普遍的处理是以快板甚至急板的第四乐章作结，而马勒在这里反常地选择了柔板，这个选择是具备特殊意义的，正是与其选用的“告别”动机有所呼应。<br>　　不难从上述的分析中找到规律：一种由快速逐渐缓慢、由强至弱、由欢快至沉郁的过程，是“告别”存在的可能形式特征。这给了我们一个线索：乐曲的节奏对于告别具有暗示意味。这样的规则尺度可以变化，即既能对应于一部作品，也能对应于作品的某一个片段。</p><h4 id="（二）告别的内涵特征"><a href="#（二）告别的内涵特征" class="headerlink" title="（二）告别的内涵特征"></a>（二）告别的内涵特征</h4><p>　　在上面的讨论中，我们似乎找到告别的一种特征，但事实是我们在援引马勒《第九交响曲》时实际上并没有严格说明，为什么这部交响曲是“告别”的，仅使用“Lebewohl”动机作为解释并不是非常有说服力。这便需要我们先简单讨论“告别”具备的内涵，及其在音乐中的表现。<br>　　我们确定“告别”具有几个要素：告别者，被告别者，告别者的自我表达，某种状态的改变。此外，我们认为，告别具有时间上的意义，其建立在回忆与遥望之上的。正如李白《送友人》中两句“此地一为别，孤蓬万里征”，“浮云游子意，落日故人情。”两句，分别对应着遥望和回忆。<br>　　对于音乐，其也应当在传达“告别之声”时埋藏着这些信息。我们再一次以贝多芬《降 E 大调第二十六钢琴奏鸣曲》为例，上述的结构在这部作品中皆有其呼应的成分。这部作品欲扬先抑，描述了从离别到思念，最后重逢而喜的过程。并且其“重逢”乐章不似“孤蓬万里征”的遥望，而似温庭筠在《送人东归》中的“尊酒慰离颜”那般愉快，同样构成了“告别”的一个重要要素。<br>　　尽管是从内涵进行的解释，上述的例证中音乐所传达的告别由于具有具体告别的场景和对象，所以仍然停留在具象的层面，使用的音乐语言意义也简明了当。然而在“告别”的内涵这个范畴下，情况可以相当复杂繁琐，特别是对于不同的告别对象，在这其中涉及到一些有趣的讨论，我们将更多例证分解到后面的小节中。但是在上述的过程中，我们已经可以找到一些告别可以被讨论的内容，例如死亡与生命、斗争与妥协种种。我们后面则将不断变更考察的对象，试图更深入地考察“告别之声”在音乐中传达的价值与意义。</p><h3 id="三、“告别”与马勒《第九交响曲》"><a href="#三、“告别”与马勒《第九交响曲》" class="headerlink" title="三、“告别”与马勒《第九交响曲》"></a>三、“告别”与马勒《第九交响曲》</h3><p>　　这时我们再次以马勒《第九交响曲》为例，讨论“告别之声” 。在前面分析的内容中，我们已经对这部作品的基本结构进行了解释。而学者普遍认为这部作品与“死亡”紧紧关联，并称之为“带有自嘲的屈从” 。这便自然构成了一个特殊的告别对象——“对于生命和世界的告别”。我们试图借助这个例子，对其第一与第四乐章加以分析，讨论死亡与告别的内在关联。</p><h4 id="（一）第一乐章：美丽过往和可怖归宿的斗争"><a href="#（一）第一乐章：美丽过往和可怖归宿的斗争" class="headerlink" title="（一）第一乐章：美丽过往和可怖归宿的斗争"></a>（一）第一乐章：美丽过往和可怖归宿的斗争</h4><p>　　第一乐章体现出告别的时间线索。我们拆解出第一乐章几个重要的主题或者动机。其一是第一乐章开头由竖琴拨奏的不规则节奏“心跳动机”；其二是由弦乐组完成的优美旋律，我们称之为“回忆”的第一主题；其三是呈现崩坏混乱特点的第二主题。<br>　　第一乐章呈现出一种明显的斗争性：美好场景与死亡威势的相互交替。第一乐章开头，随着第一主题的进入，“心跳动机”透露出的不安感便深深植入了整部作品，然后调起了崩坏的第二主题；随后借助两个主题旋律反复地构建与崩坏，制造出挣扎的场景，使得整个乐章都充满着危机，渲染出一种末世感。<br>　　在第一乐章中部存在一个微妙的变化，即第一主题变奏的重现，这个更为积极的第一主题变奏突然出现，以悠扬婉转的旋律打破了崩坏的旋律，重新将思索拉回了美好的过去。但这样的美好终难以久继，很快便被乐章开头出现的不安动机再次打断，重新进入混乱的第二主题。在本乐章最后阶段的回光返照式美好的回忆也未能胜利，终于消失在了完全崩坏的音乐中，第一乐章便在这里结束。</p><h4 id="（二）第四乐章：失败的“告别”"><a href="#（二）第四乐章：失败的“告别”" class="headerlink" title="（二）第四乐章：失败的“告别”"></a>（二）第四乐章：失败的“告别”</h4><p>　　第一乐章中第一主题对抗第二主题的失败，意味着所谓回忆向着宿命屈服，已经没有任何回转的余地，而“告别”则是非做不可的事情。抹去了第三乐章结束时的歇斯底里，第四乐章终于放弃了一切的斗争，众多声部互相交织、无尽且稳定地向前进展，展现出铺天盖地般可怕的音响效果。我们可以将其看作留恋之物的断绝，并进入最终的平静，或称“毫无苦味的告别” 。<br>　　这样的音响效果一直维持到第四乐章的结束。在第四乐章的结束时，所有旋律开始分崩离析，陷入琐碎的呓语。作为第四乐章结束的降 D 大调主和弦，由于乐曲声响的效果，呈现出似乎没能成功回到降 D 大调的惨象，仿佛作品尚未真正讲述结束时就宣告了终止。在这场“告别”之中不再设想任何将来之事，没有所谓天堂或者地狱，只是对于自我了结作出宣告而复归平静。这是一个不完整的、失败的“告别”。第四乐章结尾既没能回到期望的世界，也没能“告别”这个世界，而是就这样悄悄地停止了。<br>　　马勒的这部作品带有这样独特的色彩：在前三个乐章中不断对抗命运而失败，终于放弃斗争，进入了第四乐章的告别之时，连告别也没能完成就戛然而止了。死亡和告别是内在相关的：死亡为告别者提供了绝佳的告别对象，推动着作曲家对于“告别”这一行为的实现。然而在这部特殊的作品中，带者一切不舍的回忆与对生命的执着，“告别之声”终于在那命运将至的悲感下变成了沉默的遗憾。</p><h3 id="四、“告别”与晚期风格"><a href="#四、“告别”与晚期风格" class="headerlink" title="四、“告别”与晚期风格"></a>四、“告别”与晚期风格</h3><p>　　正像之前对于马勒作品的分析，“告别”在内涵上与“死亡”主题契合，故也和“晚期风格”内在关联。晚期风格是指作曲家在临终前突然出现的与其成熟风格迥异的新风格。在之前的讨论中，我们都将音乐中埋藏的“告别之声”赋给了一部作品。但其本身也可以是一个阶段的主题。而由于告别、死亡、晚期风格之间互相存在的关联性，我们便能将“告别之声”与晚期风格直接联系起来，在作曲家的晚期风格中找到“告别之声”的影子。这里我们将主要以贝多芬和舒伯特的晚期作品为例，对其进行更深入的讨论。</p><h4 id="（一）贝多芬的晚期风格"><a href="#（一）贝多芬的晚期风格" class="headerlink" title="（一）贝多芬的晚期风格"></a>（一）贝多芬的晚期风格</h4><p>　　贝多芬早中期的作品如《第三交响曲》和《c 小调第八号钢琴奏鸣曲》，具有显然的情感意志流露。这些作品构建出了一个强力、积极的贝多芬形象；而贝多芬的晚期作品则更加富有矛盾性，以其最后五部弦乐四重奏作为代表，呈现出了客观、晦涩而具有神秘主义的贝多芬风格，这些作品也被称为“无表现”的作品。<br>　　这种风格和其另一部晚期作品《第九交响曲》看似不同，但也存在着统一：《第九交响曲》是绝对主观、强力的，并刻意地向上，其带有过分积极宏大的愿望，并因此带有明显的斗争性 以及潜藏的斗争失败的预感。而在其后创作的第十三、第十四号、第十五号弦乐四重奏的第一乐章的开头则更露骨地在不安定与伟大目标间徘徊。<br>　　《第十五号弦乐四重奏》第三乐章中呈现的无限宁静与温暖感受，一定程度地勾勒出《第九交响曲》的斗争终于成功的未来；但在其《第十四号弦乐四重奏》中，却带着明显的不稳定情绪。这种矛盾性与马勒《第九交响曲》的第一和第四乐章对应，建立了斗争与妥协的关系，构造出了“告别”的结构，从而建立起了“告别”和晚期风格的内在联系。</p><h4 id="（二）舒伯特的晚期风格"><a href="#（二）舒伯特的晚期风格" class="headerlink" title="（二）舒伯特的晚期风格"></a>（二）舒伯特的晚期风格</h4><p>　　与之同时，舒伯特晚期风格也带有这样的矛盾性。其创作的《第九交响曲》与贝多芬的《第九交响曲》相似，脱离了《第八交响曲》的沉郁，终于到达了“伟大”的高度；而在一些其他晚期作品中，例如《C 大调弦乐五重奏》、《降 E 大调弥撒》中构造的形象神秘而消极，而这些形象“成为他在离开这个世界之前的正式告白” ，最终形成了我们所讨论的“告别之声”的架构。同时在艺术歌曲《幻影》中，“他将主角替换成幻影时，歌曲的重点也从悲痛绝望的失恋转移到了无处不在的死亡” ，明显地带着舒伯特本人的死亡省思与复杂心理。其晚期风格借助死亡省思和矛盾性和“告别”联系在了一起。<br>　　这些作品本身构成了“告别”，但不同于先前讨论的所有作品，这里的告别是正在进行的：它不会随着一部作品的完成而结束，他们怀揣着对于死亡的担忧往前行进，在众多的作品间摇摆、碰撞，呈现出一种不停顿的斗争性，最后接纳真正的死亡才复归“非尘世的宁静” 。这样的“告别”正像是背负着《欢乐颂》那样的愿景带来的无可调节的矛盾，显得隆重而庄严。</p><h3 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h3><p>　　在本文中，我们主要将注意力聚焦于音乐中潜藏的“告别之声”，分别从形式和内涵的角度，由具象至抽象、由微观至宏观地对这个问题进行了讨论。我们从“告别”的形式出发，对海顿、贝多芬和马勒等作曲家的作品分别展开了形式上的讨论，并认为“告别”在其形式上具有由快至慢、由强至弱等等特点。<br>　　从内涵出发，我们则讨论了具象的“告别”具有的例如时间线索、状态变化等等特征；并依照这条线索，进一步对马勒《第九交响曲》和贝多芬及舒伯特的晚期风格进行了简单的探究。我们通过建立起了“告别之声”与死亡观、斗争与妥协的矛盾性、晚期风格等因素的内在联系，指出了“告别之声”存在的与生命相关联的重要价值与深刻内涵。</p><p>【参考文献】<br>[1] 王振蒙，《论舒伯特钢琴小品 D946 No.2 中的“死亡意象”》，黄河之声，2019 年 11 期。<br>[2] 张晨，《马勒&lt;第九交响曲&gt;的“告别”叙事》，中央音乐学院学报，2019 年 03 期。<br>[3] 瞿枫：《幻影”之谜:舒伯特晚期艺术歌曲中的死亡书写》，中国音乐学，2019 年 02 期。<br>[4] 黄键，《马勒音乐中的死亡内涵初探》，交响（西安音乐学院报），2018 年 04 期。<br>[5] 瞿枫，《舒伯特“晚期风格”研究 ：1827— 1828》，上海音乐学院博士学位论文，2015 年，第 38— 46 页。<br>[6] 伍维曦，《终结与滥觞——舒伯特晚期风格中的死亡意象》，书城，2015 年 01 期。<br>[7] 邓军，《贝多芬&lt;第九交响曲&gt;的“欢乐颂”图景——探究末乐章“音乐”与“诗”对于作品结构的深层意义》，星海音乐学院学报，2015 年 02 期<br>[8] 爱德华·萨义德，《论晚期风格》，阎嘉译，生活・读书・新知三联书店，2009 年。<br>[9] 西奥多·阿多诺，《贝多芬：阿多诺的音乐哲学》，彭淮栋译. 联经出版事业股份有限公司, 2009。<br>[10] 孙国忠，《马勒交响曲的哲理内涵》，中国音乐学，1989 年 04 期。<br>[11] 汉斯利克，《论音乐的美——音乐美学修改新译》，杨业治译，人民音乐出版社，1978 年，第 39 页。<br>[12] 薛毛毛，《贝多芬晚期风格中的“非英雄”性—以晚期五首钢琴奏鸣曲为例》，上海音乐学院硕士毕业论文。<br>[13] Vera Micznik, The Farewell Story of Mahler’s Ninth Symphony, 19th-Century Music (1996) 20 (2).<br>[14] Kolodin, Irving (1975). The Interior Beethoven. New York: Alfred A. Knopf.<br>[15] David B. Greene, Mahler, Consciousness and Temporality (New York: Gordon and Breach Science Publishers, 1984).<br>[16] Constantin Floros, Gustav Mahler: The Symphonies, trans. Vernon and Jutta Wicker, ed. Reinhard G. Pauly (Portland: Amadeus Press, 1993).<br>[17] Donald J. Grout and Claude V. Palisca, A History of Western Music (4th edn. New York, 1998), p760.<br>[18] Gustav Mahler: A Study of His Personality and Work, Paul Stefan, trans. T. E. Clark (New York, 1913), pp. 142-43, and 124-25.<br>[19] Rose Rosengard Subotnik, Adorno’s Diagnosis of Beethoven’s Late Style: Early Symptom of a Fatal Condition, Journal of the American Musicological Society (1976) 29 (2): 242–275.<br>[20] Michael Spitzer, Music as Philosophy: Adorno and Beethoven’s Late Style, Musical Meaning and Interpretation, 2006</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看Windows电池容量</title>
      <link href="/2020/09/15/tech-%E6%9F%A5%E7%9C%8BWindows%E7%94%B5%E6%B1%A0%E5%AE%B9%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/09/15/tech-%E6%9F%A5%E7%9C%8BWindows%E7%94%B5%E6%B1%A0%E5%AE%B9%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近有同学让我帮忙查一下掉电之类的问题啊，然后我发现我并不知道如何查看电池电量。查了一下发现这个方法可用，记录一下。</p><a id="more"></a>  <p>使用<strong>管理员权限</strong>的 cmd 或者 powershell 输入：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">powercfg</span> /batteryre<span class="keyword">port</span> /output “C:\battery_report.html”</span><br></pre></td></tr></table></figure><p>这个指令会生成一个电池使用情况的 html 文件到<code>C:\battery_report.html</code>。当然这个地址是可以改的，比如改到桌面上。成功后，终端会返回：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Battery life <span class="keyword">report</span> saved <span class="keyword">to</span> <span class="keyword">file</span> path C:\battery_report.html.</span><br></pre></td></tr></table></figure><p>找到这个文件打开即可。里面包含最大电池容量和当前最大可充入电池容量，以及一些其他的电池使用情况信息。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常用语法 —— 数据结构</title>
      <link href="/2020/09/14/tech-Cpp%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/09/14/tech-Cpp%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为太久没用 C++了，导致很多细节的语法已经记不得了。借着这一次刷的少量题回顾一下 C++的语法，以后总会有时候能用上的。</p><a id="more"></a>  <h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">s.find(s1);  <span class="comment">//找到第一个出现的s1</span></span><br><span class="line">s.substr(pos, n);  <span class="comment">//截取从pos开始的n个字符</span></span><br><span class="line">s.substr(pos);     <span class="comment">//截取从pos开始的所有字符</span></span><br><span class="line">s.replace(pos, n , s1); <span class="comment">//将s从pos开始的n个字符替换为s1</span></span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><div class="table-container"><table><thead><tr><th>语法</th><th>含义</th></tr></thead><tbody><tr><td><code>vector&lt;int&gt; v1</code></td><td>默认为空的 vector</td></tr><tr><td><code>vector&lt;int&gt; v1(v2)</code></td><td>默认 v2 副本的 v1</td></tr><tr><td><code>vector&lt;int&gt; v1(n, i)</code></td><td>默认内容为 n 个元素 i</td></tr><tr><td><code>vector&lt;int&gt; v1(n)</code></td><td>默认内容为 n 个默认元素，以 int 为例，应是构建了包含 n 个 0 的 vector</td></tr></tbody></table></div><h3 id="Vector的基本操作"><a href="#Vector的基本操作" class="headerlink" title="Vector的基本操作"></a>Vector的基本操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line">test.push_back(<span class="number">1</span>); <span class="comment">// 插入新元素</span></span><br><span class="line">test.size();        <span class="comment">// 返回长度</span></span><br><span class="line">test.erase(test.begin()+<span class="number">2</span>); <span class="comment">// 删除第3个元素（下标为2的元素）。但这个操作很慢，不建议</span></span><br></pre></td></tr></table></figure><p><strong>Vector 的迭代器访问</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=test.begin();it!=test.end();it++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p><strong>算法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">reverse(test.begin(), test.end());  <span class="comment">//颠倒</span></span><br><span class="line">sort(test.begin(), test.end()); <span class="comment">//升序排序</span></span><br></pre></td></tr></table></figure></p><p>*<strong>为了降序排序</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(test.begin(),test.end(),Comp);</span><br></pre></td></tr></table></figure></p><p>需要定义一个特殊的比较函数，比较函数的输入为 vector 内含有的元素。对于结构体，可以使用类似的方法定义.</p><p>*<strong>当插入对象是数组时</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> out[<span class="number">3</span>][<span class="number">2</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>,   </span><br><span class="line">             <span class="number">3</span>, <span class="number">4</span>,  </span><br><span class="line">            <span class="number">5</span>, <span class="number">6</span> &#125;;  </span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>*&gt; v1;  </span><br><span class="line">    v1.push_back(out[<span class="number">0</span>]);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h2><p>在进入 Map 之前我们需要先搞定 Pair 类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; test;</span><br><span class="line">pair&lt;int, int&gt; test(1, 2);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;test.first&lt;&lt;<span class="built_in">endl</span>&gt;&gt;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;test.second&lt;&lt;<span class="built_in">endl</span>&gt;&gt;;  <span class="comment">//对pair元素的访问</span></span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>类似 python 的字典（不过灵活度大幅度下降。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map_int;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; map_string;</span><br></pre></td></tr></table></figure><p>其余的初始化方法和 Vector 雷同，故不赘述。</p><h3 id="Map的基本操作"><a href="#Map的基本操作" class="headerlink" title="Map的基本操作"></a>Map的基本操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; test;</span><br><span class="line">test.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>));  <span class="comment">//插入新元素，使用该方法插入已经存在的键时会报错</span></span><br><span class="line">test[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">//该方法结果和上条效果相同；不存在该键的情况下会新建，反之会覆盖</span></span><br><span class="line">test.size(); <span class="comment">//字典的大小</span></span><br></pre></td></tr></table></figure><p><strong>查找/读值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l_it=test.find(<span class="number">1</span>); <span class="comment">//查找元素，返回一个迭代器；若迭代器指向map的末尾，则不存在该元素</span></span><br><span class="line"><span class="keyword">if</span>(l_it==test.end())</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"we do not find 112"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;l_it-&gt;second&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//由于返回的对象是一个迭代器，而迭代器指向的是一个Pair类型，故可以通过Pair类型的访问方法访问</span></span><br></pre></td></tr></table></figure></p><p><strong>遍历</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = mp.begin(); it != mp.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p><strong>删除</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp.erase(k);<span class="comment">//删除某一个键</span></span><br><span class="line">mp.erase(it);<span class="comment">//删除迭代器指向对象</span></span><br></pre></td></tr></table></figure></p><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a><strong>unordered_map</strong></h3><p>效果和 map 非常相似，但是一般情况下，使用 unordered_map 更快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h2><p><strong>Stack</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.size();</span><br><span class="line">s.empty(); <span class="comment">//判断是否为空</span></span><br><span class="line">s.pop();   <span class="comment">//弹出栈顶元素但不返回</span></span><br><span class="line">s.top();   <span class="comment">//返回栈顶元素</span></span><br><span class="line">s.push();  <span class="comment">// 加入新元素</span></span><br></pre></td></tr></table></figure><p><strong>Queue</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.empty(); <span class="comment">//如果队列为空返回true，否则返回false</span></span><br><span class="line">q.size(); <span class="comment">//返回队列中元素的个数</span></span><br><span class="line">q.pop();  <span class="comment">//删除队列首元素但不返回其值</span></span><br><span class="line">q.front(); <span class="comment">//返回队首元素的值，但不删除该元素</span></span><br><span class="line">q.push(); <span class="comment">//在队尾压入新元素</span></span><br><span class="line">q.back(); <span class="comment">//返回队列尾元素的值，但不删除该元素</span></span><br></pre></td></tr></table></figure><h2 id="Priority-queue"><a href="#Priority-queue" class="headerlink" title="Priority_queue"></a>Priority_queue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq;  <span class="comment">//默认是最大堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq; <span class="comment">//最小堆</span></span><br></pre></td></tr></table></figure><p>其余操作如同普通的 queue。</p><p><strong>自定义数据结构</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    int x;</span></span><br><span class="line"><span class="class">    tmp1(int a) &#123;x = a;&#125;</span></span><br><span class="line"><span class="class">    bool operator&lt;(const tmp1&amp; a) const</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return x &lt; a.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//方法2</span></span><br><span class="line"><span class="class">struct tmp2 //重写仿函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    bool operator() (tmp1 a, tmp1 b) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return a.x &lt; b.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">int main() </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    tmp1 a(1);</span></span><br><span class="line"><span class="class">    tmp1 b(2);</span></span><br><span class="line"><span class="class">    tmp1 c(3);</span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1&gt; d;</span></span><br><span class="line"><span class="class">    d.push(b);</span></span><br><span class="line"><span class="class">    d.push(c);</span></span><br><span class="line"><span class="class">    d.push(a);</span></span><br><span class="line"><span class="class">    while (!d.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; d.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        d.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span></span><br><span class="line"><span class="class">    f.push(c);</span></span><br><span class="line"><span class="class">    f.push(b);</span></span><br><span class="line"><span class="class">    f.push(a);</span></span><br><span class="line"><span class="class">    while (!f.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; f.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        f.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><p>这里主要使用第一种方法吧：在数据结构重载运算符。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>喧哗记</title>
      <link href="/2020/09/07/essay-%E5%96%A7%E5%93%97%E8%AE%B0/"/>
      <url>/2020/09/07/essay-%E5%96%A7%E5%93%97%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-OMFZZlRJ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3947466" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>　　一早去等校车回本部，再从本部到江湾校区。去找教务处问保研的事情。这个事情搅成一团实在令人感到难受。吃晚饭的中午，教务处恐怕是没人的，于是我坐在江湾的图书馆，开始回忆前段时间发生的事情，试图记下那么一些游丝。<br>　　<br><a id="more"></a>  </p><p>　　我果然一点也不喜欢接纳新的东西。或者说从一个相对旧的地方往相对新的地方移动。这样空间上的移动给人一种难以理解的落寞感，这既不是怀念我正准备离开的地方，也不是对于目的地的抗拒。只是一种，潜意识里的对于“移动”的排斥。</p><h2 id="09-06"><a href="#09-06" class="headerlink" title="09-06"></a>09-06</h2><p>　　走出地铁站，然后我感觉那种令人不爽的温度照在了我的额头上。这是典型的、我所熟悉的上海的阳光的感触，但是我一点也不喜欢。飞机提前四十分钟到达了我的目的地，我坐在飞机上是这提前四十分钟的意义，可惜没有。在降落的时候，我看着下方的景色，但实话说这和我起飞的时刻看见的风景并不二致。难以想象这段短暂地旅程中，某种转换就完成了。<br>　　在机场前往包裹提取处的一路上，我感觉我自己的步速开始慢慢地提高，感到了一种所谓“pressure”的东西。在机场囫囵点了个 KFC 的套餐，随后就开始了返校的道路。这完全没什么新鲜事可言，除了睁眼看见的四处都有的人，以及闭眼也能想象到的四处都有的人。<br>　　出地铁站的一瞬间，我或许在期待我眼前所看见的景色能有哪怕那么一点点的不同，使我认为，“移动”不完全是无谓的事情。但映入的一起是反胃的相似性。从地点 A 时间 T0 的离开，到达地点 B 时间 T1，随后在 T2 离开地点 B，在 T3 回到了 A。我期望 T3 的 A 和 T0 的 A 不再是一个东西了。但如此的相似。这让我觉得，我的 T0~T3 的时间消失了，从故事的一个结局回到了这个故事的开头，而且这个故事是如此的单调无聊。<br>　　“新加坡的夏天令人厌烦，因为它的周而复始是以天为单位的；而正常的情况是以年为单位的，这或许能让人舒服那么一点。”我想起昨日（9 月 5 日）在自行车上移动的时候说的话。事情没能得到推进——我产生了这样的印象。<br>　　“我实在是把我的大学过得太无聊了啊。”<br>　　伴随着再熟悉不过的一切，我回到了自己的寝室。看着混乱不堪的景象，桌面上积攒的厚厚的灰尘，我连掸掸灰的想法也没有。这个地方不讨我喜欢，从最开始就是。狭小逼仄的空间，周而复始的时间。看着从门外进来的室友 S，我问：“走吧，去新寝室转转。”<br>　　新寝室也并没有什么特别的。但是最诡秘的是，我回到了大一的住宿的旁边。于是完成了从 A 到 B 再从 B 回到 A 的又一个实践。但我不觉得这段时间它消失了，我在这段时间里失去了很多，却没什么收获。这段时间它没有消失，它切实地伤害了我。然而这也确实是一种循环，一种反复的消耗。新寝室莫名地和高中的寝室相似，但在这种相似性中我感受不到亲切。自回到四川以后，和老同学的见面变成了一件时常发生的事情。但我说不清缘由。“既然你不喜欢和人打交道，为什么在大学里主动承担班委的工作呢？”这是一个朋友问我的。我不知道。矛盾性是有趣的东西，但在这一点上我完全不觉得有趣，倒不如说有一种悲剧的特征。<br>　　我记得自己原来说过，一个人开始经常地回忆的时候，他就老了。出于某种预感，我才做了这样一个预言吧。假设前方存在的分岔的路，我究竟是想走上那条前往我不知道方向的道路呢，还是那个回到过去的某个节点的道路呢。或许这两条路是一条路，只是某种错觉让我以为我有的选罢了。<br>　　晚饭我去了一家我之前就常去的茶餐厅。习惯性地点了菠萝油。在我咬下第一口的时候，我感觉那种甜度、咸度、温度都和我记忆里的一模一样，既是我所希望尝到的味道，又是我所不希望尝到的味道。我是出于什么目的选择了这样一种东西呢，这种在我还没有尝试的时候就知道了结局的食物。我大概意识到了“腻烦”这个词的含义，但又终于觉得自己下次还会再来这个餐厅，再一次点下这个菠萝油，因为 pattern 就是这样，这个人的 pattern 就是这样。就是类似那种“到了一个新的餐厅一定会点它的招牌菜”这样琐碎的特征，构成了这个人的生活。<br>　　回到了自己的寝室，看着乱成一团的景象，开始大费周折地对其进行整理。不断地找出各种意料之外的东西，各种琐碎的日常浮现出来，但终究没有特别的意义可言，这些时间确实没有给我留下什么特别值得回忆的事情，仿佛它不曾存在。</p><h2 id="09-05"><a href="#09-05" class="headerlink" title="09-05"></a>09-05</h2><p>　　难得地把三弟约出来了。虽说这次在成都呆的时间非常长，但其实没见过几面，好几次事情都因为自己或者他有这样或者那样的事情被取消了。但虽说是难得的见面，甚至带有自己给自己送行意味的见面，也没有特别的不同。除了破天荒地我去了一趟电影院——电影我是一窍不通的，但不影响我欣然接受了这个安排。这可能是一种介入。<br>　　每次吃饭听三弟谈他在学校里的生活之类的，就由衷地觉得很好：他过着一个不错的生活啊，不像我这样子。但这不是某种介入；介入在高三最后寝室告别的时候就结束了。<br>　　于是我说起当时在哈尔滨遇到的那对父子的事情。我总觉得我自己所看见的东西太少了，世界太多隐秘的角落我永远也碰不到；甚至在我浑然不知的时候，生命就结束了——它总有一天会抛弃我去完成自己的工作。“我想，支教、研究员或者做一个军官都是非常不同的体验吧。”我说，“我都想试试，但是人生它只有一次，社会也不会允许我贪心地尝试别的东西”。我想起在当时高考的时候，听三弟说他有报考军校的打算。我想那就是截然不同的、但是听起来令人兴趣盎然的道路。虽说最后还是没去，但终究贡献了一个相当不错的可能性。“我当时听说要 4 点起来跑操，我就不想去了”。我想，就是因为这个要 4 点起来跑操它才显得有趣啊。<br>　　这实在是矛盾的事情。我所厌恶的“移动”，我搞不清楚。我厌恶停在某个地方，却也厌恶离开这个地方。我清楚有许多的事情，我或许会觉得有趣，我或许会想去探查一番，那绝对不是我所厌恶的。但是我能到那里去吗？我感觉到有一个巨大的轨道，或者精致的台本在我的手中。事情依照某种顺序和必然性发生。即使有些时候一些巨大的爆发会脱离这样的轨道，但最终会被拉回来。这轨道大概是我臆想出来的东西吧；这轨道必将通向一个无趣且嘈杂的世界。<br>　　我们讨论电影里关于时间设定的问题。三弟为了解释电影里的一个现象，给出一种假说：逆时间里的人对于正常时间有更高的干预能力。正常时间的人会因为逆时间中人物的行为得到修正。我说正常时间里的人奉行着自己的 free will 吗？他回答说是，因为这些事实是通过这个人所有的时刻的 free will 的叠加组成的，这一切没有因果而只是事实。那这是他们 free will 的结果呢，还是这个事实的结果呢？这里的 free will 或许只是某种意义的事实罢了。对于时空悖论的解释于我而言最终总会进入一种相当消极的解释。<br>　　或许只是有些事情因为在轨道之外，它们才显地有趣；而为了让这些事情保留着他们的趣味，轨道才存在。这不是什么因果关系，而只是事实。我的心里存在这样的轨道的同时，也存在好恶。轨道和好恶构成的琐碎是这个人的性质。或许有的人的轨道并不存在，有的人的好恶并不存在，但是存在别的东西，比如扳手、比如迷宫、比如门。在众多的喧哗之中，保存着看见的和看不见的事物；扳动这些扳手，游荡在着迷宫或者越过那扇门并不是某种特质，这些事物的存在本身是那个特质。即使，这个人离开了这个轨道，也不意味着轨道出现了错误，而是轨道隐含着一个分支，这个分支是最开始就存在的，它是事实的一部分。<br>　　我把我的大学过得太无聊了，终究不是大学的性质，而是我的性质：是因为主角是我，它才显地无聊。我所排斥的“移动”恐怕是排斥那移动中的我自己吧……</p><h2 id="09-07"><a href="#09-07" class="headerlink" title="09-07"></a>09-07</h2><p>　　我不知道最后我讨论到了这个事情上……是一种很难以解释的郁闷造成的。就像上文讨论的轨道或者好恶之类的事情，本身就具有主观性，因为这些成段成段的讨论和废话并无差别。“这不是理所应当的事情吗！？”或许是吧。其实这些叙述完完全全脱离了我动笔的初衷，但我还是决定忠实地把这些记录下来，算是给我在成都滞留的大半年生活画上一个句号。</p><p>廙水<br>2020-09-07<br>复旦大学江湾校区图书馆</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿拉伯数字转罗马数字</title>
      <link href="/2020/08/26/tech-%E9%98%BF%E6%8B%89%E4%BC%AF%E8%BD%AC%E7%BD%97%E9%A9%AC/"/>
      <url>/2020/08/26/tech-%E9%98%BF%E6%8B%89%E4%BC%AF%E8%BD%AC%E7%BD%97%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为近日在准备保研的刷题…所以得看各种奇怪的题目。但事实上由于太久没有写算法了，现在还在康复期，先做些简单的东西好了…其实是我觉得这个东西什么时候可能会用上？</p><a id="more"></a>  <h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">    string = <span class="string">""</span></span><br><span class="line">    ones = [<span class="string">"I"</span>, <span class="string">"X"</span>, <span class="string">"C"</span>, <span class="string">"M"</span>]</span><br><span class="line">    fives = [<span class="string">"V"</span>, <span class="string">"L"</span>, <span class="string">"D"</span>]</span><br><span class="line">    ct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num:</span><br><span class="line">        n = num % <span class="number">10</span></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">            s = ones[ct] * n</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">4</span>:</span><br><span class="line">            s = ones[ct] + fives[ct]</span><br><span class="line">        <span class="keyword">elif</span> n &lt;= <span class="number">8</span>:</span><br><span class="line">            s = fives[ct] + ones[ct] * (n - <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">9</span>:</span><br><span class="line">            s = ones[ct] + ones[ct + <span class="number">1</span>]</span><br><span class="line">        string = s + string</span><br><span class="line">        ct += <span class="number">1</span></span><br><span class="line">        num //= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> string</span><br></pre></td></tr></table></figure><h2 id="阿拉伯数字转罗马数字规则"><a href="#阿拉伯数字转罗马数字规则" class="headerlink" title="阿拉伯数字转罗马数字规则"></a>阿拉伯数字转罗马数字规则</h2><div class="table-container"><table><thead><tr><th>符号</th><th>数字</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>例如以下的对应：</p><div class="table-container"><table><thead><tr><th>罗马数字</th><th>阿拉伯数字</th></tr></thead><tbody><tr><td>III</td><td>3</td></tr><tr><td>VI</td><td>6</td></tr><tr><td>XVI</td><td>16</td></tr></tbody></table></div><p><strong>特殊规则</strong><br>除了上述简单的累计外，还有一条特殊规则：对于$4\times 10^n$或$9\times 10^n$，应该使用特殊的表达方法：</p><div class="table-container"><table><thead><tr><th>罗马数字</th><th>阿拉伯数字</th></tr></thead><tbody><tr><td>IV</td><td>4</td></tr><tr><td>IX</td><td>9</td></tr><tr><td>XL</td><td>40</td></tr><tr><td>XC</td><td>90</td></tr><tr><td>…</td></tr></tbody></table></div><p>在这个规则下，<code>MCMXCIV</code>代表 1994：M：1000；CM：900；XC：90；IV：4。这意味着对于一个阿拉伯数字，最多需要 4 个符号，但基本上还是遵循十进制的规律，所以毫无竞争力可言。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>野士</title>
      <link href="/2020/08/22/essay-%E9%87%8E%E5%A3%AB/"/>
      <url>/2020/08/22/essay-%E9%87%8E%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>只是翻出了高中时期的周记本，想起最后的两页记了些“见不得人”的东西。既然找出来了，也就把它记下来吧。当时晚自习实在看不了教材的时候，相较看小说，果然还是看自己的东西更加有趣。</p><a id="more"></a>  <h2 id="野士"><a href="#野士" class="headerlink" title="野士"></a>野士</h2><p>　　棉芯将燃烧殆尽，<br>　　不，别碰那镜子。<br>　　别碰那些无趣的叹息，<br>　　让它们继续明亮。</p><p>　　却弃了你手里的烟火！<br>　　小心它们燃成了灰，<br>　　灼了你的手。</p><p>　　不，别向无物祷告。<br>　　把它们放在地上，<br>　　等待飘忽的风，<br>　　将它们燃尽。</p><p>　　　　——作于某年 12 月 15 日</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗歌？ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『ヒカルの碁』观感</title>
      <link href="/2020/07/16/essay-%E8%A7%82%E6%84%9F-%E6%A3%8B%E9%AD%82/"/>
      <url>/2020/07/16/essay-%E8%A7%82%E6%84%9F-%E6%A3%8B%E9%AD%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-tQUjlZxg" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="538824" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="评价：★★★★★"><a href="#评价：★★★★★" class="headerlink" title="评价：★★★★★"></a>评价：★★★★★</h3><p>虽然在完成钢炼 03 的观感之后就清楚地意识到了自己不具有写作观后感的才能，但终于还是落笔来记录这一部给我直接震撼的作品。</p><a id="more"></a> <p>距离我第一遍看完这部作品可能已经过去 2 个多月了吧。在这之后，我 开始重复看这部作品；把它的漫画，揪出来补完了北斗杯；把《北斗特别篇》也完成了。但总有一种意犹未尽的感觉……毫无疑问，这部作品是我到目前为止看过的一部最为杰出的作品之一。尽管我一直希望为它写一些什么东西，但总觉得那种感情很模糊，难以构成更具象的文字。</p><p>『ヒカルの碁』直译过来的话应该叫做《光的棋》，另一个译法为《棋灵王》。但私以为，《棋魂》的翻译还是更加恰当。这部作品显然不是讲述光一个人围棋道路的作品，更不是以佐为和光为核心的作品。佐为的离开暗示了关于“传承”的主题。所谓“神の一手”并不是一个具体的存在，是棋士往下奋斗的道路。但传承只是这其中众多主题之一。</p><p>很难想象一部漫画作品可以把关于围棋这种行外看热闹的严肃主题演绎到这样的程度。我几乎是在看过了前几集之后就笃定这是一部优秀的作品，甚至在期末季连续熬夜看完（特别是名人佐为两战，完全没有喘息的机会），然后二刷三刷。它所传达的可怕信念和执念，毫无疑问可以让观众为之动容。</p><p>这个故事基本上是关于对局和人的故事。围绕着这个核心，将当时日本棋界的人和事慢慢地抖落出来。以筒井、三谷为代表的以围棋作为爱好的普通学生，以棋士作为众生奋斗的和谷、伊角的院生时代，在棋坛风生水起的新生代（可能也比较老了吧）绪方、仓田，以及当时日本的巅峰塔矢名人。</p><p>整个故事基本上是由几场重要的对局作为线索拉开的，对于人物的塑造也几乎是依赖对局完成的。这其中有关乎剧情发展的重要对局，也有配角们闪烁光芒的“魂”的对局。剧情的发展环环相扣，自然而充满波折。几个重要的成长阶段也自然合理毫不做作。几次对局将整部的气氛严肃而积极。我可以清晰地感到这部作品中人物的精神透过方框地屏幕向外涌出，闪烁着他们追求的光。</p><p><strong>佐为 VS 亮</strong></p><p>佐为和亮一共对局三次。前两次使亮产生了巨大的恐惧。从此树立了追赶光的目标。然而在中学围棋大赛见到真正的光时大失所望，转而进军职业世界。</p><p>亮是一个温柔的人，但是对于超越自己的对围棋毫无尊敬的光，展现出了一种毫无动摇的决心。即使是远比自己强大的，也必须去挑战，这是通往“神の一手”的唯一道路。</p><p>亮由于自己的名人父亲，深深知道棋界的艰难，也对其抱着绝对的尊敬和执着。几乎可以说是全剧中最为执着的棋手，具有着远超光前期决意追赶亮的觉悟和决心。</p><p><strong>佐为 VS 名人</strong></p><p>佐为和名人也有三次对局。也是剧情重要的三次对局。其中第一句完成了对于光的引导，让光产生了“他们对这个如此认真，自己也相认真”的想法。这是光从“随便玩玩”到“认真对待”的重要对局。尽管这局不了了之，但也为后面的新初段埋下了伏笔。</p><p>第二局新初段赛，佐为佐为棋手的执念在这里爆发。这一战的分为塑造将视角交给了名人和观众，通过顶尖棋士的评论，将这一战的“紧张感”渲染到了极致。</p><p>第三局线上围棋战，观众变为了世界的业余棋手。这一次将上一战未完成的遗憾结束了，也终于开始了佐为的离别章节。这一章展现的是名人的意志。“这就是名人的棋，绝不退让，一定会赢。”。结束之后，名人自嘲 “名人我下出这样一盘棋，也不算坏吧。”名人也有名人的追求。后面名人摆脱成见，隐退棋坛，游历四方，不断地学习和感受围棋。完成了对于名人角色的收束。</p><p>第三战光的发现终于让佐为意识到了自己存在的意义，即便认识到了自己可能永远无法碰到神之一手，但还有后辈在不断地、不断地朝着那个方向前进。自己作为传承者的使命已经完成了，终于放下了自己对于围棋地热情，从而不可避免地迈向了消失的结局。</p><p><strong>光 VS 和谷</strong></p><p>在对局中出现对话是常见的手法。和谷和光之一战，决定了和谷能否就此走向职业棋士。接受老师鼓励的和谷拼尽全力，发现自己稳操胜券时，脑中回响的老师的话。这里算是一个刚刚将要进入棋坛新人的思想吧。朴实且充满着希望，然而这一战输了。</p><p>哎……实在是太多了。光和伊角两次对局，光和洪秀英的对局，越智和社的对局。这是一群人展现的对于围棋这个事业的执着和热爱。就是这样单纯的故事也能打动很多很多的人了，对这些棋手自然尊敬起来。</p><p>佐为的离去是在众多伏笔下必然的事件；如果作者在之后执意让离开的佐为回到这世间，尽管满足了许多的读者，却会成为这部作品的败笔。将佐为的意志寄托在光对围棋的爱中，是最优的解。佐为的离开和光的成长是密不可分的，道路总是需要一个人走下去的，对于围棋的爱也不应当是为了某个人才坚持下去，这是一条自我的、自私的道路。在光与伊角的一局中，那只突然出现的手和扇子，让我整个人愣住了。原来这个谜题是这样的啊……作者实在是……完全在意料之中的解法，但是在长时间的情感烘托之下呈现绝对的杀伤力。光重新带者佐为的执念回到了棋坛。应该是佐为真正满意的结局吧。</p><p>“传承”这个主题在北斗杯再一次托出，完成了光回归棋坛的结局，留下了无穷的可能。这部作品将棋士的精神很好地展现在了所有读者的面前，即使作为一个对围棋一知半解的门外汉，也不得不感到触动——为了一个热爱的事业竟然能够如是执着地为之奋斗，这是如此值得钦佩的事情！却在现代的世界中越来越少见，实在是令人遗憾。</p><p>我果然是，很不适合写观后感……此刻真切地感到自己完全没有足够的能力对自己发自内心喜爱的这部作品做出真正恰到好处或者生动的评价。多年以后，我一定会回到这部作品来，看看自己的人生是不是过得就那样凄凉而单调。或许每个人都藏着一颗棋士的心，奋斗且挣扎、不停地挑战、执着地追求更强的棋士的心，在各自热爱的领域里将自己的爱和执着传承下去……</p><p>这是一部可怕的作品。</p>    <div id="aplayer-vQqhNzuS" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="538768" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - How to best use Syntax in SRL</title>
      <link href="/2020/07/16/scholar-paper-Syntax-in-SRL/"/>
      <url>/2020/07/16/scholar-paper-Syntax-in-SRL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文讨论如何把句法信息加入 SRL 任务。其中提到了三种方法：使用句法信息作为输入；使用句法信息组成 Multi-task；同时使用上述两种方法，组成 auto-encoder。本文使用 CoNLL’05 和 CoNLL’12 作为训练集进行测试。</p><a id="more"></a>  <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="外部信息"><a href="#外部信息" class="headerlink" title="外部信息"></a>外部信息</h3><p>将外部信息加入 NLP 任务的思想在近几年中趋势越发明显。关于这个问题，有三种主流的做法：</p><ol><li>加入 Input：外部信息作为神经网络的额外输入特征。</li><li>作为 Output：神经网络在训练主任务的同时需要对这些信息进行 Multi-task 训练。</li><li>Auto-encoder：同时将外部信息作为神经网络的 Input 和 Output。</li></ol><p>但是这些研究主要停留在了一些浅层信息，例如将 POS 标签和序列标注任务结合。而那些标注句法依赖等等“较长”句法特征信息则没有被仔细研究。这篇文章就是针对这一点进行一个补充。</p><p>在这篇文章中，主要讨论了三个问题：</p><ol><li>应该如何将句法信息加入作为<strong>word-level featrues</strong>？</li><li>如何最好地表达句法信息？</li><li>句法信息表达的选择对于结果有多少影响？</li></ol><h3 id="SRL-System"><a href="#SRL-System" class="headerlink" title="SRL System"></a>SRL System</h3><p>一个语法标注系统能够提取 predicate-argument 结构。在研究早期句法信息一直是 SRL 的重要组成部分，然而当下的 SOTA 模型并没有显式地包含句法信息。这篇文章希望通过实验证明句法信息对于 SRL 系统的重要作用。</p><p>在这篇文章中，作者将外部信息表示为离散特征向量。其中有三类表示：</p><ol><li>Full-C：全成分树表示</li><li>SRL-C：SRL-specific span 表示</li><li>Dep：依赖树表示</li></ol><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>对于不同的整合方式，在语料库 CoNLL’05 和 CoNLL’12 上进行测试获得结果</p><h2 id="句法表示"><a href="#句法表示" class="headerlink" title="句法表示"></a>句法表示</h2><h3 id="Full-C"><a href="#Full-C" class="headerlink" title="Full-C"></a>Full-C</h3><p>参照 Gomez-Rodrıguez and Vilares 提出的方法，将成分分析树进行向量化。为了表示这个提出下列标注：</p><ol><li>$n(w_i)$：指$w_i$和$w_{i+1}$间的共有父节点的数量。</li><li>$l(w_i)$：编号最小的父节点的 non-terminal 标签。如果是 terminal，则为 S。</li><li>$r(w_i)$：$n(w_i) - n(w_{i-1})$</li></ol><p>通过记录所有节点的上述信息，可以完全还原成分分析树。示例如下：</p><center><img src="/images/Research/Full-c.jpg"/></center><h3 id="SRL-C"><a href="#SRL-C" class="headerlink" title="SRL-C"></a>SRL-C</h3><p>只有一小部分的成分分析树中的成分是发挥了作用的。这意味着将整个成分分析树都进行编码可能不是最优解。因此仅保留最有可能有利于标签分类的成分是必要的一个操作。为此，作者使用了剪枝算法，将其中的部分 argument 收集起来，并将无关的部分滤除。对于滤除的结果使用标准 BIO 标记法标记。</p><ol><li>O：单词在任何一个候选成份外</li><li>B：单词是某一个候选成分的第一个单词</li><li>I：单词在某一个候选成分中</li><li>A：单词在一个介词短语中</li><li>V：正在考察的 predicate 的核心动词</li></ol><p>这个标记在上面例图中已经标明。</p><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p>通过依赖树，编码的仍然是成分信息。其具有下列的标签：</p><ol><li>Left/Right：这个但错左右拥有的依赖数。</li><li>Edge：这个单词是管辖这个词（左边/右边/不是）最依赖这个词的词。</li><li>RG（Relative distance to governor）：这个词与其 Governor 间的距离。</li><li>DL（Dependent label）：指向这个词的 denpendent 标签。</li></ol><p>示例如下：</p><center><img src="/images/Research/Dep.jpg"/></center><h2 id="如何使用外部信息？"><a href="#如何使用外部信息？" class="headerlink" title="如何使用外部信息？"></a>如何使用外部信息？</h2><p>加入外部信息的方法如同前文所说，有三：</p><ol><li><strong>Input</strong>：将外部信息和 ELMo 提供的词向量相连。其中依赖树通过将生成的成分树进行变换得到，以保证两种划分方法的一致性。</li><li><strong>Output</strong>：同时预测 SRL 和句法特征，最后使用的损失函数是这两部分的和。</li><li><strong>Anuto-encoder</strong>：将外部信息作为特征输入，并同时作为 multi-task 训练的对象，使得这个方法呈现出 encoder 的特性。</li></ol><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>实验一共进行了 10 组：“3 种使用外部信息的方法”x“3 种将文本句法特征向量化的方法” + 1 个 baseline。实验在 CoNLL’01 和 CoNLL’12 上进行。</p><h3 id="主要结果"><a href="#主要结果" class="headerlink" title="主要结果"></a>主要结果</h3><center><img src="/images/Research/SRL-res.jpg"></center><p>结果表示，句法信息确实是对 SRL 能力有积极提升作用。其中，Full-C 获得了更优于 Dep 的实验结果。作者认为这是由于成分树更加接近于 SRL 的信息。此外 SRL-C 的方法略好于 Full-C 方法，在集外预测时也更具优势。</p><p>并且使用 Multi-task 在这个任务中并没有体现出非常好的效果，而其余两种方法效果相当。</p><h3 id="与现有系统的对比"><a href="#与现有系统的对比" class="headerlink" title="与现有系统的对比"></a>与现有系统的对比</h3><p>作者将本次实验中表现最为出色的 SRL-C used as Input 作为对比，和现有的各个工作进行对比。这个方法相较于现在已有的模型有略微的提升，但是结果并未明显胜出 ensemble 方法。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP术语集 - Grammar</title>
      <link href="/2020/07/15/scholar-NLP-Grammar/"/>
      <url>/2020/07/15/scholar-NLP-Grammar/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近开始看 NLP 的论文啊，觉得好多术语都不知道是个什么，就只能一边看一边查咯。</p><a id="more"></a><h3 id="Predicate：谓词"><a href="#Predicate：谓词" class="headerlink" title="Predicate：谓词"></a>Predicate：谓词</h3><p><a href="https://www.grammar-monster.com/glossary/predicate.htm" target="_blank" rel="noopener">Link</a></p><blockquote><p>The predicate is the part of a sentence (or clause) that tells us what the subject does or is. To put it another way, the predicate is everything that is not the subject.</p></blockquote><p>或参照韦氏词典的定义：</p><blockquote><p>the part of a sentence or clause that expresses what is said of the subject and that usually consists of a verb with or without objects, complements, or adverbial modifiers.</p></blockquote><p>简而言之谓词是描述 Subject 做什么或者是什么的一个<strong>成分</strong>，并不一定是一个词。一个谓词的 Core 是一个动词。</p><p><strong>Easy Examples of Predicates</strong></p><ul><li>Adam <em> <strong>lives</strong> in Bangor</em>.</li><li>The telegram <em> <strong>contained</strong> exciting news</em>.</li><li>The girls in our office <em> <strong>are</strong> experienced instructors</em>.</li></ul><p><strong>Real-Life Examples of Predicates</strong></p><ul><li>True friends <em> <strong>appear</strong> less moved than counterfeit</em>. (Greek philosopher Homer)</li><li>Words empty as the wind <em> <strong>are</strong> best left unsaid</em>. (Homer)</li><li>People can <em> <strong>come</strong> up with statistics to prove anything</em>. Forty percent of all people <em> <strong>know</strong> that</em>. (Homer Simpson)</li><li>With $10,000, we would <em> <strong>be</strong> millionaires</em>! We <em> <strong>could buy</strong> all kinds of useful things like … love</em>. (Homer)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>土豆汤制法</title>
      <link href="/2020/07/12/essay-%E5%9C%9F%E8%B1%86%E6%B3%A5/"/>
      <url>/2020/07/12/essay-%E5%9C%9F%E8%B1%86%E6%B3%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为一个人在家，看着家里有土豆，于是打算就试一次土豆泥。但是土豆泥总感觉味道不如土豆汤，所以打算改做土豆汤，而家里又没有用来搅碎蔬果的东西，所以用豆浆机代替。本来战战兢兢的，后来发现不仅没有出问题，而且效果还不错，而且做法简单地不可思议。</p><a id="more"></a>  <p><strong>口感</strong></p><ul><li>和西餐厅能吃到的口感相似，不过因为第一次做多放了水，所以会显得稀一点。</li><li>颜色呈粉红色</li></ul><p><strong>材料</strong><br>下述材料是两人份的。</p><ul><li>正常大小土豆一个</li><li>火腿肠（粗）：1/4 支</li><li>牛奶 250ml</li></ul><p><strong>步骤</strong></p><ul><li>将土豆切丁（很小的类型）</li><li>将火腿肠切丁</li><li>将牛奶导入上述混合物，并加入 50ml 左右的水</li><li>使用豆浆机打碎</li><li>适量放盐，结束</li></ul><p><strong>实验失败经历</strong></p><ol><li>实验 001<ul><li>第一次实验使用了半根火腿肠，发现火腿肠味道太浓，土豆味道不明显，且汤体成粉红色，明显是放多了……</li><li>并且第一次倒入了整碗水，水过多导致土豆汤过稀，应该是使用半碗即可。</li><li>这个事情的后续：豆浆机因此损坏，尽管看起来它好好的。该项目因为带来的巨大的经济损失，将不再被实验。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 食谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pip下载Module</title>
      <link href="/2020/07/12/tech-Python-pip%E4%B8%8B%E8%BD%BD/"/>
      <url>/2020/07/12/tech-Python-pip%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Pip 下载东西总是哪里会出一个幺蛾子……即使加上镜像……</p><a id="more"></a>  <p>使用下列指令下载：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip pip install -i https:<span class="string">//pypi.tuna.tsinghua.edu.cn/simple</span> <span class="params">--default-timeout=100</span> <span class="params">--upgrade</span> tensorflow-gpu</span><br></pre></td></tr></table></figure><p>其中<code>--default-timeout</code>项可以避免：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReadTimeoutError: <span class="constructor">HTTPSConnectionPool(<span class="params">host</span>='<span class="params">pypi</span>.<span class="params">tuna</span>.<span class="params">tsinghua</span>.<span class="params">edu</span>.<span class="params">cn</span>', <span class="params">port</span>=443)</span>: Read timed out.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python自动修改格式</title>
      <link href="/2020/07/11/tech-Python-Python%E8%87%AA%E5%8A%A8%E6%8E%92%E7%89%88/"/>
      <url>/2020/07/11/tech-Python-Python%E8%87%AA%E5%8A%A8%E6%8E%92%E7%89%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>偶然发现的一个 Python 自动修改代码风格的工具，感觉挺有用，在此记录使用方法。</p><a id="more"></a>  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先对于安装<code>black</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> black</span><br></pre></td></tr></table></figure><p>注意这个命令需要在 VSC Terminal 所在的虚拟环境中安装。例如如果 Terminal 使用的 conda-base，则该 Module 就应该在 conda-base 里安装。</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>打开 VSC 的 Setting(JSON)，将下列代码粘贴在最后方：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"python.formatting.provider"</span>: <span class="string">"black"</span>,</span><br><span class="line"><span class="string">"editor.formatOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"python.formatting.blackArgs"</span>: [</span><br><span class="line">  <span class="string">"--line-length"</span>,</span><br><span class="line">  <span class="string">"120"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在这个设置下，每一次保存会进行一次自动的格式修改。但由于 Python 的特殊性，这个脚本能够改变的主要是行内代码风格，不能对缩进等进行修改。</p><p>参考连接：<a href="https://zhuanlan.zhihu.com/p/73452541" target="_blank" rel="noopener">link</a></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> 脚本工具 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新老Edge并存方法</title>
      <link href="/2020/07/10/tech-%E6%96%B0%E8%80%81Edge%E5%B9%B6%E5%AD%98/"/>
      <url>/2020/07/10/tech-%E6%96%B0%E8%80%81Edge%E5%B9%B6%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>新版 Edge 尽管支持了 chrome 的插件，但是由于主力 Vivaldi 的能力过强，导致新 Edge 继续吃灰。配合 surface pen，老版 Edge 的 PDF 阅读器作为绝对优势的功能也遗憾被删除。为了能够继续使用老版本的 Edge，在网上搜索一番后，发现这个方法可行，于是记录下来。</p><a id="more"></a>  <h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><p>打开网址：<a href="https://www.microsoft.com/zh-cn/edge/business/download" target="_blank" rel="noopener">link</a>，</p><center><img src="/images/Things/edge.jpg" width="50%" height="50%" />如是选择</center><p>这个下载会获得一个名为<code>MicrosoftEdgePolicyTemplates</code>的压缩文件。将其解压可以得到下述文件：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\-</span> examples</span><br><span class="line"><span class="string">\-</span> html</span><br><span class="line"><span class="string">\-</span> mac</span><br><span class="line"><span class="string">\-</span> windows</span><br><span class="line">    <span class="string">\-</span> admin</span><br><span class="line">    <span class="string">\-</span> admx</span><br><span class="line">        <span class="string">\-</span> zn-CN</span><br><span class="line">        <span class="string">\-</span> en-US</span><br><span class="line">        ...</span><br><span class="line">        msedge.admx</span><br><span class="line">        msedgeupdate.admx</span><br></pre></td></tr></table></figure><p>将上述文件的<code>msedge.admx</code>及<code>msedgeupdate.admx</code>复制到文件夹：<code>C:\Windows\PolicyDefinitions</code>中。同时对应于上述的语言文件夹，将其中相关内容复制到对应的文件夹中。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>上述完成之后可以打开<code>gpedit.msc</code>，进入 windows configureation，依照下列路径进入：<code>Computer configuration -&gt; Administrative Templates -&gt; Microsoft Update</code></p><p>双击 Microsoft Update，点击 side-by-side 选项，将该服务 enable。</p><p>* 注意：这个文件夹只有在完成了上述的修改之后可见。</p><h2 id="重新安装"><a href="#重新安装" class="headerlink" title="重新安装"></a>重新安装</h2><p>回到最开始的网站，保持相同的版本号，下载新的 msi 安装文件安装 edge。这个操作不会将老版本 Edge 放入开始菜单，但是可以通过菜单栏中的<code>open with</code>打开 PDF。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - Towards Robust Semantic Role Labeling</title>
      <link href="/2020/07/09/scholar-paper-Towards%20Robust-Semantic-Role-Labeling/"/>
      <url>/2020/07/09/scholar-paper-Towards%20Robust-Semantic-Role-Labeling/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>ACL 2007</strong></p><p>为暑研工作阅读的第一篇论文。暑研工作的三个基石之一：SRL（Semantic Role Labeling）。现在大部分 SRL system 都基于一个数据集完成的训练。作者认为这样会造成过拟合现象。这篇文章提供了一种在特定数据集上标注后迁移到另一个数据集的方法。本篇文章基于 PropBank（很快我也需要完成这篇文章的阅读了。）这篇文章认为语法上的 parser 和 argument 判断可以很容易的迁移，然而 argument classification 不是。</p><a id="more"></a>  <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>SRL 是一种用来表征语法结构的方法。党表征一个句子时，一个好的语法标注器应当能够对句子中的每一个谓词，正确地辨别并标注出其语法 label。在近期的工作中，这个工作是通过监督机器学习完成的。尽管这些工作在数据集上都达到了很高的准确率，但是他们极大地与其训练的数据集相关。这篇文章的焦点就是讨论这样的现象。</p><p>实验基于 PropBank corpus（这是一个 WSJ 的标注数据集）完成。</p><h2 id="语义标注（Semantic-Role-Labeling）"><a href="#语义标注（Semantic-Role-Labeling）" class="headerlink" title="语义标注（Semantic Role Labeling）"></a>语义标注（Semantic Role Labeling）</h2><p><strong>成分分析（constituent parsing）</strong><br>成分解析树将一个句子划分为一棵成分树，树上的非叶子节点是划分成的短语，叶子节点是句子中的单词。</p><p>在 NLP 中，分析方法分为：</p><ul><li>词法分析 lexical analysis</li><li>句法分析 syntactic parsing</li><li>语义分析 semantic parsing</li></ul><p>其中语义分析是指将自然语言句子转化为反映这个句子语义的形式化表达。例如：</p><blockquote><p>我吃了一块肉<br>一块肉被我吃了</p></blockquote><p>在语义上都表示为吃(我，肉）的意思，但句子结构却有不同。句子的语义分析是对句子处理技术更高一级的要求，在信息检索、信息抽取、自动文摘等应用广泛。</p><blockquote><p><strong>SRL:</strong> Semantic Role Labeling (SRL) is defined as the task to recognize arguments for a given predicate and assign semantic role labels to them.</p></blockquote><p>SRL 是浅层语义分析技术，以句子为单位处理为“谓词+论元”的结构。</p><h2 id="语义标注和语料库"><a href="#语义标注和语料库" class="headerlink" title="语义标注和语料库"></a>语义标注和语料库</h2><p>这篇文章通过复现 PropBank corpus 中的语义标注方法完成实验。PropBank 是一个包含 300k 单词的语料库，其中对于除了系词（corpula）外的所有动词都标注了谓词 argument 关系。PropBank 使用了 Arg0~Arg5 作为谓词 labels。</p><ul><li>ARG0: Agent, operator</li><li>ARG1: Things operated</li><li>ARG2: EXplicit patient</li><li>ARG3: Explicit argument</li><li>ARG4: Explicit instrument</li></ul><center><img src="/images/Research/semantic-tree.jpg" width="50%" height="50%" />Semantic Tree</center><p>除了这些基本的标志外，还存在 adjuntive argument（ArgMs），以及 ArgM-Loc，Arm=gM-TMP 等等。对于下面的例子，使用 operate 作为候选词获得的标注：</p><blockquote><p>It operates stores mostly in Iowa and Nebraska.</p><p>[$_{ARG0}$It] [$_{谓词}$operates] [$_{ARG1}$ stores][$_{ARGM−LOC}$ mostly in Iowa and Nebraska].</p></blockquote><p>PropBank 假定对于一个谓词的语义单元只存在一个或多个 nodes。尽管对于大部分的 arguments 树只有一个 node，但多个 node 的情况也是存在的。</p><h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h2><p>在 ASSERT 中，SRL 是通过对于一个 syntactic parse 的组分分配一个 role label 实现的。基本上可以被分到三个步骤：</p><ol><li>Argument identification：对于一个给定的谓词，识别句子成分。对于 parse tree 中的任何一个 node，可以被分类为具有语义表示（Not Null Node）或者不具备任何语义内涵。</li><li>Argument classification：假定已知一个谓词的组成已知，这个步骤将 argument label 赋给这些组成。</li><li>Argument identification and classfication：上述两个任务的组合。</li></ol><h2 id="ASSERT（Automatic-Statistical-Semantic-Role-Tagger）"><a href="#ASSERT（Automatic-Statistical-Semantic-Role-Tagger）" class="headerlink" title="ASSERT（Automatic Statistical Semantic Role Tagger）"></a>ASSERT（Automatic Statistical Semantic Role Tagger）</h2><h3 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h3><p>ASSERT 对每一个谓词生成一组 SRL（不同于 PropBank，系词是考虑在内的）。模型基本的输入是一个句子以及成分分析树。对于每一个分析树中的成分，ASSERT 提取出一组特征，并使用分类器对这个成分指定标签。该模型使用 SVM 方法及“one vs all”构建 n 个分类器，每一个分类器的结果被综合对标签进行判断。</p><p>上述使用的方法有一个缺陷：每一个 argument 的分类是独立的，而没有考虑其他被赋给相同标签的 argument。这样会忽略部分信息。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>使用的特征如下：</p><ul><li>谓词：确定 arguments 所使用的这一个谓词，同时该谓词的形式及语法信息同样作为特征输入。</li><li>路径：从分析树到当前分类谓词的路径。</li></ul><center><img src="/images/Research/tree-path.jpg" width="50%" height="50%" /></center><ul><li>短语类型：比如 PP，NP 等等成分。</li><li>位置：这个成分出现在谓词前还是谓词后</li><li>状态：这个谓词是主动的还是被动的。</li><li>子类？：这个谓词的子节点，例如在上图中：<code>VP -&gt; VBD - PP - NP</code>。</li><li>谓词 cluster：直观是，对于相似的语法结构的动词应该有相似的对象。例如“eat&amp;devour”。动词被分为 64 类，然后通过这个分类作为特征。</li><li>Head word：这个成分的 head。</li><li>Head word Pos：这个 head word 的 pos。</li><li>成分中的 named entity。</li><li>…… 太多了，不一一列举了。</li></ul><p>在实验过程中，对于 Identification Task 和 Classification Task 的有效特征是不同的。对于 IT，有效的特征是 Path 和 Partial Path，而谓词并不是非常重要。而对于分类，更重要的是 Head word，First/Last word 这些词。</p><p>简单的结论是，结构性的特征（如 Path）对于 IT 有积极作用，而更 lexical 的词或语义上的特征则对于分类更加重要。</p><h2 id="鲁棒性分析"><a href="#鲁棒性分析" class="headerlink" title="鲁棒性分析"></a>鲁棒性分析</h2><p>基本上目前的研究都将注意力放在了带有某种相同风格的文本上，对于这些文本集表现得提高可能更多意味着对于<strong>某类文本</strong>的辨识力/拟合，然而 SRL 等工具应当是普适意味的……为了表现这些模型确实不具有很强的迁移能力，引入下列的数据集。</p><h3 id="The-Brown-Corpus"><a href="#The-Brown-Corpus" class="headerlink" title="The Brown Corpus"></a>The Brown Corpus</h3><p>BC 是美式英语标准语料库，包含 1 百万英文文本，收录 2000 多词越 500 个样本。这个数据集用做语言对照分析。</p><h3 id="跨风格测试"><a href="#跨风格测试" class="headerlink" title="跨风格测试"></a>跨风格测试</h3><p>这一个测试表现模型在一个数据集上训练以后迁移到另一个数据集上是训练得到的结果差异。其选择在 WSJ 模型上先完成训练，然后迁移到 BS 上进行对比。我们掠过结果分析部分。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>获得了在 PropBank 上的 SRL SOTA，并使用这个结果在 Brown 语料库上进行检验。事实证明，在 Brown 上的模型表现大幅度下降，作者认为其中 Identification 步骤对模型能力下降影响不大，分类部分是模型能力下降的主要原因。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用数据结构</title>
      <link href="/2020/07/08/tech-Python-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/08/tech-Python-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了准备清华的机考，花了大概半个小时整理了一下 Python 常用的数据结构的技巧（虽然可能存在其他直接的方法……）</p><a id="more"></a>  <h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2><p><strong>栈和队列的实现。</strong></p><p>统一使用 append 压入数字。对于 pop：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a.pop(<span class="number">0</span>)) <span class="comment">#删除第一个元素并返回，用来形成队列</span></span><br><span class="line">print(a.pop()) <span class="comment">#删除最后一个元素并返回，用来形成栈</span></span><br></pre></td></tr></table></figure><p><strong>排序</strong></p><ul><li>普通排序</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = sorted(a, reverse = <span class="literal">True</span>) <span class="comment"># 排序</span></span><br></pre></td></tr></table></figure><ul><li>多个数字排序</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">data = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line">data = sorted(data, key=operator.itemgetter(<span class="number">1</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>其中 operator.itemgetter 可以申明多个数字，是优先级的定义。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><strong>快速创建字典</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = set(range(<span class="number">14</span>))</span><br><span class="line">b = set(range(<span class="number">1</span>, <span class="number">15</span>))</span><br><span class="line">res =  dict(zip(a, b))</span><br></pre></td></tr></table></figure><p>这个方法可以快速组件字典。</p><p><strong>字典的操作</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">res.pop(<span class="number">1</span>, <span class="number">0</span>) <span class="comment"># 右为default值，若没有则返回该值</span></span><br><span class="line">adict = &#123;<span class="string">'a'</span>: <span class="number">12</span>&#125;</span><br><span class="line">res.update(adict)</span><br></pre></td></tr></table></figure><ul><li><code>pop</code>用来删除键，如果要删除的键不存在，则返回申明的第二个参数（这里是 0）。</li><li><code>update</code>用来更新字典，参数是另一个字典。速度比直接创建新字典快不少。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>我发现我几乎没用过 set，可能作为集合每个元素只能出现一次的性质我没太需要用到。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = set(<span class="string">'spam'</span>)</span><br><span class="line">y = set([<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'b'</span>])</span><br><span class="line"></span><br><span class="line">print(x &amp; y)</span><br><span class="line">print(x | y)</span><br><span class="line">print(x - y)</span><br><span class="line"></span><br><span class="line">y.add(<span class="string">'x'</span>)            </span><br><span class="line">y.update([<span class="number">10</span>,<span class="number">37</span>,<span class="number">42</span>])  </span><br><span class="line">y.remove(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><p>上述的功能都很直接，故不赘述。特殊的，如果往 set 里面增加重复的元素，则没有任何事事情会发生，所以可以用来快速移除重复元素；但 set 不会维护输入的顺序，所以不建议在使用 set 的情况下做与遍历顺序相关的操作。一般来说，使用<code>if a in B</code>的操作，set 会比 list 更快。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spaCy模型离线安装</title>
      <link href="/2020/07/08/tech-Python-Spacy%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/07/08/tech-Python-Spacy%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了安装 AllenNLP，不得已更新了 Torch。然后发现 SpaCy 的语言包也需要更新。奈何现在不在国内，更新语言包非常难受。网上的方法大多不济，这里简单记录。</p><a id="more"></a>  <h2 id="排雷"><a href="#排雷" class="headerlink" title="排雷"></a>排雷</h2><ul><li>在国内直接使用<code>python -m spacy download en</code>，一般下载到 50%左右就会断开连接。</li><li>下载了离线包之后，在文件夹执行<code>python setup.py install</code>并没有什么用处，模型仍然不能被正确识别。</li><li>使用<code>pip install *.tar.gz</code>，会导致开始下载模型……</li></ul><p>上述方法都是经过反复尝试并且无效的。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在 github 上找到合适的 en 模型下载并解压，得到一个文件夹：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\<span class="selector-tag">-</span> <span class="selector-tag">en_core_web_sm</span></span><br><span class="line">    <span class="selector-tag">en_core_web_sm-2</span><span class="selector-class">.3</span><span class="selector-class">.0</span></span><br><span class="line">    __<span class="selector-tag">init__</span><span class="selector-class">.py</span></span><br><span class="line">    <span class="selector-tag">meta</span><span class="selector-class">.json</span></span><br></pre></td></tr></table></figure><p>将上述文件放入</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\A</span>naconda3<span class="symbol">\L</span>ib<span class="symbol">\s</span>ite-packages<span class="symbol">\e</span>n_core_web_sm</span><br></pre></td></tr></table></figure><p>替换原本文件，然后即可正常使用。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode连接Python调试</title>
      <link href="/2020/07/04/tech-VSC-vscode%E8%BF%9E%E6%8E%A5python/"/>
      <url>/2020/07/04/tech-VSC-vscode%E8%BF%9E%E6%8E%A5python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>虽然一直用的是 VSC 和 Python 的组合，但是之前都是硬核 print 调试，并且需要从 Anaconda prompt 进入文件夹操作。确实觉得这个方法很难受，于是开始调整 VSC 连接 Python。中途遇到了不少的坑，这里对其进行一个整理。</p><a id="more"></a>  <h2 id="Anaconda环境"><a href="#Anaconda环境" class="headerlink" title="Anaconda环境"></a>Anaconda环境</h2><p>首先需要安装 Anaconda，Anaconda 会默认安装一个带有 conda 命令的 shell，但是在普通的 cmd 和 powershell 里都不能用这个东西。需要在环境变量中添加下述：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\A</span>naconda3</span><br><span class="line"><span class="symbol">\A</span>naconda3<span class="symbol">\S</span>cripts</span><br><span class="line"><span class="symbol">\A</span>naconda3<span class="symbol">\L</span>ibrary<span class="symbol">\b</span>in</span><br></pre></td></tr></table></figure><p>然后重启，这样可以在 cmd 里使用 Ananconda，例如 conda activate base 等命令。然而在 Powershell 里不知为何不能使用。使用<code>conda init</code>方法宣告无效。</p><h2 id="VSC和Python"><a href="#VSC和Python" class="headerlink" title="VSC和Python"></a>VSC和Python</h2><p>VSC 默认的 Terminal 是 Powershell，所以不能正常使用<code>conda</code>命令，所以需要添加 cmd。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"<span class="selector-tag">terminal</span><span class="selector-class">.integrated</span><span class="selector-class">.shell</span><span class="selector-class">.windows</span>": "<span class="selector-tag">C</span>:\\<span class="selector-tag">Windows</span>\\<span class="selector-tag">System32</span>\\<span class="selector-tag">cmd</span><span class="selector-class">.exe</span>",</span><br></pre></td></tr></table></figure><p>这个时候会报找不到 package 的错误，需要在 VSC 中添加 conda 的地址。在 VSC 设置中搜索<code>conda</code>并输入：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\A</span>naconda3<span class="symbol">\S</span>cripts<span class="symbol">\c</span>onda.exe</span><br></pre></td></tr></table></figure><p>同时在设置中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"code-runner.executorMap"</span>: &#123;</span><br><span class="line">  <span class="string">"python"</span>:<span class="string">"<span class="variable">$pythonPath</span> <span class="variable">$fullFileName</span>"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>根据上述的设置，将 Terminal 变为 cmd，然后即可正常 debug。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformers使用</title>
      <link href="/2020/07/04/tech-Huggingface/"/>
      <url>/2020/07/04/tech-Huggingface/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本地使用 Huggingface 的 transformer 挺麻烦的，可能之后还会碰到。这里做一个记录。</p><a id="more"></a>  <h2 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h2><p>模型如果标注了<code>from_pretrain(&#39;&#39;)</code>之类的，则需要加载模型。而不幸的是，官方下载模型的渠道很慢，需要使用离线下载方法。下述以 BERT 作为例子，下载步骤如下：</p><ol><li>进入链接，找到<a href="https://huggingface.co/models" target="_blank" rel="noopener">模型</a>的位置。</li><li>找到特殊的模型，进入<a href="https://huggingface.co/bert-base-uncased" target="_blank" rel="noopener">界面</a>。</li><li>在模型下方找到<a href="https://huggingface.co/bert-base-uncased#list-files" target="_blank" rel="noopener">List all files in model</a>。</li><li>选择其中的’config.json; pytorch_model.bin; vocab.txt’下载到同一个文件夹。</li></ol><h2 id="模型载入"><a href="#模型载入" class="headerlink" title="模型载入"></a>模型载入</h2><p>在开始载入以前，需要将上述下载文件放置到一个文件夹下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\<span class="selector-tag">-</span> <span class="selector-tag">bert-uncased</span></span><br><span class="line">    <span class="selector-tag">config</span><span class="selector-class">.json</span></span><br><span class="line">    <span class="selector-tag">pytorch_model</span><span class="selector-class">.bin</span></span><br><span class="line">    <span class="selector-tag">vocab</span><span class="selector-class">.txt</span></span><br><span class="line"><span class="selector-tag">train</span><span class="selector-class">.py</span></span><br></pre></td></tr></table></figure><p>在 <code>train.py</code> 中的代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertTokenizer, BertModel</span><br><span class="line"></span><br><span class="line">path = <span class="string">'D:/LAB/LAB-last/lex-dis/cont-cont/bert-uncased'</span></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(path)</span><br><span class="line">model = BertModel.from_pretrained(path)</span><br></pre></td></tr></table></figure><p>这里模型载入即结束。使用相对路径不知为何不能成功，需要使用全地址。</p><h2 id="模型使用"><a href="#模型使用" class="headerlink" title="模型使用"></a>模型使用</h2><p>tokenizers 和 model 的使用这里暂时搁置。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文件管理及自动更新</title>
      <link href="/2020/07/04/tech-Hexo%E6%96%87%E4%BB%B6%E5%A4%B9%E7%AE%A1%E7%90%86/"/>
      <url>/2020/07/04/tech-Hexo%E6%96%87%E4%BB%B6%E5%A4%B9%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于：</p><ul><li>Hexo 文件夹系统</li><li>Blog 在 Gitee 上自动更新</li></ul><a id="more"></a>  <h2 id="Hexo文件夹系统"><a href="#Hexo文件夹系统" class="headerlink" title="Hexo文件夹系统"></a>Hexo文件夹系统</h2><p>因为最近累积的笔记越来越多了，而 Hexo 原生似乎不支持文件夹操作，故决定建立文件夹系统。它的思路很简单，就是在一个别处的文件夹下完成笔记的记录，在需要更新的时候，使用脚本递归地搜索这些文件夹，将所有的 md 文件全部收集到对应的<code>_posts</code>文件夹下。具体脚本如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">ori_path = <span class="string">'../files'</span></span><br><span class="line">dst_path = <span class="string">'../source/_posts/'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file</span><span class="params">(path, name, cat)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">        cat_c = cat.copy()</span><br><span class="line">        cat_c.append(name)</span><br><span class="line">        files = os.listdir(path)</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            get_file(path  + <span class="string">'/'</span> + file, file, cat_c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.md'</span> <span class="keyword">in</span> name:</span><br><span class="line">            route = <span class="string">'-'</span>.join(cat[<span class="number">1</span>:])</span><br><span class="line">            shutil.copyfile(path, dst_path + route + <span class="string">"-"</span> + name)</span><br><span class="line"></span><br><span class="line">get_file(ori_path, <span class="string">''</span>, [])</span><br><span class="line">print(<span class="string">'Done!'</span>)</span><br></pre></td></tr></table></figure><h2 id="自动更新Gitee"><a href="#自动更新Gitee" class="headerlink" title="自动更新Gitee"></a>自动更新Gitee</h2><p>由于 Gitee 每一次更新 Blog 后需要访问 Gitee 手动完成 deploy。这个过程是在令人不爽。所以添加一个脚本用来自动完成这一步。具体依赖 selenium。</p><h3 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h3><p>进入谷歌商店，进入拓展商店下载 selenium。录制结束后导出为 py 文件。注意在这个过程中，需要将部分路径改为<code>xpath</code>。此外可能有 xpath 不能生效的情况，此时需要在该语句前添加 flush()。最后，由于 deploy 需要一些时间，所以需要使用 time 函数手动停止一些时间以完成 deploy。代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBlog</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup_method</span><span class="params">(self)</span>:</span></span><br><span class="line">    options = webdriver.ChromeOptions()</span><br><span class="line">    self.driver = webdriver.Chrome()</span><br><span class="line">    self.vars = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teardown_method</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.driver.quit()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wait_for_window</span><span class="params">(self, timeout = <span class="number">2</span>)</span>:</span></span><br><span class="line">    time.sleep(round(timeout / <span class="number">1000</span>))</span><br><span class="line">    wh_now = self.driver.window_handles</span><br><span class="line">    wh_then = self.vars[<span class="string">"window_handles"</span>]</span><br><span class="line">    <span class="keyword">if</span> len(wh_now) &gt; len(wh_then):</span><br><span class="line">      <span class="keyword">return</span> set(wh_now).difference(set(wh_then)).pop()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_blog</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.driver.get(<span class="string">"https://gitee.com/yoursite/pages"</span>)</span><br><span class="line">    self.driver.set_window_size(<span class="number">1514</span>, <span class="number">984</span>)</span><br><span class="line">    self.driver.find_element(By.LINK_TEXT, <span class="string">"Sign in"</span>).click()</span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">"user_login"</span>).click()</span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">"user_login"</span>).send_keys(<span class="string">"email@foobar.com"</span>)</span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">"user_password"</span>).send_keys(<span class="string">"password"</span>)</span><br><span class="line">    self.driver.find_element(By.CSS_SELECTOR, <span class="string">".two:nth-child(3) label"</span>).click()</span><br><span class="line">    self.driver.find_element(By.NAME, <span class="string">"commit"</span>).click()</span><br><span class="line">    self.driver.refresh()</span><br><span class="line">    self.driver.find_element(By.CSS_SELECTOR, <span class="string">".redeploy-button"</span>).click()</span><br><span class="line">    <span class="keyword">assert</span> self.driver.switch_to.alert.text == <span class="string">"Are you sure to redeploy Gitee Pages?"</span></span><br><span class="line">    self.driver.switch_to.alert.accept()</span><br><span class="line">    time.sleep(<span class="number">60</span>)</span><br><span class="line">  </span><br><span class="line">test = TestBlog()</span><br><span class="line">test.setup_method()</span><br><span class="line">test.test_blog()</span><br><span class="line">test.teardown_method()</span><br></pre></td></tr></table></figure><p>完成上述步骤后，结合之前的自动添加空格以及基本的 hexo 操作，我们就可以全自动地完成文件夹整理及 deploy 操作了。如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">C:</span><br><span class="line">cd C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\D</span>ocuments<span class="symbol">\J</span>oseph<span class="symbol">\B</span>log<span class="symbol">\u</span>pdate</span><br><span class="line">python update_file.py</span><br><span class="line">cd C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\D</span>ocuments<span class="symbol">\J</span>oseph<span class="symbol">\B</span>log</span><br><span class="line">textlint --fix source/_posts/*.md &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; cd C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\D</span>ocuments<span class="symbol">\J</span>oseph<span class="symbol">\B</span>log<span class="symbol">\u</span>pdate &amp;&amp; python gitee.py</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 英文文本成分分析</title>
      <link href="/2020/07/03/tech-Python-%E8%8B%B1%E6%96%87%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
      <url>/2020/07/03/tech-Python-%E8%8B%B1%E6%96%87%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了确定句子中从句的位置并将其剥离出来，需要找到一个成分分析的 parser，本文是对使用这个 parser 的一个具体的说明。使用的工具来自 ACL 2018：<a href="https://github.com/nikitakit/self-attentive-parser" target="_blank" rel="noopener">Constituency Parsing with a Self-Attentive Encoder</a>。</p><a id="more"></a>  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这个工具可以和 SpaCy 及 NLTK 一同使用。但是在尝试工程中发现和 SpaCy 的联动除了一些问题，会返回不知道如何解决的错误，但是 NLTK 则运行正常。这里记录 NLTK 版本的安装和使用方法。</p><p>首先，这个模型的运行需要先行下载：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line">nltk.download(<span class="string">'punkt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> benepar</span><br><span class="line">benepar.download(<span class="string">'benepar_en'</span>)</span><br></pre></td></tr></table></figure><p>但是这个下载速度非常地慢。希望离线下载需要访问上述 GitHub 链接，找到对应的<code>benepar_en2.zip</code>包下载。（不知道为何，找不到 benepar_en 包）。将这个压缩包放置在<code>C:/Users/.../AppData/Roaming/nltk_data/models/</code>下。punkt 包也能通过访问 nltk_data 找到对应的压缩包，不过这个包需要放置在上面文件夹旁的<code>tokenizers</code>文件夹下并解压。</p><p>这样就完成了这个模型的安装。如果不存在<code>benepar</code>则可以先 install 一次。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> benepar</span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line">parser = benepar.Parser(<span class="string">"benepar_en"</span>)</span><br></pre></td></tr></table></figure><p>由于我们使用了 nltk 的方法，所以不需要引入 SpaCy 的文件。上面的代码可以获得一个 parser，这个 parser 可以用来完成成分分析。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree = parser.parse(context)</span><br></pre></td></tr></table></figure><p>上述获得的 tree 打印出来效果如下：</p><blockquote><p>Added another executive at a big bank: “We were all a little goosey over the weekend trying to forecast what would happen Monday, but it’s been very quiet.”</p></blockquote><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">SINV</span></span><br><span class="line">  (<span class="name">VP</span> (<span class="name">VBN</span> Added))</span><br><span class="line">  (<span class="name">NP</span></span><br><span class="line">    (<span class="name">NP</span> (<span class="name">DT</span> another) (<span class="name">NN</span> executive))</span><br><span class="line">    (<span class="name">PP</span> (<span class="name">IN</span> at) (<span class="name">NP</span> (<span class="name">DT</span> a) (<span class="name">JJ</span> big) (<span class="name">NN</span> bank))))</span><br><span class="line">  (<span class="name">:</span> :)</span><br><span class="line">  (`` ``)</span><br><span class="line">  (<span class="name">S</span></span><br><span class="line">    (<span class="name">S</span></span><br><span class="line">      (<span class="name">NP</span> (<span class="name">PRP</span> We))</span><br><span class="line">      (<span class="name">VP</span></span><br><span class="line">        (<span class="name">VBD</span> were)</span><br><span class="line">        (<span class="name">DT</span> all)</span><br><span class="line">        (<span class="name">ADJP</span> (<span class="name">DT</span> a) (<span class="name">RB</span> little) (<span class="name">JJ</span> goosey))</span><br><span class="line">        (<span class="name">PP</span> (<span class="name">IN</span> over) (<span class="name">NP</span> (<span class="name">DT</span> the) (<span class="name">NN</span> weekend)))</span><br><span class="line">        (<span class="name">S</span></span><br><span class="line">          (<span class="name">VP</span></span><br><span class="line">            (<span class="name">VBG</span> trying)</span><br><span class="line">            (<span class="name">S</span></span><br><span class="line">              (<span class="name">VP</span></span><br><span class="line">                (<span class="name">TO</span> to)</span><br><span class="line">                (<span class="name">VP</span></span><br><span class="line">                  (<span class="name">VB</span> forecast)</span><br><span class="line">                  (<span class="name">SBAR</span></span><br><span class="line">                    (<span class="name">WHNP</span> (<span class="name">WP</span> what))</span><br><span class="line">                    (<span class="name">S</span></span><br><span class="line">                      (<span class="name">VP</span></span><br><span class="line">                        (<span class="name">MD</span> would)</span><br><span class="line">                        (<span class="name">VP</span></span><br><span class="line">                          (<span class="name">VB</span> happen)</span><br><span class="line">                          (<span class="name">PRN</span></span><br><span class="line">                            (<span class="name">-LRB-</span> -LCB-)</span><br><span class="line">                            (<span class="name">NP</span> (<span class="name">NNP</span> Monday))</span><br><span class="line">                            (<span class="name">-RRB-</span> -RCB-)))))))))))))</span><br><span class="line">    (, ,)</span><br><span class="line">    (<span class="name">CC</span> but)</span><br><span class="line">    (<span class="name">S</span></span><br><span class="line">      (<span class="name">NP</span> (<span class="name">PRP</span> it))</span><br><span class="line">      (<span class="name">VP</span> (<span class="name">VBZ</span> <span class="symbol">'s</span>) (<span class="name">VP</span> (<span class="name">VBN</span> been) (<span class="name">ADJP</span> (<span class="name">RB</span> very) (<span class="name">JJ</span> quiet))))))</span><br><span class="line">  (<span class="name">.</span> .))</span><br></pre></td></tr></table></figure><p>返回的 tree 是<code>nltk.tree</code>的结构，对于每一个 node，其子树或为另一个 node，或者为一个 leaf，一个 leaf 就是一个字符串。可以使用：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> type(node) == str:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>判断对象是一个 node 还是一个 leaf，如果是一个 node，则可以仿照 list 的方式对其进行遍历。此外 tree 结构的每一个 node，对应一个 label，调用的方式为：<code>node.label()</code>，可以获得这个节点的标签，在上面的实例中，”S”就是一个标签，标志着其句子成分。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows上安装LaTeX</title>
      <link href="/2020/07/03/tech-LaTeX-windows%E4%B8%8A%E5%AE%89%E8%A3%85/"/>
      <url>/2020/07/03/tech-LaTeX-windows%E4%B8%8A%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-NwvEPRPZ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1455701955" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>这不是第一次安装 latex 了，但每次安装都会遇到一些问题，消耗搜索的时间，这次对其作一个整理。</p><a id="more"></a>  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先是从 tex live 的官网上下载到最新版的 texlive 并安装。基本上，官网上下到的是一个叫做<code>install-tl-windows.exe</code>的可执行文件。这个文件点开后即可开始下载。下载的时间很长，预计从早上开始下载需要在傍晚才能下载结束。</p><p>不出意外安装结束之后，windows 的“开始”会出现 TexWorks Editor 等等工具。以及 Tex 的路径可以自动加载到系统环境变量中，重启之后即可生效。</p><h2 id="VSCODE"><a href="#VSCODE" class="headerlink" title="VSCODE"></a>VSCODE</h2><p>使用 VSC 可能会比较舒服，但是总有一些小问题。为了在 VSC 中预览 LaTeX，需要下载拓展：LaTeX Workshop。下载结束后 VSC 可以获得高亮 Tex 代码的能力。</p><p>在左侧的工具栏会在选中 Tex 文件时获得新的 LaTeX 标志，其中可以选择编译文件或者在 VSC Tab 中预览文件。</p><p>为了和 VSC 链接，需要打开 VSC 的设置代码，添加下述代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.recipes": [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">    <span class="attr">"tools"</span>: [</span><br><span class="line">      <span class="string">"xelatex"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"xelatex -&gt; bibtex -&gt; xelatex*2"</span>,</span><br><span class="line">    <span class="attr">"tools"</span>: [</span><br><span class="line">      <span class="string">"xelatex"</span>,</span><br><span class="line">      <span class="string">"bibtex"</span>,</span><br><span class="line">      <span class="string">"xelatex"</span>,</span><br><span class="line">      <span class="string">"xelatex"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line">"latex-workshop.latex.tools": [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">      <span class="string">"-synctex=1"</span>,</span><br><span class="line">      <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">      <span class="string">"-file-line-error"</span>,</span><br><span class="line">      <span class="string">"-pdf"</span>,</span><br><span class="line">      <span class="string">"%DOC%"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">      <span class="string">"-synctex=1"</span>,</span><br><span class="line">      <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">      <span class="string">"-file-line-error"</span>,</span><br><span class="line">      <span class="string">"%DOC%"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">      <span class="string">"%DOCFILE%"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line">"latex-preview.command": "xelatex",</span><br><span class="line">"latex-workshop.latex.autoBuild.run": "never"</span><br></pre></td></tr></table></figure><p>上述的代码会将 recipe 加入 build 选项，通过点击编译文件。但在这个设置中，如果文件出现 error，VSC 将会选择终止执行，在终止执行的情况下，虽然可以获得一个 pdf 文件，但是这份文件的一部分内容是有误的，例如 Content 的添加等等，所以这个版本在写作中途可以用来作为参照但并不适合作为最后微调的方法。</p><p>在这个情况下，可以使用 overleaf 或者在文件所在的文件夹下唤起 cmd，使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">xelatex</span> <span class="selector-tag">main</span><span class="selector-class">.tex</span></span><br></pre></td></tr></table></figure><p>忽视中间的错误可以获得生成的文件，在这个文件中 Content 等信息是正常的。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python英文分句</title>
      <link href="/2020/06/30/tech-Python-%E8%8B%B1%E6%96%87%E5%88%86%E5%8F%A5/"/>
      <url>/2020/06/30/tech-Python-%E8%8B%B1%E6%96%87%E5%88%86%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简记 NLTK 对英文文本进行分句的方法。</p><a id="more"></a>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.tokenize <span class="keyword">import</span> sent_tokenize</span><br><span class="line"></span><br><span class="line">sent_tokenize(<span class="string">'this is an example. simply an example.'</span>)</span><br></pre></td></tr></table></figure><p>上述代码返回的结果是包含了两个分句的 list。结束。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSV读写</title>
      <link href="/2020/06/30/tech-Python-CSV%E8%AF%BB%E5%8F%96/"/>
      <url>/2020/06/30/tech-Python-CSV%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>每一次碰到 CSV 都需要单独搜一次做法，还经常出一些小 bug。这里对最简单的 CSV 读写做一个整理。</p><a id="more"></a> <p>csv 存储的内容如：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'data'</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">'index'</span>: <span class="number">0</span></span><br><span class="line">    &#125;, ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="读CSV"><a href="#读CSV" class="headerlink" title="读CSV"></a>读CSV</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.csv'</span>, <span class="string">'r'</span>, encoding=<span class="string">'unicode_escape'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    reader = csv.DictReader(csvfile)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        print(row[<span class="string">'data'</span>], row[<span class="string">'index'</span>])</span><br></pre></td></tr></table></figure><p>注意 <code>unicode_esxape</code> 是对文件中出现了奇怪字符使用的。如果使用 <code>utf-8</code> 仍不能正常解码的时候可以使用。</p><h2 id="写CSV"><a href="#写CSV" class="headerlink" title="写CSV"></a>写CSV</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">fieldnames = [<span class="string">'data'</span>, <span class="string">'index'</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.csv'</span>, <span class="string">'w'</span>, encoding = <span class="string">'utf-8'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    writer.writerow(fieldnames)</span><br><span class="line">    writer.writerow([<span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames)</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;<span class="string">'data'</span>: <span class="number">2</span>, <span class="string">'index'</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>即第一次使用<code>writerow</code>时，需要先写入第一排域名，然后后面每一排则是根据域名排序的 list。</li><li>使用字典和 list 是等价的，哪个方便用哪个。</li><li>写入的时候一定不能标记为<code>unicode_escape</code>，否则会乱码。使用<code>utf-8</code>就 ok。</li><li>需要加上<code>newline = &#39;&#39;</code>，否则每一行后面会接一行空行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CV：深度卷积神经网络模型及调参</title>
      <link href="/2020/06/27/scholar-DL-DCNN/"/>
      <url>/2020/06/27/scholar-DL-DCNN/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为连续做了两个使用 CNN 网络的模型训练，所以这里单独开一个记录 CNN 调参的心路历程。</p><a id="more"></a>  <h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>经过众多测试，得到的通用模型如下。基本思想是深的神经网络以及小的卷积核，并且卷积核的 channel 逐渐增加的机制。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperNaiveModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(SuperNaiveModel, self).__init__()</span><br><span class="line">        self.conv0 = nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">64</span>, momentum=<span class="number">0.1</span>),            </span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">        )</span><br><span class="line">        self.conv1 = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv2 = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">128</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),            </span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv20 = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),            </span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv3=torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">512</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">512</span>, momentum=<span class="number">0.1</span>),            </span><br><span class="line">            torch.nn.ReLU(),            </span><br><span class="line">            torch.nn.Conv2d(<span class="number">512</span>, <span class="number">512</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">512</span>, momentum=<span class="number">0.1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.dense = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Linear(<span class="number">512</span> * <span class="number">4</span> * <span class="number">4</span>, <span class="number">20</span>),</span><br><span class="line">            nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = x.reshape(x.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>).float()</span><br><span class="line">        x = self.conv0(x)</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.conv20(x)</span><br><span class="line">        x = self.conv3(x)</span><br><span class="line">        x = x.view(x.shape[<span class="number">0</span>], <span class="number">512</span> * <span class="number">4</span> * <span class="number">4</span>)</span><br><span class="line">        x = self.dense(x)</span><br><span class="line">        <span class="keyword">return</span> x1</span><br></pre></td></tr></table></figure><h2 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h2><p>由于训练资源不够，所以使用一个 5x5 的卷积核代替了应有的两个 3x3 卷积核链接的效果。根据 VGG，<strong>连续使用两个 3x3</strong>可能效果会好一些。</p><p>Batchnorm 是一个玄学的东西，它的功能并不如预期一样稳定，并且没有必要在没一个网络后都接一个 BN 层。事实上，根据实验，在模型的最开始和最后一层添加 BN 层的效果是明显的。ReLU 层作为非线性化的方法，几乎是必须的。</p><p>此外，过多的全连接层是不利的，每多增一个全连接层会对模型造成一定的影响。预测的原因是由于数据量不够支撑全连接层的泛化性，导致容易过拟合，泛化性差，反而不如一层全连接。所以全连接层越多越好不是绝对的。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> ML </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观佛记</title>
      <link href="/2020/06/27/essay-tour-%E5%B3%A8%E7%9C%89%E8%A1%8C/"/>
      <url>/2020/06/27/essay-tour-%E5%B3%A8%E7%9C%89%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-NjfgJhAo" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="17685905" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>虽说已经过了快两个月了，还是想记下那个不那么特殊的旅途.2020 年劳动节的峨眉山之行。虽说确实没有太多值得大书特书的细节，但就算当作流水账一样地记下来也是不错的。</p><a id="more"></a>  <p>事实上这个旅程是我从哈尔滨回来以后就一直在考虑的，然而最终因为疫情的原因没能在春节附近付诸实践，实在可惜。然情况总是纷繁复杂，居然到了五一节，我们这些学生还是滞留在自己的窝里面没有返校。五一节的几日长假不得不使人再次萌生了造访峨眉的想法，于是简单组织一通后和几个高中同学一同出发了。</p><p>一早起来，大概九点到了峨眉山脚。当时正逢疫情还在尾声的时候，每一个关卡都要检查健康码之类的东西。不过没有造成太大的阻碍，我们进山了。在山门口买了个舒适的竹杖。（这确实是救命的东西，不是打猴子，而是作为另一条腿。）一路上人不算太多，环境也很清幽。走走停停就能看见小亭子之类的东西。风景很难说是绝美，不过与城市的氛围自然还是迥异。最开始沿着山谷走，能一直看见下面流淌的透明小溪。这种景色总给我一种我曾经来过的感觉，可能是这样的风景实在是太多了吧。</p><p>一路上碰到一个山大王抢恰巧同行的一个小团队成员的小挎包。还恋恋不舍地跟了很久，但什么都没有抢到。大概是在仙峰寺附近，我的腿开始出现抽筋的症状，本来是一只腿，后来不幸另一条腿也开始抽筋。大概像是一条很粗的虫子在筋肉里穿梭的感觉。虽然感觉到疼但还是得往上走吧，一日登上峨眉算不上那么容易的事情。中间反复了几次，但通过休息和压腿算是稳定了下来。</p><p>然后仙峰寺之后是令人崩溃的上上下下。每一次站在一个山头，就看见另一个山头的小黑顶庙子，意识到那是下一个目的地的同时，得知需要先下山然后再爬到那里，是真的想骂上几句脏话，仿佛获得了前功尽弃的挫败感。这一路上的风景也相当的一般，没有想象中的那种壮美，也没有山大王之流的助兴。</p><p>到九岭冈的时候，整个队伍已经相当疲惫了。具体什么时候到那里的我已经记不确切了，但那个时候着实是怀着是否能在天黑前登上雷洞坪的担忧。后面我奇迹般地感觉自己的小腿抽筋消歇了，在钻天坡一路向上中居然越战越勇。大家根据情况不同，整个队伍也逐渐拉长。当时我在第二位，前面和后面的同学都不在了。我看见了洗象池的屋顶的时候，看见了一个宽阔的平台，旁边的围栏上立着两只互相搔毛的猴子。然后我看见了洗象池几个字和后面的一列陡峭的阶梯。我的两腿突然传来一阵剧痛，然后我就地跪了下去。据后面同学说，是听见了我的惨叫声。不过总之来到了一个新的节点。</p><p>后面的阎王坡实在震撼人心，长度和陡度都远超前面的钻天坡。不久后就走进了夜路，看见道路两旁藏青色的影子往前进。当到了宾馆吃上晚饭的时候已经是 10 点了。那个时候也没什么胃口，手机没电了，可能只是想坐一坐了吧。</p><p>中间的小卖部密集且良心。冰粉实在是天赐美物，中途还买了瓶可乐刺激刺激，但是也怀疑是这个导致体内酸性上升，以致抽筋。小竹棍也是必备之物，后面的路途可能都是靠支着这个小竹棍一点点往上挪的吧。</p><p>好歹，这是第一次完成了一个 41km 的旅途，这是我来没有想过的东西。我原来想峨眉可能就 20km 吧，我能行。但……总之算是问题不大。第二日起床去金顶看日出。日出确实是壮丽的。伴随着众多举着相机的人的欢呼声，像高邮咸鸭蛋那般的红色太阳从云层的那端慢慢露出来，透露出整个咸鸭蛋黄的金橙颜色，越发地诱人。然后天空呈现出一种绚丽的金色，最后慢慢变成普通闪耀着金光和大菩萨像一样颜色的太阳了。</p><p>我不太清楚自己是怎么爬上这个山的。我只记得我在路途的最后一程，我发自内心地想，如果这一路哪怕有一个可以放弃的地方，我可能就结束在那里了吧。往上走的原因只是既不能停下来，也不能回头罢了，和意志力什么的是无甚关联的东西。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行迹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch方法：DataSet</title>
      <link href="/2020/06/27/tech-PyTorch-DataSet/"/>
      <url>/2020/06/27/tech-PyTorch-DataSet/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简单记录一下如何使用 PyTorch 的 DataSet 及 DataLoader 功能。</p><a id="more"></a>  <p>DataSet 的使用通过继承 DataSet 类完成，并在此基础上需要构造三个特殊函数。下例为使用 DataSet，通过访问 json 文件获取数据内容，然后在 gititem 函数中获取数据并返回的例子。</p><h2 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSet</span><span class="params">(torch.utils.data.Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, train_or_valid, transform, path)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        file = open(<span class="string">'data/dataset.json'</span>, <span class="string">'r'</span>)</span><br><span class="line">        data = json.load(file)</span><br><span class="line">        self.datalist = data[train_or_valid]</span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        name = self.datalist[index][<span class="number">0</span>]</span><br><span class="line">        img = Image.open(self.path + name)</span><br><span class="line">        label = self.datalist[index][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"img"</span>: img, <span class="string">"label"</span>: label&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.datalist)</span><br></pre></td></tr></table></figure><p>上述返还的是一个数据字典。</p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>依旧使用上述的例子。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainset = DataSet(<span class="string">'train'</span>, transform_train, normal_path)</span><br></pre></td></tr></table></figure><h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>DataLoader 是 PyTorch 用来调取 DataSet 的一个类，其声明和使用如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"></span><br><span class="line">trainloader = data.DataLoader(trainset, batch_size = batch_sz, shuffle = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>第一个参数是上述生成的 DataSet，后面如同表述。</p><p>但往往上述的结构由于数据不规整不能满足要求，需要自己定义 Batch 函数。如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span><span class="params">(data)</span>:</span></span><br><span class="line">    src_len = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> data:</span><br><span class="line">        src_len.append(p[<span class="string">'wav'</span>].shape[<span class="number">1</span>])</span><br><span class="line">    src_pad = torch.zeros(len(data), data[<span class="number">0</span>][<span class="string">'wav'</span>].shape[<span class="number">0</span>], max(src_len))</span><br><span class="line">    tgt = torch.zeros(len(data))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        p = data[i]</span><br><span class="line">        end = src_len[i]</span><br><span class="line">        src_pad[i, :, -end:] = p[<span class="string">'wav'</span>]</span><br><span class="line">        tgt[i] = p[<span class="string">'label'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'wav'</span>: src_pad, <span class="string">'label'</span>: tgt&#125;</span><br><span class="line"></span><br><span class="line">validloader = data.DataLoader(validset, batch_size = batch_sz, shuffle = <span class="literal">False</span>, collate_fn = padding)</span><br></pre></td></tr></table></figure><p>返回的也是字典，并会使用 padding 函数。</p><h2 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h2><p>上面完成了预先代码的构建，最后是调用的步骤：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, samples <span class="keyword">in</span> enumerate(trainloader):</span><br><span class="line">    wavs, labels = samples[<span class="string">'wav'</span>], samples[<span class="string">'label'</span>]</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>返回的 samples 就是前面 padding 的结果，可以对此进行修改，例如保留原有的长度信息等等。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch常用训练框架</title>
      <link href="/2020/06/27/tech-PyTorch-%E5%B8%B8%E7%94%A8%E8%AE%AD%E7%BB%83%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/06/27/tech-PyTorch-%E5%B8%B8%E7%94%A8%E8%AE%AD%E7%BB%83%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>现在模型建的比较多了，因此也形成了一套成熟的流程，这里简单的记述一下常用的模型构建的方法，为了后续改进。</p><a id="more"></a>  <h2 id="文件夹架构"><a href="#文件夹架构" class="headerlink" title="文件夹架构"></a>文件夹架构</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\-</span> model</span><br><span class="line">    dataset.py</span><br><span class="line"><span class="string">\-</span> data</span><br><span class="line">    <span class="string">\-</span> images</span><br><span class="line">    <span class="string">\-</span> ori_data</span><br><span class="line"><span class="string">\-</span> preprocess</span><br><span class="line"><span class="string">\-</span> utils</span><br><span class="line">train.py</span><br><span class="line">config.py</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p><code>config.py</code> 保存 train 以及预处理中的超参，但是不建议使用该文件保存模型的超参（除非整个调整结束）。  <code>utils.py</code> 保留操作函数，用来辅助预处理以及数据分析等等功能。<code>data</code>中存储原始数据以及处理后的数据，部分时候有中间生成数据。<code>images</code>保存为了报告生成的图片。</p><p>生成上述结构代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(paths)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">    folder = os.path.exists(path) </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> folder:</span><br><span class="line">    os.makedirs(path)   </span><br><span class="line"></span><br><span class="line">mkdir([<span class="string">'model'</span>, <span class="string">'data'</span>, <span class="string">'preprocess'</span>, <span class="string">'utils'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'train.py'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'config.py'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'README.md'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h2><p>常用的 import 库文件。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> pk</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h3 id="自己的模型"><a href="#自己的模型" class="headerlink" title="自己的模型"></a>自己的模型</h3><p>常用的 Model 架构：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaiveModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(NaiveModel, self).__init__()</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="预训的模型"><a href="#预训的模型" class="headerlink" title="预训的模型"></a>预训的模型</h3><p>使用一些预训的模型使用。有两种魔改方法，其一是替代原模型中的部分层，另一部分是取出模型的某些部分和自己的其他网络组合。</p><p><strong>替换层方法</strong></p><p>以 vgg16 的替换方法为例。其中可以通过<code>model.features._modules[]</code>拿到对应的层，其中输入为 <code>print(model)</code>产生的输出。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VGG</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(VGGTorch, self).__init__()</span><br><span class="line">        model = torchvision.models.vgg16(pretrained = <span class="literal">False</span>)</span><br><span class="line">        init = torch.load(<span class="string">'data/vgg16-397923af.pth'</span>)</span><br><span class="line">        model.load_state_dict(init)</span><br><span class="line">        conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">5</span>, stride=(<span class="number">2</span>, <span class="number">2</span>), padding=(<span class="number">3</span>, <span class="number">3</span>), bias=<span class="literal">False</span>)</span><br><span class="line">        model.features._modules[<span class="string">'0'</span>] = conv2d</span><br><span class="line">        model.classifier = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">25088</span>, <span class="number">20</span>),</span><br><span class="line">            nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        self.model = model </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = x.reshape(x.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>).float()</span><br><span class="line">        x = self.model(x)</span><br><span class="line">        <span class="keyword">return</span> x, x</span><br></pre></td></tr></table></figure><p>上面可以通过<code>pretrain = True</code>拿到预训参数，但是下载很慢，可以复制链接自行离线下载然后通过上述方法导入。</p><p><strong>重新组合方法</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面是使用resnet18作为下采样层的UNet模型，通过将ResNet的层取出获得最终模型。其中还使用了预训参数。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_class)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.base_model = torchvision.models.resnet18(pretrained = <span class="literal">True</span>)</span><br><span class="line">        self.base_layers = list(self.base_model.children())</span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=(<span class="number">7</span>, <span class="number">7</span>), stride=(<span class="number">2</span>, <span class="number">2</span>), padding=(<span class="number">3</span>, <span class="number">3</span>), bias=<span class="literal">False</span>),</span><br><span class="line">            self.base_layers[<span class="number">1</span>],</span><br><span class="line">            self.base_layers[<span class="number">2</span>])</span><br><span class="line">        self.layer2 = nn.Sequential(*self.base_layers[<span class="number">3</span>:<span class="number">5</span>])</span><br><span class="line">        self.layer3 = self.base_layers[<span class="number">5</span>]</span><br><span class="line">        self.layer4 = self.base_layers[<span class="number">6</span>]</span><br><span class="line">        self.layer5 = self.base_layers[<span class="number">7</span>]</span><br><span class="line">        self.decode4 = Decoder(<span class="number">512</span>, <span class="number">256</span>+<span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">        self.decode3 = Decoder(<span class="number">256</span>, <span class="number">256</span>+<span class="number">128</span>, <span class="number">256</span>)</span><br><span class="line">        self.decode2 = Decoder(<span class="number">256</span>, <span class="number">128</span>+<span class="number">64</span>, <span class="number">128</span>)</span><br><span class="line">        self.decode1 = Decoder(<span class="number">128</span>, <span class="number">64</span>+<span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">        self.decode0 = nn.Sequential(</span><br><span class="line">            nn.Upsample(scale_factor=<span class="number">2</span>, mode=<span class="string">'bilinear'</span>, align_corners=<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">32</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">            )</span><br><span class="line">        self.conv_last = nn.Conv2d(<span class="number">64</span>, n_class, <span class="number">1</span>)</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(n_class * <span class="number">224</span> * <span class="number">224</span>, <span class="number">1024</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dropout(<span class="number">0.4</span>),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">2</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="Train"><a href="#Train" class="headerlink" title="Train"></a>Train</h2><p>下面是简化的框架。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> pk</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> model.dataset <span class="keyword">import</span> DataSet</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> model.naive_model <span class="keyword">import</span> NaiveModel</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(args)</span>:</span></span><br><span class="line">    cuda = torch.cuda.is_available()</span><br><span class="line">    <span class="keyword">if</span> cuda:</span><br><span class="line">        print(<span class="string">"CUDA is prepared"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dataset</span></span><br><span class="line">    trainset = DataSet(<span class="string">'train'</span>, transform_train, normal_path)</span><br><span class="line">    validset = DataSet(<span class="string">'valid'</span>, transform_valid, normal_path)</span><br><span class="line">    trainloader = data.DataLoader(trainset, batch_size = batch_sz, shuffle = <span class="literal">True</span>)</span><br><span class="line">    validloader = data.DataLoader(validset, batch_size = batch_sz, shuffle = <span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># model</span></span><br><span class="line">    model = NaiveModel(batch_sz, <span class="number">224</span>)</span><br><span class="line">    <span class="keyword">if</span> cuda:</span><br><span class="line">        model = model.cuda()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># lossfunc and optim</span></span><br><span class="line">    lossfun = nn.CrossEntropyLoss()</span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters())</span><br><span class="line">    </span><br><span class="line">    accs = []</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        <span class="comment"># valid</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            preds, labels = [], []</span><br><span class="line">            <span class="keyword">for</span> idx, samples <span class="keyword">in</span> enumerate(validloader):</span><br><span class="line">                img, label = samples[<span class="string">'img'</span>], samples[<span class="string">'label'</span>]        </span><br><span class="line">                <span class="keyword">if</span> cuda:</span><br><span class="line">                    img = img.cuda()</span><br><span class="line">                pred = model.eval(img, labels)</span><br><span class="line">                preds.append(pred)</span><br><span class="line">                labels.append(label)</span><br><span class="line">            torch.save(model.state_dict(), model_path)</span><br><span class="line">            labels = np.concatenate(labels, axis = <span class="number">0</span>).astype(int)</span><br><span class="line">            preds = np.concatenate(preds, axis = <span class="number">0</span>)</span><br><span class="line">            report = classification_report(labels, preds)</span><br><span class="line">            print(report)</span><br><span class="line">            acc = precision_score(labels, preds, average = <span class="string">'micro'</span>)</span><br><span class="line">            print(<span class="string">"Precision: &#123;&#125;"</span>.format(acc))</span><br><span class="line">            accs.append(acc)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># train</span></span><br><span class="line">        <span class="keyword">for</span> idx, samples <span class="keyword">in</span> enumerate(trainloader):</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            imgs, labels = samples[<span class="string">'img'</span>], samples[<span class="string">'label'</span>]</span><br><span class="line">            <span class="keyword">if</span> cuda:</span><br><span class="line">                labels = labels.cuda()</span><br><span class="line">                imgs = imgs.cuda()</span><br><span class="line">            </span><br><span class="line">            pred = model(imgs)</span><br><span class="line">            loss = lossfun(pred, labels.long())</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            print(<span class="string">'loss: &#123;&#125;'</span>.format(loss), end = <span class="string">'\r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'--pretrain'</span>, type=str, default=<span class="string">'yes'</span>,</span><br><span class="line">                        help=<span class="string">'if pre-train'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--finetune'</span>, type=str, default=<span class="string">'yes'</span>,</span><br><span class="line">                        help=<span class="string">'if finetune'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    train(args)</span><br></pre></td></tr></table></figure><h2 id="模型保存及预加载"><a href="#模型保存及预加载" class="headerlink" title="模型保存及预加载"></a>模型保存及预加载</h2><p><strong>保存</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">torch.save(<span class="keyword">model</span>.state_dict(), PATH)</span><br><span class="line"> </span><br><span class="line"># example</span><br><span class="line">torch.save(<span class="keyword">model</span>.state_dict(),<span class="string">'model.pth'</span>)</span><br></pre></td></tr></table></figure><p><strong>加载</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model.load<span class="constructor">_state_dict(<span class="params">torch</span>.<span class="params">load</span>(PATH)</span>)</span><br><span class="line"></span><br><span class="line"># example</span><br><span class="line">model.load<span class="constructor">_state_dict(<span class="params">torch</span>.<span class="params">load</span>('<span class="params">model</span>.<span class="params">pth</span>')</span>)</span><br></pre></td></tr></table></figure><p>这样就是整个模型的最基础框架搭建。但事实上一个任务真正困难的是在数据预处理策略和最后的调参上，这些就放在别的地方补充了吧。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> PyTorch </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用系统操作及文件操作</title>
      <link href="/2020/06/27/tech-Python-%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/06/27/tech-Python-%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-teBGffvn" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="465149196" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>在预处理文件以及训练模式时经常用到一个文件操作，这里稍加整理。</p><a id="more"></a>  <h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br></pre></td></tr></table></figure><p>OS 操作很常用，用于获取文件夹之类的操作。主要使用<code>os</code>和<code>shutil</code>两个库文件。</p><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.path.exists(path)</span><br><span class="line">os.path.isdir(path)</span><br><span class="line">os.path.isfile(path)</span><br><span class="line">files = os.listdir(path)</span><br></pre></td></tr></table></figure><p>判断路径是否存在，是一个文件夹还是一个文件。对于一个文件夹可以继续使用 <code>listdir</code> 获得文件内容</p><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(path)</span>:</span></span><br><span class="line"> </span><br><span class="line">    path=path.strip()</span><br><span class="line">    path=path.rstrip(<span class="string">"\\"</span>)</span><br><span class="line"> </span><br><span class="line">    isExists=os.path.exists(path)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        os.makedirs(path) </span><br><span class="line">        print(<span class="string">'OK!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Existed!)</span></span><br><span class="line"><span class="string">        return False</span></span><br></pre></td></tr></table></figure><h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.remove(path)</span><br><span class="line">os.rmdir(path)        <span class="comment">#仅能删除空文件夹</span></span><br><span class="line">shutil.rmtree(path)   <span class="comment">#递归删除所有内容</span></span><br></pre></td></tr></table></figure><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p>对于文件夹和文件的操作方法是一样的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.rename(<span class="string">"test"</span>,<span class="string">"test1"</span>)    </span><br><span class="line">os.rename(<span class="string">"test.txt"</span>,<span class="string">"test1.txt"</span>)</span><br></pre></td></tr></table></figure><h3 id="复制和移动"><a href="#复制和移动" class="headerlink" title="复制和移动"></a>复制和移动</h3><p>需要使用 <code>shutil</code> 的库文件操作。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shutil.copyfile(<span class="string">"foo.txt"</span>,<span class="string">"bar.txt"</span>)  <span class="comment"># file only</span></span><br><span class="line">shutil.copytree(<span class="string">"foo"</span>,<span class="string">"bar"</span>)          <span class="comment"># dir only</span></span><br><span class="line">shutil.copy(<span class="string">"foo"</span>,<span class="string">"bar"</span>)              <span class="comment"># both</span></span><br><span class="line">shutil.move(<span class="string">"foo"</span>,<span class="string">"bar"</span>)</span><br></pre></td></tr></table></figure><ul><li>上述的文件的复制方法，存在覆盖能力。文件夹的复制方法则不允许在目标地址存在相应文件夹。</li><li>如果调用<code>.copy()</code>，输入为一个文件和一个文件夹，则会将文件复制入文件夹中。</li><li><code>.move()</code>细节和<code>.copy()</code>相同</li></ul><h2 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h2><h3 id="基本读写"><a href="#基本读写" class="headerlink" title="基本读写"></a>基本读写</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path, <span class="string">'w'</span>, encoding = <span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'foobar!'</span>)</span><br><span class="line"><span class="keyword">with</span> open(path, <span class="string">'r'</span>, encoding = <span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>模式：</p><div class="table-container"><table><thead><tr><th>参数</th><th>效果</th></tr></thead><tbody><tr><td>w</td><td>写文件</td></tr><tr><td>r</td><td>读文件</td></tr><tr><td>a</td><td>追加文件</td></tr></tbody></table></div><h3 id="特殊：json"><a href="#特殊：json" class="headerlink" title="特殊：json"></a>特殊：json</h3><p>JSON 文件是常用的格式，为了方便存储字典型结构的最优选择。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.load(f)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(dataset, f)</span><br></pre></td></tr></table></figure><h3 id="特殊：pickle"><a href="#特殊：pickle" class="headerlink" title="特殊：pickle"></a>特殊：pickle</h3><p>pickle 常用来保存二进制数据结构。基本上是什么都能存。不过对于 PyTorch，还是建议使用 torch 自带的 save 函数，不然 torch 会报 warning。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> pk</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.pk'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pk.dump(data, f)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.pk'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = pk.load(f)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习的操作们</title>
      <link href="/2020/06/27/scholar-DL-%E8%B0%83%E5%8F%82/"/>
      <url>/2020/06/27/scholar-DL-%E8%B0%83%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>每一次深度模型调参都是让人头疼的东西，总感觉有很多玄学的东西能用，但事实上最后效果都不会太好。这里专门记录一些可能会有影响的调参方法。所以这是一个累积更新的文章。希望之后碰到新的方法和雷区能在这里记下，减少调试时间。</p><a id="more"></a>  <h2 id="有效措施"><a href="#有效措施" class="headerlink" title="有效措施"></a>有效措施</h2><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>数据预处理的效果可能比模型的各种调参来得更加直接有效。对于 NLP 任务可能不那么明显，但是对于 CV 或者 DSP 任务却是立竿见影的。</p><h4 id="数据增广"><a href="#数据增广" class="headerlink" title="数据增广"></a>数据增广</h4><p>计算机视觉中常用的方法。基本是对于图片随机翻转、随机截取、添加高斯模糊、随机遮盖等等措施。其中随机截取和随机翻转是一般都有效的，随机遮盖等则不一定。数据增广可以在模型训练中完成，让模型实时更改数据集内容；也可以在训练前就完成增广；两种方法都用也没有问题。</p><p>对于图片的数据增广方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line">transform = tfs.Compose([</span><br><span class="line">    tfs.Resize((<span class="number">256</span>, <span class="number">256</span>)),  <span class="comment"># 先调整图片大小至256x256</span></span><br><span class="line">    tfs.RandomCrop((<span class="number">224</span>, <span class="number">224</span>)),  <span class="comment"># 再随机裁剪到224x224</span></span><br><span class="line">    tfs.RandomHorizontalFlip(),  <span class="comment"># 随机的图像水平翻转，通俗讲就是图像的左右对调</span></span><br><span class="line">    tfs.RandomRotation(<span class="number">5</span>),</span><br><span class="line">    tfs.ToTensor(),</span><br><span class="line">    tfs.Normalize((<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>), (<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.2225</span>)),  <span class="comment"># 维度和图像的channel相关</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>调用时使用即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = transform(img)</span><br></pre></td></tr></table></figure></p><h4 id="数据标准化-归一化"><a href="#数据标准化-归一化" class="headerlink" title="数据标准化/归一化"></a>数据标准化/归一化</h4><p>即使是非常简单的数据标准化/归一化，就能取得显著的 performance 提高以及训练速度的大幅度提升。对于图像信息，可以使用灰度图均衡化，而对于数字信号或者其他信息，则可以使用 MinMax，标准化众多方法。这个对于模型训练速度的提升可能是数量级上。</p><p>但无论如何，数据标准化几乎应当是数据预处理的必要操作，绝对不能跳过。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直方图均衡化</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.equalizeHist(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准化 - 对于一维数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">std</span><span class="params">(data)</span>:</span></span><br><span class="line">    mu = np.mean(data)</span><br><span class="line">    sigma = np.std(data)</span><br><span class="line">    <span class="keyword">return</span> (data - mu) / sigma</span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><h4 id="损失函数权重"><a href="#损失函数权重" class="headerlink" title="损失函数权重"></a>损失函数权重</h4><p>对于普通的损失函数，对于不同的类加以相同的权进行处理。但是对于类分别不均的训练集/测试集，可以轻微调整模型的损失函数权重，一般权重添加方法是按照训练集的比例强行加权。一般这样就能获得略好的效果。但是还有一定的调整空间。事实上使用这个方法对于一些数据分布不均的方法有非常明显的效果。不过如果实在分布不均的话，可以考虑数据预处理方法解决。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weight = torch.Tensor([<span class="number">1</span>, <span class="number">0.8</span>])</span><br><span class="line">lossfun = nn.CrossEntropyLoss(weight = weight)</span><br></pre></td></tr></table></figure><p>如果使用 cuda 训练，还应该申明<code>.cuda()</code>。</p><h4 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h4><p>原来习惯性用 Adam 也就没有再关心过学习率的问题，但事实上学习率仍然是有影响的。使用过小的学习率前期的训练时间过长而且容易进入一个不太好的局部最优解，相反使用大的学习率在前期能够势如破竹。（甚至是数量级的提升）但是训练到后期的模型 performan 却需要更小的学习率，所以这里引入学习率衰减的方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjust_learning_rate</span><span class="params">(optimizer, epoch)</span>:</span></span><br><span class="line">    lr = <span class="number">1e-4</span> * (<span class="number">0.4</span> ** (epoch // <span class="number">8</span>))</span><br><span class="line">    <span class="keyword">for</span> param_group <span class="keyword">in</span> optimizer.param_groups:</span><br><span class="line">        param_group[<span class="string">'lr'</span>] = lr</span><br><span class="line">adjust_learning_rate(optimizer, epoch)</span><br></pre></td></tr></table></figure><p>传入的 optimizer 参数就是 PyTorch 的模型。对于 Adam 模型，建议使用 $1e^{-4}$ 作为起始训练速率。</p><h2 id="不稳定措施"><a href="#不稳定措施" class="headerlink" title="不稳定措施"></a>不稳定措施</h2><h3 id="添加模型的全连接层"><a href="#添加模型的全连接层" class="headerlink" title="添加模型的全连接层"></a>添加模型的全连接层</h3><p>添加全连接层会大幅度增加模型的复杂度以及参数量，强制减低模型的训练速度，但而提高模型的过拟合能力。所以增加全连接层方法在数据量不足以支撑的情况下是绝对不推荐的。但是有的时候能发挥一定的作用。</p><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>Dropout 不是万能的方法。例如对于最后的分类器叠加 Dropout 反而会使模型的表现变得滑稽。Dropout 的添加是需要通过反复实验的。不过建议在模型的一开始不要使用 Dropout，因为模型自身的能力可能就不够，不能够很好地拟合训练数据。而且增加 Dropout 增加了训练时间，对于判断模型的强度也是不利的。在实验的最后发现过拟合严重可以考虑尝试使用 Dropout 方法。</p><h3 id="Multi-task"><a href="#Multi-task" class="headerlink" title="Multi-task"></a>Multi-task</h3><p>这是一个很不确定的东西。Multi-task 的效果随着设计的多任务而变化。事实上，在我使用 Multi-task 的情况下，几乎都没有得到明显的提升，有的时候甚至会拖后腿使模型的能力下降。所以 Multi-task 是需要仔细思考后使用的。</p><h3 id="加载预训数据"><a href="#加载预训数据" class="headerlink" title="加载预训数据"></a>加载预训数据</h3><p>对于 NLP 任务，使用预训参数是必要的，特别是对于 BERT 等模型，即使固定参数，只训练后面的部分也能获得很好的效果。但是对于 CV 任务这个效果却不是一定的。例如在 COVID-19 分类任务中，我使用了 ResNet18 作为一个模型，并加载了 PyTorch 的预训结果，获得了训练速度的显著提升；然而在语谱图分类时，使用预训的结果并没有明显的优势。</p><p>所以模型的训练对象和预训的数据集应该有一定的共同之处时才能够发挥作用。语谱图是完全和 ImageNet 不同的东西，所以不能发挥作用也是在预期之中的。</p><h2 id="基本无效措施"><a href="#基本无效措施" class="headerlink" title="基本无效措施"></a>基本无效措施</h2>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python绘图集</title>
      <link href="/2020/06/26/tech-Python-%E7%BB%98%E5%9B%BE/"/>
      <url>/2020/06/26/tech-Python-%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>每一次写程序为了可视化都避不开 Python 的 matplotlib，干脆整理一下这个东西。以防后面每次需要反复查一样的东西。</p><a id="more"></a>  <h2 id="绘图基础"><a href="#绘图基础" class="headerlink" title="绘图基础"></a>绘图基础</h2><p><strong>导入步骤</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br><span class="line">plt.clr()             <span class="comment">#清空</span></span><br><span class="line">plt.savefig()         <span class="comment">#保存</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**绘制**：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">plt.plot(x, y, label = <span class="string">'name'</span>, color = <span class="string">'blue'</span>, linestyle = <span class="string">'--'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Time'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Acc'</span>)</span><br><span class="line">plt.legend(loc = <span class="string">'upper left'</span>)</span><br></pre></td></tr></table></figure><p>关于上面的位置，有下表：</p><div class="table-container"><table><thead><tr><th>值</th><th>位置</th></tr></thead><tbody><tr><td>upper right</td><td>右上</td></tr><tr><td>lower left</td><td>左下</td></tr><tr><td>center</td><td>center</td></tr></tbody></table></div><p>排列组合……</p><h2 id="特殊图"><a href="#特殊图" class="headerlink" title="特殊图"></a>特殊图</h2><p><strong>混淆矩阵绘制</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_confusion_matrix</span><span class="params">(cm, savename, title=<span class="string">'Confusion Matrix'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>), dpi=<span class="number">100</span>)</span><br><span class="line">    np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在混淆矩阵中每格的概率值</span></span><br><span class="line">    ind_array = np.arange(len(classes))</span><br><span class="line">    x, y = np.meshgrid(ind_array, ind_array)</span><br><span class="line">    <span class="keyword">for</span> x_val, y_val <span class="keyword">in</span> zip(x.flatten(), y.flatten()):</span><br><span class="line">        c = cm[y_val][x_val]</span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">0.001</span>:</span><br><span class="line">            plt.text(x_val, y_val, <span class="string">"%0.0f"</span> % (c,), color=<span class="string">'red'</span>, fontsize=<span class="number">15</span>, va=<span class="string">'center'</span>, ha=<span class="string">'center'</span>)</span><br><span class="line">    </span><br><span class="line">    plt.imshow(cm, interpolation=<span class="string">'nearest'</span>, cmap=plt.cm.binary)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    xlocations = np.array(range(len(classes)))</span><br><span class="line">    plt.xticks(xlocations, classes, rotation=<span class="number">90</span>)</span><br><span class="line">    plt.yticks(xlocations, classes)</span><br><span class="line">    plt.ylabel(<span class="string">'Actual label'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Predict label'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># offset the tick</span></span><br><span class="line">    tick_marks = np.array(range(len(classes))) + <span class="number">0.5</span></span><br><span class="line">    plt.gca().set_xticks(tick_marks, minor=<span class="literal">True</span>)</span><br><span class="line">    plt.gca().set_yticks(tick_marks, minor=<span class="literal">True</span>)</span><br><span class="line">    plt.gca().xaxis.set_ticks_position(<span class="string">'none'</span>)</span><br><span class="line">    plt.gca().yaxis.set_ticks_position(<span class="string">'none'</span>)</span><br><span class="line">    plt.grid(<span class="literal">True</span>, which=<span class="string">'minor'</span>, linestyle=<span class="string">'-'</span>)</span><br><span class="line">    plt.gcf().subplots_adjust(bottom=<span class="number">0.15</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># show confusion matrix</span></span><br><span class="line">    plt.savefig(savename, format=<span class="string">'png'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><strong>子图</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.plot(x1, y1)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(x2, y2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>热力图</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(matrix)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python图像处理</title>
      <link href="/2020/06/26/tech-Python-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2020/06/26/tech-Python-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这个是对于 COVID-19 分类任务结束的一个回顾。第一次完成这个图像相关的任务，基本上是一头雾水。在这一次过程中遇到了很多处理的方法，在这里列出来，方便后面使用。</p><a id="more"></a>  <h2 id="读取以及格式转换"><a href="#读取以及格式转换" class="headerlink" title="读取以及格式转换"></a>读取以及格式转换</h2><p>图像处理一般使用 OpenCV 及 PIL.Image 两个库。</p><p><strong>导入</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure><p><strong>图像的读取与保存</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"pic.jpg"</span>， flags)</span><br><span class="line">cv2.imwrite(filename, img)</span><br><span class="line"></span><br><span class="line">img = Image.open(filename)</span><br><span class="line">img.save(filename)</span><br></pre></td></tr></table></figure><p>关于 flags：</p><ul><li>cv2.IMREAD_COLOR:读取一副彩色图片，图片的透明度会被忽略，默认为该值，实际取值为 1；</li><li>cv2.IMREAD_GRAYSCALE:以灰度模式读取一张图片，实际取值为 0</li><li>cv2.IMREAD_UNCHANGED:加载一副彩色图像，透明度不会被忽略。</li></ul><p>以及文件名需要声明为 <code>.jpg / .png</code> 类似的格式才行。</p><p><strong>与 Numpy 互换</strong></p><p>事实上，cv2 导出的数据就是 np.array，例如对于彩色图像是(x, x, 3)的矩阵。而 Image 读出的是 Image 数据，需要转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = Image.fromarray(data)   <span class="comment"># 从array到Image</span></span><br><span class="line">data = np.array(img)          <span class="comment"># 从Image到array</span></span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>裁剪</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = img.crop((x0, y0, x1, y1))</span><br></pre></td></tr></table></figure><p>传入的是一个数组，标明左上角 <code>x0, y0</code> 及右下角 <code>x1, y1</code>。而由于 cv2 本质上是 np.array，所以可以使用 array 的操作完成。</p><p><strong>Resize</strong></p><p>Resize 是一个相当常用的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = img.resize((<span class="number">256</span>, <span class="number">256</span>), Image.ANTIALIAS)</span><br><span class="line">img = cv2.resize(img, (<span class="number">256</span>, <span class="number">256</span>), interpolation = cv2.INTER_AREA)</span><br></pre></td></tr></table></figure><p>后面是可选项。</p><h2 id="深度学习相关"><a href="#深度学习相关" class="headerlink" title="深度学习相关"></a>深度学习相关</h2><p><strong>直方图均衡化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <span class="comment"># 先转化为灰度图</span></span><br><span class="line">img = cv2.equalizeHist(img)                  <span class="comment"># 然后均衡化</span></span><br></pre></td></tr></table></figure><p><strong>随机变形</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line">transform = tfs.Compose([</span><br><span class="line">    tfs.Resize((<span class="number">256</span>, <span class="number">256</span>)),  <span class="comment"># 先调整图片大小至256x256</span></span><br><span class="line">    tfs.RandomCrop((<span class="number">224</span>, <span class="number">224</span>)),  <span class="comment"># 再随机裁剪到224x224</span></span><br><span class="line">    tfs.RandomHorizontalFlip(),  <span class="comment"># 随机的图像水平翻转，通俗讲就是图像的左右对调</span></span><br><span class="line">    tfs.RandomRotation(<span class="number">5</span>),</span><br><span class="line">    tfs.ToTensor(),</span><br><span class="line">    tfs.Normalize((<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>), (<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.2225</span>)),  <span class="comment"># 维度和图像的channel相关</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>调用时使用即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = transform(img)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> ML </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - Classification of COVID-19 in chest X-ray images using DeTraC deep convolutional neural network</title>
      <link href="/2020/06/04/scholar-paper-Classification%20of%20COVID-19/"/>
      <url>/2020/06/04/scholar-paper-Classification%20of%20COVID-19/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文为课程项目：“COVID-19 的分类和鉴别”做出的准备工作。由于做的工作类型相似，所以做一篇阅读笔记便于参考。</p><a id="more"></a>  <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>现有的众多方法：</p><ul><li>SVM</li><li>Backpropagation Network</li><li>CNN，作为医学领域最为出众的模型</li><li>Transfer learning。这个方法简单迅速<ul><li>精调（fine-tune）：三类精调：只训练分类层；训练所有参数；训练直到大提升</li></ul></li></ul><p>类分解用来加强低方差的分类器，使在分类边界上更灵活。经常这个方法被用在预处理中提高模型的表现。在医学分析中，类分解经常被用来提高类似随机森林等的分类表现。</p><p>这篇文章使用基于类分解的 CNN 网络，并使用迁移学习方法。对于原数据集中的类，先将其分解为几个完全视为独立的子类，然后对这些子类进行分类，最后组合在一起获得预测结果。</p><h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h2><ul><li>使用基于 CNN 的感知网络检测 COVID-19。</li><li>使用 ResNet 预训的网络分类 CT 图像。</li><li>ImageNet 预训的网络分类 X-ray 抽取特征，然后放入 SVM 中进行分类。</li><li>基于 Transfer Learning 的分类方法，分类 CXR 图像。分为四类：正常、细菌感染、non-COVID、non-COVID 且感染。</li></ul><p>作者认为前面的成果没有讨论数据集的不规则性。这篇文章就讲关注数据的不规则性。</p><h2 id="3-DeTraC-模型"><a href="#3-DeTraC-模型" class="headerlink" title="3. $DeTraC$ 模型"></a>3. $DeTraC$ 模型</h2><p>这个部分讨论整个训练方法的细节。</p><p><strong>3.1 Overview</strong></p><p>整个模型分为三个部分：</p><ul><li>训练从$DeTraC$抽离出的预训的 CNN 模型分离出深层信息，然后使用类分解</li><li>使用复杂优化器进行训练</li><li>使用类组合器去精确分类</li></ul><center><img src="/images/Research/detrac.jpg"/></center><p>类分解器将每一个类分为 k 个子类，并进行单独训练。然后通过类组合器恢复。</p><p><strong>3.2 深度特征挖掘</strong><br>使用 ImageNet 预训的 CNN 模型，通过浅层精调，这样构建特征空间。然后使用 PCA 将高维度信息转换为低维度信息，这对于产生等价类非常有用，并且可以降低空间存储要求，提升效率。</p><p><strong>3.3 类分解器</strong><br>特征空间设为 2D 矩阵$A$，$L$是类别，$m$是特征数量，$k$是类数量，$n$是图片数量。为了完成类分解，使用 k-means 做聚类，将类别划分为等价子类。所有的原标签按照新分出的类别，按照欧几里得距离计算最近的类别然后重新分配标签。这样新获得的数据集称为 $B$。</p><p><strong>3.4 Transfer Learning</strong><br>本论文使用通过 ResNet 预训练的模型，并具有优秀的表现。<strong>作者选择仅变动 low-level 的层数而固定住 high-level 层</strong>。</p><p>参数设定：</p><div class="table-container"><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>学习率</td><td>除最后一层外设定为 0.0001，最后一层设定为 0.01</td></tr><tr><td>批大小</td><td>64</td></tr><tr><td>Epoch</td><td>256</td></tr><tr><td>Weight Decay</td><td>0.01</td></tr><tr><td>Momentum value</td><td>0.9</td></tr></tbody></table></div><p>因为数据很少，使用 SGD 存在不稳定性，所以使用批训练。损失函数为 cross-entropy。</p><p><strong>3.5 Evaluation 与重组</strong><br>在重组阶段，被赋予的新标签会恢复原来的标签，用来衡量模型的性能。这里使用的量为 Accuracy，Specificity, Sensitivity。各自的定义是：（$TN$ 为 <em>true negative</em>。其余的标记就足够明显了。）</p><script type="math/tex; mode=display">   \begin{aligned}       ACC &= \frac{TP+TN}{n} \\       SN  &= \frac{TP}{TP+FN} \\       SP  &= \frac{TN}{TN+FP}   \end{aligned}</script><p>事实上使用的是多类别的判别方法。</p><h2 id="4-实验部分"><a href="#4-实验部分" class="headerlink" title="4. 实验部分"></a>4. 实验部分</h2><p><strong>4.1 使用的数据集</strong></p><ul><li>数据集包含两个部分：Normal CXRs （80 个正常样本）</li><li>Chest X-ray images，脑筋 105 个 COVID-19 样本和 11 个 SARS 样本。</li></ul><p>经过了数据增强。使用的上下左右翻转等等策略。最后获得了总计 1764 个样本。</p><p><strong>4.2 基于深度学习的类分解</strong><br>使用经过浅层训练的 AlexNet 预训网络，用以抽离原本三个类的特征。然后设定 $k=2$，使用 k-means，对类进行划分，将一个类别进一步划分为 2 个子类。最后得到 norm1, norm2, COVID191,COVID192, SARS1, SARS2 六类。</p><p><strong>4.3 结果</strong></p><ul><li>Acc：95.12%</li><li>SN：97.91%</li><li>SP：91.87%</li></ul><p>使用 70%的数据进行训练，30%的数据进行 Eval。</p><h2 id="5-讨论"><a href="#5-讨论" class="headerlink" title="5. 讨论"></a>5. 讨论</h2><p>训练 CNN 有两种策略。可以使用 end-to-end 的方法，需要大量的标注数据；或者使用迁移学习，仅需要有限的数据就能够完成任务。</p><h2 id="6-读后"><a href="#6-读后" class="headerlink" title="6. 读后"></a>6. 读后</h2><p>感觉是很平庸的一篇文章，将各种预训的结果拼在一起回避数据量过少的问题。唯一可以注意的地方是采用的 decomposition 方法，但这个方法也不是初创的。总体而言像是一个缝合怪。不过就研究方法和使用的数据集构造值得学习。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSP：MFCC计算</title>
      <link href="/2020/05/23/course-DSP-MFCC/"/>
      <url>/2020/05/23/course-DSP-MFCC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-GbRWsNer" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5173080" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>MCFF（Mel Frequency Cepstrum Coefficient）的计算过程、背景以及相应的<code>python</code>代码。</p><a id="more"></a>  <p><strong>MFCC</strong>：考虑了人的听觉系统特性，将线性频谱映射到基于听觉感知特性的 Mel 频谱上，然后再计算倒谱。声道的 shape 表现为短时间功率谱的包络线（envelope of the short time power spectrum），MFCCs 的工作则是如何准确地表征这种 envelope。</p><h2 id="1-人听觉系统的特性"><a href="#1-人听觉系统的特性" class="headerlink" title="1. 人听觉系统的特性"></a>1. <strong>人听觉系统的特性</strong></h2><p>人听到的声音高低和声音频率不成线性关系，而是成对数关系。</p><script type="math/tex; mode=display">B(f)=2595log_{10}(1+\frac{f}{700})</script><p><strong>屏蔽效应：</strong>人不能听到所有的声音，只有两个频率分量相差一定的<strong>带宽</strong>时，人耳才能区分。否则只有听到一个音调。这个带宽称为<strong>临界带宽</strong>：</p><script type="math/tex; mode=display">BW_c=25+75[1+1.4(\frac{f_c}{1000})^2]^{0.69}</script><ul><li>其中$f_c$为中心频率。</li><li>当$f_c$在 1kHz 以下时，临界带宽基本恒定为 100Hz。</li><li>当$f_c$在 1kHz 以上时，临界带宽呈指数增加。</li></ul><p>模拟上述的听觉特性，可以进行构造模仿人耳的感知特性。</p><ul><li>Mel 频率尺度：对数关系</li><li>Mel 滤波器组：屏蔽效应<ul><li>每一个滤波器的中心频率在 mel 频率域中呈等间隔分布</li><li>每一个滤波器的带宽在其临界带宽范围内</li></ul></li></ul><h2 id="2-MFCC的计算步骤"><a href="#2-MFCC的计算步骤" class="headerlink" title="2. MFCC的计算步骤"></a>2. MFCC的计算步骤</h2><ol><li>输入语音信号 — 语音波谱</li><li>预加重、分帧、加窗 — 分为不同帧的语音波谱</li><li>用 FFT 计算信号频谱 — 不同帧对应的频谱</li><li>计算频谱的绝对值/平方 — 不同帧对应的能量谱</li><li>使用 Mel 滤波器组 — 获得更符合人类听觉的 Mel 谱特征</li><li>取对数 — 为了倒谱做准备</li><li>DCT — 将乘积通过对数转化为加法。</li><li>Delta MFCC</li><li>输出语音特征</li></ol><h3 id="2-1-预加重、分帧、加窗"><a href="#2-1-预加重、分帧、加窗" class="headerlink" title="2.1 预加重、分帧、加窗"></a>2.1 预加重、分帧、加窗</h3><p><strong>2.1.1 预加重</strong></p><script type="math/tex; mode=display">H(Z)=1-\mu z^{-1}</script><p>即通过一个高通滤波器。在时域中写为：</p><script type="math/tex; mode=display">s_m=s_m-\mu s_{m-1}</script><p>预加重的目的是使频谱变得平坦。同时，也是为了消除发生过程中声带和嘴唇的效应，来补偿语音信号受到发音系统所抑制的高频部分，也为了突出高频的共振峰。$\mu$的取值一般为 0.9~1 之间。</p><p><strong>2.1.2 分帧</strong><br>一个窗为一帧。通常情况下 N=256，时间为 20ms~30ms。对于 8kHz 的信号来说，若帧长度为 256 个采样点，则对应的时间为$256 / 8000\times 1000 = 32ms$。</p><p><strong>2.1.3 加窗</strong><br>对每一帧使用汉明窗。通常，$a$取值为 0.46.</p><script type="math/tex; mode=display">w(n)=1-a[1+cos(\frac{2\pi n}{N-1})]</script><h3 id="2-2-FFT"><a href="#2-2-FFT" class="headerlink" title="2.2 FFT"></a>2.2 FFT</h3><p>对每一帧进行 FFT，变换到频率域中。</p><h3 id="2-3-Mel滤波器组"><a href="#2-3-Mel滤波器组" class="headerlink" title="2.3 Mel滤波器组"></a>2.3 Mel滤波器组</h3><p>人的听力像是一组滤波器（见第一节讨论的<strong>屏蔽效应</strong>），听见的声音在频谱上是不连续的;并且在低频上分布更密集（同样参见第一节中人听到的声音特性）。将能量谱通过一组 Mel 尺度的三角形滤波器组，定义一个有 $M$ 个滤波器的滤波器组。</p><center><img src="/images/Single/Mel组.jpg" width="50%" height="50%" /></center><ul><li>中心频率$f_c(l)$在 Mel 频率域中是等间隔分布</li><li>每一个滤波器的中心频率为：<script type="math/tex; mode=display">f(m)=(\frac{N}{F_s})B^{-1}(B(f_l)+m\frac{B(f_h)-B(f_l)}{M+1})</script>其中：$N$为窗口宽度，$F_s$为采样频率，$M$为滤波器数量，通常取 22~26。通过上式可以获得 M 个带通滤波器$H_m(k)$<script type="math/tex; mode=display">H_m(k)=\begin{cases}0 & \text{ k < f(m-1) }\\\frac{k-f(m-1)}{f(m)-f(m-1)} & \text{ f(m-1) < k < f(m) }\\\frac{f(m+1)-k}{f(m+1)-f(m)} & \text{ f(m) < k < f(m+1) }\\0 & \text{ otherwise }\end{cases}</script></li></ul><center><img src="/images/Single/DSP-滤波器组.jpg" width="50%" height="50%"/></center><p>对频谱进行平滑化，并消除谐波的作用，突显原先语音的共振峰。因此一段语音的音调或音高，是不会呈现在 MFCC 参数内，换句话说，以 MFCC 为特征的语音辨识系统，并<strong>不会受到输入语音的音调不同的影响</strong>。此外，还可以降低运算量。</p><p>计算每个滤波器组输出的对数能量。其中$M$为滤波器个数，$N$为窗口大小。</p><script type="math/tex; mode=display">S(m)=ln[\sum_{k=1}^N|X(k)|^2H_m(k)]</script><!-- **MFCC**$$log|S(e^{jw})|=\sum_{m=-\infty}^{\infty}c_me^{-jwn}$$$$S(w)=lim_{N\to\infty}\frac{1}{N}|X(e^{jw})|^2=lim_{N\to\infty}\frac{1}{N}|\sum_{n=0}^{N-1}x(n)e^{-jwn}|^2$$ --><h3 id="2-4-离散余弦变换（DCT）"><a href="#2-4-离散余弦变换（DCT）" class="headerlink" title="2.4 离散余弦变换（DCT）"></a>2.4 离散余弦变换（DCT）</h3><p>对滤波器组输出$S(m)$，DCT 得到 Mel 频率的倒谱系数$c(n)$。</p><p>DCT 正变换：</p><script type="math/tex; mode=display">   \begin{aligned}       F(0) &= \frac{1}{\sqrt{N}}\sum_{x=0}^{N-1}f(x),~~~u=0 \\       F(u) &= \sqrt{\frac{2}{N}}\sum_{x=0}^{N-1}f(x)cos[\frac{\pi}{2N}(2x+1)u], ~~~u=1,2,3...,N-1   \end{aligned}</script><p>DCT 反变换：</p><script type="math/tex; mode=display">f(x)=\frac{1}{\sqrt(N)}F(0)+\sqrt{\frac{2}{N}}\sum_{u=0}^{N-1}F(u)cos[\frac{\pi}{2N}(2x+1)u], ~~~x=1,2,3,...,N-1</script><p>将$S(m)$作为上式中的$f(x)$，$m$作为$x$得到下式：</p><script type="math/tex; mode=display">c(n)=\sum_{m=1}^MS(m)cos[\frac{\pi n(m-0.5)}{M}], ~~~n=0,1,...,L</script><p>这里的$L$是 MFCC 系数的阶数，通常取 12~16。</p><h3 id="2-5-Delta-MFCC"><a href="#2-5-Delta-MFCC" class="headerlink" title="2.5 Delta MFCC"></a>2.5 Delta MFCC</h3><p>到此为止，MFCC 只是获得了当前帧的语音特征。而相邻帧之间是连续的，可以通过相邻帧之间的变化更好地表达语音的特征。</p><center><img src="/images/Single/DMFCC.jpg"/></center><h2 id="3-MFCC常用参数集"><a href="#3-MFCC常用参数集" class="headerlink" title="3. MFCC常用参数集"></a>3. MFCC常用参数集</h2><div class="table-container"><table><thead><tr><th>参数</th><th>取值</th></tr></thead><tbody><tr><td>$\mu$（预加重参数）</td><td>0.9~1</td></tr><tr><td>$N$（窗口大小）</td><td>256/512</td></tr><tr><td>采样率</td><td>8kHz/16kHz</td></tr><tr><td>帧长</td><td>20ms~30ms</td></tr><tr><td>$M$（Mel 滤波器组数量）</td><td>22~26</td></tr><tr><td>$L$（MFCC 阶数）</td><td>12~16</td></tr><tr><td>$a$（汉明窗系数）</td><td>0.46</td></tr></tbody></table></div><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ol><li>这篇文章将原理解释得挺不错：<a href="https://blog.csdn.net/zouxy09/article/details/9156785/" target="_blank" rel="noopener">梅尔频率倒谱系数（MFCC）</a></li><li>这篇将流程解释得更清楚：<a href="https://blog.csdn.net/class_brick/article/details/82743741" target="_blank" rel="noopener">语音特征 MFCC 提取过程详解</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动给中英混合文本加上空格</title>
      <link href="/2020/05/22/tech-%E6%8A%80%E5%B7%A7-%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%A9%BA%E6%A0%BC/"/>
      <url>/2020/05/22/tech-%E6%8A%80%E5%B7%A7-%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用 textlint 给文本中英文交界的地方加上空格。对 Markdown 文件或者 txt 文件都会挺有用。</p><a id="more"></a>  <p><strong>安装</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> textlint <span class="comment">--global</span></span><br><span class="line">npm <span class="keyword">install</span> textlint-rule-ja-<span class="keyword">space</span>-<span class="keyword">between</span>-half-<span class="keyword">and</span>-<span class="keyword">full</span>-width <span class="comment">--global</span></span><br><span class="line">textlint <span class="comment">--init</span></span><br></pre></td></tr></table></figure><br>这里使用<code>--save</code>似乎是不行的，无法被程序找到<code>textlint</code></p><p>修改生成的<code>.textlint</code>文件为（似乎不修改也没事）<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"filters"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"rules"</span>: &#123;</span><br><span class="line">        <span class="attr">"ja-space-between-half-and-full-width"</span>: &#123;</span><br><span class="line">            <span class="attr">"space"</span>: <span class="string">"always"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加空格：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">textlint</span> -- fix <span class="regexp">*.md</span></span><br></pre></td></tr></table></figure></p><p>注意，使用这个语法即使写错了也不会报错的。对于 Blog 文件，可以考虑在生成脚本文件最前面，添加一行<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textlint --fix <span class="keyword">source</span><span class="regexp">/_posts/</span>*.md</span><br></pre></td></tr></table></figure><br>这样每一次生成 Blog 的时候就能自动纠错了。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - Departures from Tree Structures in Discourse - Shared Arguments in PDTB</title>
      <link href="/2020/05/22/scholar-paper-Departure-from-tree-structures-in-discourse/"/>
      <url>/2020/05/22/scholar-paper-Departure-from-tree-structures-in-discourse/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了更好地搞清楚自己究竟读过哪些论文，于是决定为读过的论文写一些笔记。这是第一篇笔记，关于 PDTB 中树结构的构建问题。</p><a id="more"></a>  <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>这篇文章关于 Discourse Structure，是指任何超过句子结构以上的结构。尽管在大多数时候，DS 都可以被放在一个树地结构下，但是存在这样一个结构：两棵树会存在交集的情况，即存在一个“daughter”被两个 root 管辖。这篇文章将关注点放在“the shared discourse structure is a <em>syntactically subordinate clause</em> introduced by a <em>subordinating conjunction</em>”。</p><p>关于上述定义：</p><ul><li>syntactically subordinate clause：是指语法上的从句结构</li><li>subordinating conjunction<ul><li>从属连词，a connecting word or phrase that introduces a <strong>dependent clause</strong> and joins it to a <strong>main clause or independent clause</strong>.</li><li>常常被用来加上时间、让步、对比、因果等等条件</li><li>从属连词必须放在 dependent clause 的开头</li><li>例子：because, before, when; even though, as long as, except that</li></ul></li></ul><p>这篇文章考虑的是，从属句可能会作为另一个 DS 的一个 Argument，并暗示了 Syntactic subordication 及 DS 的关联。这篇文章的主张是：尽管在大多数时候，SS 和 DS 是对应的，但是有一些例外的存在。这里讨论这些例外，以及它们的意义。</p><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h2><blockquote><p>a subordinating conjunction is a grammaticization of the rhetorical organization of discourse</p></blockquote><p>一般认为 Sc（subordinating clause）和其他 non-salient discourse 一样，对主题的连续性无关。这些成分被认为是句子的背景，但是他们本身并不能使主题更进一步。依据这种思路给出了做 Summarizer 的思路：移除所有的 non-salient 部分即可以完成概括。而有人指出，Sc 只是作为一个造成 discourse saliency 的原因。<br>这篇文章会通过经验上的方法，去检验句法和篇章之间的关系。</p><h2 id="3-方法及发现"><a href="#3-方法及发现" class="headerlink" title="3. 方法及发现"></a>3. 方法及发现</h2><p>考虑这样一个句型：”X although Y”，其中 X, Y 是 although 的两个 arguments，Y 是从句，假设标注者并不知道这个句子的关系的情况下，遇到了另外一个句子，这时候我们关心的是，Y 是否被选出作为另一个 DS 的一个 argument。</p><blockquote><p>The London index finished 2.4% under its close of 2233.9 the previous Friday, <strong>although</strong> it recouped some of the sharp losses staged early last week on the back of Wall Street’s fall. London was weak throughout Friday’s trading, <strong>however</strong>, on what dealers attributed to generally thin interest…(1505)</p></blockquote><p>在这个例子中，although 是第一个 ds 的一个 argument，同时也是第二个句子的一个 argument。为了方便我们称呼由 however 引导的这个 ds 为 external relation。在 PDTB 中，这样的 subordinating conjunctions 还有 after, although, as, because, …共计 12 个最为常见。在所有的情况中，以全句作为 er 的比例是最高的；其次是使用 matrix clause；最其次是使用 sc 作为 argument。而使用 coordinating conjunctions 作为对比则可以发现，其后两类的比例是几乎一样的。</p><blockquote><p>it does seem to be the case that there is a correspondence between syntactic<br>coordination and subordination on the one hand, and symmetric or asymmetric salience of discourse arguments on the other</p></blockquote><p>几乎可以认为，sc 的 saliency 低于 matrix clause。因此，认为语法和 ds 相关的观点是可以成立的。</p><h2 id="4-讨论"><a href="#4-讨论" class="headerlink" title="4. 讨论"></a>4. 讨论</h2><p>几个例子：</p><blockquote><p>They won’t buy <strong>if</strong> the quality is not there. <strong>Or</strong> if they feel the wine is overpriced. (0071)</p></blockquote><p>这个例子特殊在，尽管”the quality is not there“是一个 sc，并被 Or 判定为 er，但是可以发现整个句子是以 if 作为基础的，这样的例子可以使用树状结构加以概括。这和前文出现的例子不一样，前文的例子是一些并列的关系。于是可能在没有出现明显的嵌入的情况下，我们认为把 discourse 放入某些树结构中没有太多价值。</p><script type="math/tex; mode=display">{X~~IF~~(Y~~OR~~Z)}~~~--5i</script><p>上述式子可以概括原句。我们给一个新的例子：</p><script type="math/tex; mode=display">{X~~ALTHOUGH~~(Y}~~HOWEVER~~Z)~~~--5ii</script><p>我们认为 Y 延续了这个 DS，而再上面那个例子没有。(5i)这样是符合预期的，因为我们不希望一个 sc 去作为句子的主要成分并 continue 一个 DS。而(5ii)则更有意思。所以在什么情况下，一个 sc 会变成推动句子发展的 salient clause？下面是文章的作者们做的一些观察（文章作者声称自己并不仅仅是做观察，并会将系统的分析留到将来数据集更完善的时候（感觉这是我的锅了））。<br>首先，有两种固定的模式：</p><ul><li>这个 sc 总是后置的。例如”The dilligent boy passed the exam because <strong>he studied hard</strong>“，前置或者居中的 sc 是不行的。</li><li>er 总是限定在 - 对比、因果这样的关系中，而例如并列这样的关系则没有。</li></ul><p>以及一些大概率的模式：</p><ul><li><strong>Anaphoric matrix clause</strong>：这个 matrix clause 在原文中有一个很明显的前指。</li><li><strong>Reduced matrix clause</strong>：通过代词等短句很简单地指向了前文。</li></ul><blockquote><p>it may be <strong>because</strong> these shows need all the protection they can get. (<strong>Implicit-CAUSE</strong>) European programs usually target only their own local audience, and often only a small portion of that. (2361)，对应第二种模式</p></blockquote><p>在上述的情况中，主句总是在前文中有一个前置。可以认为是前置提供的信息削弱了后面主句的 saliency，使得 sc 上位。即，如果主句更多的是在照应前文的观点，则使得其从句更加自由，便可以作为承接下文的句子。</p><ul><li><strong>sc 被一个”coordinating-type“的 subordinating conjunction 引导</strong>：特别的，这里指两个词：<em>although</em>和<em>because</em>。这两种词引导的句子经常被用作 external argument，在发现的 349 例中，有 189 例归于上述两个中的一个。</li></ul><p>所以是否在 DS 中使用树结构，还是说在 DS 下使用树结构只是从语法分析上遗留下来的策略？</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paper </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章：互连网络</title>
      <link href="/2020/05/21/course-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Chap7-%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/05/21/course-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Chap7-%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>互联函数</li><li>互联网络的参数与性能指标</li><li>静态互连网络</li><li>动态互连网络<a id="more"></a>  </li></ul><p><strong>互连网络</strong>是一种由开关元件按照一定的拓扑结构和控制方式构成的网络，用来实现计算机系统中节点之间的相互连接。</p><ul><li><strong>节点</strong>：处理器、存储模块或其他设备。</li><li>在拓扑上，互连网络为输入节点到输出节点之间的一组互连或映射。 </li><li>SIMD 计算机和 MIMD 计算机的关键组成部分。 </li><li><strong>3 大要素</strong>：互连结构，开关元件，控制方式。 </li></ul><h2 id="7-1-互连函数"><a href="#7-1-互连函数" class="headerlink" title="7.1 互连函数"></a>7.1 互连函数</h2><h3 id="7-1-1-互连函数"><a href="#7-1-1-互连函数" class="headerlink" title="7.1.1 互连函数"></a>7.1.1 互连函数</h3><p><strong>互连函数</strong>：通过数学表达式建立输入端号与输出端号的连接关系。即在互连函数 f 的作用下，输入端 x 连接到输出端$f(x)$。</p><ul><li>互连函数反映了网络输入数组和输出数组之间对应的置换关系或排列关系。</li><li>互连函数 f(x)有时可以采用循环表示<ul><li>${x_0, x_1, … x_{j-1}}~\to~f(x_0)=x_0, f(x_1)=x_2, …, f(x_{j-1})=x_0$</li><li>$j$称为循环的长度。</li><li>互连函数表示为$f(x_{n-1}x_{n-2}…x_1x_0)$</li><li>$x=x_{n-1}x_{n-2}…x_1x_0$，其中$n=log_2N$。</li></ul></li></ul><h3 id="7-1-2-几种基本的互连函数"><a href="#7-1-2-几种基本的互连函数" class="headerlink" title="7.1.2 几种基本的互连函数"></a>7.1.2 几种基本的互连函数</h3><p><strong>恒等函数</strong>：$I(x_{n-1}x_{n-2}…x_1x_0)=x_{n-1}x_{n-2}…x_1x_0$<br><strong>交换函数</strong>：实现二进制地址编码中第 k 位互反的输入端与输出端之间的连接。</p><ul><li>主要用于构造立方体互连网络和各种超立方体互连网络。</li><li>该函数有 n 种</li><li><strong>立方体互连函数</strong>：当$N=8$，即$n=3$时。</li></ul><script type="math/tex; mode=display">   \begin{aligned}       Cube_0 &= x_2x_1\bar{x_0} \\       Cube_1 &= x_2\bar{x_1}x_0 \\       Cube_2 &= \bar{x_2}x_1x_0   \end{aligned}</script><center><img src="/images/Single/cube.jpg" width="50%" height="50%" />N=8的立方体交换函数</center><p><strong>均匀洗牌函数</strong></p><ul><li>将输入端分成数目相等的两半，前一半和后一半按类似均匀混洗扑克牌的方式交叉地连接到输出端（输出端相当于混洗的结果）。也称为<strong>混洗函数</strong>。直观的来说是将原地址乘 2 取模。</li><li>$ \sigma(x_{n-1}x_{n-2}…x_1x_0)=x_{n-2}x_{n-3}…x_1x_0x_{n-1} $</li><li><strong>第 k 个子函数$\sigma_(k)$</strong>：把 s 作用于输入端的二进制编号的低 k 位。将低 k 位左移一位。</li><li><strong>第 k 个超函数$\sigma^(k)$</strong>：把 s 作用于输入端的二进制编号的高 k 位。将高 k 位左移一位。</li><li>$\sigma^{(n)}=\sigma_{(n)}=\sigma$</li><li>$\sigma^{(1)}=\sigma_{(1)}=f$</li><li>若存在函数使$f(x)\times g(x)=I(x)$则称为$g(x)$是$f(x)$的逆函数。</li><li>逆均匀洗牌函数</li></ul><center><img src="/images/Single/均匀洗牌.jpg" width="50%" height="50%" ></center><p><strong>碟式函数</strong></p><ul><li>把输入端的二进制编号的最高位与最低位互换位置，便得到了输出端的编号。</li><li>$\beta(x_{n-1}x_{n-2}…x_1x_0)=x_0x_{n-2}…x_1x_{n-1}$</li><li><strong>第 k 个子函数$\beta_{(k)}$</strong>：将输入端第 k 位（编号 k-1）与编号 0 交换。</li><li><strong>第 k 个超函数$\beta^{(k)}$</strong>：将输入端第 n-k 位与编号 n-1 交换。</li><li>$\beta^{(n)}=\beta_{(n)}=\beta$</li><li>$\beta^{(1)}=\beta_{(1)}=f$</li></ul><center><img src="/images/Single/蝶式函数.jpg" width="50%" height="50%" /></center><p><strong>移数函数</strong></p><ul><li>将各输入端都错开一定的位置（模 N）后连到输出端。</li><li>$\alpha(x)=(x\pm k)~mod~N$</li></ul><p><strong>PM2I 函数</strong></p><ul><li>一种移数函数，将各输入端都错开一定的位置（模 N）后连到输出端。</li><li>$PM2_{+i}=(x+2^imod)N$</li><li>$PM2_{-i}=(x-2^imod)N$</li><li>该函数互联网络具有 2n 个不同的互连函数。</li></ul><center><img src="/images/Single/PM2.jpg" width="50%" height="50%" /></center><h2 id="7-2-互连网络的结构参数与性能指标"><a href="#7-2-互连网络的结构参数与性能指标" class="headerlink" title="7.2 互连网络的结构参数与性能指标"></a>7.2 互连网络的结构参数与性能指标</h2><h3 id="7-2-1-互连网络的结构参数"><a href="#7-2-1-互连网络的结构参数" class="headerlink" title="7.2.1 互连网络的结构参数"></a>7.2.1 互连网络的结构参数</h3><ul><li>网络通常是用有向边或无向边连接有限个节点的图来表示。</li><li>互连网络的主要特性参数有：<ul><li><strong>网络规模 N</strong>：节点个数，连接的部件数量</li><li><strong>节点度 d</strong>：与节点连接的边数（通道数）</li><li><strong>节点距离</strong>：从一个节点出发到另一个节点终止所需要跨越的边数的最小值</li><li><strong>网络直径 D</strong>：距离的最大值</li><li><strong>等分宽度 b</strong>：把 N 个节点切成节点数相同的两半需要的切除边数的最小值<ul><li>线等分宽度：$B=b\times w$</li><li>w 为通道宽度</li><li>反映了网络最大流量</li></ul></li></ul></li></ul><h3 id="7-2-2-性能指标"><a href="#7-2-2-性能指标" class="headerlink" title="7.2.2 性能指标"></a>7.2.2 性能指标</h3><p><strong>通信时延</strong>：指从源节点到目的节点传送一条消息所需的总时间，它由以下 4 部分构成：</p><ul><li><strong>软件开销</strong>：在源节点和目的节点用于收发消息的软件所需的执行时间。<ul><li>取决于节点处理消息的软件内核</li></ul></li><li><strong>通道时延</strong>：通过通道传送消息所花的时间。<ul><li>通信时延 = 消息长度 / 通信带宽</li><li>有瓶颈的通道带宽决定</li></ul></li><li><strong>选路时延</strong>：消息在传送路径上所需的一系列选路决策所需的时间开销。<ul><li>与路径的节点数相关</li></ul></li><li><strong>竞争时延</strong>：多个消息同时在网络中传送时，会发生争用网络资源的冲突。为避免或解决争用冲突所需的时间就是竞争时延。</li></ul><p><strong>网络时延</strong></p><ul><li>通道时延与选路时延的和</li><li>由网络硬件特征决定，与程序星为和传输状态无关</li></ul><p><strong>端口宽带</strong></p><ul><li>对于互连网络中的任意一个端口来说，其端口带宽是指单位时间内从该端口传送到他端口的最大信息量。</li><li>在对称网络中，端口带宽与端口位置无关。网络的端口带宽与各端口的端口带宽同。</li><li>非对称网络的端口带宽则是指所有端口带宽的最小值。</li></ul><p><strong>聚集带宽</strong>：网络从一半节点到另一半节点，单位时间内能够传送的最大信息量。<br><strong>等分带宽</strong>：与等分宽度对应的切平面中，所有边合起来单位时间所能传送的最大信息量。</p><h2 id="7-3-静态互联网络"><a href="#7-3-静态互联网络" class="headerlink" title="7.3 静态互联网络"></a>7.3 静态互联网络</h2><p>互连网络通常可以分为两大类：</p><ul><li>静态互连网络：各节点之间有固定的连接通路、且在运行中不能改变的网络。</li><li>动态互连网络：由交换开关构成、可按运行程序的要求动态地改变连接状态的网络。</li></ul><p><strong>线性阵列</strong></p><ul><li>一种一维的线性网络，其中 N 个节点用 N-1 个链路连成一行。</li><li>端节点的度：1</li><li>其余节点的度：2</li><li>直径：N－1</li><li>等分宽度 b=1</li></ul><p><strong>环和带弦环</strong></p><ul><li>环<ul><li>用一条附加链路将线性阵列的两个端点连接起来而构成。可以单向工作，也可以双向工作。</li><li>对称性</li><li>节点的度：2</li><li>双向环的直径：N/2</li><li>单向环的直径：N </li><li>环的等分宽度 b=2 </li></ul></li><li>带弦环<ul><li>增加的链路越多，节点度就越高，网络直径就越小</li></ul></li><li>全连接网络</li></ul><center><img src="/images/Single/带弦环.jpg" width="50%" height="50%" /></center><p><strong>循环移数网络</strong></p><ul><li>通过在环上每个节点到所有与其距离为 2 的整数幂的节点之间都增加一条附加链而构成。</li><li>即如果$|j-i|=2^r$，则 j 与 i 连接。<ul><li>节点度：2n-1</li><li>直径：n/2</li><li>网络规模：$N=2^n$</li></ul></li></ul><center><img src="/images/Single/循环.jpg" width="50%" height="50%" /></center><p><strong>树形和星形</strong></p><center><img src="/images/Single/树形.jpg" width="50%" height="50%" /></center><ul><li>树形可靠性较差，具有较高的节点度</li></ul><p><strong>胖树形</strong></p><p><strong>网格形和环网形</strong></p><ul><li>网格形<ul><li>对于$n\times n$的网格<ul><li>内部节点的度 d=4</li><li>边节点的度 d=3</li><li>角节点的度 d=2</li><li>网络直径 D=2（n-1）</li><li>等分宽度 b=n</li></ul></li><li>一个由$N=n^k$个节点构成的 k 维网格形网络（每维 n 个节点）的内部节点度 d=2k，网络直径 D=k(n-1) </li></ul></li><li>Illiac 网络<ul><li>把 2 维网格形网络的每一列的两个端节点连接起来，再把每一行的尾节点与下一行的头节点连接起来，并把最后一行的尾节点与第一行的头节点连接起来。</li><li>对于$n\times n$的网格<ul><li>所有节点的度 d=4</li><li>网络直径 D=n-1</li><li>Illiac 网络的直径只有纯网格形网络直径的一半。 </li><li>等分宽度：2n</li></ul></li></ul></li><li>环网形<ul><li>把 2 维网格形网络的每一行的两个端节点连接起来，把每一列的两个端节点也连接起来。 </li><li>将环形和网格形组合在一起，并能向高维扩展。 </li><li>一个 n×n 的环网形网 <ul><li>节点度：4</li><li>网络直径：2×(n/2)</li><li>等分宽度 b=2n </li></ul></li></ul></li></ul><center><img src="/images/Single/网格形.jpg " width="50%" height="50%" /></center><p><strong>超立方体</strong></p><ul><li>一个二元 n-立方体由$N=2^n$个节点组成，它们分布在 n 维上，每维有两个节点。</li><li>为实现一个 n-立方体，只要把两个（n－1）立方体中相对应的节点用链路连接起来即可。共需要 2n-1 条链路。</li><li>n-立方体中节点的度都是 n，直径也是 n，等分宽度为 b=N/2 。 </li></ul><p><strong>带环立方体（3-CCC）</strong></p><ul><li>把 3-立方体的每个节点换成一个由 3 个节点构成的环而形成的。</li><li>带环 k-立方体（简称 k-CCC）<ul><li>k-立方体的变形，它是通过用 k 个节点构成的环取代 k-立方体中的每个节点而形成的。</li><li>网络规模为 N=k×2k</li><li>网络直径为 D=2k-1+k/2</li><li>比 k-立方体的直径大一倍</li><li>等分宽度为 b=N/（2k）</li></ul></li></ul><center><img src="/images/Single/带环立方体.jpg" width="50%" height="50%" /></center><h2 id="7-4-动态互连网络"><a href="#7-4-动态互连网络" class="headerlink" title="7.4 动态互连网络"></a>7.4 动态互连网络</h2><h3 id="7-4-1-总线网络"><a href="#7-4-1-总线网络" class="headerlink" title="7.4.1 总线网络"></a>7.4.1 总线网络</h3><p>由一组导线和插座构成，经常被用来实现计算机系统中处理机模块、存储模块和外围设备等之间的互连。</p><ul><li>每一次总线只能用于一个源（主部件）到一个或多个目的（从部件）之间的数据传送。</li><li>多个功能模块之间争用总线或时分总线</li><li>特点：结构简单、成本低、带宽窄</li></ul><p><strong>一种由总线连接的多处理机系统</strong></p><center><img src="/images/Single/总线系统.jpg" width="50%" height="50%" /></center><ul><li>系统总线在处理机、I/O 子系统、主存储器以及辅助存储设备（磁盘、磁带机等）之间提供了一条公用通路。</li><li>系统总线通常设置在印刷电路板底板上。处理器板、存储器板和设备接口板都通过插座或电缆插入底板。</li></ul><p><strong>带宽窄的解决</strong></p><ul><li>多总线是设置多条总线，有两种做法：<ul><li>为不同的功能设置专门的总线</li><li>重复设置相同功能的总线</li></ul></li><li>多层次的总线是按层次的架构设置速度不同的总线，使得不同速度的模块有比较适合的总线连接。 </li></ul><h3 id="7-4-2-交叉开关网络"><a href="#7-4-2-交叉开关网络" class="headerlink" title="7.4.2 交叉开关网络"></a>7.4.2 交叉开关网络</h3><p><strong>单极开关网络</strong></p><ul><li>交叉点开关能在对偶（源、目的）之间形成动态连接，同时实现多个对偶之间的无阻塞连接。</li><li>带宽和互连特性最好。 </li><li>一个 n×n 的交叉开关网络，可以无阻塞地实现$n!$种置换。 </li><li>对一个 n×n 的交叉开关网络来说，需要 n2 套交叉点开关以及大量的连线。当 n 很大时，交叉开关网络所需要的硬件数量非常巨大。</li></ul><p><strong>C.mmp 多处理机的互连结构</strong></p><ul><li>用 16×16 的交叉开关网络把 16 台 PDP-11 处理机与 16 个存储模块连在一起</li><li>最多可同时实现 16 台处理机对 16 个不同存储模块的并行访问<ul><li>每个存储模块一次只能满足一台处理机的请求</li><li>当多个请求要同时访问同一存储模块时，交叉开关就必须分解所发生的冲突，每一列只能接通一个交叉点开关。</li><li>为了支持并行（或交叉）存储器访问，可以在同一行中接通几个交叉点开关。 </li></ul></li></ul><center><img src="/images/Single/mmp.jpg" width="50%" height="50%" /></center><h3 id="7-4-3-多级互联网络"><a href="#7-4-3-多级互联网络" class="headerlink" title="7.4.3 多级互联网络"></a>7.4.3 多级互联网络</h3><p><strong>多级互连网络的构成</strong></p><ul><li>MIMD 和 SIMD 都采用多级互联网络 MIN（Multistage Interconnection Network）</li><li>一种通用的多级互连网络 <ul><li>由 a×b 开关模块和级间连接构成的通用多级互连网络结构</li><li>每一级都用了多个 a×b 开关<ul><li>a 个输入和 b 个输出</li><li>在理论上，a 和 b 不一定相等，然而实际上 a 和 b 经常选为 2 的整数幂，即 a＝b＝2k，k≥1。 </li></ul></li><li>相邻各级开关之间都有固定的级间连接</li></ul></li></ul><center><img src="/images/Single/多级互连.jpg" width="50%" height="50%" /></center><ul><li>最简单的开关模块：2x2 开关</li></ul><center><img src="/images/Single/22开关.jpg" width="50%" height="50%" /></center><ul><li>各种多级互连网络的区别在于所用开关模块、控制方式和级间互连模式的不同。<ul><li>控制方式：对各个开关模块进行控制的方式。<ul><li>级控制：每一级的所有开关只用一个控制信号控制，只能同时处于同一种状态。</li><li>单元控制：每一个开关都有一个独立的控制信号，可各自处于不同的状态。</li><li>部分级控制：第 i 级的所有开关分别用 i＋1 个信号控制，0≤i≤n－1，n 为级数。</li></ul></li><li>常用的级间互连模式：均匀洗牌、蝶式、多路洗牌、纵横交叉、立方体连接等</li></ul></li></ul><p><strong>多级立方网络</strong></p><ul><li>多级立方体网络包括 STARAN 网络和间接二进制 n 方体网络等。<ul><li>两者仅在控制方式上不同，在其他方面都是一样的。</li><li>都采用二功能（直送和交换）的 2×2 开关。</li><li>当第 i 级（0≤i≤n-1）交换开关处于交换状态时，实现的是 Cubei 互连函数。 </li></ul></li><li>一个 N 输入的多级立方体网络有 log2N 级，每级用 N/2 个 2×2 开关模块，共需要 log2N×N/2 个开关。</li></ul><center><img src="/images/Single/多级立方网络.jpg" width="50%" height="50%" />一个8个入端的多级立方体网络</center><ul><li>STARAN 网络采用级控制和部分级控制。<ul><li>采用级控制时，所实现的是交换功能；</li><li>采用部分级控制时，则能实现移数功能。</li></ul></li><li>间接二进制 n 方体网络则采用单元控制。<ul><li>具有更大的灵活性。</li></ul></li></ul><p><strong>Omega 网络</strong></p><center><img src="/images/Single/Omega网络.jpg" width="50%" height="50%" />一个8×8的Omega网络</center><ul><li>一个 N 输入的 Omega 网络<ul><li>有$log_2N$级，每级用 N/2 个 2×2 开关模块，共需要$Nlog_2N/2$个开关。</li></ul></li><li>每个开关模块均采用单元控制方式。</li><li>不同的开关状态组合可实现各种置换、广播或从输入到输出的其他连接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧克力奶茶</title>
      <link href="/2020/05/20/essay-%E5%B7%A7%E5%85%8B%E5%8A%9B%E5%A5%B6%E8%8C%B6/"/>
      <url>/2020/05/20/essay-%E5%B7%A7%E5%85%8B%E5%8A%9B%E5%A5%B6%E8%8C%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文简单记叙一下巧克力奶茶的做法，为提高下一次水准做准备。</p><a id="more"></a>  <p><strong>口感</strong></p><ul><li>呈现巧克力牛奶般的颜色</li><li>口感粗粝，不算非常顺滑，略苦</li><li>可能会因为巧克力过多而盖过茶味，这个还需要探索</li><li>黑巧克力可能并不合适，和奶茶自身的味道些许冲突，没有展现各自的优势</li></ul><p><strong>材料</strong></p><ul><li>纯牛奶一盒：250ml</li><li>红茶叶若干：大概小半把，煮沸后占 1/4 个碗</li><li>冰糖：15 颗以上</li><li>黑巧克力：20g。如果放整条那茶味会被盖过去</li></ul><p><strong>步骤</strong></p><ul><li>冷水煮沸，冷水量不能太多，两碗以内。</li><li>放入茶叶，小火熬制一段时间，会闻到“番茄味”，水会变成棕红色。</li><li>倒入牛奶、冰糖、巧克力，小火熬制。煮沸后静置一段时间</li><li>可以按照相同的办法，但是不放巧克力就变成普通的奶茶</li></ul><p><strong>实验失败经历</strong></p><ol><li>实验 001<ul><li>使用了 40g 黑巧克力</li><li>三碗水，水似乎放多了</li><li>使用冷水煮红茶，效果不理想</li><li>结果：巧克力味道过重，几乎盖过了茶味，呈现巧克力牛奶的味道</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 食谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『鋼の錬金術師』03版观感</title>
      <link href="/2020/05/19/essay-%E8%A7%82%E6%84%9F-%E9%92%A2%E4%B9%8B%E7%82%BC%E9%87%91%E6%9C%AF%E5%B8%8803/"/>
      <url>/2020/05/19/essay-%E8%A7%82%E6%84%9F-%E9%92%A2%E4%B9%8B%E7%82%BC%E9%87%91%E6%9C%AF%E5%B8%8803/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-tnDvvONh" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="636907" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="评价：★★★★☆"><a href="#评价：★★★★☆" class="headerlink" title="评价：★★★★☆"></a>评价：★★★★☆</h3><a id="more"></a><p>　　在相对高压的接近期末季的时候，看完了钢之炼金术师 03 版，就简单地记一下观感吧。（这真的似乎是我很不擅长的方式，不过不妨一试）<br>　　整体而论，03 版叙述了一个更小的故事，但是述说了更真实的故事；09 版叙述了一个巨大的阴谋，但是结局显得过于乐观。仅就故事节奏、完整性种种考虑，个人认为 09 版优于 03 版。许多人认为 03 版较 09 版更为深刻，这一点本人暂无法苟同，但不可否认 03 版本的严肃压抑氛围对于这样一个故事时是更得体的，09 版显得太欢乐。</p><blockquote><p>人は何かの犠牲なしに、何も得ることはできない。何かを得るためには、同等の代価が必要となる。<br>人没有的牺牲的话就什么也得不到，为了得到某些东西，就必须付出同等的代价。</p></blockquote><p>　　在观看 03 版之前先看的 09 版，毫无疑问的是 03 版的氛围比 09 版沉重了很多。03 版很大的问题是在后期脱离原作基础的情况下，事件发生的逻辑链开始频繁断裂，人物在场景间的移动和出现往往突兀得不讲道理。此外许多人物的谢幕方式也显得莫名其妙，例如被 Sloth 被 Wrath 坑掉，大总统被儿子坑掉。毫无疑问此二人这样的结局是<strong>相当具有意味</strong>的，也是我很欣赏的部分，但是非常生硬地让之前的伏笔串在一起打出结局，效果终于是不太理想。</p><p>　　不过除开上述描述的严重缺陷，03 版做得相当出色的一点是对于“等价交换”原则的讨论，这是一个逆否命题。整部作品中，有至少两点是被讨论到了的。第一点是：付出了代价是否就能获得同等的回报。第二点是：这个原则本身是否就是可信的？</p><blockquote><p>痛みを伴わない教訓には意義がない、人は何かの犠牲無しには何も得ることには出来ないのだから。しかし、その痛みに耐え乗り越えた時、人は何物にも負けない強靭な心を手に入れる、そう鋼のような心を……<br>不伴随着痛楚的教训就没有意义，因为人若无牺牲，就不会有收获。然而，当战胜这痛楚时，人就将获得不屈服于任何事物的坚强之心，是的，钢铁般的坚强之心。 ——09版</p></blockquote><p>　　在 09 版中，“等价交换”这一原则是不容置疑的，整部作品也没有违背这一点。在故事的最后，兄弟二人耗费了多年的时间，换来了一颗坚毅的心，这是对于等价交换的总结。但是在 03 版中，对于等价交换的诠释构成了问题的核心。等价交换原则是被两兄弟坚信的一点，也是二人被但丁嘲笑的一点。这是一个很现实的问题，正像在剧里面提到的“人生而不平等”问题在当今社会是显然的，一个人可能付出百倍的努力获得的回报只是另外一部分人付出一倍努力的结果，我们称之为天分或者运气。这个问题在 03 版并没有得到解答，是一个“失败”的结束，对于所有人来说都是。努力复活母亲的兄弟最后只能亲手再杀一次人造人；企图恢复手臂的爱德华，不仅没有成功，反而永远与弟弟分离；希望夺取大总统之位的大佐最后被流放。这是一个对于几乎所有人都是“失败”的结尾，然而世界还是依旧地运转。</p><p>　　不过在这样的悲哀之中，主人公还是抓到了渺小的希望：有一些获取的东西，是不需要付出代价的，这是被称为“爱”的东西。这是一个朴素的答案，却照亮了整部阴暗的作品。03 版的故事是关于“爱”的故事，它隐藏了行动的动机，却强调了行动造成的不可挽回的后果，省略了“爱”带来的温暖或者企图让它们看起来理所应当。但事实上这才是真正的动力，让所有人行动并坚强的唯一的理由。（听起来挺怪的，但这一部对于这一点的诠释挺棒的。）</p><p>　　03 版的部分人物处理得比 09 更为富有内涵。斯卡自不必说，从一个复仇者最后变成一个殉道者，整个过程 03 版较 09 版来得更为自然而有人性。03 版设定下的人造人的记忆也是令人造人出彩的点，Rust 在这个版本里如若新生，找到了自己最后的价值。但是大总统较 09 而言差了很大一截，人物显得略有扁平化，09 版的大总统有血有肉，是一个塑造地成功太多的角色。有一点最后想说一下，许多人在剧情后期指责阿尔圣母心坏事，爱德华行事拖沓；但事实上，人善良而弱小，这不是罪，而是<strong>现实</strong>。</p><p>　　PS：03 整部觉得最为最为令人感动的细节：在修斯准将殉职的那一集，黑色底的报幕。节制而真诚。</p><center><img src="/images/Things/钢炼.jpg"/>钢之炼金术师03剧场版</center>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章:IO系统</title>
      <link href="/2020/05/15/course-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Chap6-IO/"/>
      <url>/2020/05/15/course-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Chap6-IO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ol><li>I/O 性能</li><li>I/O 可靠性</li><li>廉价磁盘冗余阵列 RAID</li><li>总线</li><li>通道处理机</li><li>I/O 与操作系统</li></ol><a id="more"></a><h2 id="6-1-I-O系统性能与CPU性能"><a href="#6-1-I-O系统性能与CPU性能" class="headerlink" title="6.1 I/O系统性能与CPU性能"></a>6.1 I/O系统性能与CPU性能</h2><ol><li>IO 系统包括 IO 设备与 IO 设备和处理机的连接</li><li>IO 系统是计算机的一个重要组成部分</li><li>IO 系统可分为存储 IO 系统及通信 IO 系统</li><li>系统响应时间：从用户输入命令开始，到得到结果需要的时间。由 IO 系统响应时间和 CPU 处理时间组成</li><li>评价 IO 系统的参数：连接特性/IO 系统容量</li></ol><h2 id="6-2-I-O系统的可靠性、可用性、可信性"><a href="#6-2-I-O系统的可靠性、可用性、可信性" class="headerlink" title="6.2 I/O系统的可靠性、可用性、可信性"></a>6.2 I/O系统的可靠性、可用性、可信性</h2><p><strong>系统可靠性</strong>：系统从某个初始参考点开始一直连续提供服务的能力，用<strong>平均无故障时间 MTTF</strong>来衡量。</p><ul><li>MTTF：Mean Time To Failure</li><li>MTTF 的倒数是系统的<strong>失效率</strong>。</li><li>MTTR：平均修复时间<br>计算系统可靠性的方法：将不同部件的失效率相加求倒。</li></ul><p>提高系统部件可靠性的方法：</p><ul><li>有效构建方法：消除故障隐患</li><li>纠错方法：即使出现故障也能正常工作</li></ul><p><strong>系统的可用性：</strong>系统正常工作的时间在连续两次正常服务间隔时间中所占的比例。</p><script type="math/tex; mode=display">可用性=\frac{MTTF}{MTTF+MTTR}</script><p>平均失效间隔时间 MTBF：MTTF+MTTR</p><p><strong>可信性：</strong>服务的质量。多大程度上可以合理地认为服务是可靠的。这是不可以度量的。</p><h2 id="6-3-磁盘冗余阵列RAID"><a href="#6-3-磁盘冗余阵列RAID" class="headerlink" title="6.3 磁盘冗余阵列RAID"></a>6.3 磁盘冗余阵列RAID</h2><p><strong>磁盘阵列 DA（Disk Array）</strong>：使用多个磁盘（包括驱动器）的组合来代替一个大容量的磁盘。</p><ul><li>多个磁盘并行工作。</li><li>以条带为单位把数据均匀地分布到多个磁盘上。（交叉存放）</li><li>条带存放可以使多个数据读/写请求<strong>并行</strong>地被处理，从而提高总的 I/O 性能。<ul><li>多个独立请求可以由多个盘并行地处理：减少了 IO 请求的排队时间</li><li>如果一个请求访问了多个块，就可以多个盘一起处理：提高了单个请求的数据传输率</li></ul></li><li>增加磁盘数量会导致磁盘阵列的可靠性下降</li><li>磁盘阵列组成<ul><li>细粒度：<strong>优点：</strong>所有 I/O 请求都能够获得很高的数据传输率；<strong>缺点：</strong>在任何时间，都只有一个逻辑上的 I/O 在处理当中，而且所有的磁盘都会因为为每个请求进行定位而浪费时间。</li><li>粗粒度：多个较小规模的请求可以同时得到处理。对于较大规模的请求又能获得较高的传输率。</li></ul></li><li>设置冗余需要解决的问题：<ul><li>如何计算冗余信息：奇偶校验码</li><li>如何将信息分布：将信息存放在几个盘中；将数据均匀分在所有盘中</li></ul></li></ul><h3 id="6-3-1-RAID0"><a href="#6-3-1-RAID0" class="headerlink" title="6.3.1 RAID0"></a>6.3.1 RAID0</h3><center><img src="/images/Single/RAID0.jpg" width="50%" height="50%" />RAID0</center><ol><li>非冗余阵列</li><li>将数据切分为条带，交叉地进行存放</li></ol><h3 id="6-3-2-RAID1"><a href="#6-3-2-RAID1" class="headerlink" title="6.3.2 RAID1"></a>6.3.2 RAID1</h3><center><img src="/images/Single/RAID1.jpg" width="50%" height="50%" />RAID1</center><ol><li>双备份磁盘：将数据写入镜像磁盘</li><li>特点：<ol><li>能实现快速读取</li><li>写性能由最差的磁盘决定</li><li>可靠性高</li><li>昂贵</li></ol></li></ol><h3 id="6-3-3-RAID2"><a href="#6-3-3-RAID2" class="headerlink" title="6.3.3 RAID2"></a>6.3.3 RAID2</h3><center><img src="/images/Single/RAID2.jpg" width="50%" height="50%" />RAID2</center><ol><li>存储式磁盘阵列，使用汉明码</li><li>特点<ol><li>每个数据盘存放所有数据字的一位（位交叉存放）</li><li>各个数据盘上的相应位计算汉明校验码，编码位被存放在多个校验（ECC）磁盘的对应位上。</li><li>冗余盘是用来存放汉明码的，其个数为 log2m 级。m：数据盘的个数（也就是数据字的位数）</li><li>并未被广泛应用，目前还没有商业化产品。</li></ol></li></ol><h3 id="6-3-4-RAID3"><a href="#6-3-4-RAID3" class="headerlink" title="6.3.4 RAID3"></a>6.3.4 RAID3</h3><center><img src="/images/Single/RAID3.jpg" width="50%" height="50%" />RAID3</center><ol><li>位交叉奇偶阵列</li><li>特点<ol><li>采用奇偶校验</li><li>写数据时需要写入校验盘</li><li>读数据时可以通过校验盘恢复数据</li><li>采用的带宽比较小</li><li>校验空间开销小</li></ol></li></ol><h3 id="6-3-5-RAID4"><a href="#6-3-5-RAID4" class="headerlink" title="6.3.5 RAID4"></a>6.3.5 RAID4</h3><center><img src="/images/Single/RAID4.jpg" width="50%" height="50%" />RAID4</center><ol><li>块交叉奇偶校验</li><li>采用比较大的条带，可以同时处理多个小规模访问请求</li><li>特点<ol><li>访问只需要访问数据所在的磁盘</li><li>只有在故障时才会读取校验码并进行重建</li><li>对于上图的设定，写数据需要两次磁盘读和两次磁盘写</li></ol></li></ol><h3 id="6-3-6-RAID5"><a href="#6-3-6-RAID5" class="headerlink" title="6.3.6 RAID5"></a>6.3.6 RAID5</h3><center><img src="/images/Single/RAID5.jpg" width="50%" height="50%" />RAID5</center><ol><li>块交叉分布奇偶校验磁盘阵列</li><li>无需冗余盘，将奇偶校验分布在所有盘上</li></ol><h3 id="6-3-7-其他RAID"><a href="#6-3-7-其他RAID" class="headerlink" title="6.3.7 其他RAID"></a>6.3.7 其他RAID</h3><ol><li>RAID6：P+Q 双校验磁盘阵列：使用两个校验位，检验空间开销是 RAID5 的两倍；可以容忍两个磁盘出错</li><li>RAID10：先进行镜像再进行条带存放</li><li>RAID01：先进行条带存放再进行镜像</li></ol><h2 id="6-4-总线"><a href="#6-4-总线" class="headerlink" title="6.4 总线"></a>6.4 总线</h2><p>优点：成本低、多样性<br>缺点：不同外设分时共享，限制了 I/O 的吞吐率</p><h3 id="6-4-1-总线的设计"><a href="#6-4-1-总线的设计" class="headerlink" title="6.4.1 总线的设计"></a>6.4.1 总线的设计</h3><ol><li>难点<ol><li>总线上信息传输收到物理因素限制：总线的长度、设备的数目、信号的强度</li><li>I/O 既要快又要高吞吐</li></ol></li><li><p>分离事务总线</p><ol><li>又称流水总线、悬挂总线</li><li>多个主设备时，可以通过打包技术提高总带宽：将事务分为请求和应答。再请求和应答之间，总线可以供给其他 I/O 使用</li><li>分离事务总线有较高的带宽，但是数据传输延迟更大<center><img src="/images/Single/总线.jpg" width="50%" height="50%" />分离事务总线</center></li></ol></li><li><p>同步总线：包含一个供总线上所有设备使用的时钟，并且这些设备是基于该时钟按照一个固定的协议来发送地址和数据的。 </p></li><li>异步总线：没有统一的参考时钟，每个设备都有各自的定时方法。采用握手协议 。</li></ol><h3 id="6-4-2-与CPU的连接"><a href="#6-4-2-与CPU的连接" class="headerlink" title="6.4.2 与CPU的连接"></a>6.4.2 与CPU的连接</h3><ol><li>I/O 总线的连接有两种方法：连接到存储器上；连接到 Cache 上</li><li>I/O 总线连接到存储器总线上</li><li>CPU 对 I/O 设备的编址<ol><li>存储器映射 I/O，将存储器地址分给 I/O 设备，使用 load 和 store 进行读写。将一部分存储空间空出用于设备控制</li><li>为 I/O 设备设置单独的 I/O 指令用于访问设备</li></ol></li></ol><h2 id="6-5-通道处理机"><a href="#6-5-通道处理机" class="headerlink" title="6.5 通道处理机"></a>6.5 通道处理机</h2><p><strong>通道处理机（简称通道）</strong>：专门负责整个计算机系统的输入/输出工作。通道处理机只能执行有限的一组输入/输出指令。</p><h3 id="6-5-1-通道的作用"><a href="#6-5-1-通道的作用" class="headerlink" title="6.5.1 通道的作用"></a>6.5.1 通道的作用</h3><ol><li>程序控制、中断和 DMA 方式管理外围设备会引起两个问题：<ol><li>所有外设的输入/输出工作均由 CPU 承担，CPU 的计算工作经常被打断而去处理输入/输出的事务，不能充分发挥 CPU 的计算能力。 </li><li>大型计算机系统的外设虽然很多，但同时工作的机会不是很多。 </li></ol></li><li>一个典型的由 CPU、通道、设备控制器、外设构成的 4 级层次结构的输入/输出系统。</li><li>通道的功能 <ol><li>接收 CPU 发来的 I/O 指令，并根据指令要求选择指定的外设与通道相连接。</li><li>执行通道程序：从主存中逐条取出通道指令，对通道指令进行译码，并根据需要向被选中的设备控制器发出各种操作命令。</li><li>给出外设中要进行读/写操作的数据所在的地址。如磁盘存储器的柱面号、磁头号、扇区号等。 </li><li>给出主存缓冲区的首地址：该缓冲区存放从外设输入的数据或者将要输出到外设中去的数据。</li><li>控制外设与主存缓冲区之间的数据传送的长度：对传送的数据个数进行计数，并判断数据传送是否结束。</li><li>指定传送工作结束时要进行的操作。例如：将外设的中断请求及通道的中断请求送往 CPU 等。</li><li>检查外设的工作状态是否正常，并将该状态信息送往主存指定单元保存。</li><li>在数据传输过程中完成必要的格式变换。例如：把字拆分为字节，或者把字节装配成字等。</li></ol></li><li>通道的主要硬件<ol><li>寄存器：数据缓冲寄存器，主存地址计数器，传输字节数计数器，通道命令字寄存器，通道状态字寄存器</li><li>控制逻辑：分时控制，地址分配，数据传送、装配和拆分等</li></ol></li></ol><h3 id="6-5-2-工作过程"><a href="#6-5-2-工作过程" class="headerlink" title="6.5.2 工作过程"></a>6.5.2 工作过程</h3><ol><li>通道完成一次数据输入/输出的工作过程<ol><li>在用户程序中使用访管指令进入管理程序，由管理程序生成一个通道程序，并启动通道。<ol><li>用户在目标程序中设置一条广义指令，通过调用操作系统的管理程序来实现。</li><li>管理程序根据广义指令提供的参数来编制通道程序。 </li><li>启动输入/输出设备指令是一条主要的输入/输出指令，属于特权指令。</li></ol></li><li>通道处理机执行通道程序，完成指定的数据输入/输出工作。通道处理机执行通道程序与 CPU 执行用户程序是并行的。 </li><li>通道程序结束后向 CPU 发中断请求。</li></ol></li><li>时间关系</li></ol><center><img src="/images/Single/通道时间.jpg " width="50%" height="50%" />通道时间示意</center><h3 id="6-5-3-种类"><a href="#6-5-3-种类" class="headerlink" title="6.5.3 种类"></a>6.5.3 种类</h3><ol><li>字节多路通道<ol><li>为多台低速或中速的外设服务。</li><li>以字节交叉的方式分时轮流地为它们服务。</li><li>字节多路通道可以包含多个子通道，每个子通道连接一台设备控制器。 </li></ol></li><li>选择通道<ol><li>为多台高速外围设备服务。 </li><li>在一段时间内只为一台高速外设独占使用。</li><li>选择通道的硬件：寄存器/格式交换部件/通道控制部件</li></ol></li><li>数组多路通道<ol><li>适用于高速设备。</li><li>每次选择一个高速设备后传送一个数据块，轮流为多台外围设备服务。</li></ol></li></ol><h3 id="6-5-4-重要：流量分析"><a href="#6-5-4-重要：流量分析" class="headerlink" title="6.5.4 重要：流量分析"></a>6.5.4 <strong>重要</strong>：流量分析</h3><ol><li>通道流量：一个通道在数据传送期间，单位时间内能够传送的数据量。所用单位一般为 Bps。  <ul><li>又称为通道吞吐率、通道数据传输率等。</li><li>通道最大流量：一个通道在满负荷工作状态下的流量 。</li><li>参数的定义 <ul><li>$T_S$：设备选择时间。从通道响应设备发出的数据传送请求开始，到通道实际为这台设备传送数据所需要的时间。</li><li>$T_D$：传送一个字节所用的时间。</li><li>p：在一个通道上连接的设备台数，且这些设备同时都在工作。</li><li>n：每台设备传送的字节数，这里假设每台设备传送的字节数都相同。</li><li>k：数组多路通道传输的一个数据块中包含的字节数。在一般情况下，k &lt; n。对于磁盘、磁带等磁表面存储器，通常 k = 512。</li><li>T：通道完成全部数据传送工作所需要的时间。</li></ul></li></ul></li><li>字节多路通道：<ol><li>传送过程：通道每连接一台个外设，只传送一个字节，然后又与另一台设备连接，并传送一个字节。</li><li>为 p 个设备传送 n 个数据需要时间：<script type="math/tex; mode=display">T_{BYTE}=(T_S+T_D)\times p \times n</script></li><li>最大流量：<script type="math/tex; mode=display">f_{max}=\frac{pn}{(T_S+T_D)pn}=\frac{1}{T_S+T_D}</script></li><li>实际流量：连接在这个通道上所有设备的数据传输率之和</li></ol></li><li>选择通道<ol><li>在一段时间内只能单独为一台高速外设服务，当这台设备的数据传送工作全部完成后，通道才能为另一台设备服务。 </li><li>为 p 个设备传送 n 个数据需要时间：<script type="math/tex; mode=display">T_{SELECT}=(\frac{T_S}{n}+T_D)pn</script></li><li>最大流量：<script type="math/tex; mode=display">f_{max}=\frac{1}{\frac{T_S}{n}+T_D}</script></li></ol></li><li>数组多路通道<ol><li>为 p 个设备传送 n 个数据需要时间：<script type="math/tex; mode=display">T_{SELECT}=(\frac{T_S}{k}+T_D)pn</script></li><li>最大流量：<script type="math/tex; mode=display">f_{max}=\frac{1}{\frac{T_S}{k}+T_D}</script></li><li>选择通道和数组多路通道的实际流量就是连接在这个通道上的所有设备中数据流量最大的那一个 。</li><li>各种通道的实际流量应该不大于通道的最大流量</li></ol></li></ol><h2 id="6-6-I-O与操作系统"><a href="#6-6-I-O与操作系统" class="headerlink" title="6.6 I/O与操作系统"></a>6.6 I/O与操作系统</h2><ul><li>在用硬件实现的 I/O 技术中，哪些会实际被采用，是由操作系统来决定的。 </li><li>I/O 操作主要是在外设和存储器之间进行，所以操作系统必须保证这些 I/O 操作的安全性。</li></ul><h3 id="6-6-1-DMA与虚拟存储器"><a href="#6-6-1-DMA与虚拟存储器" class="headerlink" title="6.6.1 DMA与虚拟存储器"></a>6.6.1 DMA与虚拟存储器</h3><p><strong>DMA 是使用虚拟地址还是物理地址？</strong></p><ol><li>使用物理地址进行 DMA 传输，存在以下两个问题：<ul><li>对于超过一页的数据缓冲区，由于缓冲区使用的页面在物理存储器中不一定是连续的，所以传输可能会发生问题。 </li><li>如果 DMA 正在存储器和缓冲区之间传输数据时，操作系统从存储器中移出（或重定位）一些页面，那么，DMA 将会在存储器中错误的物理页面上进行数据传输。 </li></ul></li><li>解决这些问题的方法 <ul><li>使操作系统在 I/O 的传输过程中确保 DMA 设备所访问的页面都位于物理存储器中，这些页面被称为是钉在了主存中。</li><li>“虚拟 DMA”技术：允许 DMA 设备直接使用虚拟地址，并在 DMA 期间由硬件将虚拟地址转换为物理地址。在采用虚拟 DMA 的情况下，如果进程在内存中被移动，操作系统应该能够及时地修改相应的 DMA 地址表。 </li></ul></li></ol><h3 id="6-6-2-I-O和Cache数据一致性"><a href="#6-6-2-I-O和Cache数据一致性" class="headerlink" title="6.6.2 I/O和Cache数据一致性"></a>6.6.2 I/O和Cache数据一致性</h3><ol><li>Cache 会造成两个副本</li><li>把 I/O 连接到存储器上会出现以下情况：<ul><li>CPU 修改了 Cache 的内容后，由于存储器的内容跟不上 Cache 内容的变化，I/O 系统进行输出操作时所看到的数据是旧值。（写直达 Cache 没有这样的问题）</li><li>I/O 系统进行输入操作后，存储器的内容发生了变化，但 CPU 在 Cache 中所看到的内容依然是旧值。 </li></ul></li><li>把 I/O 直接连接到 Cache 上：<ul><li>不会产生由 I/O 导致的数据不一致的问题。 </li><li>所有 I/O 设备和 CPU 都能在 Cache 中看到最新的数据。</li><li>I/O 会跟 CPU 竞争访问 Cache，在进行 I/O 时，会造成 CPU 的停顿。 </li><li>I/O 还可能会破坏 Cache 中 CPU 访问的内容，因为 I/O 操作可能导致一些新数据被加入 Cache，而这些新数据可能在近期内并不会被 CPU 访问。  </li></ul></li><li>解决内容一致性问题的方法（不管 Cache 是采用写直达法还是写回法）<ul><li>软件的方法：设法保证 I/O 缓冲器中的所有各块都不在 Cache 中。<ul><li>把 I/O 缓冲器的页面设置为不可进入 Cache 的，在进行输入操作时，操作系统总是把输入的数据放到该页面上。</li><li>在进行输入操作之前，操作系统先把 Cache 中与 I/O 缓冲器相关的数据“赶出”Cache，即把相应的数据块设置为“无效”状态。   </li></ul></li><li>硬件的方法<ul><li>在进行输入操作时，检查相应的 I/O 地址（I/O 缓冲器中的单元）是否在 Cache 中（即是否有数据副本）。</li><li>如果发现 I/O 地址在 Cache 中有匹配的项，就把相应的 Cache 块设置为“无效”。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>番茄炒蛋</title>
      <link href="/2020/05/12/essay-%E7%95%AA%E8%8C%84%E7%82%92%E8%9B%8B/"/>
      <url>/2020/05/12/essay-%E7%95%AA%E8%8C%84%E7%82%92%E8%9B%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>虽然这是道家常菜吧，但也不经常做。偶尔有一次效果不错，所以记一下。<br><a id="more"></a><br><strong>口感</strong></p><ul><li>甜味为主的风格</li><li>颜色可以算是鲜艳，绝对不用葱子，导致色调只有红色和黄色。</li></ul><p><strong>材料</strong></p><ul><li>一个鸡蛋</li><li>一个番茄</li><li>少量姜</li></ul><p><strong>步骤</strong></p><ul><li>打蛋放盐，放置一段时间</li><li>番茄滚刀切成大块，撒上白砂糖放置一段时间，尽量将白砂糖涂抹均匀</li><li>放油炒热，多放些油避免粘锅</li><li>倒入鸡蛋，尽量摊开</li><li>迅速倒入番茄，炒</li><li>用铲子把番茄切开，小火炒，让番茄逐渐变软</li><li>待到颜色看起来像样子了就能起锅</li></ul><p><strong>实验失败经历</strong></p><ul><li>按照上述方式，成功完成一次，可喜可贺</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 食谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语音频谱处理</title>
      <link href="/2020/05/10/course-DSP-%E8%AF%AD%E9%9F%B3%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/10/course-DSP-%E8%AF%AD%E9%9F%B3%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>叠加原理</li><li>卷积同态系统</li><li>复倒谱和倒谱</li><li>复倒谱的计算</li><li>语音信号的倒谱分析</li><li>计算 MFCC 系数<a id="more"></a>  </li></ul><h2 id="1-广义叠加原理"><a href="#1-广义叠加原理" class="headerlink" title="1. 广义叠加原理"></a>1. 广义叠加原理</h2><p>对于线性系统，使用卷积或者乘法代替线性系统的叠加原理，即：</p><script type="math/tex; mode=display">H[x(n)]=H[x_1(n)*x_2(n)]=H[x_1(n)*x_2(n)]=y_1(n)*y_2(n)=y(n)</script><h2 id="2-卷积同态系统"><a href="#2-卷积同态系统" class="headerlink" title="2. 卷积同态系统"></a>2. 卷积同态系统</h2><p>卷积同态系统由三部分组成：</p><ul><li>特征系统：$D_*[]$</li><li>线性系统：$L[]$</li><li>逆特征系统：$D_*^{-1}[]$</li></ul><p><strong>$D_*[]$</strong><br>输入是若干信号的卷积，输出为若干信号的加法组合。有以下的特性</p><script type="math/tex; mode=display">D_*[x(n)]=D_*[x_1(n)*x_2(n)]=D_*[x_1(n)]+D_*[x_2(n)]=\hat{x}_1(n)+\hat{x}_2(n)=\hat{x}(n)</script><p><strong>$L[]$</strong><br>服从叠加原理：</p><script type="math/tex; mode=display">L[\hat{x}(n)]=L[\hat{x}_1(n)+\hat{x}_2(n)]=L[\hat{x}_1(n)]+L[\hat{x}_2(n)]=\hat{y}_1(n)+\hat{y}_2(n)=\hat{y}(n)</script><p><strong>$D_*^{-1}[]$</strong><br>变换回卷积组合：</p><script type="math/tex; mode=display">D_*^{-1}[\hat{y}(n)]=y(n)</script><p>卷积同态的实现方法。利用 Z 变换，可以将卷积组合变为乘法，利用对数特性，将乘法组合变为加法，用此构成同态系统的特征系统$D_*[]$。其逆同态则是将取对数转化为指数运算。</p><center><img src="/images/Single/逆卷积.jpg" width="50%" height="50%" /></center><p><strong>同态系统的用途</strong></p><ul><li>将二个信号通过卷积（或乘积）合成的信号分开，是一种非线性处理方法。</li><li>对语音信号来说，同态处理的目的是将激励和声道分开，然后再分别进行研究<ul><li>对激励进行研究，可以确定语音片段是清音、浊音及浊音的基音频率等特征</li><li>对声道进行研究，可以确定声道特性及共振峰等特征</li></ul></li></ul><h2 id="3-复倒谱和倒谱"><a href="#3-复倒谱和倒谱" class="headerlink" title="3. 复倒谱和倒谱"></a>3. 复倒谱和倒谱</h2><p>设信号$x(n)$的 Z 变换为$X(z)$，其对数为$\hat{X}(z)=lnX(z)=ln[z[x(n)]]$。<br>那么$\hat{X}(z)$的逆变换为$\hat{x}(n)=z^{-1}[\hat{X}(z)]=z^{-1}[lnz[x(n)]]$</p><p><strong>复对数的多值性问题</strong><br>在复倒谱分析中，Z 变换得到的是复数，所以取对数涉及复对数运算，存在相位多值性问题，称为<strong>相位卷绕</strong>。</p><blockquote><p>例如：对于a为正实数，b为负实数，$ln(ab)=ln(a|b|e^{jk\pi})=ln(a)+ln(|b|)+jk\pi$。</p></blockquote><p>在计算复倒谱时，应保证复对数函数的单值性，满足广义叠加原理，且要选定<strong>收敛域</strong>以保证逆 z 变换的唯一性。</p><p><strong>注意</strong><br>在计算倒谱的情况下，信号经过同态处理的正、逆特征系统后，不能还原自身！因为此时只有幅值信息，丢掉了相位信息。对语音信号分析来说，因为人的听觉系统对频谱幅值敏感，对相位不敏感，所以倒谱分析可以用于语音信号。</p><p>如果对$X(e^{jw})$的绝对值取对数，得</p><script type="math/tex; mode=display">\hat{X}(e^{jw})=ln|X(e^{jw})|</script><p>求出的倒谱频称为<strong>实倒谱</strong>，即</p><script type="math/tex; mode=display">c(n)=\frac{1}{2\pi}\int^{\pi}_{-\pi}ln|X(e^{jw})|e^{jwn}</script><h2 id="4-复倒谱的计算方法"><a href="#4-复倒谱的计算方法" class="headerlink" title="4 复倒谱的计算方法"></a>4 复倒谱的计算方法</h2><p>设信号为$x(n)=x_1(n)*x_2(n)$，<br>则其傅里叶变换：</p><script type="math/tex; mode=display">X(e^{jw})=lnX_1(e^{jw})+lnX_2(e^{jw})</script><p>其幅度为：</p><script type="math/tex; mode=display">ln|X(e^{jw})| =ln|X_1(e^{jw})|+ln|X_2(e^{jw})|</script><p>相位：</p><script type="math/tex; mode=display">\phi(w)=\phi_1(w)+\phi_2(w)</script><p>这被称为相位缠绕。</p><h3 id="4-1-微分法"><a href="#4-1-微分法" class="headerlink" title="4.1 微分法"></a>4.1 微分法</h3><p>信号$X(n)$和倒频谱$\hat{x}(n)$的计算方法：</p><script type="math/tex; mode=display">j\frac{d}{dw}X(e^{jw})=\sum nx(n)e^{-jwn}</script><script type="math/tex; mode=display">j\frac{d}{dw}\hat{X}(e^{jw})=\sum n\hat{x}(n)e^{-jwn}</script><script type="math/tex; mode=display">\hat{X}(e^{jw})=lnX(e^{jw})</script><p>有：</p><script type="math/tex; mode=display">    \begin{aligned}        j\frac{d}{dw}\hat{X}(e^{jw})        &= j\frac{d}{dw}[lnX(e^{jw})]\\        &= \frac{j\frac{d}{dw}[X(e^{jw})]}{X(e^{jw})}\\        &=\sum n\hat{x}(n)e^{-jwn}    \end{aligned}</script><center><img src="/images/Single/int.jpg" width="50%" height="50%" /></center><p>这样就避开了复对数运算。但<strong>缺点</strong>是，$nx(n)$的高频分量较$X(n)$更多，按照原采样频率进行分析回导致频率混叠问题。</p><h3 id="4-2-最小相位信号法"><a href="#4-2-最小相位信号法" class="headerlink" title="4.2 最小相位信号法"></a>4.2 最小相位信号法</h3><p>被处理的信号$x(n)$是<strong>最小相位信号</strong>：Z 变换的全部几点和零点都位于 Z 平面单位元内部的信号，本质上是指具有<strong>最小相位延迟的序列信号</strong>。在实际应用中，许多信号是最小相位信号，或可以看作是最小相位信号。语音信号的模型就是极点都在 z 平面单位圆内的全极点模型，或者极零点都在 z 平面单位圆内的极零点模型。</p><p>设$x(n)$为最小相位信号，则$\hat{x}(n)$为因果稳定序列。</p><script type="math/tex; mode=display">\hat{x}(n)=\hat{x}_e(n)+\hat{x}_o(n)</script><script type="math/tex; mode=display">\hat{x}_e(n)=\frac{1}{2}[\hat{x}(n)+\hat{x}(-n)]</script><p>则有：</p><script type="math/tex; mode=display">\Phi[\hat{x}_e(n)]=\frac{1}{2}[\hat{X}(e^{jw})+\hat{X}(e^{-jw})]=\hat{X}_R(e^{jw})</script><p>该式不包含相位信息。</p><p><strong>注</strong>：原序列的实偶对称序列的傅里叶变换等于原序列的傅里叶变换的实部。</p><script type="math/tex; mode=display">    \begin{aligned}        \hat{X}(e^(jw))        &= \hat{X}_R(e^{jw})+j\hat{X}_I(e^{jw})\\        &= ln|X(e^{jw})|+j{arg[X(e^{jw})]+2k\pi}\\    \end{aligned}</script><p>则$ln|X(e^{jw})| =\Phi[\hat{x}_e(n)]$。<br>又由于：$\hat{x}_e(n)=\frac{1}{2}[\hat{x}(n)+\hat{x}(-n)]$且$\hat{x}(n)$是一个因果序列，可得</p><script type="math/tex; mode=display">    \hat{x}(n)=\left\{    \begin{aligned}    0,~~~n<0 \\    \hat{x}_e(n),~~~n=0\\    2\hat{x}_e(n), ~~~n>0    \end{aligned}    \right.</script><center><img src="/images/min.jpg" width="50%" height="50%" />最小相位法求复倒谱原理</center><h2 id="5-语音信号的倒谱分析"><a href="#5-语音信号的倒谱分析" class="headerlink" title="5. 语音信号的倒谱分析"></a>5. 语音信号的倒谱分析</h2><p>根据语音信号产生的线性模型，语音信号由激励信号与声道冲激响应<strong>卷积</strong>产生的，<strong>解卷积</strong>就是将卷积分量分开，可采用同态解卷积的方法。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语音信号 -&gt; 同态解卷积分析 -&gt; 分离出激励信号和声道冲激信号相应</span><br></pre></td></tr></table></figure></p><ul><li>对声门激励信号进行分析，以判断浊音、清音以及浊音的基音频率</li><li>对声道冲激响应进行分析，以判断声道特性及共振峰</li></ul><p><strong>5.1 声门激励信号的倒谱</strong><br>声门激励信号（浊音）：$e(n)=\sum_{r=0}^M\alpha_r\delta(n-rN_P)$<br>对其进行Z变换得：</p><script type="math/tex; mode=display">E(z)=\alpha_0\Pi_{r=1}^M[1-\beta_r(z^{N_P})^{-1}]</script><p>* <strong>此处的$\beta 可以通过\alpha 求得$</strong></p><script type="math/tex; mode=display">\hat{E}(z)=ln[E(z)]=ln\alpha_0-\sum_{r=1}^M[-\sum_{k=1}^{\infty}\frac{\beta_r^k}{k}(z^{N_P})^{-k}]</script><p>求 z 反变换获得倒谱：</p><script type="math/tex; mode=display">\hat{e}(n)=loga_0\delta(n)+\sum_{k=1}^{\infty}\beta'_k\delta(n-kN_P)</script><p>一个周期冲激的有限长度序列，其倒谱也是<strong>周期冲激序列</strong>，且周期长度是$N_P$不变，只是信号长度成为无限长，振幅随 k 增加而衰减。当声门激励为浊音时，其倒谱只在$kN_P$诸点上不等于 0，其它均为零，那么第一个非零点和原点的距离就是<strong>基音周期</strong>。</p><p><strong>5.2 声道冲激响应的倒谱</strong><br>用极零点模型描述声道响应，其 Z 变换如下：</p><script type="math/tex; mode=display">X(z)=Az^{-r}\frac{\Pi^{M_i}_{k=1}(1-a_kz^{-1})\Pi_{k=1}^{M_o}(1-b_kz)}{\Pi^{N_i}_{k=1}(1-c_kz^{-1})\Pi_{k=1}^{N_o}(1-d_kz)}</script><p>a, c为单位圆内零极点；反之为单位圆外零极点。$z^{-r}$：序列相对于时间原点的延迟。<br>单位圆内的零极点形成复倒谱的右边；单位圆外的零极点形成复倒谱的左边；在原点的值取决于增益。复倒谱通常是双边的，且是比例因子为1/n的衰减指数之和。<br>$\hat{X}(z)$的复对数为：</p><script type="math/tex; mode=display">\hat{X}(z)=ln(A)+ln(z^{-r})+\sum_{k=1}^{M_i}ln(1-a_kz^{-1})+\sum_{k=1}^{M_o}ln(1-b_kz^{-1})\\-\sum_{k=1}^{N_i}ln(1-c_kz^{-1})-\sum_{k=1}^{N_o}ln(1-d_kz^{-1})</script><p>我们希望上式逆 Z 变换是稳定序列，即绝对可求和，即使<strong>ROC</strong>包括单位圆。$\hat{X}(z)$的 RoC：</p><center><img src="/images/Single/Roc.jpg" width="50%" height="50%" />Roc</center><p>其复倒谱：</p><script type="math/tex; mode=display">    \hat{x}(n)=\left\{    \begin{aligned}    ln[A],~~~n=0 \\    \sum_{k=1}^{N_i}\frac{c_k^n}{n}-\sum_{k=1}^{M_i}\frac{a_k^n}{n},~~~n>0\\    \sum_{k=1}^{M_o}\frac{b_k^{-n}}{n}-\sum_{k=1}^{N_o}\frac{d_k^{-n}}{n}, ~~~n<0    \end{aligned}    \right.</script><h2 id="6-基于听觉特征的MEL频率倒谱系数"><a href="#6-基于听觉特征的MEL频率倒谱系数" class="headerlink" title="6. 基于听觉特征的MEL频率倒谱系数"></a>6. 基于听觉特征的MEL频率倒谱系数</h2><p>一种常用的语音特征：<strong>MFCC</strong> （mel frequency cepstrum coefficient）</p><p>人耳能在嘈杂的环境中分辨各种声音 -&gt; 耳蜗起到重要作用 -&gt;耳蜗相当于滤波器组 -&gt;作用：在对数频率尺度上进行滤波 -&gt;对低频信号敏感。基于上述原理，得到类似与耳蜗的滤波器组：Mel 频率滤波器组。Mel 频率：$f_{mel}=2595\times log(1+f/700)$</p><p><strong>MFCC 计算</strong>:</p><ul><li>分帧 -&gt; 预加重 -&gt; 加汉明窗 -&gt; 短时傅里叶变换 -&gt; 得到频谱；</li><li>求频谱平方，即能量谱，用 M 个 Mel 带通滤波器进行滤波；</li><li>对每个滤波器的输出取对数，得到相应频带的对数功率谱，并进行反离散余弦变换，得到 L 个 MFCC 系数，一般 L 取 12 ~ 16 个左右。MFCC 系数为：<script type="math/tex; mode=display">C_n=\sum_{k=1}^Mlogx'(k)cos[\pi(l-0.5)n/M],~~~n=1, 2, ..., L</script></li><li>将直接得到的 MFCC 特征作为静态特征，再做一阶和二阶差分，得到相应的动态特征。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致我的第一幅眼镜</title>
      <link href="/2020/05/08/essay-%E7%9C%BC%E9%95%9C-%E7%89%A9%E5%BF%97%E9%93%AD/"/>
      <url>/2020/05/08/essay-%E7%9C%BC%E9%95%9C-%E7%89%A9%E5%BF%97%E9%93%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-kSywBXnk" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="401804976" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>虽然勉强还能继续使用这副眼镜，但他已经在修补之后一个月不到的时间之后又裂开了。他可能累了吧。我想这么多年过去了，他的使命差不多可以在这里结束了？<br><a id="more"></a>  </p><center><img src="/images/Things/glasses.jpg" width="50%" height="50%" />我的眼镜</center><p>这幅眼镜是我的第一幅眼镜，外观相当朴素，从初中开始一直到现在大三的时候，中间从未换过。尽管中途因为升度数换过几次镜片，但镜架总没有换过。也不是只有这一副眼镜，但平时大多数时候带的都是这一副，备用的眼镜总觉得这里那里不舒服。本来是全黑的一副眼镜，却因为戴的时间长，眼镜腿什么的已经差不多磨成透明的了。尤其是中梁那里，可能是个人习惯性推镜架吧，那里变得尤其的光滑而透明。之前有同学表示过难以置信：这居然原来是黑色的部分。现在他的镜框折了，镜片总希望从里面逃出来。我想他差不多能休息了吧，遇上这么一个主人。</p><p>想起最早的时候，我总是把他放在眼镜盒里，直到上课前才拿出来，用眼镜布反复擦拭几遍，然后小心地戴上，一到下课便立刻取下来又放回原来的盒子里。但是后面慢慢度数高了，便也只能一直戴着，慢慢地擦拭得也少了，眼镜盒也不翼而飞……后面我知道不应该用眼镜布擦，于是用水冲洗。直到最近我端详它的表面的时候，已经发现了不少细密的纹路覆盖在眼镜片上。我想这对视力可能不太好吧？</p><p>这副眼镜陪我看过了很多的东西——可能我所知道的一切事务中的一半，我的眼镜也知道吧…真的是很长的一段时间…几乎现在是我身边陪伴我的时间最长的东西，特别是对于一个熄灯后才摘下眼镜，一睁眼就带上眼镜的人来说。</p><p>感谢你替我看见的世界。请休息了吧！</p><p>—— 致我的第一幅眼镜</p><p>廙水</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物志铭 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX常用语法</title>
      <link href="/2020/05/03/tech-LaTeX-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/05/03/tech-LaTeX-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为最近一段时间有使用$\LaTeX$写公式的需要，所以专门在这里整理一些常用的公式写法，防止后面反复查询。<br><a id="more"></a>  </p><h3 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h3><ul><li><code>\infty</code>: $\infty$</li><li><code>\ge</code>: $\ge$</li><li><code>\le</code>: $\le$</li><li><code>\pm</code>: $\pm$</li><li><code>\int</code>: $\int$</li><li><code>\prod</code>: $\prod$</li><li><code>\arg\mathop{\max}_{\theta}</code>: $\arg\mathop{\max}_{\theta}$</li></ul><h3 id="常用等式"><a href="#常用等式" class="headerlink" title="常用等式"></a>常用等式</h3><p>连等式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">    A &amp;&#x3D; B+C\\</span><br><span class="line">    &amp;&#x3D;C+D\\</span><br><span class="line">    &amp;&#x3D;D+F</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">    \begin{aligned}        A &= B+C\\        &=C+D\\        &=D+F    \end{aligned}</script><hr><p>大括号等式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X_p(w)&#x3D;\left\&#123;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">    \frac&#123;1&#125;&#123;2j&#125;,~~~w&#x3D;\frac&#123;\pi&#125;&#123;2&#125; \\</span><br><span class="line">    -\frac&#123;1&#125;&#123;2j&#125;,~~~w&#x3D;-\frac&#123;\pi&#125;&#123;2&#125; \\</span><br><span class="line">    0, ~~~otherwise</span><br><span class="line">    \end&#123;aligned&#125;</span><br><span class="line">\right.</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">    f(x)=    \begin{cases}        0& \text{x=0}\\        1& \text{x!=0}    \end{cases}</script><p>$$</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX在Hexo中的渲染</title>
      <link href="/2020/05/03/tech-LaTeX-%E5%9C%A8Hexo%E4%B8%8B%E7%9A%84%E6%B8%B2%E6%9F%93/"/>
      <url>/2020/05/03/tech-LaTeX-%E5%9C%A8Hexo%E4%B8%8B%E7%9A%84%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>该段落处理$\LaTeX$无法顺利在 Hexo 中渲染的问题。以下为上一次尝试且成功的步骤。<br><a id="more"></a>  </p><p>Hexo 默认的渲染引擎为 hexo-renderer-marked，这里将其更换为 hexo-renderer-kramed，该引擎在前者的基础上修复了一些 bug，具体操作：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">uninstall</span> hexo-renderer-marked <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-kramed <span class="comment">--save</span></span><br></pre></td></tr></table></figure></p><p>修改 marked.js。具体修改方式，用编辑器打开 marked.js（在./node_modules/kramed/lib/rules/inline.js 中）<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([<span class="string">\\`*&#123;&#125;\[\</span>](<span class="link"></span>)# +\-.!_&gt;])/, //替换掉</span><br><span class="line">escape: /^\\([<span class="string">`*\[\</span>](<span class="link"></span>)# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure></p><p>同时<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">em: /^<span class="symbol">\b</span>_((?:[^_]|__)+?)_<span class="symbol">\b</span>|^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,  //替换掉</span><br><span class="line">em:/^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br></pre></td></tr></table></figure><br>这样应该就能成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的坡县游历</title>
      <link href="/2020/04/27/essay-tour-%E5%9D%A1%E5%8E%BF%E6%B8%B8/"/>
      <url>/2020/04/27/essay-tour-%E5%9D%A1%E5%8E%BF%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在坡县交流了一学期，这里是提交给学校的坡县经验的副本，先做一个小记。可能以后会突发奇想补充一个更自由一点的记叙，如果我还有那个时间的话。如果有什么当时留下的照片什么的也先留在那个版本里吧。</p><a id="more"></a><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>因为 CSC 的缘故，被禁足在了新加坡本地，所以没有机会去马泰游玩，不过在本地的生活也是很惬意的。</p><h3 id="住"><a href="#住" class="headerlink" title="住"></a>住</h3><p>据说 NOC 的同志因为学校 NUS 宿舍装修种种原因不能住在校内，于是我们大部分人都住在离学校有一些距离的 MDIS，需要早上坐大概半小时的车到 NUS 校区。楼下有一个食阁，但是周末几乎不开，幸好附近步行一刻钟处有一个社区的食阁，周末能去吃。除此之外，其他的东西都还算方便，不过刚到寝室的时候，还是不免一阵吐槽，毕竟大家都是抱着体验单人间的生活入住的 hhh。</p><p>新加坡无尽的夏日还是让人头疼的，虽然可以一直穿凉鞋短袖也很爽。不过长袖几乎是必备的东西，因为室内的空调温度相当的低，比如 Science Lib。</p><p>这里和中国的文化差异并没有想象中的那么大。但这确实是个多元的地方，有各种各样的宗教文化、饮食文化并完全不用顾虑歧视种种问题。</p><h3 id="食"><a href="#食" class="headerlink" title="食"></a>食</h3><p>食物开销是除了住宿以外的大头。新加坡的食物很多样，但算不上太好吃，惊艳者甚少。作为学生，最常接触的是食阁，几乎 NUS 校区每个片区都有一个，里面囊括了各个地方的食物，西餐、杂菜饭、海南鸡米饭、叉烧面、日料是几乎每个食阁都有的东西。不过水准价格皆参差不齐。全校最好的是 UTown 的两家，但是略贵一点。一般在校内一餐消费在 4 刀到 10 刀不等。在校外消费的话，普通食阁 5 刀左右，下馆子得 15 刀起步。</p><p>新加坡当地的食物，可以算是十分奇特。<strong>酿豆腐</strong>，一种白水煮豆腐，里面可以加蔬菜、肉制品煮成一团，一些可以加辣酱和叻沙调味，这个东西的价钱是按“件”算的，比如一块豆腐就是 5 毛。<strong>叻沙</strong>，一种调味料？大概是一种椰汁熬出来的辣酱，完全不能被我所接受，但是似乎有不少同学喜欢？这个东西传出的鱼腥味能散布整个商场。最早一次是在新加坡的 Changi Airport 见到这个东西，被它的味道劝退了。<strong>辣螃蟹</strong>，十分昂贵的一种食物，大多是游客来吃的。不过味道很有趣，值得一试。甜辣甜辣的，类似国内一些菜品。此外还有肉骨茶等一些食物，没有尝试就不多说了。</p><p>然后是新加坡的中国菜。新加坡或许能偶尔找到挺正宗的中国菜馆，但大抵会让人失望。这边主要是火锅和港式/广式的茶餐厅，仔细找找能找到不错的。这边几乎每个食阁都有叉烧面和杂菜饭。叉烧面稳稳全食阁最价廉主食，一般是面上放几块叉烧；杂菜饭和复旦的食堂相似，为自选菜。火锅有点贵，香天下和海底捞等都有，还有一些本地的火锅。</p><p>此外，日料、马来菜、印度菜、西餐都很多。坡上似乎有不少不错的日料，我在读期间找到了一家网红鳗鱼饭，吃完满满的满足。还有日语课老师安利的回转寿司之类的，好店需要自己多找找。</p><p>本地有吃完饭和饮料的习惯。所以每个食阁都会有饮品店，卖的一般是 Koppi（马来语的咖啡，还有些类别，比如 Kopi O，Kopi Kosong 等等），还有各种鲜榨果汁，薏米水，还有一个叫 Milo 的饮料，味道和高乐高很像，深受当地人欢迎。令人疑惑的是一瓶可乐卖 1.9 刀，但是在 711 打折的时候，也有 1 刀的，并长期处于打折。</p><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>骑车是不可能骑车的。坡县不愧坡县，一路都是上上下下，在校区内更是不能骑车，因为学院大都建在山包包上。共享单车类似摩拜有，但是非常少，几乎不可用。有共享电动车，但是看起来非常危险，我听到过新加坡同学吐槽这东西有多危险。</p><p>主要出行是靠公交车。公交车需要自己按按钮下车，前方到站是不会在车内通报的，需要自己留意。一趟公交车并不便宜，在 1 刀左右，有起步价和同站换乘优惠。坡县内公交车网路非常密集，几乎可以利用公交车到大部分位置。</p><p>坡县地铁还是挺便利的，不过线路密度不如上海，很多时候还是靠公交车方便。地铁价格和公交车相似。</p><p>步行也是相当友好的。新加坡的道路旁一般建有走廊，走在下面不会被太阳晒也不会被雨淋，很舒适。校内连廊四处都是，楼与楼之前几乎不会有雨淋的风险。</p><p>校内通行主要靠小车.校车有专门的 app，如果选课不幸四处都有的话，坐校车就会是家常便饭了。因为每个学院都是分得比较开，所以不同学院的课一般避不了校车。不过很多 Tut 的选项会有不同的位置可选，所以尽量选自己方便的 Tut 上吧。</p><h3 id="浪"><a href="#浪" class="headerlink" title="浪"></a>浪</h3><p>新加坡好玩的地方不算太多，就那几个，一会就能逛完。不过可以趁着两次 Recess Week（期中和期末的一周复习周，学校强制不能在复习周中安排作业）去周围的国家转转。也可以和同去的小伙伴约在东海岸烧烤，同时坡县有诸多可以徒步的地方。此外新加坡的音乐会虽然不太多，但是票价便宜容易买到。就算是只提前一周也能买到低价的 5~8 排的黄金座位。</p><p>此外这里的建筑相当有特色，各种奇形怪状，并带有夸张色块的建筑随处可见。而且植被非常之好，很多楼顶或者楼内都攀爬着绿色植被。就算是在 NUS 里面也是充满了绿色植被，甚至学校中央是一片有野猴子和野鸡出没的小山包，无愧花园城市之名。</p><p>如果是秋季来可以赶上圣淘沙万圣节的鬼屋活动和国庆烟花，都是可以去凑热闹的不错的选择。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="关于选课"><a href="#关于选课" class="headerlink" title="关于选课"></a>关于选课</h3><p>选课上限 5 门。最开始可能自己申请的课都会被踢掉，但是不用担心，后续的申请很宽松，想要的课一般都能拿到。虽然上限只有 5 门课，但是并不轻松。以日语课为例，一周有 2h 的 lecture 和两次各 2h 的 tutorial，以及对应的课程作业，预计一周的工作量接近 8~10h。</p><h3 id="专业课"><a href="#专业课" class="headerlink" title="专业课"></a>专业课</h3><p>专业课分为偏应用的和偏理论的。理论课程会有很多的例子，一般一个公式就会跟着大量的例子去说明（不过很多时候说明挺累赘的，如果懂了就可以自己看着走。）实践课程会有很多 lab 和 pj，不过这些项目描述都很成型，基本没有歧义，按着老师的要求做就能做出不错的东西，当然还可以在此基础上继续发挥。期末考试不算太难，平时认真应该就不会翻车。</p><h3 id="语言课"><a href="#语言课" class="headerlink" title="语言课"></a>语言课</h3><p>NUS 的语言课真的超良心。以日语课为例，课程由一周一个 lecture 和两个 tutorial 组成。Lecture 是老师讲解知识点，tutorial 是由助教老师带领同学互相对话，调整发声和学习句子的使用等等。Tutorial 人数一个班十个人左右，因为不断换着换着 partner，所以氛围超有爱。到课程后半段之后就大家邀请老师一起愉快聚餐 Utown，中间还有两次蹭到了高贵的 Yale 学院的伙食，大家吃饭时聊天的话题也和国内完全不一样。</p><h3 id="自习"><a href="#自习" class="headerlink" title="自习"></a>自习</h3><p>自习一般不愁找不到地方。在 CS 楼附近是 Central Lib，虽然我在的期间在维护，但还是很大了，插座也很多。Lib 里面自带午休室和小躺椅。然后是 Science 附近的 Science Lib。这个 Lib 并不好找，需要专门寻觅一下，在某栋楼的四楼。该 Lib 人不多，异常地冷，插座不多，有的时候会找不到空的插座。其次是 Utown 的各个 Commons，PC Commons 和 Mac Commons 都是好去处，安静，并且有配好的台式机能用。问题是座位很少，周末一般找不到（除非去很早）。所有 Lib 都是周六开放半天，周日不开，平时也关的很早，可能是建议大家不要只是学习吧？并且 Central Lib 和 Commons 都是打印文件便利的地方。因为我在实验室板搬砖，所以也常常在实验室里的小工位干活。</p><h2 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h2><h3 id="进组"><a href="#进组" class="headerlink" title="进组"></a>进组</h3><p>到了 NUS 后不久，还没开学之前，我就听学长的建议开始在 CS 学院里找合适的 Prof，希望加到 Prof 的实验室做一些事情。于是大胆地写了一封邮件附带一个完全没有经历的 CV。万幸的是，我发的第一个 Prof 就回复了我，让我自己在组里找一个自己喜欢的项目加进去。于是找来找去联系了以为中国的学长，几封邮件来往，相谈甚欢，于是就进组啦。整个学期都在和另一位 master 一起做 NLP 的事情。</p><h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><p>尽管很顺利地进组了，但还是有诸多的问题。其一是国外的交流环境和国内很不一样，很多东西都是不断地请教学长菜慢慢摸清楚；其二是组会里面大家讨论的问题用的语速比上 lecture 的 Prof 快了不止一点，真的常常听不懂。</p><p>最大的问题其实是时间平衡和心态调整。泡实验室真的很耗时间，一般我作业做完了的周末或者课少的工作日都是泡在实验室调代码看数据，自己的时间确实很少了。中途没有去太多地方玩，也没能去马泰一圈。甚至到了期中季也只能请到几天的假，我期末季刚结束的那个周末就再次回到岗位了。并且就算是花了这么多时间，也不一定会有成效，经常在实验室泡了一天心态真的挺崩的。我还记得有一次和 master 一起调代码到了凌晨五点，是真的辛苦。不过每一次看到有一点点进步都会是由衷的喜悦。</p><h3 id="体验-amp-收获"><a href="#体验-amp-收获" class="headerlink" title="体验&amp;收获"></a>体验&amp;收获</h3><p>尽管前面说得这么辛苦，但还是觉得实验室值得一去。而且交流期间进组很容易的，一般给老师说一下，他们都不会拒绝。但是做多少事情，大多就是靠自觉。Prof 很亲和，会邀请你在组会上提出问题，偶尔也会问你几个问题。每次组会整个组会一起去附近的食阁聚餐，吃饭完后 Prof 会请客一人一杯饮料。</p><p>也深刻体会到了科研生活的艰辛和不易，也算是完成了一个科研周期吧。总之收获颇丰，代码能力、越读论文的能力、思辨能力都提升了不少。如果不像把这个学期用在四处游山玩水上，泡在实验室会是不错的选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做一个简单的总结吧。这是一个交流的好去处。不太大的文化差异、轻松的氛围、各式各样值得体验的新鲜事物、难得的实验室搬砖经历都让我在现在敲打这些文字时怀念这个美丽的城市。要说我唯一希望有所变动的地方，是那里永不结束的夏季。</p><p>廙水</p><p>2020-04-27</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行迹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章:存储系统</title>
      <link href="/2020/04/24/course-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Chap5-storage/"/>
      <url>/2020/04/24/course-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-Chap5-storage/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>存储系统的大纲。主要内容是 Cache 的特性及优化。</p><a id="more"></a><h2 id="5-1-存储系统基础"><a href="#5-1-存储系统基础" class="headerlink" title="5.1 存储系统基础"></a>5.1 存储系统基础</h2><ol><li>存储系统的层次结构<ol><li>要求：容量大、速度快、价格低</li><li>但是这三个要求相互矛盾</li><li>解决办法：采用多种存储器技术，构成多级存储层次  <ol><li>利用程序的局部性原理：时间局部性&amp;空间局部性</li></ol></li><li>存储系统要达到的目标：整个存储系统的速度接近于最快的访问速度，而容量和单位价格接近于最大的存储器</li></ol></li><li>性能参数<ol><li>考虑两层存储层次<br>| $M_1$ | $S_1$（容量） | $T_1$（访问时间） | $C_1$（每单位价格） |<br>| ——- | —— | —— | —— |<br>| $M_2$ | $S_2$  | $T_2$  | $C_2$  |</li><li>整个存储系统的容量即为第二级存储器的容量，即$S=S_2$。</li><li>每单位价格$ C=\frac{C_1S_1+C_2S_2}{S_1+S_2} $。</li><li>命中率<ol><li>$ H=\frac{N_1}{N_1+N_2} $</li><li>$ N_1 $：访问$ M_1 $的次数</li></ol></li><li>平均访问时间$ T_A $<ol><li>$ T_A=HT_1+(1-H)(T_1+T_M)=T_1+(1-H)T_M $</li><li>不命中开销：$ T_M=T_2+T_B $。从向$M_2$发送访问请求到把整个数据块调入$M_1$所需的时间。</li><li>传送信息块的时间：$ T_B $。</li></ol></li></ol></li><li>三级存储结构<ol><li>三级存储系统<ol><li>Cache</li><li>主存储器</li><li>磁盘存储器</li></ol></li><li>“Cache-主存”层次和“主存-辅存”层次<ol><li>前一个层次弥补速度不足，由硬件实现</li><li>后一个层次弥补容量的不足，主要由软件实现</li></ol></li></ol></li></ol><h2 id="5-2-Cache基础"><a href="#5-2-Cache基础" class="headerlink" title="5.2 Cache基础"></a>5.2 Cache基础</h2><ol><li>基本构造和原理<ol><li>存储空间分割和地址计算</li><li>Cache 和主存<ol><li>Cache 是按照块进行管理的。其被分割为大小相同的块。</li><li>主存块地址：用于查找该块在 Cache 中的位置。</li><li>块内位移：用于确定数据在该块的位置。</li><li>地址串 = 块地址|块内位移</li></ol></li><li><img src="/images/Chap5-storage/cpuToCache.jpg" alt=""></li></ol></li><li>映像规则<ol><li>全相联<ol><li>空间利用率最高、冲突概率最小、实现最复杂</li></ol></li><li>直接映像：每一块只能放在 Cache 的一个位置<ol><li>空间利用率低、冲突概率高、实现简单</li></ol></li><li>组相联映像：分组<ol><li>低位被称为索引（对应组相联的组数/直接映像的块大小）</li><li>相联度 n</li></ol></li></ol></li><li>查找算法<ol><li>确定 Cache 中有需要的块</li><li>通过查找目录实现<ol><li>目录表：<br><img src="/images/Chap5-storage/menu.jpg" alt=""></li><li>并行查找：<ol><li>相联存储器：根据查到的组内块地址，从 Cache 中读出一个发送给 CPU</li><li>单体多姿存储器+比较器</li></ol></li></ol></li></ol></li><li>容量：$Cache=2^{index}\times 相联度\times 块大小$</li><li>过程<ol><li>写缓冲器：如果在进行写入操作时，写缓冲器不满，则可以把数据及完整地址交给写缓冲器。</li><li>读不命中：向 CPU 发送暂停信号，从下一级存储器调入数据块</li></ol></li><li>替换算法<ol><li>当新调入一块，而 Cache 又已被占满时，替换哪一块？</li><li>主要替换算法：随机法；FIFO；LRU</li><li>LRU 的实现：<ol><li>堆栈法：用一个堆栈来记录组相联 Cache 的同一组中各块被访问的先后次序。<ol><li>这个方法需要为每一个相联组准备一个小堆栈。</li><li>该方法速度低成本高</li></ol></li><li>比较对法<ol><li>让块两两组合，每一个比较对用一个除法器的状态表示所相关的两个块最近一次被访问的远近次序。</li><li>需要的硬件<ol><li>与门，数量等同块数目</li><li>触发器，和两两组合的比较对的数目相同 $=n(n-1) $</li></ol></li><li>当组内块数较多时，可以使用多级状态位技术减少所需的硬件量。</li></ol></li></ol></li><li>写策略<ol><li>写必须再确认命中之后才可以进行</li><li>写操作可能导致 Cache 和主存内容不一致</li><li>两种写策略：写直达法和写回法</li><li>两种策略的比较：写回法地速度快，使用的存储器的带宽较低；写直达法易于实现、一致性好</li><li>写直达法中，CPU 必须停顿，这个称为“CPU 写停顿”。（可以采用写缓冲器进行优化）</li><li>写操作的调块：写时取，先把所写旦苑所在的块调入 Cache；绕写法，直接写入下一级存储而不调块</li></ol></li><li>性能分析<ol><li>不命中率：与硬件速度无关</li><li>平均访存时间：平均访存时间 = 命中时间 + 不命中率 × 不命中开销</li><li>程序执行时间：CPU 时间 = ( CPU 执行时间 + 存储器停顿周期数 ) × 时钟周期时间<ol><li>存储器停顿周期数：“读”的次数 × 读不命中率 × 读不命中开销＋“写”的次数 × 写不命中率 × 写不命中开销</li><li>存储器停顿周期数＝访存次数 × 不命中率 × 不命中开销</li></ol></li><li>$CPI_{execution}$越低，固定周期数的 Cache 的不命中开销的相对影响就越大；在计算 CPI 时，不命中开销的单位是时钟周期数。因此，即使两台计算机的存储层次完全相同，时钟频率较高的 CPU 的不命中开销较大，其 CPI 中存储器停顿这部分也就较大。因此<strong>Cache 对于低 CPI、高时钟频率的 CPU 来说更加重要</strong>。</li></ol></li><li>改进 Cache 的性能<ol><li>平均访存时间 = 命中时间 + 不命中率 × 不命中开销</li><li>从三个方面改进性能：降低不命中率；减少不命中开销；减少 Cache 命中时间</li></ol></li></ol></li></ol><h2 id="5-3-降低Cache不命中率"><a href="#5-3-降低Cache不命中率" class="headerlink" title="5.3 降低Cache不命中率"></a>5.3 降低Cache不命中率</h2><p>提高 Cache 性能的方法是降低不命中率。本节介绍 8 种降低不命中率的方法。需要降低不命中率的方法都会增加命中时间或者不命中开销。因此，使用时需要综合考虑。</p><ol><li>三种类型的不命中<ol><li>强制不命中：第一次访问一个块，其不在 Cache 中。这种不命中称为冷启动不命中或访问不命中。</li><li>容量不命中：执行程序所需要的所有块不能同时调入 Cache，在程序运行时需要被重复调用。</li><li>冲突不命中：太多块映射到同一组，被重新访问的情况。</li><li>相联度越高，冲突不命中就越少；强制不命中和容量不命中与相联度无关；强制性不命中与 Cache 容量大小无关</li></ol></li><li>增加块的大小<ol><li>增加块的大小：增加了空间局部性，减少了强制不命中；同时减少了 Cache 中块的数目，导致冲突不命中上升；会增加不命中开销</li><li>当第二个作用超过第一个作用时，不命中率会上升</li></ol></li><li>增加 Cache 容量：该方法会增加成本，并增加命中时间</li><li>提高相联度<ol><li>8 路相连和全相联一样有效，故超过 8 的方案实际意义不大</li><li>2：1 经验规则：容量为 N 的直接映像 Cache 的不命中率和容量为 N/2 的两路相联的 Cache 的不命中率相似</li></ol></li><li>伪相联 Cache<ol><li>又称为列相联。获得多路相联的低不命中率，又能保持直接映像的命中速度。<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 先按直接相联的方式进行访问，如果命中则返回</span><br><span class="line">   <span class="number">2.</span> 如果不命中，则会检查另一个块上是否匹配</span><br><span class="line">      <span class="number">3.</span> 如果命中，则发生伪命中</span><br><span class="line">      <span class="number">4.</span> 如果不命中，则访问下一级存储器</span><br></pre></td></tr></table></figure></li><li>如果许多时候，命中发生在伪命中，则速度会变慢。一种简单的方法是，发生伪命中时交换两个块的位置。</li><li>这个方法会使 CPU 流水线设计复杂化，因此一般使用在离处理器较远的 Cache 上。</li></ol></li><li>硬件预取<ol><li>指令和数据都可以在处理器提出访问请求之前预取，可以将其放在 Cache 中或者放在访问速度较快的外部缓冲其中。</li><li>指令预取：一般由 Cache 之外的硬件完成。在一次不命中时，取出相邻的两块指令数据。被请求指令返回时放入 Cache，而预取的指令则放入高速缓冲器。下一次 Cache 访问不命中时，则可能可以通过访问高速缓存器获得信息。</li><li>预取建立在空闲带宽上。如果它影响了对于正常不命中的处理，则有可能会降低性能。可以利用编译器减少不必要的预取。</li></ol></li><li>编译器控制的预取<ol><li>它不是通过硬件预取，而是由编译器在程序中降入预取指令来实现的，这些指令在数据被用到之前，就将它们取到寄存器中去。</li><li>分为：寄存器预取；Cache 预取。</li><li>也可分为：故障性预取，如果出现虚地址故障或者违反保护权限，则会异常；非故障性预取，如果出现故障，则会放弃预取变为空操作</li><li>预取不会改变指令和数值之间的逻辑关系。</li><li>编译器预取的目的是要在执行指令和读取数据能重叠进行。循环是预取优化的对象。每一次预取需要消耗一次指令的开销。</li></ol></li><li>编译优化<ol><li>对于软件进行优化降低不命中率。这个方法的特点是不需要对硬件做出改动。</li><li>程序代码和数据重组：<ol><li>将程序中的过程重新排序，减少冲突不命中；将基本块对齐</li><li>如果编译器知道分支指令很可能转移，则可以<ol><li>将转移目标处的基本块和紧跟着该分支指令的基本块进行对调</li><li>把该分支指令换为操作语义相反的分支指令</li></ol></li><li>同时也可以对数据进行变换，例如调整顺序以改善空间局部性</li><li>编译优化技术包括数组合并、内外循环交换。数组合并是将本来相互独立的多个数组合并为一个复合数组；循环融合是把独立的循环融合为单个的循环</li></ol></li><li>内外循环交换：程序中包含的嵌套循环，并不是按照存储器中存储的顺序进行访问，这时需要交换嵌套关系。</li><li>分块：提高时间局部性来减少不命中。在一次循环中既有对行的访问，也有对列的访问</li></ol></li><li>牺牲 Cache：在 Cache 和下一级存储器的数据通路上增设全相联的小 Cache。这个 Cache 存储因为冲突被替换出去的块，当不命中发生时，在访问下一级存储器之前，先检查牺牲 Cache</li></ol><h2 id="5-4-降低Cache不命中开销"><a href="#5-4-降低Cache不命中开销" class="headerlink" title="5.4 降低Cache不命中开销"></a>5.4 降低Cache不命中开销</h2><p>随着技术的发展，Cache 不命中开销随时间不断增加。</p><ol><li>采用两级 Cache<ol><li>本技术不会印象 CPU</li><li>令第一级 Cache 和 CPU 的时钟周期匹配；第二级 Cache 足够大，能够捕捉大部分到达主存的访问</li><li>平均访问时间公式：<br>$平均访存时间 = 命中时间_{L1}+不命中率_{L1} \times 不命中开销_{L1}$<br>$不命中开销_{L1} = 命中时间_{L2}+不命中率_{L2}\times 不命中开销_{L2}$<br>即，访存时间为$平均访存时间 = 命中时间_{L1}+不命中率_{L1}\times(命中时间_{L2}+不命中率_{L2} \times 不命中开销_{L2})$</li><li>$局部不命中率=该级 Cache 的不命中次数/到达该级的访存次数$；$全局不命中率=该级 Cache 不命中次数/CPU 发出的访存次数$</li><li>对于第二级 Cache，其命中次数小于第一级 Cache，所以其重点放在减少不命中次数上，导致了更大的容量、更高的相联度和更大的块大小；第二级 Cache 不会影响 CPU 的时钟频率，因此设计有更大的考虑空间。</li></ol></li><li>读不命中优先<ol><li>对于写直达，每一次访问需要对主存进行写入。为了提高性能，设置一个写缓冲器，但是这个操作会导致储存访问的复杂化，因为所读单元的最新值可能正在写入</li><li>最简单方法是推迟对读不命中的处理，直至写缓冲器清空。而这个增加了读不命中的开销。</li><li>另一种策略是，检查写缓冲器，如果没有冲突则继续访问</li><li>对于写回 Cache 法，也可以利用写缓冲器。读不命中将替换一个修改过的储存块时，将被替换的块临时复制到一个缓冲器中，从存储器调块，再写入存储器</li></ol></li><li>写缓冲合并：对于写缓冲器。在写缓冲器不为空的情况下，需要将这一次写入地址和写缓冲器中地址进行比较，寻找匹配项：如果有地址匹配而对应的位置是空闲的，则将要写入的数据和该项<strong>合并</strong>。</li><li>请求字处理技术<br>本方法不用增加硬件。从存储器向 CPU 调入一块时，往往只有一个字是立刻需要的。请求字处理技术，就是着眼于这个特性，在 CPU 的请求的字到达后，CPU 不需要等待整个块调入，就将 CPU 重启并继续执行。有两种策略：<ol><li>尽早重启动：一旦请求字到达，就立刻发送给 CPU，CPU 重启继续执行</li><li>请求字优先：调块时先传递 CPU 需要的请求字，让 CPU 继续执行。<br>这个方法有效需要块相对大才能生效；以及下一个指令没有访问同一个块。</li></ol></li><li>非阻塞 Cache 技术<br>Cache 在不命中时仍允许 CPU 进行其他的命中访问，能处理部分的访问，减少了实际不命中开销。</li></ol><h2 id="5-5-减少命中时间"><a href="#5-5-减少命中时间" class="headerlink" title="5.5 减少命中时间"></a>5.5 减少命中时间</h2><p>直接印象时钟频率的高低。</p><ol><li>容量小、结构简单的 Cache：硬件越简单，速度越快；应让 Cache 足够小，以便可以和 CPU 放在同一个芯片上。</li><li>虚拟 Cache<br>采用虚拟存储器的计算机中，每一次访存都必须进行虚实转换，将 CPU 发出的虚地址转换为物理地址，这个一般是由存储部件 MMU 完成的。<br><strong>物理 Cache</strong>：使用物理地址访问的传统 Cache。其标识存储器中存储的是物理地址，地址检测使用的也是物理地址。CPU 需要访问时，先给出一个虚拟地址，由 MMU 转换为主存物理地址，再使用这个物理地址访问 Cache。<strong>缺点</strong>：地址转换和访问 Cache 是串行进行的，访问速度很慢。<br><strong>虚拟 Cache</strong>：可以直接用虚拟地址进行访问的 Cache，存储器中存储的是虚拟地址，检测的也是虚拟地址。当 CPU 访问存储器时，虚拟地址同时送给 MMU 和 Cache，Cache 找出相应的指令。如果 Cache 不命中，则需要 MMU 读出物理地址进行访问。虚拟 Cache 的优点是命中时不需要地址转换；并且不命中时也是并行的，速度更快。<br>但<strong>并不是</strong>所有的计算机都是用虚拟 Cache。其在进行切换时，需要清空 Cache，因为新进程的虚拟地址可能和原进程使用的地址相同。解决这个的方法可以是增加一个 PID，用于标识进程。在 PID 被重用的时候，仍然需要清空 Cache。<br>虚拟 Cache 没有流行的另一个原因。操作系统可能对一个物理地址有多种虚拟地址访问，这可能会导致虚拟 Cache 存在两个副本。</li><li>虚拟索引-物理标识方法<br>优点：兼得虚拟 Cache 和物理 Cache 的好处。<br>局限性：直接映像 Cache 的容量不能超过页面的大小。$Cache 容量\le 页大小\times 相联度$<br>直接用虚地址内的页内位移作为访问 Cache 的索引，但标识是物理索引。CPU 在发出访存请求后，在进行虚实转换的同时，可以进行标识的读取。在完成地址转换以后再比较物理地址和标识。其局限性是为了实现大容量 Cache，又能使索引数比较少，可以采用提高相联度的方法。</li><li>Cache 访问流水化：不能减少命中时间，但能增加带宽</li><li>追踪 Cache：存放 CPU 执行的动态指令序列</li></ol><h2 id="5-6-并行主存系统"><a href="#5-6-并行主存系统" class="headerlink" title="5.6 并行主存系统"></a>5.6 并行主存系统</h2><p>主存的性能主要用<strong>延迟</strong>和<strong>带宽</strong>衡量。第二级 Cache 很大，对主存带宽有一定要求。并行主存系统就是<strong>一个访问周期内能并行访问多个存储字的存储器</strong>，其能有效提高存储器的带宽。<br>对于一个单字宽普通存储器，其字长与 CPU 字长相同，每一次只能访问一个存储字。设其访问周期是$T_M$，字长为$W$，其带宽为：</p><script type="math/tex; mode=display">B_M=\frac{W}{T_M}</script><p>在相同器件条件下，为提高主存带宽，可以采用并行存储器结构：单体多字存储器和多体交叉存储器</p><ol><li>单体多字存储器。<ol><li>对于一个单体 m 字存储器，该存储器可以在每个存储周期读出 m 个 CPU 字，将其带宽提升为原来的 m 倍。但是由于程序执行访问的数据具有一定的随机性，所以实际带宽比最大带宽小。</li><li>优点是实现简单，确定是效率不高：<ol><li>如果提出的指令含有分支指令，且分支成功，则有一部分指令是无效的</li><li>当前指令所需要的多个操作数不一定在一个长存储字中</li><li>必须凑齐 m 个数才一起写入存储器。如果只写个别的字，则需要把相应的长存储字取出，放到数据寄存器中，再修改一个字放回存储器</li><li>如果独写数据在一个长存储字内时，读写操作无法在一个存储周期内完成</li></ol></li></ol></li><li>多体交叉存储器<ol><li>多体存储器由多个单体存储器构成，每一个体有自己的地址寄存器等电路。</li><li>设有 m 个体，每个体有 n 个存储单元。对于计算机使用者来说，存储器是按照顺序线性编址的，如何在二维矩阵和线性地址之间建立对应关系，就是多体存储器编址问题。</li><li>有两种编址方法：高位交叉编址和低位交叉编址。低位交叉编址才能解决访问冲突问题。高位交叉编址能方便地扩展常规存储器的容量<ol><li>高位交叉编址<ol><li>对存储单元矩阵按列优先方式进行编址，即先给第 0 列的各单元按从上到下的顺序依次赋予地址，然后按第一列赋予地址。对于同一个体的高$log_2m$位都是相同的，这就是体号。</li><li>对于第 i 行第 j 列，其地址为$A=j\times n+i$</li></ol></li><li>低位交叉编址<ol><li>先给第 0 行编码，然后从左到右赋予地址</li><li>同一个体的低$log_2m$位是相同的，这是体号</li><li>需要分时启动 m 个存储器。如果每个存储体的访问周期是$T_M$，则各个存储体的启动间隔是$t=T_M/m$。</li><li>采用低位交叉访问能大幅度提高存储器的带宽。由于访问冲突，实际加速比小于 m</li><li>$B=\frac{1-(1-\lambda)^m}{\lambda}$，$\lambda$为转移指令成功的概率。当$\lambda=1$时，并行多体交叉的实际带宽同单体单字并没有区别。由于数据的随机性，单纯依靠增大 m 来提高并行的带宽是有限的。对于标量运算，一般取$m\le8$</li></ol></li></ol></li></ol></li><li>避免存储体冲突<ol><li>体冲突：两个访问要求访问同一个存储体。</li><li>解决这个问题的方法是采用许多体去减少体冲突的次数。体冲突问题可以通过硬件解决也可以通过软件解决。</li><li>软件方法：循环优化法/拓展数组大小，使之不是 2 的幂次</li><li>硬件方法：使体数为素数。体内地址为$地址<del>mod</del>存储体中字数$</li></ol></li></ol><h2 id="5-7-虚拟存储器"><a href="#5-7-虚拟存储器" class="headerlink" title="5.7 虚拟存储器"></a>5.7 虚拟存储器</h2><ol><li>基本概念<br><strong>“主存-辅存”进一步发展的结果。</strong>由小主存储器和大的辅助存储器组成，在管理下像一个单一的、可以直接访问的大容量主存存储器。程序员可以使用地址码对整个程序进行编址，不需要考虑实际主存空间的大小。<br>虚拟存储器可以分为<strong>页式</strong>和<strong>段式</strong>。页式存储器把空间划分为<strong>大小相同</strong>的块，称为页面；段式把空间划分为<strong>可变长</strong>的块，称为段。此二者各有优劣。许多计算机采用段页式，每段被分为若干个页面。</li><li>快速地址转换技术<br>页表放在主存中，每一次访存会引起两次访问，第一次是访问页表，以获得数据的物理地址；第二次是访问数据。这个效率是不可用的，一般采用翻译后备（TLB）解决这个问题。<br><strong>TLB</strong>是一个专用高速缓存器，用于存放近期经常使用的页表项。TLB 是页表部分内容的一个副本。只有在 TLB 不命中时才会进入主存页表查询。TLB 中的项由两部分组成：标识和数据。标识放的是虚地址的一部分，而数据部分存放的是物理页帧号、有效位、使用位等。操作系统需要保证 TLB 中没有该页表项的副本。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冰上行</title>
      <link href="/2020/01/11/essay-tour-%E5%86%B0%E4%B8%8A%E8%A1%8C/"/>
      <url>/2020/01/11/essay-tour-%E5%86%B0%E4%B8%8A%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-fVVCzAbe" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1210185" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>　　我原以为冰是某种坚硬而强大的东西，可是在它遇到温暖的时候，却逃掉了。</p><p>　　这是在冰城的第六天了。这一小段时间，放在我在上海的生活，根本不值一提，它会显得平庸单调而乏味；但在这里，却像是从宇宙诞生到终于坍缩那样漫长而混乱。如果现在我试图从任何一个角度去逼近在这几日里的自己所处的某一个瞬间，都会觉得匪夷所思，像是积累了很多年的顽疾在这一刻突然张牙舞爪，像是目睹了一个明知是自己编织的伟大梦境的崩坏。</p><a id="more"></a><p>　　坐在哈工大的一个藏在角落里的咖啡厅，我决定把这几日的事情记下来。我要记下来的或许不是什么重要或者意义深刻的事情，而是仅仅是一些我没有记在随身小日记上的别的事情，甚至只是那些琐碎平白的语言的补充。尽管我这样费力地铺垫这几日中发生事件是如何地危险可怕、或者平凡无趣，但终究它是一场普通的旅程：这段旅程不论对于我还是别的什么人，都是如此。</p><p>　　早上，我居然很早就起来了，比我平时起床的时间早了不知道多久，我不想躺在床上。我想站起来。外面依旧没有下雪，但是雪满满覆盖着每一个屋顶。我抬起我的手机想看些什么，却意识到我拿起的这部手机没有连接网络，连接着网络的那台手机上没有我想看的东西。想起这几日尚未填写的日记，再一阵肚子小痛，便拿着我没有连着网络的那部小手机小心翼翼地进了厕所。</p><p>　　我从房间门出来，看见隔壁正睡得舒适的三弟。他侧向有太阳射着的一面，他的被子皱成一团，很好地盖住了上半身，两只腿却从被子下支了出来，几缕稀疏的头发很乱地叠在头上。我不打算吵醒他——在他醒了之后便要工作了，还是让他多睡会吧。于是悄悄地，我进入了厕所开始补上前几天的日记。</p><p>　　补完日记的我再一次躺在了床上。很安静的空间，很自我的空间。我盯着天花板上的灯发呆，想着这不是我昨天盯着的灯。我再一次瞥了一眼外面那一片拥有着雪顶的屋子，于是我终于决定还是起来了。想起昨天承诺的今天做出回复，于是便掀起电脑开始阅读昨天仅仅是草草读过的一部分文本。这个房间的设计很是成问题，从我所正坐着的的沙发的位置，沿着时钟一点的方向看去便正好能看到主卧的样子，便是三弟安详的睡容。他换了一个姿势，面向了背光的一侧，头枕在弯曲的右手臂弯上，轻微地蜷缩着，继续着他的睡眠。我很高兴刚才没有不小心吵醒他。但我又在沙发上想着如果我移到他的房间，立刻用某种粗鲁的办法就这样把他把吵醒，或许对于我来说会成一种趣味。但终于我还是没有动，请他再睡一些时间吧。任由这几日的折腾，他虽然嘴上不说，我想也总是疲惫的。</p><h2 id="第五日"><a href="#第五日" class="headerlink" title="第五日"></a>第五日</h2><p>　　疲惫这种东西可能是险恶的世界没藏好自己的全部而露出来的不易察觉的尾巴。不论是前进或是后退，或者停在原地，合着各种五颜六色的情绪一同出现的是恐怖的疲惫。这是我在咖啡厅的想法。此刻我已经结束了上午的滑雪而回到了哈工大，坐在哈工大的某个咖啡厅了，等着一群我认为不会再出现在我的世界中的人，三弟现在的室友们。</p><p>　　点了一杯热可可，然后开始百无聊赖地看着 COC 模组，虽然心里想着，这终于是没有机会的，但还是慢慢地用手机那种小得可怜的屏幕查看这种费劲复杂的文本。在我翻来覆去地看了很多遍之后，终于放弃了。我想趴在自己的手臂上，就在这咖啡厅里睡上一个不管什么用的觉，因为我觉得累。但是又同时觉得不好意思，便一只手当作枕头，侧着脸倒在那桌子上，像个醉汉。我想到底是因为我总是让别人看见一个虚假的自己而感到抱歉，还是因为我总是尝试扮演出来的一个积极有为的青年而感到费劲。我在这样的地方呆了很长一段时间，我并不清楚确切地过了多久，感到时间正在以诡异的速度流逝。尽管我早已预料到某些事情已经不会如同计划那样向前展开了，我还是坐在那个地方，等着那个被告知这个结局的时候。</p><p>　　终于，我听到似乎有叫我名字的人。然后三弟走了进来。他问我其他两个人呢，我只能说还没来。尽管我想着他们已经不会再来了。请告诉他们如果不特别想来今天就先算了吧，我也累了。但是我是因为什么事情而感到疲惫的呢。终于下了这个决策，我们就朝着住宿的地方走去了。</p><p>　　现在虽标着零下 20 摄氏度这样吓人的标签，冰城屋外的夜晚却出奇地不那么冷。两个人便这样走在哈工大的校园里，看着四周不断改变着光彩的冰雕。校园里已经没有太多人，四处行动的是各式各样结成伙的三五人或者成双成对的小情侣，大多数人是不会在这样的晚上还到处走的。我想把刚才那段我想的关于疲惫的话说出来，或许我正在想着这么一个打算的时候，我的嘴就已经开始行动了。我可能若有若无地说了几句。三弟可能是误以为我是因为滑雪而感到累，而我或许矢口否认了几句什么滑雪使人累这种事情，滑雪这样的东西是不会这么伤人的。我想他终于还是不理解我到底想说什么吧。可能我自己也不知道自己想说些什么，以及是不是要让立在我身边的三弟知道这样一些荒唐的想法，于是仓促地岔到了别的话题。经过一番费力地挣扎，我终于又回到那疲惫中去了。</p><p>　　虽然维持这样的状态已经足以可以使我感到愉快，但却心底里明白，这样的时光就如同浮游一般，在刚浮上水面的时候，就预示着它的生命快要消失了。我想我的旅程也快要结束了，但是另一场更大的旅程才刚要开始。从一个旅程跳到另一个旅程，就像是下了一趟火车然后赶上另一辆，终于丧失了所有熟识的人，再一次到一个不知所云的目的地去。我和三弟抱怨说，或许我喜欢的旅程正是那种在一个小湖边，住在一个木房子里，什么也不干，就在里面呆着，这样的生活吧。他说，梭罗就是这样的。我想，我没有梭罗那种底气吧，更没有梭罗那样的气节，我只是一个中国众多普通人中的某一个罢了，也是千千万万个为今晚的月亮感到疲惫而受伤的人中的某一个罢了。</p><p>　　今天这月亮就很圆，虽然小，但是仔细看看，可以看到月亮上的灰蓝色的阴影和乳白色的外皮，架在城市高楼顶上那种泛着红光的灯之间。我说，这月亮很圆。是，哈尔滨云很少。三弟这样回答。</p><h2 id="第四日"><a href="#第四日" class="headerlink" title="第四日"></a>第四日</h2><p>　　我早早地出发前去一个叫做关东古巷的地方。到了才发现，这是一个和关东或者和古巷都无甚关系的地方，一个纯粹的商业街，却打着 AAA 级景区的称号，这实在是费劲。我希望在这里吃一顿午饭，却终于没有找到合适的东西。便到了全中国都可能有的地方去寻觅我想要的东西。进了一家东北菜的餐厅，随意地点了两份菜，却发现东北的菜的分量果然是名不虚传，我不小心点了两个人都吃不完的份。此时手机提示我我收到了些什么消息，我简单地扫了一眼，又出奇地立刻回复了几句，就把它撂在了一边了。</p><p>　　然后便出发去今天的另一个目的地，中国木雕馆。我是不知道中国木雕馆分为木雕馆和金丝楠木馆的，于是我稀里糊涂地走进了金丝楠木馆。我刚进展厅，便看见一个青褐色的小柜子。柜子大概有一米五高，分为上下两个部分，上半部分是竖着的一些密致分布着的等距的长方体木条，围满了上半部分的三边，而留出了面向我的这一边。下半部分是两扇对开的木门，也是呈青褐色，这青褐色上浅浅地游离着一些金色的波浪般的纹路。整个柜子呈现出轻微的上窄下宽。</p><p>　　就在我端详着这一个精巧的柜子时，一个年轻的女性便走到我旁边开始做简单地介绍。现在木雕馆很空，除了我这样游手好闲的零零星星的几个游客，便没有别的人了。她开始很热情地和我聊天，介绍各种各样的木料的来历、构造、设计等等，还讲了些什么清代家具和明代家具的不同什么的。为了解释这个柜子的木门设计之巧妙，她特意无视了“请勿触摸”的标志，将木门拉开，然后等它自动合上。这确实是我从未见过的精巧的设计。</p><p>　　我尽可能做出自己很感兴趣的样子，赞赏了明代家具设计的典雅大气，适当地问了不少的问题，却没想到这位更加热情，开始讲述更多的事情。到最后终于不再讲解和木雕相关的事情，而是讲到了自家鱼缸里养的叫银龙的两条鱼。在这样的一个多小时后，她似乎不小心因为什么我不清楚的缘由当我是一个从事艺术相关工作或者事业的人，然后以这个为假定说出了：想必你也是搞这方面相关的（木雕或者绘画，我也不甚清楚她所说的相关为何物）……然而她正要再往下接着说更多的话时，我最后还是忍不住在这里稍稍地打断了一下她道，我是学计算机的。</p><h2 id="第五日-1"><a href="#第五日-1" class="headerlink" title="第五日"></a>第五日</h2><p>　　坐在从亚布力滑雪场往哈尔滨的高铁上。我们退掉了之前计划的下午五点返程的票，改成了车程一个小时的下午两点出发的动车，代价便是从坐票变成了站票。于是四个人站在狭小的动车车门附近过道那里。一路上聊一些稀奇古怪的东西，讲一些稀奇古怪的故事。我不知道自己为什么要讲某些事情，或者对某些听到的事情保持兴趣。我想你是学文科相关的吧，三弟的某一个室友终于还是问了。是，三弟帮腔到。不是，我是学计算机的。幸好只有一个小时，不需要再继续消耗那么多的精力去构想一些有趣的、可以使这里闷热拥挤的空气不至于沉默的事情。就在我以为还有一段时间才会到站的时候，我们到站了。一路上，我没有机会看见窗外的景色，我的视线里的，是三弟的脸，三弟的一个室友的脸，和另一个室友正弯着腰趴在某一个座椅上睡觉的身影。</p><p>　　我暗自想到，他们的关系真的很好，可以肆无忌惮地开一些奇怪的玩笑，什么顽劣的、过分的玩笑都可以。我想起我自己在大学的室友们，就像是不太认识的一些人，连酒肉之交可能都不太称得上。每个人做自己的事情，有自己的奇怪笑点。我不理解他们有时突然在深夜里爆发的大笑是什么意思，就是那种一会咯咯咯一会哈哈哈的大笑，也没有那种精力去一一询问原由，我知道就算我知道了那么一两个答案，也只会陷入更深的不解之中。最初我在来到这个新的寝室的时候，我还会装模做样的询问一两句，后来便算了吧，他们或许对我是不是关心这样的事情感到无所谓，正如同我对关不关心这样的事情也无所谓一样。我不知道他们的大笑的意味，是想激起那些不知道他们为何而笑的人的注意力，或者仅仅是想大笑而已，这两种原因对我而言都是莫名奇妙的。</p><p>　　我也想发自内心地笑的，但是我找不到机会，更找不到原因。我怎么能期望找到那种可以真正令人愉快的事情。我明明清楚，愉快本身本是与不愉快相对的东西。只有在不愉快的存在下，愉快才显得弥足可贵；而比不愉快更不愉快的时候，愉快才真正地呈现了愉快本来的含义。如果随便一个什么人，一日日地都充满了愉快的话，我只能认为他是分不清愉快和不愉快的人了。像是把黑与白混作一滩一样，搞不清楚自己是否真的愉快，生活在一个自认为美妙的灰色的世界里，并称这种灰色为每日的愉快。但这样，当我们终于分辨出愉快和不愉快是什么东西的时候，愉快本身便不会那么愉快了，因为我们总是在愉快之中的时候意识到这样的被称为愉快的场景终将很快地逝去，否则这样的生活会变成某种日常而不再被人所珍视，而愉快会沦至单调无聊这样的意义，从而变成另一种不愉快。</p><p>　　所以我想：愉快本身性质是消极的。处在愉快之中，或者朝向愉快，或者背离愉快的时候，都是令人难受的，这比处在不愉快这样的环境里更让人难受，像是证明了愉快这种东西的无力。或者说或许愉快是在不愉快的大洋中扔进去的一颗石头，它所激起的每一个波澜都在敲打人逐渐麻木迟钝的神经，用这种微不足道的冲击唤起人对于不愉快的每一份回忆。所以可能对我而言，真的笑或者假的笑，都和哭没有多大的区别吧，只是嘴角的弧度不太一样罢了。</p><p>　　于是这一趟列车就是这么个东西，它是到达愉快和远离愉快的一个分界线，是我旅程的中点，也是下一趟旅程的预告。就在这么一种中间的点，神经不由得紧绷着，承受着一种庞大的、飘渺的感受，承受着这种不怀好意的涟漪。</p><h2 id="第四日-1"><a href="#第四日-1" class="headerlink" title="第四日"></a>第四日</h2><p>　　我走进了一家名为果戈里书店的地方，这是冰城这里著名的书店。看着里面充满了俄罗斯风情的装修，五颜六色的玻璃面板，和橙黄色的灯光，相较于外面的银白色，这里显得相当温暖而舒适。经过一个两层的小楼梯，一个规模不大的书店进入了我的眼帘。这个小书店被一个五六阶高的小楼梯划分为了两部分。前面一个较低的平台，里面摆着两排挺矮的书架，以及一两张装饰繁复的椅子。顺着这个平台正前方的楼梯而上，便到了第二块平台，这个平台沿着第一个平台的四周延伸，形成了一个不完整的高起的回廊。回廊两边都是书架，但是就这样一眼看去，就可以清楚这里没有多少书的。再回头看一眼，看见刚来的楼梯其实可以再往上，但是已经打上了 VIP 的标签。看来我所可以涉猎的知识，便在我面前的两块平台之内了。</p><p>　　我不是漫无目的地进入一个书店，我希望在里面找到一本名为《罪与罚》的书，一是我想到自己一直没有机会再把这本书看一遍，自己当时读这一本书的时候便是感到云里雾里的；二是我想到今年三弟的生日因为自己身在新加坡，也还没有送他什么书，我考虑着《罪与罚》是不是一个合适的选择。于是以这一本书为目标，我开始在这不大的更像是咖啡厅的书店里寻找它。我本来想着，这家名为果戈里的书店，应该或多或少有托尔斯泰、果戈里或者陀思妥耶夫斯基的书吧？可是我一本也没有找到，我希望找的《罪与罚》便自然落了空。我想轻微地谴责一下这家名为果戈里书店的书店，这让我觉得如果我要想瞻仰这些书的真容，非要什么拥有 VIP 名号的大人物不可。当然是我无端地谴责，毕竟就算是对于 VIP 这样的大人物而言，也不一定会有这些书的存在。</p><p>　　于是我两手空空地从书店出来，透过路旁的街牌，发现自己在一个名为果戈里大街的地方。然而这里为什么叫果戈里大街呢？这条道上什么也没有特别的，和我见过的每一座城市的样貌一摸一样。我或许想在这里搜寻一些和果戈里相关的东西，或者和东北相关的东西，但我最后却走进了一家日本的拉面店。一进门听到不太标准的日式欢迎光临，就在那一个瞬间，我想到如果我不知道什么样的欢迎光临是标准的，我或许就不会在意什么，也不会因为这一点小小的差异而搅了兴致，正如去那果戈里书店一样。我在果戈里大街上游走着时，想着可能三弟的考试快结束了，还是等着他一起吃晚饭吧，但终于在这样的考虑中四处溜达了一个小时以后放弃了，最终进入了那一家拉面店。拉面馆最先迎接我的，是糊了我一眼镜的雾气。</p><h2 id="第三日"><a href="#第三日" class="headerlink" title="第三日"></a>第三日</h2><p>　　中央大街是真的名不虚传。里面充斥着各种各样的俄罗斯风格的建筑，特别是那些各种深浅的绿色房屋，在耐克、以及 H&amp;M 这些店的标志下显得更为雅致而别具一格。一条熙熙攘攘的大街，在我到的时候，天已经差不多黑下来了。街两旁的行道树上挂着黄色的灯，将两边的房屋连接了起来，在夜幕下显得温馨。但这温馨是假的，寒风轰击着我的全身，让我感到我当时在雪山之中都尚未感受到的寒冷。路两旁放着许许多多的冰雕，这些冰雕自然比哈工大里面放着的显得更加精致复杂，但也终究是会在不久之后就化掉的艺术，而第二次被造出的时候，这些冰雕也就不是这些冰雕了，只是那些存在过的冰雕的复制品。并这些冰雕耐人寻味多的是那些被成为折衷主义或者巴洛克风格的房子。</p><p>　　我频频地掏出手机想要抓住那些印在我眼睛里的那些五彩斑斓的令我赞不绝口的建筑，直到自己的手失去了手的感觉也没有停下来。然后再一次抓住我注意力的是两个食物，一个是烤红肠、另一个是冰棍。虽然这名为马迭尔冰棍的、售价 15 元每根的冰棍我早有耳闻，也知道这是必然会在之后尝试的东西，但是这寒风劝阻了我立在那数十人的后面为一根冰棍排队的冲动。我只是站在那卖冰棍的地方之外，远远地望了一眼，假装自己有所迟疑地停留了一小会，然后继续前进了。</p><p>　　然后是红肠。我想起在这学期在新加坡的日语课上，老师在最后一节课上问寒假的安排时，我说，我要去哈尔滨。同学们说，那个地方的冬天很冷吧。但我说，那里有很多好吃的。他们问有什么呀。我说，一种叫红肠的东西。现在这个东西真正地出现在了我的眼前，10 元每根。但是在我正走近它想要买下一根来实现之前的回答的时候，我再一次莫名其妙地犹豫了。认为这不过是旅游景点常见的套路罢了，像这样的东西，别的地方也是有的，只是以不同的名字，不同的身份，出现在各个摊贩的名录上，并标着各种正宗云云的名号。于是我抬起的手被我放回了温暖的口袋里。就这样在冰城最出名的城市建筑群里呆了一段时间之后，我决定去寻找我的晚饭，以及拜访圣索菲亚大教堂。</p><h2 id="第四日-2"><a href="#第四日-2" class="headerlink" title="第四日"></a>第四日</h2><p>　　我看着呈上来的拉面中飘着的鸣门卷，它飞起的热气又一次糊了我的眼镜。在到了这里之后不知道第几次抱怨眼镜是多么不方便的同时，慢慢的消耗了这一碗拉面。就在这一碗碳水化合物被我全部吃下去的时候，我看见一条新的信息。三弟考完了，他说他好了，开始问吃晚饭的事情。这样的事情也是有的。这样巧合而令人啼笑皆非的事情也是有的。</p><p>　　我想，这个时候，我应该怎么办呢。如果是我的话，如果是我自己考完了的话，我会想招呼上几个酒肉朋友，或者比酒肉朋友稍好那么一些的零星的几个朋友，在一个可能比平时吃饭的地方略微好上那么一点却又不至于让我承受不起的餐厅吃上一顿，作为惯例式的别过。然而这样的惯例并不使人愉快，它既不是愉快的一部分，也不是不愉快的一部分，而是惯性的一部分，无关乎情感，仅仅是一种惯例。自然这样的饭局甚至会显得比愉快的饭局更为自得，就像是平时随便吃的一顿饭一样。虽然它有着某种仪式上的标签，却终究没有某种仪式的感受。</p><p>　　我想，这样的惯例或者仪式对于每个人来说，应该也是必要的吧，对三弟这样社交圈里如鱼得水的典范来说，应该会更为重要吧。于是我给出了这样的提议：请不用管我吧，叫上自己大学还好的朋友一起吃一顿吧，就当是别过了，后面再想抽出时间就很难了。然而最后他还是没有接受这个提议，或许会觉得难为情吧。确实或许会吧，像是将一个木雕馆里那种老房子拆下的板材制成的柜子摆在充满了明亮并带有玻璃现代风格的展示厅里那样不能称为和谐的场面，我也会在不能够搭上话的氛围里被击溃。毕竟历史和正在发生的已经是两码子事了，历史发生的一切都是某种执念留下的幻觉，或真或假，伴随着主观的某些微不足道的想法而变形。于是便觉得他做出这样的决定不可不谓明智吧。</p><p>　　于是我最后也接受了三弟的决断，抱着再吃一顿夜宵的想法前往刚刚得知的约定的地点。就在推开门的那一瞬间，寒风从外面扑进来问候我，但是刚刚拉面店所赋予我的热的感觉还没有消散，我就在这样的寒风中突然想起来刚入肚的拉面，同时觉得温暖。</p><p>　　我需要四十分钟到那里，我这样回复了三弟。</p><h2 id="第六日"><a href="#第六日" class="headerlink" title="第六日"></a>第六日</h2><p>　　在吃完午饭后告别了三弟，便第二次朝着中央大街前进。这一次，我是奔着之前被自己放弃的马迭尔冰棍而前往的。这一次我从中央大街的腰部的某一个支道上进入了主道，随便选了一个方向，然后笃信着我所寻找着的马迭尔冰棍就在前方。当我再一次看向那些我曾经赞不绝口的建筑以及房屋，却总觉得缺了那么些味道，我想是这或许不够寒冷的缘故，也可能是现在还没有进入夜晚的缘故，还是说因为我知道我将离去而遇见了一些别的感受。我说不清楚。这些即使在白日中也点亮着的霓虹灯招牌，间杂在这些富有着历史感的建筑间闪闪发光。我这一次无心再一个接一个地端详那些冰雕了，我只想找到那个驱使我再一次来到这里的马迭尔冰棍。</p><p>　　我这样盲目的往前前进着，但是却发现我已经走到了中央大街的尽头，便终于意识到自己在十字路口选择了一个没有马迭尔冰棍的方向。这让我感到懊恼，于是我转头开始往回走。然后我立刻发现了一个我上一次便看见但是却没有进去仔细观察一番的建筑，中央书店。没有在果戈里书店找到的《罪与罚》，这里应该会有的吧，我这样想着，进入了书店。这个书店和果戈里书店完全不一样，没有果戈里那种高雅温馨的氛围，里面密密麻麻的是走动着人群；也没有像果戈里书店那样坐在地上看书的群众，也没有停在走廊上拍照的人群。这个书店天花板很高，整个宽阔的房间也几乎没有什么装饰，几列一进门就能看见的书架，和左右向上一直延升到了天花板的书柜。这意味着这里有许许多多的书。我想着我计划里的书或许终于有着落了。于是我埋头进去，寻找我想要的书。</p><p>　　不久，我在那里找到了我正在寻找的书。书很厚，封皮很薄，不像是近段时间常见的把经典或者不经典的书都统一用又硬又厚的封皮包起来那样的做法，而只是在书上包了一层简单的封面就放在书架上了。它甚至连腰封都没有。很中我意。封面和封底都是是完完全全的猩红色，从前到后都是大片的猩红色。正面用端正的某种楷体的变体竖着写着黑色的“罪与罚”三个汉字，以及横着写的 crime &amp; punishment 几个英语字母。悬在这一系列字上方的，是一把被手握着的黑色的斧头。在剩下的空处标着陀思妥耶夫斯基和译者曾思艺的大名。很中我意。</p><h2 id="第五日-2"><a href="#第五日-2" class="headerlink" title="第五日"></a>第五日</h2><p>　　闹钟在五点半准时地把我叫了起来，今天得立刻就离开床铺，我拉开了自己房间的门，示意三弟自己已经醒了，然后穿上衣服出了自己的卧室。透过那扇就在我的卧室旁边的门，我知道三弟也已经起来了。他正坐在自己的床上弯着腰发呆，上衣尚还没有穿上，腰上和肚子上的少些赘肉略微地鼓了起来。而被子被推在一旁，形成了一个突起的泡沫。三弟还是像高中那样每每起床之后就要盯着某个怪异的方向，神志不清地发会不明所以的呆，同时也是比高中的时候胖了一些。</p><p>　　想罢这些我就移步去了卫生间洗漱去了。我再一次出来的时候，三弟已经穿好了衣服开始给室友打电话叫他们起床了。待到我们两人都准备妥当的时候，便出了门。预约的师傅搞错了我们上车的地方，不过总算是顺利坐上了车。本以为车上不会有别的乘客，没想到这一次还是受到了冰城出租车乱象的捣乱，车上坐着另一位去哈尔滨火车站的乘客。不巧的是，另外两名并未来得及准备妥当，而那个没在我们预期之内的乘客的火车在我们的火车之前，着急着去赶自己的车。我们并不占理，就只能先舍下两位室友友人，继续乘着这辆车前往火车站。</p><p>　　然而就在我们到达火车站之时，却发现火车的出发时间比我们原以为的早了二十分钟。而三弟的室友们便没了这个赶上这班车的机会，他们可能得买新的票了。</p><p>　　安稳地坐在了火车上之后，就开始处理那两位室友的行程，好在目前尚有别的车可以到达目标。就在三弟处理着这些我非常不擅长对付的事情的时候，我开始观察车厢之外的情况。外面是一大片被枯树弄得支离破碎的雪原，在这些枯树的间隙里，有着几片不大不小的类似田垄的东西。我之所以可以知道那些是田垄，是因为在那洁白的雪地之中留着规则的被犁过的平行的痕迹。在这些田垄之上，极有规律地堆着些要么圆柱形的、要么三角锥形的谷堆。有的阳光会穿过枯树照在雪地上，使雪地看起来被什么东西踩过一样。远处的山，迷迷蒙蒙，说不清楚是被雾罩着还是什么，呈现出一种很深很暗的藏青色，就像是只调了一点水的花青色。时不时我们会路过一些屋顶上堆满着雪的屋子，却没有见到几个在雪地里行走的人，只看得见地上偶尔稀稀疏疏的脚印。就在我观察着这些平日难得见到的北国风光时，三弟那边的事情也处理结束了。</p><h2 id="第一日"><a href="#第一日" class="headerlink" title="第一日"></a>第一日</h2><p>　　在不知原因地三次延误了航班之后，终于在比原计划晚了三个小时的时候，我到达了冰城。在我假想出的寒冷的空气的威逼下，我准备好了手套、围巾以及两层袜子，却发现外面远没有想象的寒冷。赶上了从机场到火车站的大巴之后，便注意到了坐在一旁的一对父子。虽说是注意，但不是我的眼睛看见了他们，而是我的耳朵抓住了他们交谈的声音。儿子坐在了我左边的座位上，而父亲则是站在或者蹲在儿子的旁边。父亲之所以这样是为了和儿子说话这一点我很清楚，但我也不愿起身离开我的座位而给父亲一个方便，因为车已经开始移动了。</p><p>　　从这对父子零零星星的对话中我大概了解到，这个儿子在广州某地读书，年龄大概在十余岁，声音尚未变得富有男性的特点。这一次是从读书的地点回到哈尔滨旁的某各小城市里过年。父子会在哈尔滨住上一晚上，然后第二天就赶回家。令我感到奇怪的是儿子读书的内容。我只大概听到儿子这一年的课业是背诵《论语》；下一年的课业是背诵《孟子》，再之后是背诵《易经》和《黄帝内经》。</p><p>　　你要记下老师讲的所有的东西，父亲这样说道，它们以后都很有用。爸爸我没有什么学问，我不懂什么《论语》，但是知道这些东西很有用，你把这些东西给爸爸记牢了，永远都不要忘记。儿子支支吾吾地回答，他不觉得有什么用，自己在生病的时候，老师给扎针也没有治好。于是父亲又重复了一遍上面的话。接下来父亲开始挨着挨着询问课业的事情、生活的事情。最后说，爸爸下次再带你回一次家，再下一次你就该自己回来了。你也大了，该自己走了，这个不难。旁边的乘客也帮腔到，对的，这个不难，都是这么过来的。儿子先是小声地回答自己不行，后来才慢慢地问着父亲自己能不能有一支手机，这样就可以自己回来了。后面父亲又反反复复地交待了不少的事情。</p><p>　　我一边有心无心地偷听着这一对父子的对话，一边看向窗外。窗外没有什么景色，在黑夜里面，无非就是在高速道旁往后滑坠的立着的树，这些树都没有叶子，光秃秃的，这些光秃秃的树使人感到平静。你早点休息吧，我这边应该不会有什么问题了，我编辑了这么一条信息发给了三弟，然后再一次把视线转回了窗外。</p><p>　　直到下车的时候，我瞥到了这一对父子。虽然看不清楚他们穿了些什么衣服，但确实地看见他们一起下了车，朝着我不会再遇见他们的方向前进。没事，你再适应适应吧，三弟这样回复到。原来他还没有睡啊。</p><h2 id="第七日"><a href="#第七日" class="headerlink" title="第七日"></a>第七日</h2><p>　　我终于踏上了回去的路途。然而就在这回去的一天的夜里我一点也没有睡着。房间里墙上钟的声音在不停地刻板地踢踢踏踏，时不时也传来冰箱的些许噪声，房间之外的马路上尚有不少的汽车正在道路上行驶着，出租车“有人的”黄色标牌在夜色里拉成一条长线。三弟今晚回到自己的寝室收东西去了，这个二室一厅一卫一厨的屋子里现在就躺了我这么一个人。</p><p>　　我不知自己出于什么样的目的，没有和三弟订下一起返回成都的飞机，而是古怪地晚了那么两个小时。在这一天之前的晚上，三弟劝我还是自己走吧，不用起那么早了，可以多睡一会。我拒绝了这个提议。于是便还是决定一起去机场。然而我正住着的并不是什么繁华的地段，没有特别多的住户，尝试多次以后，我也没能预约到合适的出租。那走去地铁站吧。我想，凡人的偏执乃是危险的东西，而这一个决心是我已经下好了的。于是我就在这样踢踢踏踏的声音里，看着时间从 2020 年 1 月 11 日的 11 点一点一点划到了 2020 年 1 月 12 日的 5 点。我起身去洗漱，零零碎碎地吃一些东西，再检点了一遍有没有忘记了的东西，顺便检查了一下三弟的房间有没有留下什么他忘记的东西。在仔细地确认这些无误以后，我开始坐在客厅的小沙发上发呆。</p><p>　　这样，我在这寒冷的地方的旅途就竟然就要结束了。我终究没有吃马迭尔冰棍或者是红肠，更不要说别的什么的东西。但是我又没有固守没有人的城池这样的想法，或许这就是时候离开了吧。我心里暗想到，三年后的这一个时刻，我可能会再一次坐在现在我所在的房间里，思考一些相似的问题。想到这个，我不免觉得奇怪，原来我还要回到这里来呀，对，三年之后，我会再到这里来，可是那个时候我或者这里的人们都是什么样了呢？</p><p>　　就这样坐在黑暗里，我终于下定了决心出门。把要是小心翼翼地放在了桌子上，再环顾了一下这个不大的空间。一个双开门的冰箱，一个只能坐下两人的小桌子，坐下两人的小沙发，一台大电视，一个小巧的厨房以及浴室，几面墙上都挂着的小画。于是我再这样望了一眼，出门将门关上。</p><p>　　我是在将来真的会回到这里来，还是会到一个别的什么地方去呢？</p><h2 id="第二日"><a href="#第二日" class="headerlink" title="第二日"></a>第二日</h2><p>　　在时隔上一次见面将近一年这样的时刻，我站在哈工大校门的广场那里竖着的巨大的校庆的冰雕的旁边，看见了耳朵被冻得略微泛红的三弟。这个时候正是哈工大的学生从寝室或者图书馆出来寻觅午饭的时候，在滑溜溜的地板上，小心翼翼地走着许多带着羽绒帽子并把手揣在兜里的人。在我左前方立着一个高大的冰雕，冰雕的下面刻着哈工大的校徽，以及 2020 的纪年的数字，在我的右边是一个用冰砌成的国旗的围栏。我向三弟打了一个简单的招呼然后问我们现在去哪里。</p><p>　　很快，我们抵达了哈工大的食堂。哈工大的食堂是一个怪异的物种。从外面看过去完全不像是在营业的样子，作为一个闯入的外来人，我或许有可能永远都不知道在那垂着的重重的帘布一样的黑色空间之后，藏着一个卖粥与饺子的地方。</p><p>　　于是在这里，热气第一次扑向了我的眼镜。三弟提议吃饺子之后，接着问我要多少，我说二两。他露出了怪异的表情，眼睛瞪得很圆以表示难以置信，然后再一次确定了我的答案，端给了我一份二两的饺子。盘子里的饺子大多不太完整，也不太大。这些饺子不像是平时吃到的饺子那样中间鼓起，而更是呈现出一个扁平的状态。说是二两的饺子，估计一下也就是十个左右的数量。这样我就知道为什么三弟奇怪地看着我了，原来二两的饺子是如此分量微小之物。</p><p>　　于是后来我又去补了一杯粥。本来我是想要一杯豆浆的，然而这里中午没有豆浆。我自作主张地给三弟也要了一碗，尽管他之前说过自己不要豆浆了。这粥是不太甜的那种，不是我喜欢的味道。在若有若无地聊着天的时候，我终于决定去加糖。然而加糖这种事情是不可以一步到位的，在折腾了来回几趟之后，我才终于仰起头，将碗里的黑粥一饮而尽。</p><p>　　待到我放下碗，才第一次认真的注视着三弟的面貌。毕竟也是有将近一年没见了，虽然说不清楚具体哪些东西发生了变化，我却感觉到一些不一样的地方。我指的不一样，自然不是指他的头发如何地变换了形式，或是眼睛如何地望向不一样的方向，而是一些别的东西，一些我的视线抓不到却可以感受到的东西。他可能也趁着在这个时候注视着我吧，我想。</p><h2 id="第五日-3"><a href="#第五日-3" class="headerlink" title="第五日"></a>第五日</h2><p>　　走进门，把随身的东西都撂在一边，然后走进自己的房间把围巾和外套都丢在了床上，折回了客厅，然后摊在了沙发上。疲惫的影响力，真的是不容小视。我就这样茫然地架在沙发上，三弟却看起来很精神。我确实是短时间内没有力气再说一些新的话，于是就任由我的身体稀里糊涂地倒在沙发上。然后我开始很仔细地，试图尽力地消耗着剩余的所有力气那般，盯着头顶的灯。灯是三层蓝色的荷花叶子一样的图案的组合。每一层之间都很好地错落地分部，不至于拥挤。每一朵花瓣都是向外舒展的、完美的、圆滑的弧线。它从那里发出柔和的光，我接触不到它，它离我太远了。三弟坐在一侧开始试图找些有趣的东西来看，我在旁边继续倒着。</p><p>　　我想，这一趟旅程就这样快要结束了吧。就像一顿火锅已经下完了所有的肉一样，后面的期待也如同捞起来的一块块肉一样，终于寡淡了。也并不完全是这样一个事情。在刚才从咖啡馆回到住宿的路上，三弟和我说他在和老板交接任务的时候，知道了明日自己需要加个班，完成一个仪器的调试。我听着三弟这样一段话，心想自己去冰雪大世界以及二访中央大街的计划就这样被取消了一大半。</p><p>　　我看着自己呼出的水汽在空气中凝结成一片飘摇的白雾，在我伸手抓到那段白雾以前，它们就没影了。如果不是哈工大这片路灯的照耀，这片白雾也就不会出现在我的视线里了。一路上依旧没有什么行人，许多店铺也早早地关了门。我想这些店铺就算开着，也不会有很多人去了，这里已经放假了。我就在这样想着的时候，越发觉得身上正承载着的疲惫的真实与复杂。</p><h2 id="第四日-3"><a href="#第四日-3" class="headerlink" title="第四日"></a>第四日</h2><p>　　毕竟是晚高峰，放在哪里，晚上七点应当都是晚高峰。就晚上来看，忽略掉路旁的冰以及行人穿着的厚衣服，这里的晚上和上海的晚上或者成都的晚上都没有特别的差异。路两旁排了一列闪亮着的灯，灯前排了一列匆促行走在人，匆促的人前排了一列公交车站，公交车站前排了一列等车的人，人前面排了一列排队的公交车。就是很朴素的夜晚的景观，放在中国哪座城市里都是的那种晚上的景观。纵使是冰城，也不可能四处都是冰雕，总会有些不那么哈尔滨的时候的。</p><p>　　终于经历了一路走走停停，我到了目的地。就在我快要到达的时候，手机上的新消息告诉我三弟也到了。时间正好。走进约定的烤肉店再转到二楼，就在进门不远的地方，我见到了三弟。之后就是观赏菜谱的时间。虽然我总是不愿意担当起点菜的重任，但总有些事情不能顺心如意。三弟就是这样，每次在我看着菜谱的时候，他总是要让我也点一些什么东西，不论我怎么推脱掉这份差事。于是我只能打开菜谱，逐页地翻着。这确实是相当厚的菜谱，我很久没有看见这么厚的菜谱了。里面的菜也很有意思，比如一个叫大串的东西。就在我计划随意点两串的时候，我被三弟制止了。于是我想起了中午在东北菜馆的尴尬境地，终于还是缩减了点的东西。然后将菜谱让给了三弟。这些事情还是交给他吧。</p><p>　　这家店不知为何，据说今天的人特别的多，也就使我们上菜的速度很慢。一道菜往往等不到下一道的到来便早早地投了地府，我本以为肚子里占着碗拉面和章鱼丸子便不会吃什么东西，但还是老老实实地吃下了一顿饭的分量。不过三弟定然是没有吃饱的。我们又追加了一份什么榴莲烤饼，但它终于没有被端到我们的桌子上。粗心的服务员忘记了我们的加餐，于是我们坐在桌子上聊了很长一段时间的天——上一次并没有来得及聊到这么多的东西，但所谓聊天，也就是些琐碎的话题，没有什么中心，也没有什么重要的话题。我大概描述了一下我在新加坡的生活，三弟大概描述了一下他在哈工大的生活。</p><p>　　与这顿被服务员忘掉榴莲烤饼的美中不足的晚饭不同的是，三弟的生活听起来很幸福。</p><h2 id="第一日-1"><a href="#第一日-1" class="headerlink" title="第一日"></a>第一日</h2><p>　　终于，我离住宿的地方近了。我刚到冰城的时候，这里就下起了雪。我在雪里等着出租车，旅途遇到一群推销着住宿的人。仓促地拦了一辆车，不太顾砍价的，我逃离了这个地方。还好这里离住宿的地点不太远。一路上师傅开始与我交谈，和我聊着哈尔滨的各种事情。他似乎没有看出我是外地人，先是用本地的话和我攀谈起来，发现我没有完全听懂的时候，他便开始试图说一些更类似普通话的语言。他问我是来做什么的，我说我是来看亲人的。这句是我出于自我保护而说的一句谎话，后来想想却的确如此。我若不是来看亲人的，又是来看谁的呢。</p><p>　　我被司机放在了小区的正大门前，按照之前房东的说法，我顺利进了这个小区。小区很是安静，在这个稍微偏一点的地方显得很舒适。四周实在是安静，地面上由于正下着雪，已经满满地铺了一层。树上挂着黄色的灯，也是这里唯一的光源。这里唯一不和谐的是我这个就算在雪里也隆隆作响的箱子的声音。</p><p>　　我的前面是一条洁白的长路，在黄色的光的照耀下也呈现出些许黄色。我忍不住回头看我走来的路，在我来的那一边，它本也应如同我前方的道路一样整洁，现在却烙上了一串凌乱的脚印以及不连贯的纠缠着的两条长线。拖着箱子、破坏着着安静与整齐的我，在这个时候很清楚地知道：我不属于这里，我只是造访这里，拜访一位亲人，然后再从这里离开。</p><p>　　我之所以在这里停住，恐怕不是由于掌管生命的神这样对我说：请停留在这里。私以为，我之所以停留在这里，是因为我决定如此，而不是其它什么花里胡哨的原因。这件事情的发生既不是我的计划，也不是像我的某个人所构造的计划，它根本就称不上什么计划。尽管我在甚至离开上海前往新加坡以前就如此打定了我要来一趟哈尔滨的主意，甚至是在前年的夏天，我就做出了这样的打算。但它仍然算不上是一个计划，这趟旅程毫无理性的成分，既不考虑支出，也不考虑时间。只有“到这里”是重要的，这是计划的一部分；但是计划也没有别的部分了。被问起我为什么来这里，我谎称自己是因为自己想感受一下寒冷，或者是自己是对东正教教堂颇有兴趣。但我清楚地知道这是敷衍别人以及自己的理由，我知道理由就只有一个，而且正是为了达成这个理由，仅有“到这里”才是重要的，也是必要的。</p><p> 　　这里寄寓着我的一部分生命，我必须到这里，将这一块回忆填上。</p><h2 id="第四日-4"><a href="#第四日-4" class="headerlink" title="第四日"></a>第四日</h2><p>……</p><h2 id="第五日-4"><a href="#第五日-4" class="headerlink" title="第五日"></a>第五日</h2><p>　　站在雪板上，我感受到了最大程度的恶意。我没有任何移动的可能，我所能做的就是坐在哪里，或者任着向下的冲动终于把我一直拽下去。我停不下来，也改不了方向。我所驶向的地方既不出于我的意志，也不违抗我的意志，它独立于我的意志。决定我方向的，终究就是我在踏上这个路途上那一瞬间受到的力。除此之外，再无他物。</p><p>　　我总以为，在不断挣扎的时候，我能够通过某些途径改变自己行进的方向，然后到达我所期望到达的地点；但终于发现这是个徒劳。于是我就停在了我意识到了这一点的那里，感到挫败。我想，如果将这个倾斜的雪道变得水平，那么我所面临的另一个困境便变成了：我只能留在原地，而不是像现在那样向下滑去。或许那个时候，维持移动的唯一便是惯性本身，它既不是无形时刻存在的重力法则，也不是我渺小的意愿。这个雪板就会载着我各式各样的胡思乱想，没道理地一直往前，直到这个巨大的船只撞上了什么东西，终于再也不能移动。</p><p>　　就像这样，我要么在雪上仓皇地四处乱撞，要么就倒在雪地里。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>　　这篇罗嗦的，也没记下很多东西的后记是在第五日受到清华某友人的启发后打算写下的。本来是计划完成一份详尽一些的、3w 字左右的文本，但终于在离开了冰城以后完全丧失了继续完成它的氛围和意念，就如同我在离开那个城市时所担心的那样。所以终于大部分内容都停留在了停留在哈工大小咖啡馆的内容，只是后面草草再补了一些东西。</p><p>　　这篇文本也并应该包含太多的深意，甚至有很多相当重要且关健的事件出于各种考虑以及个人的懒惰终于没有添加进来。简单来说，这或许是因为离开了那里而被迫腰斩的一篇小文章。或许是到了后面越发觉得自己的笔之沉重，终于不能再将原本定下此题的勇气重现出来。</p><p>　　更多是对当时一些思绪的整理，就没有更多的东西了，且当作胡乱作文的结果吧。</p><p>2020-1-11，作于冰城哈尔滨</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行迹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公开信-给YT的第二封回信</title>
      <link href="/2019/11/12/essay-letter-%E5%85%AC%E5%BC%80%E4%BF%A1-%E7%BB%99Yuting%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%B0%81%E5%9B%9E%E4%BF%A1/"/>
      <url>/2019/11/12/essay-letter-%E5%85%AC%E5%BC%80%E4%BF%A1-%E7%BB%99Yuting%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%B0%81%E5%9B%9E%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-rmiNKGig" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="438562829" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>YT，</p><p>　　想起来这一封信也是，好像好几次打算开始，都没能完成，真的是非常抱歉了。想着上一封回信被我从上海带到广州，又从广州带回上海，再从上海带到新加坡，若不是一个契机，恐怕又要被我从这里带回去了。时间太久，恐怕之间好些事情已经有变化了吧。在这一次的追加之前，是在我 11 月动笔之前遗留的信的内容。这之后的事情，就留在这部分之后吧。</p><p>7-29 日书：</p><p>　　很抱歉已是拖沓了如此之久了。一段时间以来，我常常想起，或许我应该提起笔来写这一封信，如同每日起床时我想起我的琴，但每当太阳落下的时候，这种感觉就丧失殆尽。以至于当我意识到，过了这么久了，我居然都快要离开中国的时候，我还没有真正开始写这么一封信，就感到一阵无奈。倒不是为事情本身无奈，而是为我自己无奈。</p><p>　　这一个学期发生了不算多、但也不算少的事情。除却学业自接近半期开始初露爪牙这些事情，还有出国一条线时显时隐。个人的心境在这长期中，似乎受了些扰动。或许这是无法提笔的根本原因吧。但这些扰动的原因或者影响，我都是说不清楚的。</p><p>　　首先是对上一封信件文风的回应吧。说一个人的文字有些许味道，是很高很高的赞扬了；或许我的信的风格是变化的，是不稳固的，所以我并不知道自己的风格是什么，所以更没有什么有心之举了。或许我的部分语言结构受日本文学翻译那一脉，或者日本文学那一脉影响很深吧。在高一那段时间，可以说是疯狂地看各种书。当时，除了忙社团和班级活动一堆事情，也就只想看书。那段时期看的书，最多的就是日本文学了。并不是说自己对日本文学有多么深厚的喜爱，而是那种温馨与悲凉交错的感觉，让人觉得真实而深刻。</p><p>　　YT 的文风就和我迥乎不同了，有一种细致明媚的感觉。仅就一系列常见的语气词，用法及效果差别都很大。因为拖欠了如此之久的回信，又时不时想着要回，所以这封信我也是看了好几遍了。而每一次的阅读体验都是相对一致的，虽说内容或各种变化，却有一种稳定含蓄的积极情绪。虽说我写了很多信了，但是真正的回信这却是第一份，这封回信还是出乎意料地长。巧的是，就在这不久后，我接到了另一位同学的回信，不过这是另一个诡秘事情了。</p><p>　　听 YT 谈面包，我想到或许自己更喜欢做一个厨师胜过做一个研究者。或许因为下厨只是因为兴趣，而且也不经常，所以可能对美食的制作有一种自然的好感吧。仔细想想，为了一道小菜围着锅炉转一两个小时还是有点累的。所以干脆做个品尝者好了，见识到没见过的食材和做法永远都是令人激动的事情，虽说常常标新立异的菜并不合人胃口。说起面包，我倒是一直认为越丑的面包味道越好，那种形状奇绝，浑身疙瘩的面包估计就是我的最爱了。</p><p>　　回信中 YT 也对后悔有了一个表述，于是我更清楚地意识到，我确实离这种感情太遥远了。于是说起我的好朋友的事，如果以“如果……就好了”这样的评判去评价当时的那一次选择，我是不后悔的。我有一个非常值得怀念的高中生活，我的朋友也和我一起度过了很多事情。但这不是我不后悔的理由，这不后悔并没有什么理由。这些事情只是恰如其分地发生了，然后事情总会继续往下发展的。至于那个或许“有意味”的团建就是如此，我只是在零零落落的瞬间中意识到了道路的分叉。分叉不是被哪一次偶然构建在那里的，而是一直都在那里的。所谓联结，或许不是执着于道路的方向是否一致，而只是一种联结罢了，一个名字或者一种理念。至于为什么会有一些惋惜之类的情绪呢？犹如一块巧克力，咬下这一块的人都会意识到，这一块巧克力的一部分丧失了，一种味道在被获取的时候丧失了另一部分味道。当巧克力的一部分味道被知晓的同时，其他千千万万种味道就丧失了。惋惜或许就是如此吧。</p><p>　　不过说来也巧，YT 居然有极为类似的经历，只是发展方向截然不同。YT 在信里面有很多的推测与猜想，这确实是一件有意思的事情，只是我不太擅长做出这些假设。</p><p>　　还是很羡慕 YT，不论顺或者不顺，生命中都有如此多有意思而重要的人。我听了很多人的故事，其中不乏有如小说般出人意料、走向戏剧化的故事。但最后还是更喜欢恬静美好的故事，YT 的故事就已经很是恬静美好了。我或许向往一个恬静美好的生活吧，但是自己的生活又是恬静得过分，可以算波澜不惊了。安稳着安稳着，又想来些猛烈的东西，然而这样的东西又使人感到恐惧。所以就在这样安稳，而向往着波澜的生活中避免着波澜，继续着安稳。</p><p>　　说到这些事，说来也怪，我碰到的感情事项不算多，但都是以诡秘而单调的模式出现的。想来也是无聊的些许生活琐事，真要谈起怕是枯燥之至，若想要听，我再抽时间谈谈吧。总之就是如此。说到这里，可以大概谈谈之前有提到的“朋友”的事了。对我而言，友情是一个非常广阔的概念，但是却仅仅适用于一小波人。无疑，我对“朋友”是看得很重的。这里当然指的金兰之交以上的朋友；无论在谁的眼里，这样的朋友恐怕屈指可数吧。我也说不清楚一个朋友在我的生活中会扮演怎样的角色，有时我觉得他们是我的一部分，有时我又觉得，他们或许远离我会更好。这倒也并不是一种飘忽不定。对很多东西我都是变化无常，但是朋友却不是。我说不清楚这是一种尊重还是什么，更多来说，与朋友的相处就如呼吸一般正常，如同张开自己的嘴，或者挥动自己的手臂。有如自己思想的延升，感受到了一些自己感受不到的快乐与痛，然后有了一种一同体验的感觉，便是如此。</p><p>　　以上便是之前的内容了，上一次差不多也快到了结束的位置。我再看了一遍，大概小改动了一两处吧，别的便是如旧了。其中的几点，可能现在 YT 会有不一样的感受吧。特别是我给出的“积极”、“明媚”、“恬静美好”这样的描述。不过还是希望生活大部分时间都会如此。那么我先大概讲一下我这边的情况吧。正如我在前一部分描述的如此，尽管某些细节发生了很大的改动，生活还是如同往日一样前进。更离谱的是，由于这里常年夏天的气候，连天气的转变都不明显。每一日的区别便更加地小。</p><p>　　或许你会对这边我做的科研有一点兴趣吧。这边做的工作是自然语言处理的一个小分支工作。研究的是句子间的联系。简而言之的话，语言学家基本认为大部分句子间的联系可以分为四大类：下文是上文的展开或收束、下文与上文形成反差或对比、上文与下文构成因果关系、上下文间具有时序关系。这些关系大概有句子间具有关联词和不具有关联词两类。句子间没有关键词的这一类的判断非常困难，这就是我这边的工作了。本来以为九月份可以结题，因为已经做了一段时间了。后来发现最初的设想不够有效，于是只能转变方法。后面又尝试了一两种新的想法，还是差一点。最后的思路大概在一个半月前提出，然后在一段时间的工作之后认为这个方法有效，但是距离本任务的最佳成绩有非常细微的差距。在这个情况下挣扎了很长时间，知道上一周周末终于有了突破性进展。想起来在这段时间里，好长一段时期就是有空就到实验室看样例分析句子结构，也是很辛苦了。科研这边的情况大概就是这样了。</p><p>　　然后是日语的事情。我也没想到居然自己会修日语这一门课。这确实是一门挺有意思的语言，也学到了不少东西。今天这刚考完口语，看着日语老师在我离开后在房间里面收东西。我想，这门语言在以后会以如何的形式存在在我的生活里。大概就是那一瞬间的事情，我大概意识到我的交流生活就快结束了。然后熟悉的感觉便再一次到来了。就是那种说不太清楚的难受的感觉，像是现在某些东西往往如此的平淡，总因为种种原因而在生活里消失了。在日后回忆起的时候，一种模棱两可的气息就会涌起来。像是怀疑起自己经历过的岁月是自己的还是像自己的某个人的，像是自己暂时保管着这样一份回忆，觉得这个事情居然真的发生过那样，感受到恐惧。这种恐惧或许是我生活中最执拗的情感了。发现自己不小心扯到这里来了。</p><p>　　那接着这个问题谈吧。YT 看起来是最近遇到了一些“琐碎”但是却难以消解的压抑情绪吧？既然现在不是很清楚 YT 指的是什么，那先谈谈我的吧。我之前应该也说过，自己并不是一个十分积极的人。我之前怀疑过自己有没有抑郁，我想用复旦的心理测试那里试一试，但是它的网络频繁崩溃，后来也不了了之了。我想自己如果还有那么几个真心的朋友，情况或许就不会太遭。我现在没有太怀疑这个问题，可能是我已经忘了吧，也可能是我觉得不重要吧。</p><p>　　啊啊…这后面一段我反复改了好多次，但终于没有找到很合适的东西写下来。抱歉…这一部分我可能不太能直接接下去。我想我在说下去会更多地把一个悲观的世界观展现出来，这个话题我这边先就此打住吧。可能每个人有着自己的痛苦与解脱的方式吧。说起上一次推荐的《荒原狼》，尽管很可能是误读，但我觉得最惊异还是那种态度。那种意识到人生无从寻找价值却仍然创造一种价值的态度。这样的表达不是很合理，但我想，大概就是这样了。</p><p>　　那么，我这边的情况就是这样了。很难说是一个积极的回应，不过还是希望 YT 能够把压抑或者难受吐露一些出来。说不定我只是不擅长处理我这边的。再者，不论怎么说，我都慢慢开始意识到这个时代内在的一种无奈。我感到不是说选择怎样变多，或者说生活如何充满物质、人的生活如何的空虚，而是那种使生活延展下去的动力显得越来越模糊。（一种偏激且极为悲观的看法吧）所以容我先胡乱猜测，也许某些东西，我们所有人都需要找到解决得方法。</p><p>　　回到这个话题早开始的起因吧。电影的话我真的不太能推荐出来，毕竟自己看得十分有限。小说的话，如果《荒原狼》现在还没有来得及读的话，我会再推荐一次。可能再推荐的话，我可能会给卡夫卡的《审判》吧，如果从不同于法律的角度考虑，说不定可以发现新的东西。按照之前，我还是附上推荐的音乐。这一次，在这个状态下，我可能推荐的其一是《马勒第九交响曲》。至于原因，我很难说清楚。它的张力在不同人的面前定会有不一样的感触。其二是过于有名的巴赫的《恰空舞曲》（BWV1004-5），理由同上。不过也有可能这两组都听过了吧……</p><p>　　那么，这一次先如此了。再一次为自己的不守时感到抱歉，以及希望使用电邮不会显得过于随意。最后，希望在你回信的时候，你会感到更快乐一些。</p><p>　　廙水</p><p>　　顺颂清安</p><p>作于 2019 年 11 月 12 日。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给LZ回信</title>
      <link href="/2019/06/23/essay-letter-%E7%BB%99Luzhi%E7%9A%84%E5%9B%9E%E4%BF%A1/"/>
      <url>/2019/06/23/essay-letter-%E7%BB%99Luzhi%E7%9A%84%E5%9B%9E%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Sorry, password needed.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="db1d9cb1fc9d9f93591b8e70963e65f5375c795d9be771598b7d2cb5134eb560">06ec672228af806f6ec08d793425ade0bec8dda191b67fafbc7cc886a506766d43c90893053957757ca7b34cda971242fdb387f1ffbe7ee7889944e0f89a9bc93c98cf203492c4ef62da7d8750dc3323577fb91ba42283ed553df858a3ac7745d26fef8b12c8cfe6c2f40c5f4440b554949a470049caa9a1f60731f23bedc5776819a269ab1c4b964612260166b593ce49ade2a187a6b1dd050c738f2cb689428329f7baef41bbaa200f90aab5dfa0fa36b648e4d2bb759eaa33741b705a2085fb432856b900c534ab04720a70aabc2225b840d34506c1b1856f19df0ea39f86d37a7de36e52fa30ac0699c09d7d51ffe1a9dea960bd576a3d0d84104f605ee3ea514e4e69db1aeb343481846ab3c1ecf154be1bca676afb00e72f4b243418c0145a72d04a088a478b3804ec6fba844cb7079b17250b523cf817bc6225e3d26dce3dacd03679e66c59e00b9fa13ef2442df30469ede484efe42b5edf3a11f908031549a6b1e0865d198ce3cd063ea2d3d759f202967412466fe130c5e0d8fb226c53fd017f0e1f24b806c9c5e7a2ed552613933a209be5f36ff67e7abb7ceff67f7990a61d0b6e4a3c4c7dda8dad5dcc6441b16f9593dac17401773e4875824de4ceb5692fe0d2bbf0e76eaa536689888ef1f9948b94663fbcd5df80212c11d0123e958b3cb7c83049ca5ac7019c12cfd06e6141a9a4dcb8efb8889939c62119b8f4961491dd65fdb488da61e991fb3f1073a401e85772b506691efab9a6b4b10b31f8a5be7329d371c7c5bf5d536102256ccfe821a7d5f7834e1234a99f6caf81c9ddcd42930c2195d7bc5c40726b53e41c6fc7298533f691eed4970a479535224528bf3c3d115d1904d2f479d02693ad2a290482358f3209b74900bc5d559b8781e98bd655dfae348fdfff3fd7da8806694a9f007c8de7655d304cb60b3c15582407a577e4f40e36ad5c98aee5f517b66959c14cf5b96a80a9eb0fed5c975bd3f55b8964cf08aee15137422f4b355b2a93051d091c14559f9458dac768645e21f11f664d4e8f95354ccd8d2dce3dc1e3ca442ea2a90e15f2c73ca77ff81b95a24f59fccd1818229c39ebe94ea37928a09c72faa82eb128303a31ca705b31fa1e1fbb33dd848839c6aea98023742a34bdb15542caa20cf9351c7883a3d9e04543dd6a10108b88b877d0019d12dd03082faa323ce9c2ff4e8aa517f5a6be677bf1cd899879b3178cdeebdd61a87f2278b6ba95651b24778c581f73be472896c4f177779e8cd1f29abdab539324cb6e36719ffd990c240ee56a23745e1bd5bf4a65b0e0250e29b5a0f1d3a00823ab035e27bfd77d45130f4581fb34c309460a2d868f5bafec3c562b20d70e3e6eaeed21398a98010ea5d32af65397a46e22679e90fbb3903106462235ee8a49565713c94805be61be8cadec438201cf7f327b20faa18bfae4a852ce8a4caf06acdeeb67c594de14cd8dbf4cfd2ab084e36391138b3f62ccf6dbe72f64a80676ee284460ef1cfac687e27cce87f88228c776c25009e68a1d28af94f296189d56584054feabd129a0823b3c244d209f5022c97699ff90c9184393354352358f5577d32615214f37cbccf594e072feaf3f53d13ed5d9083f3b6d681b90b047732c57af96a86d59d43ada0b022adce4b0b70e8831e9f07f18c9ea0bd8fd828542ac1502ffe51a355eb183356efe6206dbbc6164508b4d5b920fde876b7cb68663bc218396c1fb0b1dbe19315784d002090e6d83ed0e6d45d87d4de43a0bea50e4652c7a26e87f9c0dfcda65c4457a8df8b2f43c1c582c219303942a4aac78b30bfb8e8126ac992289213bd9781fcf02b4312293d9a570584835f24f11c3e93bc787d25853ab097d8b9c47dcfaf8e8490e94679f7d446b51675df22e0eece3b11e7358a5f75de02e3c07eb4f2bf2a47e1d0d61dedf49129f5900bc06ac6c1eb1adcfeea3353402c4b364a68aaa76824c75544b4d05cbc037d09f3c78c1ee97765e03d524ad9d978ec6affc06976e3eeb4c6212b624e005787269102c64d88c5c4adea16c76aa7e43d3a0ae4497e4ce234a42d8673a5c2f316036fe05b25a399963190a8f5a1df69a9fa15f2c3d8dedbafa2d5eea97e34a422dc89dd314f6740f0599a3b5b07a2f25181b04c90671fa77936ec824afefed8aa7e18f911a39209d1f12713e3f13c9692b4a6431552f0eca7570ca8ca86e5ae10ee25364d7e37a404292ec7cad46da2569322ad69326ee2b95a463448c8627efd761d0b9651ff010c8c59e2d1a1e56a4f1e537e1646376d6086901757f2192bee157c2b4b2295ef6d3a80eb0abb589df4e8aab67e708a2045cd6833b58e44a29bea7ba7ce276f19aff6b4e628d2b1cfc803945b9c924ac32ca207b0ad41c6dc43b68226f173c7062620235ef85fc5115986359249482920d45383929ead07a57026377712182c5fab77059a2501cdb6f0737f565101643106eba709a1493e8f62e3b34e96a2120f5dda493dc326136093b8a9e60b0db30a597127290724a7484f3d9cba1d4d6c9208044b05918a6c00fedc665d869dd2a2960249b0547e8ecfcd6eace332443df3c52ee3d4b43f52645545dfb7008e3c7c2789659c66e663f95fdd7654d509438c03740b258f51cb9ce84becec78cd0e9d1e139baca72ac3bac605623087704b76a462e25469511de18e131bbccfda6e6e36f6878aa3e0c3d5272c78bb73db60494af90341867cdf436471973cc56b3b8d0b5697e0e5a1645c75346f578b6a00c3110bae46931adf63c3e59f7919d109d1cf7b336462139757efec0e6ef77a47d0427b588c155eb4894b9519f15dd962fefd8bfc1ec45b5762f94518b195d18c960ea65488493e2ac4a3c688e4c3fe81270fef62ecfe13591dffd4b5e6daa81c17869de93edd89f631e1fcc56f4921891af9bb696ad9ba1acf5728e1c811c5a44f5f291ffca3859a6531ea739efb8a5dd509363dd323a7b6179705c124e0ada322a76e76cb9eee6c8784a4b98c68d0512ac561e40b5abbd40d4a726e54e15ec449ae527d295bfd8dff3b2d6d35221a16ba9ced8c452ddb21f4a5a78549fddd96f93a2d1d142aaad5f20d285401857399dba65f3b007fa7b2a6f2a6daa05ed1b82d1b21c869c35ab5cf0891a016bd324ece83ab9410420caeebd043ee1ef4e649728b408109db9bd54d2231533a64c39872d65335e0197f320a4180c7e302da2572856727b7504f93373caebd8cd3d342d88489ed711cc01cca7519a30d6d32caa205ff335ab32520aea6c1a0b3f1adb4e78e51bb7581edb988026c70f0c313fd76aa72a193b2a3c8d22c4207ab938b0dc3d524c14ab10c75c1429ce0d8fbb19268c2f0f8456f75c17e13318bb1ef8333f88831d66af1616279983c0b697b74ef2e56aceab3bc5993aff9469ba5283be7f8b300f4f25fc200795985b2858b4f1a4383cb9930acdc447b1934164c8cc18d2b4664de1485974b65248154ab061ab72bbbec721313e2bdbc935cb55e02ff7732a48f4b94de53fb51c1d56f2d0ab019170ebf19a5fd07066a97ed6d98bd4f5d7ffff779f71ddef3d3b3263d1c672049c57435974f6e1fba158d8b582af7ed7a9f71c073beacf192cdc8e979d372f77b235491deceda4777fc49766a1d9d1a9688e9939253801d195ba346042ec979f7f1aecbf907946bb98bfaf9747f5aa720edcf0ba8763fd19adca18a92607d65eb4765d6018f1d4442f80f7cbf6761dd11bd3d5c20b0269834e94ca6ad7351f83a55e3f55e49047d5a77313b146eea8f3cd728083cc33a440683d82787d677d1a1f7feb877db775685337aa7c0eea295db506b1b0b576c65a102a8cafcfa6efea1dbcc1646e055d2149689d1517b2e7677d0cdbe328306205ab41e38803dfdb449497bf525ac56e520dac912948953749636f33c30fe1977b1785dd1fd1e947cb95990f1ecbd2f2a01a724a689a06b47a51e1831368fe8c296b21df39bcd1ad8383234d7bb23b721a7856f82547f218bea9839c88c8ac628a1f84f20941f4bbaeeb15416794af364f4acf6d4a0b3f1023842112b00d936ae1725b1b87d1ad1d15595db18d79a92cbfc10faa2bb1d65dd5285162c122d7f96cbe075c066de3e1132241baad7490ac51de8e663205e18f2dc140bbfa9d8aeb7dacfc8070cb534b3144287a5180919012814aa6c53ac887760e8f88b74e24c1fb866eec5d580a9a170a3954688dca6c6f483324adad5b8a1c4184d7dfe90332beea8534571d2cf3ebf575775ddc3ce2481458e65459d106ba9a3d9a5ebb97e2d2843736a865674b03c7f230439e58b6e634e3b5092b83baa3f6a8d079ba63b20285bef9ce00fa3c2241e900d2bd78a12db712017ddf7cc67ee5c92f5748900dfca330368aec699e40ba8d3e6d39bd5b7ca065cec2faeb1edcee7ad6cb49d7f4015ebadf38348e4d17e51b662cf714c8c55f376bb2b8d7e61ba8b7bd470b3d3e3d8ee157b10d778a1adda7ee2ab119020022be15accafc40151923b5035bb5867d366f4f77a751402b543534068a4383ff443626024edabfd955b5abb68cdacca390f66753c07533d1afecbdde18333ed358ea6a02ea74b89ea67812fcf2d99e238d44f8203dc33e7f5d1703e4704d59633bbe4185647649f27d8d88ea0a4d15b29283130bffa535a23b81d1cc276a4dc12cec535ea5f2d03c122ae64100fc1ad2b8cc470bbc220961e199c63dde2960c8c1c334fdbb1b3ee3721471071e9dbca9d584b426a2f05c9750055dbf53f76fa3f6bcf69f3b452841aae1b76485474fb719eb1f2cd5334577a14f750265e222adda0e7aa6825a1e94c50954666063c1d88459d0d29efa5d6104b6304e69c7470aed416b7504996ae75b49d682b1564a7df9b7128d3920a327050955202ae3d2067665bc1be2d5b690430bad7a33d40316605fa62164634e708ec2b29ff73da536f8698174d55bdb7eb12f01c6626eaab3b5a916c63e57e555e736a6953b8f77ed7559a8ed601549b987aea511704ded4e2a99eb9e3979630def072b792cfc5aa45e5a7986a2b7606e890c73e9a812557ec29a9f44302777624fbb7108ab58ae1a1ed5ccf3c377e11e1e9bb1ddcd72ab4b82a4adcd6d4b934a86aa7851dee9152b7e1cf03bacdc151b13064f4edf3d173d8cbb11691e4f68fd6089b786e89112da11345dbc049f5f434f1474bd1c095640ec9f906b03ed55b5fa8dc5e8d24941c079ec2946298b278fc5dfd08f27612503ae86f7ec3909f6f445ee1e7c2d680923d3e9aed6d0e6441fa3456b9a1d33683b2d5befd477f9ecad4d9eebdec7b6d33920d3d7812b39e41e147b18cfc59f3d2ae6b92f7baba1f7ac9bf27065b65c8c350e1954608a71818ea5b5d7f2ee175b200a3803bbd409c8409e356dd91e50d3a24c3f21f3a52d784c67ab681df9fad016c4525f50779626a526989e3efb8d3e6d1553e058455fcfac0d202d3be3e9537550fd659f4ee7c5c7fe4d5d4750ddc406d7247b12ce922eae724fcabd4147fb1b9ea47524173a0228a7cb1234d877103135a4c0e556ba0a5184f5606698cc721c6ec572a883cef6d60d35199991119ff46c8a54406d7c963d48fc87a78dd2c4747eefb2a1de7aae88ff5c02e3f0f09a7f6e5cdd70be68550b8353e71b15c987240a2045d050cab7749202e8c696406ae9f1e3359e2c5bbcefbd52b3979faf46323eca65d789c9826c9277181de590c8cde4f5f1bfc4e040e61aefacb47a66ba70464223180ab25381ba59f14d508eaa0672f164501f0bd7d0942b510332cd8339daaca5490982cfe5504c2007bfd1069ddca4ff25eb088b6f031fd3851714f62ee8929aac7a853903213c061b543893e156e73984abc407c845bfdcd1b11402426a745a1915c1256d42856c37d6cdf20c9bc8ac7c6d7d2225b1e657cf67615cfd4b707339ecea092fe5e7a08d6cc6021c719a85f8d9eb3bb9797eccfe7841f67cb6c204552654c90ac6f9b4e8f5886ceafde59a539ecfbb976c9c897f62dec9cfd3499271a8837c110d338d3ef4fefa80f1db6e9f43c209c3157fe25af90df1a5df80306a32f471b428f6268e5433f00eddad396a29cd29e1cf0fc83ca93e52fbe813ac98f547b79cfadf861ec30266c11c8441a99bbfb412623909511f3f0fcff216d0bf7a3c6ab926ce4266495767754c659c0e3ba2a37d8f1dec87bbf01ad740699958cbfb0324845632559c50bf8ae7cc0a934c0c463534805a68211089fbdff78b398a3e617adc65f07576d41d869c0bab213e0dfc699d2d828a6da8d4c284daf6918d0d7a052a5ca30074c26b2a2c13ee76fed2228f57c7f458aad380152a0573262c35a002d1efaa630544e1451257cc6167dc863a2a143891d6d47fd0</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公开信-给YT的回信</title>
      <link href="/2019/03/03/essay-letter-%E5%85%AC%E5%BC%80%E4%BF%A1-%E7%BB%99Yuting%E7%9A%84%E5%9B%9E%E4%BF%A1/"/>
      <url>/2019/03/03/essay-letter-%E5%85%AC%E5%BC%80%E4%BF%A1-%E7%BB%99Yuting%E7%9A%84%E5%9B%9E%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-mHDkUobK" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1422978054" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>YT，</p><p>　　至于怎么称呼，居然想了好一阵子。希望这样叫不会显得尴尬？算起来，好久不见了。上一封信遗失了真是遗憾，推荐书和音乐这些只能期待有可能出现的这封信的回信了。剪纸也就没有办法了。事情是因为残缺才富有诗意的嘛，不过这也是我喜欢信这种交流方式的原因。如果是邮递的信，这种意味也就更重了一些吧。那种发出去就可能杳无音讯的东西，真是蛮有意思的，这也是信的命运吧。</p><p>　　其他的事情暂时先撂着，我尝试一下回答那三个问题吧。初次看到三个问题，以为第一个是最难的，但仔细想想是最后那一个，也不存在什么隐私之类的事啦。那我就尝试从这个最难的问题开始解决吧。</p><p>　　之所以说这个问题比较难，是觉得几个形容词两个形容词离我蛮遥远的。我查了一下“懊恼”的定义：“因委屈或愧悔而心里不自在。”给的例句是「即使被别人误解，他也并不懊恼」。遗憾的意思我倒是知道。但是这个最字就很难了。说我是一个沉闷的人倒是可以，但是这两种感情似乎离我很是遥远。怎么说呢，感觉，如果什么事情发生了，我也难得激起这样子的想法。委屈我是很难感到的，似乎也没碰到什么让我委屈的事，或者说我心大吧？至于愧悔，这个事情就更少见了。我很少后悔什么事情。至于后悔就是觉得当初应该做什么而不应该做什么之类云云，可能一瞬间会有这样的想法，但是很快就消失掉了。正如小径分岔的花园，一条道路在某个地方分叉，便构成了一个新的世界。我选择了其中一个，也就这样成为了自身；另一条道路上的怕不是我吧。所以这样子的心态让我不太产生后悔这种情绪；同时我也接受缺陷之类不完满的因素。所以遗憾的心情若要产生便更是困难了。倘若用时下流行的话来说的话，差不多就是“佛系”了吧。但是又很奇怪的，我自以为自己是一个看起来大大落落，但是还算敏感的人，不应该没有这些细微稠密的情感才是。但在仔细的思索之后，我觉得没有什么。</p><p>　　但这样子也未免会让现在的读者感到索然无味。所以说一个可能和这种心情有关系的事情吧，然而我也早就释怀了。即使曾经有过可能类似的感情，现在或也早已不在了。</p><p>　　是初中和高中时候的事。我小学六年级和中学时代都是在一个成都的私立学校里度过的，这个学校在当地挺有名的，也有很高的直升率。所以从小学一直到高中都在这个学校就读并不是什么奇怪的事。于是在这个阶段里我有很多七八年的朋友或者同学，但是在直升的过程中也会存在之前的好友分到同一个学校两个班的情况。虽然叫很多情况来说已经再好不过了，但总是叫人遗憾。于是你或许大概知道我要说什么样的故事了，但是为了避免感到无聊，请先打消自己的猜想吧。</p><p>　　其实上面的背景并没有描述完。这里再补充一些东西。我中学时代在的学校一直都有精品班这种东西，即使小学也是。我当时是小学五年级稀里糊涂地通过笔试（这是另一个诡异的事了）进入这个学校，然后进入了初中部的两个精品班中的一个。时间很快到初三了，这个时候也是决定直升的时候了。然而高中很特殊的是，他的两个精品班是两个等级，分为更优秀的和一般优秀的。既然这样说了，这个故事就更平常不过了。</p><p>　　下面可以开始正是讲这个事情了。当然是说关于我和我的好朋友的事。下面以 L 君代替他的名字吧。我们是从小学六年级开始做同学的，初中也是一个班。怎么说呢。我是那种不太外向的人，平时也喜欢孤零零的做事情（直到现在也是）。加上初中学校实行的是住宿制，然而我是走读的。所以从哪个角度都是和同学关系更疏远一点的那种，于是很容易想见我并没有太多的交心的朋友。L 君是其中的一位。前面的事情就不多说了，总之我一直感到很幸运能有 L 君这样子的朋友。非要说的话，其实已经结拜兄弟了……总之这之前的事情琐琐碎碎，就跳过吧。</p><p>　　虽然我初中很划水（我一直属于很划水的那种），但还是勉强又可以进入更好的精品班的资格。遗憾的是 L 君没有。然后，当时我说服了我的父母，我的班主任和年级组长，选择放弃进入最好的那个班的资格进入后面那个。每一个年级一共有一百来个人直升，这么多年来也没有人这样子干过。我很难说是不是因为 L 君的缘故，但是坦白来说，极大程度是因为这个。对于我这样的人，能找到一个朋友是很难的。所以这一番努力之后，也就能继续和 L 君做同学了。后来高中快要开学了，然后军训、开学。拉拉杂杂一堆。当我走到我的新教室的时候，我的初中同学及高中同学告诉我，因为我选择退出最优班，以及两三个直升的同学违背直升协议去了期中，于是通过最后在直升期间内的先导课的结业考试中的三个优秀同学升入其中。他告诉我那场考试我是考的最好的，但是我自己选择退出了，所以并没有通知我。然后我就知道了，L 君进入了最优班。这个时候，我正好看到了他，确认了这个事情。他大概给我解释了为什么没和我说这个事，然后抱歉地笑了笑。</p><p>　　事情就是这么诡异，可能其他人看来这巧合也过分了点。所以自然而然的这里会产生这个故事中应当会出现的后悔的倾向，也是我讲这个故事的原因。在那很久之后，我都觉得很难受。倒不是因为他去了另一个班，而是我在这一个班。我为他能去哪一个班而感到高兴，他可以有更多优秀的同学、获得学校更多的帮助，是真心的高兴。同时觉得自己如果当时什么也不做就好了，这样还能继续是同学。于是这样，在高一上的时间内，因为不在一个班，寝室也不在一层楼，平时难得见到面，也就上操之类的能打个照面。于是当我在为高一艺术节写班级节目的话剧剧本的时候，不免觉得遗憾。这种心情真是难以描述、更难以消解。这种心情持续了一个学期，他是知道的，但也没有说什么。</p><p>　　然后到下半学期的时候，我们高中有一个类似于团队建设的大型活动，有一个下午是户外活动。那个时候是夏天，最后是那个翻墙的活动。就是一些人作为支柱把另一些人托上高墙然后再上墙之类的。我想你也玩过。当时我们分到了一个组里面，但也没有说什么，就是坐在一起看其他人四处跑啊跳啊。然后我们就在那坐了很大一阵子。后来爬墙开始了……最后我找到 L 君的时候，白体恤上就全是泥巴脚印子了。然后紧接着的校运动会，L 君是学生会的人，自然要负责纪律啊什么东西。然后我在学校里瞎溜达，去了趟小卖部买了瓶水给他。</p><p>　　后来我大概就知道了。这件事情没有什么好遗憾的，我想。或许正是因为当时我选择下降，才会有上升的机会。我想这样子也就够了。我是一个阴沉的人，平时就喜欢翻翻杂书，周末也不会有什么交际，思想也总是混乱消极的很；然而 L 君是一个完全不一样的人，很积极、主动，在同学间也很受欢迎。我想，这样也就够了。他是一个很有意思的人，我觉得，这个机会给他比握在手里更好一点。当然，这也是瞎想，可能不论我是不是做了那个决定，他都会上升一级。但是并没有什么遗憾的，我有着一个朋友，突然自己觉得非常难受的时候可以倾诉，可以站在那里一言不发的听着自己的抱怨，或者听我平时的漫无边际的空话，我觉得已经很好了。这样看来，我稍稍远一点，他会有机会结交更多的人、认识更多的朋友、看见更多的世界。后来我甚至有点庆幸发生了这样子的事情，虽然我并没有觉得自己发挥了什么作用。但是看见他后来过得很好，我也就释怀了。</p><p>　　再后来，高一下分文理，于是又有了一次调整班级的机会。当时我的成绩出奇的好，于是没什么疑问的可以到 L 君的班级。我的班主任希望我过去，他觉得我可能在那边可能会有更好地发挥。我后来还是放弃了，呆在了原来的班级，我觉得这样就可以了。后来又陆陆续续发生了不少有意思的事情，但是整个故事差不多交代清楚了。至于我中间的心情变化，是很难用形容词之类的描述的。如果希望更真切地知道我当时的想法的话，或许可以在这些句子的构造，以及叙事的节奏里略知一二吧。所以我的懊恼就是这样，无来由的生出又消失，最后甚至这样子很完满。所以所谓这种感情，我怕我是真难得体会一次了。我自以为这一个问题我是回答了。</p><p>　　然后我试一下回答第二个吧。这个答案就相对随意了，因为我的答案自身就是随意的。这里重述一下前提是不考虑生计问题，也就是也足量但不保证丰裕的资金，我是这样理解的。如果让我选的话，如果假设我有那么一点点文学或者音乐的才能的话，我想做一个流浪歌手在各地走走。就是到处走走，先把中国走一遍，走累了就在就近的城市歇一歇，看看当地的博物馆、非遗什么的，就一间小旅馆里面写写歌，作作诗，最好的话是有个能力写一个长篇小说。然后思考一些无关紧要的琐碎问题，学习我感兴趣的科目和知识。如果在一个地方呆的厌烦了，就继续走。中国走完了就沿着中东的方向往西走，去一趟埃及，然后往上走去欧洲。把欧洲差不多都走一圈，走累的就找个民俗呆着，继续写诗写小说，学习以及游览。北欧这些地方我要多呆一会，看看北极光什么的。然后继续到处走。</p><p>　　如果能活得久一些，就走完了全球还能勉强回到中国，我差不多也就累了，就去云南贵州四川交界的那个泸沽湖里呆着看日出日落，写写旅行记录以及回忆录，把自己所见所闻都写下来。偶尔去其他城市拜会拜会老朋友。然后等待那个时刻的到来就可以了。</p><p>　　这样看来这个答案是够自私了，我没有提到自己的父母、妻儿家庭、朋友和社会事业什么的。我想平时回家看看，在家里带一些时日就可以了。家庭的话我并不想考虑，这并不是我理想生活的一部分，我是个浪荡的人，并不想连累其他的人过上这种漂泊的生活，并且我是一个习惯自由的人——看起来很是一个没责任心的人说的话了。以及朋友，或许我有提到，既然是旅行，到一个地方就拜访当地的朋友。当然并不会又很多。社会事业？这是一个很难的问题了。它本就与漂泊的方式格格不入。如果存在那么个清闲一点的工作，比如一年都某个高校里呆个三四个月讲讲课，然后其他时候就自由地到处走走、学习自己想学的东西，这样最好不过了，不过难得有这样的机会吧。如果以什么责任心或者别的来指责我，我也是会心虚的。因为在这种生活里，责任心没有什么容身之地，我也觉得苦恼。</p><p>　　这样，我觉得我的第二个问题也回答了，虽然觉得可能自己回答的不是你想听的内容？但是我尽力表达了自己的意思。倘若为这个选择遗憾的话，我也觉得遗憾，但人生就是一个稍纵即逝的东西。有形的事物终将凋亡。</p><p>　　然后我来回答一下第一个问题吧。猎人、农夫、铁匠、木匠、神职人员、外科医生、天体物理学家、小说家、桥梁工程师、幼儿园老师。这个是没有采用先后的，如果要排个先后的话，估计是农夫和猎人占首，神职人员和天体物理学家，然后是幼儿园教师和小说家，其余的话看着办吧。总之既然有十个席位，那谁先谁后就不重要了。至于原因，相当主观了。不过既然是个问题，也许可以对人的性格分个类吧？或者判断一个人的决策能力？我还是大致说一下自己的原因吧：农夫和猎人，满足或是需要，并且这两个的新环境生存能力很强，适合开荒；然后是神职人员使留下的人保有生存的希望，科学家尽量留存人类世界遗留的智慧；幼儿园老师和小说家担当教育的职责。其余的就是保证可以有屋子住，可以有好的工具使用，可以排除简单的病痛。这样就足够了。至于其他没有上榜的人，原因不一一赘述了。至此我认为这三个问题算是解决掉了。至于你是否满意，我就并不清楚了，我尽量保持真诚就可以了。</p><p>　　然后猜想着你的上一封信是有书籍推荐之类的东西。我试着也推荐一些吧，可惜最近读的书是真不多，而且很多还不令人感到满意。可能之后都会这样了，毕竟也越来越忙了。这里我还是推荐一点吧。《荒原狼》，虽然感觉你很可能读过，我还是列在了这里，对它有一种特殊的感情。也许是代入感？如果没有读过的话，请试一下吧，应当是不会失望的。音乐的话，我并不是太敢使用这种形式推荐出去。说实话，我平时惯于听的音乐都不太开朗，阴郁的小调占了大部分。欢腾的曲子也莫过于贝九了。所以我试着在这里不推荐古典乐，先推荐一个《归乡》吧。本来是火影的一个配乐，高梨康治谱曲，不太好描述，可能听了就知道了？本来不是个看动漫的人，但是火影是个例外。很难说明原因，都看了多少遍了。总觉得有一些特殊的情愫吧。虽然我没听什么歌，还是推荐一点点吧？David Bowie 的<em>Five Years</em>， Ashram 的 For My Sun 以及 Tamino 的 Habibi。这样子，你估计就知道我平时听音乐的风格了吧？</p><p>　　然后，说起这个，现在也可以反问你我这里回答的第一个（懊恼）和第二个问题（没有生存压力）啦。我也有那么一些兴趣吧。至于第三个，你肯定正经地想过了，所以我得换一个。所以，既然我这里讲了一些关于我的朋友的事，请你也稍微说一说你的朋友吧？如果可以的话？</p><p>　　最后的遗憾是不知道你的上一封信里写了一些什么。我是挺想知道的，这样子我的回信里也可以有一些评述。可惜遗失掉了。现在希望的是这一封就不要遗失吧？最后愿笃志，找到自己的那本书。这次，就这样吧。</p><p>　　顺颂清安</p><p>　　廙水</p><p>作于 2019 年 3 月 3 日。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给三弟的信</title>
      <link href="/2019/02/26/essay-letter-%E7%BB%99%E4%B8%89%E5%BC%9F%E7%9A%84%E5%8E%BB%E4%BF%A1/"/>
      <url>/2019/02/26/essay-letter-%E7%BB%99%E4%B8%89%E5%BC%9F%E7%9A%84%E5%8E%BB%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Sorry, password needed.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="72fff1012231b5871b6b561f6493b5824eadb42119e5cc17f318f25ad12eb99e">8144f56efd693c6b52f918ba14052d30e187e09e1796f5d24845830e100d850e813284e1e4f27fb7a17b520000639e3fe11260150f738dafa19c2a484a6093b37cb2e03c1826502862a66bed0f8b3f8c49d5e2f86b9b0cddb25ea358b848b5ad4df97aed595cc703b1b26db84ad561fd6013d587f975a7437844a6b3ed3d784f3c434c51b15031f7e1e5c26d8592d9452583f942a2927354ca805f30ca9f364fc6a0b8bd7118c02302471b51b3d527f623d67b8c32f5b5aed541dcefa36082e1b5ff2bd97770da695839dc0b122fa11503829790d752a69afe306c172192013ff7d42a6658b996b05ffdca27375a89eb7bff2147121c3c70af040adc69e6404e76ba1e4d147205406f9a76389fbfd1cddec5d6f5c74415fa92cfbe653e99594eb480798a30dcfd3a59fddcbf9030fc675977a60e087eb93792cc92052ea47a9535e0b9a0904518f3ea993d9f9cbaed842db5687734177b4a65ad814b8d34f420929a00013ec8a8e192d237f650557559427b42663cc0c767be55297da79253dedf25984ef14d42a6050b59ff63e537ee132e21ea63930ad5b2b6eafae608a3ee72c4e376b1232502380d0cce3f4de6cf5c16483cb17f2b001c013926638db3c0022655fa1ebb8a1772b961bfa423a65772e66530d43490a3e484e1035b4622347065f2012b2358a18d08271f781a76ff2a03b3dbdfa23ecded659cfbb2e7d8582e05de9da19d4e9a2b6b79c5baaa04a59a3711b6d50a63fd91bea23a3804bd434d654dc36b1cb6f6969917c5761802fb3922748cba4e0777a37ea6dc676e895cda4d16338a558e9df691fd14e970a2106e5fcde97e8b52e5bc2a2d33559642143263d4edb1c3fb34d87cd7d0bdf28e44ec972f1d551e49e0c4d2b337155dd5293ebea1057df285dfda2ea448efd85b121b20083878afa5cadd0b7d7a02c32c92fdc0c1a75f4ce8ee521d39309b3845e02efdbfc43e6cf9bb094e355b7236144c3e64d20dc91edc70f317e2c23f822ad2ae4b037f736ca4ccb7c7b7286cb086a633111fc238c84880163f34215f820d91d39226108134b5920f6ba6fc589f3aec8f2339b1bba540755004c488ccea1939ea36f713322a3970726ee99967ecf3748ce86851405480ebb4a0249f2533bb883417a64a9a81ef6002122820948582311c1b2378b0f33d07a5f694409447636c16ee4f40699b39b4a64563c9f862431f9c4a9ffe059a7086e93e663ba885b2b8c4b7996d48ebc406d8cad458d953bdb9ac5123b0d84aae5e0d6d649814ff737e9c20ac9c2cad4f2782b778d6ce62e9cb0402c4e15addc505b8f0c46c949cd4e931a7e49fa7056c53d535c7d148359685e8326ae010f66c5292a2d5298a55d8e05434187e70d3922dae120db5ab9ab605b07f425891100e2f01c121b92a2681a47e94bc9f320e3d6c19a14df8b990192689d0944ba60809f9f7eeef8ffd381b7db399ffa61673fffadf4d0957717c89e980e102f091e4665ceec899c4c304ae0f67875387b4e5d0e522d6fd771f0b9e25f83fd72993f34b6cad8891c492a740cb4f0c57d61c85dc53553359a21cc599ce3490fca5b312ca3af150619ebcb96908bf629056ff56a860ee548af60c12ed4e002d0ae5e98351f0ff41fbd28a4bd4f085c6a90acf20f4dc17f15f12bb9a3eccba5f92e718370f3a6e9ef7b423605eca17b744a6aa8f728a5063725a4bb5da71b4cd35b60c01f2d8ce3200ac4526977d455e9d99c904b32f4861883652e95b6a29493f0782641077e49ddd907cc7bde64d68ee0e7eac560cd0c0b5a9f36ea26a10993837eca2031bfc518b4b17230f59508a91eae6c48f24cab30386dcdd98f7ec81270840b2805f35e006b1a6b10a6831dde46aabdc060a6138b147a87f80d137b1dcafc8afba3b20a8fb2111c0a31a55f03efc9e3f3da9bb1c6f22f47d3a7055d64478722cbf5724515eeae6728e84c65883c5349172c9c71726b400e1e4ddb27b95ab3e3a63386ef4969d472cec8bba05c923721a1b39985dbc380abd6ffe3381c722b15caf58ce6b4830330c2e87a69e00dfccc9e8bf9283b28fc5c0a7fc54eff56a79dd59d8d50bbad1388a698e790e7635b096c650069b1baf2160ae26d0e963d2a6876063e5eea349910b80e35ce088fe370e0673618cb5292e5854cb6e181d82d2f61862c9a79b6e75e440fb984c3d69cb3b9dec7afc6593cc12dc1303f0f03e77496050ed06752c16fbc33fd2059ae0e4b4b4eff4dcb02586ac97184c675223f2c273e89674890368e27fe6e9f5f9503f627fa0098fd0de506efaf4498b154c0742fc2acb8da931828c56283dce3980b8d2782153c9c19e9b60fbad4d00de7b654698df8062b6d50b13d1eca2573061cd77d1e582099f713db62d0875cbd20a9c885bbb3577911df7c5adf393ff8ca7846175ef99e0341c7301b51bd5d0c70833cce7fa5e908b1b28bd14dd3eba0d7c190b97ca78377d88e42440fcf742d7bbd2763565a34c22db5c021e0e0e7c4f17b9bfac0fb3e3a454d2348ee61417a337aa4c1e899cd602bfa0b5214f8dcb3fd26b42cd298b535347823da28c06b580b1064921abafee32f4465b8a2ab864d3fe8aa48040e13fc58f853275ac9326b2d0916a5928e97def1805ed14d465165a5f2ef853bd477440b41df63f0cc6528687f1db0e115ff5cea27f71bc09dbac26655732272a7e6688c18c7063b774a08933193f3b693c5f7846ee5ebf6c5d37284c99e582d1f28cc694852eb4d1fcdf197cb0ccb8cee63e09d6f38b7c9123f3a863c827c2ee91f88959f51f91f4770f983dd2904708045bed05d5313deed0889f392c0995e884704a030f4bf8a84859a78711882cfdbeb2cb15ae88894c51f3ec4eb52e0cc39286468a22c02198df8f02d7b5d772eb34edfb4aa08653be3619adff1e3f97bf67b5cce38f8aa2bf10eea4f1bd0468f792134661908c3555292c4c54d83eec740978ed5697b183801e0a352afaf3e0a978440f010b39602a055d2085c2718dd6458b50ae5803120d81fb5ff084e9f5bc0af001c6ec1316047a3fd14da3d705023072527cc283e6fb8dc64bd2479310aa989304ddc09a8776d754e1e824e233c9fb1a8cbf7ea31d6ddac6e0c3b261c29b7ec5f47055b3755ae11c01a56e4f60a8da497bff1da73972da9f9f49bdbc372812b36f88417ac9eb3980ba9da70ca3136a6e1d2ddcfa9d2c63f7fdc2cdcb3f3a7109895fe219c0b9c24a63c8f38730d3036ccb2482b3ac55ed2258b644e0ea3bfa4265dc805a02b7a106c3f97c750126fec858da6eb9cc92e6ebd1e9182247806ac9bce701bc74dbaf6993c7c6f429531a48ec69295cd87a14d95f059931d778eb3d483d1a11898e9e723e9badbe56cef843d0f242722d10f75123c379716d3f7a719e3ae924dc4781126095d537849f141300674f2c6b9a252f2865d6f63b2b37f393eeebbe773b285804276e65299345779066b60352ec21dea66b7569db01a07916575190f46afc98d2007e8d7dbd5395d7ed30cd8db6d6570b91cecd11f70619fe284166bf08689eb088993fc4d9d2f049110c08568c90c413f369a079029504787fdb395336f615d21dc16649224d7182232deb8bc085e765b2fcec05a2528cb996c9a642102efd8e353bc946ad5e9087d022c1035b5cf5ded739809b2f2dec84d0cadd110da7f10af46fa44619e2c07ef95bb9aba2040f26d48259302514ecf52340bad346956785ee6af96618e2c7cdfacd89dc3017c35c0b7556330d7e68e0930e9abf428764877fc33a4561dc28595dc8363408cefc13c9b48d426ee8249551663bfea11828d44c7db529e965481972119460ea143f0ed93f2b3d164120b0cbddfa0b964e5a6cfbdf0b9e22eed7f736e7ad19366afe8f5cadbcbfadcf2e9a5847ed4b52af3466eefd419db30667fd87a82fe411c7fa2a58be42eee3818bc402b2c37ea0be29e680d09834d7943d8de6875b57b178c9f961e4db9094d19eeb27102344a1e17a76f1e8eae1599a5704f1ea015fb7cac628206abc3deeff2a57a2aa20cf6b407b6b4b04d09f3f848af0605fb047997a1ca5a6848c6ad37670e16520dbe17ec5b313ff3c631f0c1a50104501bc954e2930ded98086a09aa29b418631b42ee3d860b41355a24e8feb73ae674090d04b4f6313c31e9248458a2941dfc2715d000b9b406f4b9c75ad2e64b6452a1de572d6609204087a55be519ff3d5d1e4ba3ef47e9b504689876b56259e4f9a74a2141a86592ab091534ba7817e2fe60cab840e024f57d1d8660605eab9e0f460e2321844ef00990f309f9791494893727af9e161c557ef9c58e7095f2f585dd90dc7770e33164fc65f5308b0ec1dd638fac80b756e41c083f093713b3f5b8e3f1874b687d13d7c2737719655077828485bee15fe1773deac4f767b05487a896c3b9c414850bcd3488dd8cdd1ecab442c4f069cba3a86d1db71dc161764546510d1bc997355449b939e9fac808ff0959044665699908cf1888672c369c022409940cf540dc17fd28158a03d9a79b9be637de192f42e59293f9243b3614bee58c10d290766d08d0a5376c90d30089afdc540320e5b3dceb1473602ee53157dba8f1ce5ee66de54b4970b7eac1940b92ca143a5a02bafba9297f4c0c04912d6a202be56e5328025ee8813b3af5ae00765c53b217d4dcaacaa8f239419f26c4410152ea9a5b2caf3edeb5eb5f462a462c36d430cd5056bd35116986888d67359d8b9b18eaf5993fb02d893d02828dae7594d16f1496f123b599b2c1bf5e35723341d04230b9ac8a3e826448ff38465f38186030bd4b40131230e3a31571841af988fab5dc6f934b52101471f4b68d4a0b95e5887ccac64eca63c7e7e5d39f12dc47c0dc70dfa46a072e9024c20e89da4fed4a6180cfa301f1f34794ed662c09e106ad4ccdd20ce29e762b87cefc7a2393ae6ecce17cc07d083e8472ec159a2edf1a1b4946907599e832871663b57ba998bac33c9428542afd6c68c4e9ce0ab7cbc010faa50e2f438fda3068e8bce228285ebbcb45548242be301a8ba277eac6867b4d98d8ece9d2437fc738ab43371aae345b7123eea1264ab11dd0ebf5e69b64a6b033a782b0969aad248ab41abb0465902b667110bc7a1fea17147dc0699e0c501dfc015721bf7fd0c7cb54335992f69a0062908482c1630da7118dcbb6697025b913997a2dc9118e4aacbd61b6a1a8257897e7abade21aa911a66a2b9afbdbf340f9d6d9939862cbb199299df4aec5fb52b56ac40c645513e455e633218ed3e3ed1afa5057952cae0a6df1a6821f8c865607802b18abc06b78cd9fc560a4bfb150dc1ca75cd8e389c25ed1010cce64e04a82adf56a94ba8da76bda18e18faf5b32b16758ee97ddbcf3696fd6f01e042c16d7e9510417532f1c5bc19d21f3bbab9bad37b38c8e445bdeb8794ca63029ee1f6ba7fe56302702701343a1029a757bd57432065f16e6543e9b4d313adbbab4ca5edba8d2b69c0a0075cc247b0cbd20cb98bc69e7f9b3c3b7c717d2f2f5dad2811419aa0336224361aece6f1e031296f8e654d7210d5b9ba3535db58e8b9049a962d200005929e9c64cf8410e448b8c596b00ae92d3be12badcd1b3471b7eec4e0f7b6b445c26a02649ff61070a231aea90b0650715d543be4e8797b8a5a93661662e7becd0226154d86b4cfe1e88dcd0d231a672675157e59ba7f6fdfbf3d41eeed0362f2e2f1e079818b00db33708fa16f1fc5c59b630686165a9d1d7f29b0280e6d68b4c44ebf0ef89f80bada80f25b6f86f483fdcdbaa830372780b42b454776dd58bf6de8a65b38c8365485d163fd5a3c78f16e46f8d9bb9f002d25e2f3e677cd4bc1e7e4b6111c27d28c331e1771164583f13e1582e3c5b9fe684c9196b254b68dd4ea9ac7bb6933f195f227aa451ab7f0cc10ed97a4916a55a4cb22ee8bf733c80ef3ab6d7d69ec1b8350183ce127901d4541cb80b4990042a48be648a32aff01875e4dc8ca1180967788fba407852ae690c6d192aa672d7f93fbc9470f55ce0b526cf04b3ddb7a37624de08347f762679e21e9cfa42cf53d86ae230c7525ff8dedfa372aa626b76d05926441a70eada8491959f98bc571010b8046d1325f384f3a6e08b9e4d100e05bd4f6f676c8d5e6f2fe072ff415e497c41c590ca1fe409123f09bd811d405453294ee5ab98a7249eeece58cbf5d38d9008d82062ffd441f4df3a576b4a04f9928da35ea0d191e5b623c70dcffd2dcfd688f3ccb08bb996aa85265d084fe360b05388f715426c5ca3ad41bacebbed86e659aa4539a368b9fc4e13de4d6631840e98fa841d5eb84649a1bd6c427e1af22a494811338bcd578ebb08ed725bdf31cb53f349e5ea7b0c9ceec8a7b8712f3e9b75bdc15bc7a04c6cc046d1a03829372c19641728229fe4326b71dc08c3facfd8c2e08cfe8bf5071cfc60717cc2a93c69ceebdb4d805ca37b26e023e6cf58caa227dcd4c53beed4d9524d159e5be8737d9611977fd739768a7a21b4ea279d68f944e79207786300991faa4a5b7f793dea1f3b46d917731251c34965796c37e56e7f74df72405eb47b8ab481fb944e7dfaf5e630c56e180b9756c9d4cfc8c9461be595df153ffcc78f1f7f3772e79a406891e1d66a7dfce7e0ec748ac05c8f03961e7c184f35fe4ee36f81b08e58b140a09d834089711d6bc4e71f5761cc5e69c399629fb31bd0f7b2cf5dc99c5d166bd8e297d74e16334046774bfdb6cc2b403fee4ed7db0ae063ec1a905886229c0d8c52e9f8014dd9c661702d77b714ebc5cf220f24f7905e55bc40f0c6af2826a2c21efbe50bda87b0f24ef4cc52f80931df4eddc5396ace09758d89ab79391d9f6a00566ffcff0e2433da340fbe923ebc194be690c296e57b2d08c221a64a763071c3979f221ee815d94af2b0317fe015341ed2e955fd869be42a379b8a5eef2ee72ae6d7d0b6341f4697804cb6e27287990bfb4fa33a55e7ade5346bcc95d3d91b32bfecec1a4a4ace5e4eb26912235a2811d8cab037a23ea9d28be1bc3e8502cf8b9f127cf22ebba379b84ca139e8b8b27e0e2e0a8641e70bf65cb2c0128b30cc1598bb2713e2ecb0afff97538dc9d0e86b7e0681aa6c2182d3dcf5887e0b3fdc611fc5297a8bd5e46e8c037c6f58ed09a7a9396d90c505c8ad51462ebb3eba1f1bca9bac79e1eb3c160836c8619a1e0976264094e3f4349887becd8abb6b41d1a285800609fd2d34b4944e83e36df8ad1672be3ca0344826ec0ec30cbe0ad2ecc5f0034ac2fad9d37354a0da6569964b37d6a44b771188e62e814e75ecc494491139a9499a08a628164dc7a520da830ae9ff46ce8702cb737c6c70b0eb5469328c06069689af4c89d6e24f15b3a820ae88b7292ac4426733c4b13fc7d2cad7b03450e862dc4185d28fc39af8da8ffe040be361aeb88f321fe2cf9110885f57a8bb7505479f18774b26a79f2cb8e5b05c402311b18ebe86aaa46a9fffd2f509a90af2f3ecdfc82c3b3f8b7d58ee509ae1e27c05be1cf016e09409d1e7b33aa2b453a634bc7dacd419aa58e74aaeb0bbc31d623e73d2e0816b7cfa241c9a23ee1551ee2f369cf3782981b2140513d76f92a93c6a160954ea1261e16e5cf867e0eb7d2333375cac0220d655a86761b3b271a1bd63ccb226c5ffd19934fc9ddb62ea7da788c7d26a3be24d7e54b1b2b1dc4f43c9bf61251ef07f188acc7910bc078a81b5d2b1268fe8e06ddb07c8abaa932a9a13a0cee5d192bf5b82b64503b6127732870d11688baa3d646a0c49b88216ac23c36c18366d3cf1671f0b188169664282642cdc9ef1fdaa5a824f0968a97834b709f4306d96def41b7dbf50a4b9c014a7d7f75a0e2a5b230c105ce45337ed715519229a84b5e7f7651b8465fb84c1a6854f2ca6b7ec67fb8987c0391c999a43bcabec7f45ce1e4ef7d9413b3ec5392d013d2a42b80fb625697163c52cd887aa541f94da6925dbad48ded8a758a5590ed70cfcbfae96e856b244269f28722c75d8d93137c577f5aa3b03931b1d1317d5a565b40eb7775f38debfbea18687436fc8818f2c2dbc108f99fc90e8930cea7ca62524b2cb6c5558791722fc0a21f48d9c14107cb4251c27ae3a6b090ef3c89c338789c46417032b909d8619873e9c1ec3a84610d92432112b1017374c296759b561c77e2b672201d34bc42e00799ab7cfc70b104386b23b939b5bddfe53f51627ef742bd9d395342cd96a09b5d8041e5f879c64523e3ef61ea20b864c230ce04a6467aea521624685029c62b541479ada7290791a5d7897cc4fa77753f08c16623d3cbbd6132d349a7ce4749e90efa9064181777630226b080798085e760c3a89bd2c4523eb71d4063229a478d6ab87c360e27005e3444ad8327f7481331ae7b60fb6fbb0ea6d8244cb4817e1ece158e43c36a42b6c0ff94745f4f47d67dd9d44b11db3da207514fda7aab9babaefbeab1aae2974f5de25f0aecefc73147621e04738fe923018978710573a39f7a1c7cc9f853802792f03915c6ef06da8c6cc41e5f50b84f9a2b5d67e3a33d2b452b9598e78df8bd626969ca5c845ff6bd47c6367d2c43ed9580f999cabd42bc198feb6db59ab93cac74337812d990db75898f4d25e54dc4bdfd8135f709c26cb6cb537d054483cd326b40416cae5279c6d68acca28d0308385c403c2a581049965203b16628b4fc3eaf0516151d613f0e5607890d40db5d1dc97c37f475eb1b54fdc9d2c0673524bf281b9b3aae64ca8f93f3773ca55f95ba05ce62b94ba03e8ce1fad48968744279c89d9a32ea3cf04de30e6461339d46d2709f80602b382f69872c2afd1790eba663ead49cf59d8ba05f993a92f6adac58e7344f3fb81014d1e55ede7f1e4b193380338ea8001d5c662442623d1d7ed01b49b0404ac30959f8207f7a43a2353c2bae3f672eab59bde59fbae1b467149df9e7161fbd15a70bf7d48d72adbd38fd075f4d260ec0c1274feda2985804c2cdfe2ddf068b5628135b766ba53d163aaedcb445efedde23427ec7aca1b2632fc11c168eeb13bab726528dfb94f8ef2bf582f427c3c746125f9b57a05e7756e11b2ccfa06ed176323e344def7640f712a16cc8c297f7a2de15a7d96233ef5f5da3f6071aa8b1589f4fb5681bc7d0263a05b5aab18f9db46be38cac44f8a135fbae5ddc15c70022ca9c2367dc7d5efdc050d80602816b521137da83d75111417941d45445809bfa8a7da866112afd3d675246f17b1f0b5c9aebb2b99b2393169cd0c3a14a4b1864982be70366f7b3f35efd02a7e74e868debe26dff7626065035f8478771f19588cfcf46da8f9de1a71b60caf5f338dbddb643e220a0d960910cbad74c5f9355e11c20c228d1cdd66223db48f23a5d922ec2552d83d7ac6bd8910e2b4a059d108572f94b43420731dc4db9fcb98ea5f824a7191474e9635d305b58d33ab717216dfeb5633af6ef250b458472ae31d259ce3e914c220d2b72b46c91e8d1eb01cb135a380da399afb685c73f3b4c82f9ed2960c98b7509bbc8c97043e4f3bcba39a41075ed12f2cdbe6fd4bf81853accc736933efccda9039ad74cff44cf5294cf524a0a1d54360b2c4e5442b4855dd831c7865878c6230e020aedae02625a9738f164fe41418e0caac2924e390bf796c3287696dcfd7847722d044118e5618d331b23be477a60a9eb8d3118d7826e7b251660438d5f88b1e45e3ade4041bcff933eaf811679c43515329852246f22775c0af9219ec0d0340fd82b213672e51b4354ed4efc066757cbd835a6884f7966a4cc9b077a527e383bfbcfa648165bcff1e475fa98dfb3c9d372effe6be4ac2b4f3cd1dfe3aece1729a55a80e986a166cc692a28e5f25d617c666672c7f1857daa0221a13286104f3a08d69ae405c9d1b9fba020f27aab7e40ccf3ae7b2e8b5b2cfa1b300f657a798d5aaec9654ee85fe9341b70772c812b0bf532bd79e42fa66d3c5c22a8a7e98c7f2dcb6afaee37f40b0721036cbb575e3a39cc07189f5cc068202b6e71fcea929244bfa9cd5a4f2cdffa66a4f6c27a13ab8832fbf34a9faf150bb0e0c44b478af2bf4ed66076cd281789dd1cc11280c3c2777e74f0b1bb3ad3d22eb2e53470f883c72009aa1462d1cd46cca6d75bb16b8638152c23023f4e2c2c6910f89c7b6665a47ce7e3edf012791df0d00ea9bf248d59dabe101780d15b199d1270a460d19836e2c1cf7c6248fe0f3748282eb19935a58bb908df63d4a0e0c112bdf21af024490d302bc08e8a45c7d84edaf5e60c095fe3f4f19fd6ee973bde1bda704300d1cd82cf59d69c5f6c8b2faffda63d0756c18d2b80d567daa6192825ddea43ac7c59a5c8e5c951baf2e9e00fa952ea7f48e0bfe9bdd8e668853f0fd7aba4a42a711d5fac4841fe98796f75f14d4da8c6efc5f64e98f707eba6afbe4e3aead74ad9efdf142f7d65c5147510e701225ca5737c0b97b19c11a138658cc5ea81034753437a3da08f5295f61511e792606e083232aa421050ba70bdb98c9ecf1199e0ec24531394a09bfc9428505873cfbb4710c3c9f8efda1e70cb9c81949ad9ea1f65b8e222058ca28d282c56f2cb81f8da1f5b63a9e6df116dc77797ff955ba63f77c04dc91e5262778dee90c5e5acca5647a8ecfbce0fae5648e8b518d34c3e360d2f796889b84b137db4dfdc2144271bac7dfd105e62caf1bc576530503dc8787947d2e7c71cd4b035472426bb5727fe7b139a5782389ad2147cbcc4328a46a2d14cfef3db719fa0075b5414217782ba427c077dfb406247fb8a2c47865b0cbc8d26be08b9b02493d49f050a7a2c859b696d10e5fb00c47441b0efb779109dd101b33717dee34a4f10cc7981d4cd32c9be1bf85b78298d95b3c2a7426269e367090e2f99903d9e2ec820857b7152e7ea4858a62b21ec40f92d84c17fe2485af754e5801dd7d050e008bd87575c9e3af3e22ca54dbb86174cf1285ab093d65b1d8f946d1a6a596dd4934bf8e68421af1172484eafb47f48d28ea8171b062cc56bbd42d9004e35513865a70ebb923bf97db229b3eb6d20e0b80fc9bc2dd7219836f23bd8530e4699d1e4e24a880d7b4e7e90d6b77849ad625de710387a0ad622bf0fdeecb0eb3a559f9b0b223fa6de363ad50fb93075adfa00bd6b22c2929b3e0d2127b475e477c25da86dfb127103fd8334b42b3f2970936ab0ae4eab2cdef066ab2d4760e5001f5d0ec3a4b76b341e0162810109fbb77e4487aca92d7e877d9cda613befa38d437ee10fa1b25eaad22cd9ea2e8d66b4c003ce0f77b357e9c13c28222c912698537363543074ef0526e40d572b2c28190cdc9ea1821a54cb0b57d30c29b9b66afd8441ba3735fa8e932bfe5fa7faa303b73772a63973e3286f3d3de01fbe3a54503652c41092d4756d9eb11ce5512375a0e5d0d4209cd5d960c4f016fea08d369ee3576b6e8749a1a8542281caba608e7f603d058f38969e59252d67fc7c2c9dbd0012e9456e56a9a9d0a232cfa808a2da936756133296c76721cea6b6f134ed38dac84d65520ea58b3bd13a00ad61248aae270933f81ee2927644fa35ebb07a99791c5240727a0ef45d4df3133ed25975b3e87304b9340735c416f4e3bd5f228c029186fb61e720cfc18351a9562fe2e5a2a79389d64ffd42dc0e1d6c1d8723ac54cd2c2205ab71a5490391a3cbee2bbf5e2231f17e629cf295f8fcf21e9f181de4107d57f32ac82b4e966d3708fdd57e742057e11ae958a322721b8e35e14d4d7c54e776797f7ad913294f6c1d952f6f28a2467a5d8e4319f57edad169c02a84ef6c57f2a760480c436716fe1f3d679818498e6468eb660bbf34e10ffe74c0cd78ab872dd55d97bc3ca735a79d1282c075670cba3a031c98a297084489b9c4774d822cc90f20deb132276f245ffb0da638e2d060dc5aa7a85ec5dad4476b0d18b35239d95c3fb2048804050893c2544f4ea797c84267520bc6462bbd9fd32e9b6cc02271f5d3fbe8705db98369ed0454176aeeab835842a7f25da2f3749f74c1ca68d6ec57213ccaac28db12d2d77df6f53dd91dc1e061fe003a9123e5478f909aea6ef276f202439893436175e9005302bcd9469706250e7000dec344f3e38894fd9723cce76c22e6bb927dc32a835dfb9963f23d1ae4346568ed7e308278294d8ca0d24f2b50f3f2458ef7aabd72b3818f09a1ffbb7d6f0b1c7465ef783c06202cfbab843e0f1331011c0ad0da1e1114cfa2b307cda6eebeb99e669f322b0b046d3bcf06b74f7733db1626382b3bccfe327d0f127fb783273291f3b6a3fe3deb8f73769071b5ad91628fab46b6f8c4220a8c1c8772d5f7cba0da241700efe327cb2cd5dcf2d693be2b085bfc057d926384a06bc92e8f39f294b3d6875b3048b60c62f080313e8f1ebed72017ca0295b79b5151aab42ccef0c91b386089a1508af426d5ef6ab2d5b01bc43b076543ee3581e8347770999cdb03d6cec3e1e521926a5c3589f0ed784450e58f31da8b7eeee59241d2dc418d2a145bda20659919da1ede927d8b1aa590cf716b1692ab051443656723ee528b4288a43b772ffc67a7cb990dfa31dced34a70ec7c569b4ab5c203d2ae05eb54fef73a431e8160bafebef4d1c53f22a175f000c0478df89773b2ca87ce2bcb9b9fe5dfb0ededccd73e8d08d39f568049d1b3c7b10ef29170e1e5e0b1b7494e376018fe17684be9139e7c7d8cc3d220ae9d3e5004b7998a5c7fac3259ca3c72611a65b659a474d2224eb754a8a3811a65718618075bfedaea0b34220333d16fa73903aab791a32a0aebedc322dd8cdeed5c59c12e7cdab42521fc2596721510e93ad749d2eeaf2ab19d71982dd5f8518abc205c8bf4a961195c061327762bda4f44c568a632b5a2027b1c004b29e50d06dd0e874b29b320472b5b351f620bfac1ae017ca6248ff361c19b55879ab7d032d3ac7bdbb2badbbf7f84c788c4a0bbfd3680abd95242061365fcc257508b4ef383fd1e561fbd98e5ef7a19d92fc4b4c4c74a7e158c659fd7470478e9a50fa0a48b8fd7a8447721c9357397dcf2da4141a40c6ae28be0a62b30adc6ef94bf9af842d9a514f02c1321cf1274ab6a46af8d740ec5811199b8e6559bf853bcc71a3c43323e6da4051251e01c671381ff0df18b351cf4bc786f936c88ede687955bf7e89410b9c71be3e1373983c1b135d61736a5964ff2b546866c3d97365b8a5a007a0153c8b2cc80f83c77ba4bbb611fa4941ea11bbd54239dd001d06a0d5eabc1bb3ad41871e0d241f35c230c6fea29f9e6d587b1959f98f02e4dab521b6d6350cfebae33613d7e3aeff4c7005f0dd44bd195cdbcac7581a1d16903f6b0a02c1eb16266ce7c97b7532f0859463fa40f7e9ad37828294c1964d23bb2706922788501dc244310495c42087e3d526658fa4e60ba5f140e694f1a6e8e4d98996c625eed8f27b2a9152989ddce5810363414f3a590893e742670865db46bc1048aef46b6282c3b2f3f39a579458c97afc12597d27c72fa2f947bf8de47f421a33fbc6582864bc317604eb28155ba68825546661e7b79c1d2a01aa936ef340534497834fbec9f1bf843b87579aa3bd581da9b716d6245fcd99bb8ac725519a0645dd0f5a34a9b831124023f76a001a8f78aca8d3a0cddf6c0f3a7c7002f2863f13bf5cf1b5924f7c4c139254965a173bbdb3d48a46e5a34ccdf0babc3cd94ae60289fa99145520d377a29fb41c9a502dd1234b177cdc4cc874aba0e98300a7712bc44d66086584b197bea606b8a42c1a2cff5222eee9b536147f21f8cd96cea8abff98494ce2ba5ea2d76254bcc4bc20f22e525ee9339bac957dfdc9e3953fea51943df9c4b37b0fdaee127480885fc036de88f0ea776c329f6c85deb462a54342483406bb58ae7e59251cec722e0594cae1905b52dde493831092f5e23a4ded1a4b585e19a2b6ee93c442bc700aa17736817eb679b77b8e173cb7abdf39d9a0a28fa7d148ddd61ba805355aaa4eae7ce186fd3c3dff9a9c3974a8f135ce3fddadf23f25f8228fe4a9153e2652969ac4bf54e8c9aa8c4111b1ca7d977bc64e2c84155e4f3bea081f0bab29f5c1dbcfc713e29de32a0c96e40bb16e651e7defd812af5d5371065f1924bee239945f508334da45a3db0c0663d0a212f456d0ac39e76140a8981cee072e8f47868b8661448ae97beb6bc9d02865883da9d03b2ab23aa9c831aed52ebbe32e902b8531ba83a13ba17479e32af05bc2ac9856c1806acd104def8a49b21a0955d29e9c27a7decbe42bfb73b7a88ca21df0a40c43803d8027abc9ded2a89b63ca03007162cd2d3b9a2c2813861379702aaec9cea5be3c1aa2261de6f07f3a5b91a0ab4ceca1ad4bc85e785be31182ca326c58091d04fc087fb5b27f98e0f3cb7dac15f8c07a85d0a3b30eea8d395ed6b0c5a170b00f4dbf98ce4889ee9620351c8e30940f13aaf6f69dbc773841d0b121e4d3d3fa52708ccbc782d5bce5364a586fc7d1d7a9a2546ad227e759db9ef128a01eac478791deb529a972ef0913f8dc2dd357db38c8a004fd70111ac7badb6ddd27c30fc481e3725d12cc68e19986aae5f891e5a2e0f46f438c077fc6a874e4b49f72f2b2018a1425fff3c9268714e18d17e7cf927ca99815c1b218166a0705acf9f91dd5355514125ecefadb7356be75709ecd03e15cdf9a63f3be3e4c6e698dbe2ffa6983b6b99c32fae1bb04e75a9b30ac01b95cb1e147a5c9789129a18abffa1bccb6b24982f1fcbf00b30ab77e588c10796f814580ee62f88d04c499b0ed0070ced3852d40cfb9d9d9244b2b88b56557995122829446bb4b57a60f35a6dbed84ab1d1ca462e649df81b5e608e0b247991c640b98d613aed925693b8c64acac0e5425259a44622320e65f748886d1bd6c3a7f0d3828484d1e2262e9746d8c988c1569ffbf12cdf6a8e4ceff03e51ccf90fc3cf181b056e09c590353d2</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>落日记</title>
      <link href="/2019/02/17/essay-%E8%90%BD%E6%97%A5%E8%AE%B0/"/>
      <url>/2019/02/17/essay-%E8%90%BD%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-avMGhzwY" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="17685905" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>应邀写的一篇稀里糊涂的日记，权当是好玩吧。写作的时间已经不可追溯了，大概是在大一下开学的时候。粗粗地记录了一下报道的事情。</p><a id="more"></a><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>&#160; &#160; &#160; &#160;太阳本来升的高高的，但是上海根本看不见。地上带有一些雨的印子。“明天是要下雨。”WU 君看着地上约 10 厘米的蚯蚓这么说。他们热乎的谈着篮球，什么三分啦，全明星啦。“这个投篮大赛是真的没意思”。F 君及 H 君聊得很是投机。我刚刚想的那一段是什么曲子里的来着？第几乐章？“有人可以从中线投到篮筐的吗？”“在空中连续投三个栏是什么意思”。表述不对。过了正大体育馆的门，然后是 WU 君寝室的门，然后是 C 君寝室的岔口。每周必有的罗森晚宴。哈，和 WU 君及 C 君都谈过的 2 的根号二次方的故事。“去年的特别好看……”，谁？然而名字我已经记不到了。然后是 H 君的寝室门口。“你们拐一下吧，能多聊一会。”“那能从中场投到篮框是真的厉害。”H 君已经离开了讨论。“是，NBA 的运动员和我们不是一个等级的。”“你系统是多少级的。”出寝室的时候 F 君如此问。　</p><p>　　“哎？你这么早到啦？”“还好吧。”出去吃早餐的时候刚刚碰见 F 君。“W 先生仍未出现……”然后去把教材买了。昨天溜达的太久，从这里到光华楼，再回来。于是我忘了。一定记着，不然教材会没有的。然而知识的门紧闭着是在早餐之后被发觉的。昨天我疑心食堂换了师傅，我该和 C 君说一下，毕竟是有趣的事。C 君还没到，C 君报到怎么办？不，等我先检验一下。于是和昨天的内容一样。蛋饼同昨日一般软，肉包却已是很久以前的味道。也许师傅换了一半，也许改良了一下，也许时日已长。其实应当买生煎的，好久没吃过了。生煎那里没有豆浆，不，不要排两次队。Lament, lethal…vital?不，不对。Nomadic, romantic。到我了。昨天师傅说点包子请指明种类。“肉包。”L 君提到的日记的事情，我应该用什么东西记一下？不然就忘完了嘛。馅泛黑色，酱油依然多，是上学期的 genre。看着豆浆盖里的泡泡。我也许拿了一批豆浆的最后一杯，豆浆也许是最少的。我昨天应当把第十章看完，然而还有一本书。对，我的书该还了。先还了再借出来。嗯！是恰空，我收藏过没有：没有，演奏者：不明。那上面写着巴赫。但是《韦洛克》不需要了。等会记着去买教材。对，是要记下来，我昨天什么没买齐来着。手机掏出来。洗发露……我没和 F 君说我昨天借用了一下，但是应该干了。和燕麦片。走吧，看看教材。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>&#160; &#160; &#160; &#160;今天应当是没有太阳了，“你报道去吗？”“不是的，买教材，你去不去买教材？”“你等我一会。”“一会是多久？”“十分钟。”“好。”手上有个扳手，刚刚做什么去了来着？不会借个扳手这么久的。那回去吧。合着节奏的敲击声的声音，为什么阿尔蒂夫尼的回礼是放屁显得费解。“扳手比锤子好用。”“不会吧？”“他还可以把弯的钉子扳正。”“好吧。”他的床板现在看起来结实了。等等，我要还书。让我先把书放进包里。我缺哪几本书？模电是紫色的。“你们什么班的？”“找模电。”我正找不到来着。那里，果然紫的。还有一本 C++的书。外面没有了，里面有几本，绝版了。绝版了为什么还当教材，有老师喜欢。果然有两本，红色的。我想起了《C++ primer》。一共 100.8.“好，支付宝在哪里？”哦，看见了，两毛钱。支付在哪里？哦，看见了，另一个码。“有红包可以领”老板说着，“72”。为什么便宜一点？对，他模电的辅导书没拿。帮他拿一本，多少钱来着？50.不是五折。“支付宝到账一佰……”。　　</p><p>　　“元宵节快乐哈，回去就给你打钱，[笑脸]。”“你这个寒假都听了些什么？”“有一首恰空特别好，维塔利的。”“喔喔，我知道，我听了一个寒假的平均律。”我看着手里的手机屏幕亮了又灭，F 君应该是开始睡午觉了，我该不该提醒一下？不了，Z 君挺高兴的样子。我们愉快地谈起赋格，我突然想起刚看完的第十章。“我给你看一个有趣的东西。”我搜索着《尤利西斯的注释》，并不在书架上，在书包里。啊，我忘记还书了，算了，明天去。我把书拎出来给 Z 君看，Z 君兴味盎然。于是平均率的声音从 Z 君的手机里传出来。于是 Strauss.R 的曲子从我的手机里传出来。于是莫钢的声音从 Z 君的手机里传出来。于是勋伯格月光下的比埃罗从我的手机里传出来。于是萨蒂某我不知道的曲子从 Z 君的手机里传出来。于是萨拉萨蒂的流浪者之歌从我的手机里传出来。“揉弦和颤音有什么区别？是手用的不一样吗？”我不知道，我可以查查。“帮我把琴拿过来吧，我正好在练揉弦。”我两天多没练琴了。上学期甚至更长。“那我先回去了。”“好”。F 君呼吸的声音涌进之后的沉默。我把琴放了回去。　　</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>&#160; &#160; &#160; &#160;“你去报道了吗？08:07”“没，在超市买东西，要帮忙带东西吗”“带两瓶矿泉水吧”“那你马上回来再去报道？”“是”“报道不是还早吗”“OK 那我等你一块吧”“嗯”。“GPA Tool 为什么已经下不了了 18:33”WU 君。等会，等会再回复，直接发给他。我的日记才开头。“[分享]各 DBG 简评 18:19”LY 君。等会，等会再回复他，他怕不是掉进了这个坑。“您的快递已签收。”　　</p><p>　　他好像开始研究多人游戏的打法了。我真的想看会书，去报到以前的那一章的最后几道题没有做出来。“我这个月要吃土了。”“我已经把我的女朋友拉进坑了。”不行，三缺一。“我现在正在给我初中的同学安利。”我这个月要吃土了……　　</p><p>　　“我系统是 7.0.0 的，三星系统升级一向比较保守，你应该是 8.0.0 的。”“我看下。”蓝厂的 apex，真的可怕。“你知不知道知乎被下架了？”拿进来外卖的 F 君如此问。“不知道。”“据说是讨论任期的事情。”“真是可怕……”耳机重新戴上。是莫扎特的小步舞曲？不是，是三重奏。“你知不知道 MWC2018 大会上 vivo 的 APEX？845，真正全面屏，连前置摄像头都没有，甚至有 HIFI 芯片……”于是我们走到了食堂。其实我想吃全家的。出门时我如是想，但毕竟时间还长。走到了难以抉择的三岔路口。“中午吃什么？”“我随便。”于是我迈上了右转的道路。“二楼吧。”于是我收敛了我的腿，迈上了上升的阶梯。阳光普照炒饭，我一直想吃来着。“阳光普照炒饭。”8 元。“我以为是黄金蛋炒饭…你看过《中华小当家》没有？”“你看过《神厨小福贵》没有。”于是迈上童年之路。路上有着游戏王的事，预言的事，反转的事，大反派的事。然后…“你看过《死神》？”“对啊，六年级开始看的，烂尾时伤心好久。”于是迈上讨论《死神》的小径，童年里的讨论者开始向寝室方向进发。　　</p><p>　　洗发露。于是开始向着学校外不远的超市移动。但是我的储值卡昨天就用完了。酸奶没有我要的口味，只能提着原味回寝室。我还是去学校里的超市吧，也许便宜一点。不，我已经走了一段距离了。骑车吗？不，那种东西会滑出来，而且车是湿的。燕麦片只有那种很大包的，那只能拿一瓶洗发露了。然后我的手机响了。　　</p><p>　　为何变成奥斯卡金曲些了。不行，我休息一下。　　</p><p>　　好了，现在是肖斯塔科维奇了。　　</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>&#160; &#160; &#160; &#160;为什么这个表情老是打不开，昨天是这样，前天是这样，这样都好久了。我是挺想给对面发一个滑稽的，不知道为什么这么突然喜欢上这个老游戏。啊？这个肖斯塔里面有人在唱歌？这么如痴如醉地买了这么多扩充包。网上说是 dpi 的问题，也有说是隐藏底栏的问题，我都试试吧。于是手机进入了反复调整重启的状态。太阳从来没出现过，但是天就开始黑了，该吃饭了。我的手机屏幕一会亮一会黑，不行，这个底栏太大了。重启。GALAXY S8。嗯，这个合适了，那个菜我没见过。“今天有汤圆。”对，我刚刚看见了。对，今天是元宵节。“我这儿元宵十五上物理课”一个不辨男女的头像。L 君。不要急啊，正在写啊。“汤圆在那边。”“不，就吃饭。”我想试试那个新菜。像是土豆。“我要那个土豆。”果然是甜的，也确实是土豆。里面的肉有股快餐店的味道？食堂或许真的来了新的师傅。那边有个同学的头发挺长的，眼睛都看不见了。我以前也这样，我以后也这样。再过几个月？　　</p><p>　　门口碰见了阿姨在浇水。“阿姨好。”“哎，你好，有你的快递。”浇的什么？蒜？“阿姨这是蒜吗？”“是，蒜发芽了就…你吃汤圆没有？”“没，我们那边不吃汤圆的。”我现在是在干什么来着。阿姨整理着一些快递的包裹。嗯，我是来领快递，我都忘了的。“你把那个表填了。”为什么要填这么多，原来不是只签字的么。也许还在放假的阶段。我抱着我的箱子继续向上攀登。</p><p>　　“是盖个章就可以走了吗？”H 君问辅导员先生。“是呀，盖个章，签个字就能走了。”“早知道我让个同学帮我办了，我能多睡几天懒觉。那延迟报道怎么办？”辅导员旁边站的是哪位？是他的女朋友？他女朋友长什么样的，我记不得了。上学期指导形势与政治来着。不，我不知道，不知道就不要乱说。那我们可以回去了。“话说我们组上学期讨论要聚餐的，趁没开学聚聚啊。”“晚上约了高中同学。”大家都忙啊，然而热闹是他们的，我……“你了解笔记本电脑吗？”“不，不清楚，在攒钱买，估计大二换。”我突然感到有人拍我，“嗨，新年快乐！”是 H 君。“嗨，好久不见。”“上海真是冷，来了就盖个章，早知道多睡几天。”“早来两天也挺……”“学校也真是的，如果晚开学两天，我妈绝对会多留我两天的，我等会问一下怎么延迟报道。”上海和成都温度没什么差别。哪里都一样。我想起了哈尔滨的三弟。愿安好吧。养生，现在也有 0 摄氏度了，没这么冷了。　　</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>&#160; &#160; &#160; &#160;这教材居然是哈工大的，果然……那那本程序语言呢？看起来特别厉害。原来是斯坦福的老教材。上学期那个教材是真的不像话，这本也许会比较有趣，网上评价还蛮好的。“去吃饭吗？”“我把床收好就去。”于是我开始计算偏导数。翻到昨天那一处。“x 与 y 的地位是平等的。”我记得我折了一下。对，是这里了。　　</p><p>　　“我找到了，不知道你有没有兴趣，我这里刚好有《死神》的一个游戏，PSP 移植的，刚好我还有模拟器，你要我考给你。”我应当继续看我 Python 的课，第五节看了一半了。“好，你给我嘛。”我饶有兴趣地看他玩了一小会，我的手机提醒来了。对，是看那个课的时间了。“你先玩着，我去看看书。”等等。微信。我们班有了个新同学？难道是今天……？不，不重要。耳机带上没多久，敲键盘的声音听不见了。对，他还在自己的座位上，但是应该是没玩了。一节课仍没看完，有敲门的声音。W 君到啦？不，里面探出 Z 君的头。“你烫头发了。”Z 君与 F 君攀谈起来。过了一会，他进了我的寝室。“你在干什么？你剪头发啦？”午饭那个同学头发确实挺长的。我把包挪出来给 Z 君一个位子。书包里有什么？</p><p>　　我不知道。这么多问题自问自答有什么好的。“汇了 2000 元哈，元宵节快乐[微笑]。”我不知道，元宵节应该是个团圆的日子吧。我在昨天看见了月亮，成都是不可能看见月亮的。但是上海的月亮异常的清晰，它是那么的圆，那么的白，像绕成环的抽纸，像漂白的太阳在污水里燃烧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bonjour</title>
      <link href="/2019/01/01/essay-Bonjour/"/>
      <url>/2019/01/01/essay-Bonjour/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-VRvTlPPp" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="465469873" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>这是 Joseph 的博客。也许你在其他地方几乎听不见他的声音。但是这里可能会留存一些，我是说可能。当然，很感谢你可以找到这个地方。</p><a id="more"></a><p>但是有几个麻烦的问题需要解决。</p><h2 id="Joseph为什么写博客？"><a href="#Joseph为什么写博客？" class="headerlink" title="Joseph为什么写博客？"></a>Joseph为什么写博客？</h2><p>正如前面提到的，也许在大多数情况下，这个博客的主人都会保持沉默。或许有一些特殊的理由，但他自己也不知道。或许是他希望可以和别人分享一些小小的东西，当这些东西在心里产生了巨大的重量，以致于他需要排泄出来。</p><p>或者他只是简单地希望一小部分人——很小的一部分人知道这个鬼鬼祟祟的人在想一些什么，或者干一些什么。当然，这样解释并不是很合理，大部分人阅读信息的目的也许并不是为了了解其他人，而是为了更好地理解自己。所以下一个问题是：</p><h2 id="Joseph的博客写给谁？"><a href="#Joseph的博客写给谁？" class="headerlink" title="Joseph的博客写给谁？"></a>Joseph的博客写给谁？</h2><p>这个问题同样是难以回答的。因为大部分人应该都意识不到这个网址的存在，Joseph 自己也不知道这个冲动将要维持多久。同时他不知道可能会有兴趣看这些杂七杂八的人在哪里。但是无论是谁，一定是 Joseph 的朋友们吧，不论他们曾否蒙面。</p><p>但是很大意义上，这个博客是 Joseph 写给自己的。现代人缺乏一种自我沟通的方式，也变得健忘。也许他只是打算用这种方式让一些片段的思维可以保留的更远一点而已，让以后的自己可以知道他原来在这个星期天的下午在思考一些什么样的东西，读了一些什么样的书，给出了什么样的评价，学习了一些什么样的技术。如此就可以了。</p><p>当然，我欢迎我的其他朋友。很高兴我们可以在这里碰面，并且一些人或许愿意多停留一会，多来几次听这个稀里糊涂的人的絮絮叨叨。我很感谢你们。但是你们可以在这里找到一些什么呢？</p><h2 id="Joseph在这里写一些什么？"><a href="#Joseph在这里写一些什么？" class="headerlink" title="Joseph在这里写一些什么？"></a>Joseph在这里写一些什么？</h2><p>他原本的初衷是想做一些永久的，私人的笔记。然而这个野心迅速就扩大了。也许这里将变成一个半公开的思维的储存地。会有很多混乱的言语进入其中。但很有可能的，这里面是一些关于文字、音乐、思考、科技的东西，但是除此之外可能会夹杂一些随意的笔记，那种散漫的，毫无目的的简短文字。我知道你懂我的意思。当然，初衷：一些学习的笔记。</p><h2 id="如何联系Joseph？如果你想聊几句？"><a href="#如何联系Joseph？如果你想聊几句？" class="headerlink" title="如何联系Joseph？如果你想聊几句？"></a>如何联系Joseph？如果你想聊几句？</h2><p>嗯，他并不想让他的读者们在文章下面拉拉杂杂的讨论自己拉拉杂杂的文字，所以？邮件联系他吧。他也许会很快回复你，也许不会。这个几率可能和那一天出太阳没有相关。总之他一定会回复的。如果有一些有意思的话题，他希望更深入的探讨，他也许会写一封公开信，当然在征得同意之后。</p><p>总之就是如此了，我很感谢你们的到来。让我觉得这里有那么一点点的人情味。再次感谢。祝好。</p><h2 id="P-S-如果你是第一次来到这里"><a href="#P-S-如果你是第一次来到这里" class="headerlink" title="P.S. 如果你是第一次来到这里"></a>P.S. 如果你是第一次来到这里</h2><p><strong>关于字体</strong></p><p>本来 Joseph 打算将 Blog 的字体统一为自己常常使用浏览器时设定的字体，但似乎对于字体的客制化没有非常好的方案。使用将字体挂在网路上的方法，每一次刷新需要从网站上拉取字体文件导致访问体验骤降。这在 Joseph 看来是不能忍受的延迟（这关乎美感），于是最后还是砍掉了使用特殊的字体。</p><p>现在的字体设定将会使用查看网页的设备自己的字体库，如果在设备中恰巧拥有同样的字体，它会以正确的方式呈现。如果你们有兴趣的话，可以主动在自己的设备上安装相同的字体。这是通往这个字体 [源樣明體] 的<a href="https://github.com/ButTaiwan/genyo-font" target="_blank" rel="noopener">Link</a>。你们可以通过点击这个<a href="https://josep-h.gitee.io/images/GenYoMinTW-Medium.ttf" target="_blank" rel="noopener">Link</a>进行主动下载安装。（这个流程在 Windows 系统下非常容易。）以下是这个字体的效果：</p><center><img src="/images/font_example.jpg" width="80%" height="80%" /></center>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
