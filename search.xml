<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>路邊風塵故事</title>
      <link href="/2021/05/13/essay/%E8%B7%AF%E8%BE%B9%E9%A3%8E%E5%B0%98%E6%95%85%E4%BA%8B/"/>
      <url>/2021/05/13/essay/%E8%B7%AF%E8%BE%B9%E9%A3%8E%E5%B0%98%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-lyAjiVZt" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="20175101" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>好像快要畢業了，但不免覺得人是難以變化的生物。聽輔導員說着，反思一下四年間發生了什麼變化。人的性情無非就是窗外的樹，春天長出了葉子，秋天又落掉了，到第二年的春天又長出來，僅此而已。即使不斷地發生着變化，也非常無力吧。毫無疑問，這是個錯覺。</p><a id="more"></a>  <h2 id="典當行和老市場"><a href="#典當行和老市場" class="headerlink" title="典當行和老市場"></a>典當行和老市場</h2><p>上海是一個大得出奇的城市，但又和別的城市沒有什麼差別。無論生活在多大的背景里，人類活動的範圍都是侷促的。我抱怨新加坡是一個無聊的國度，並往往以自己暫時不能離開這個城市作爲歸因。雖然這麼說着，即使那個時間可以離開這個國家，估計也不會走更遠的地方去，即使去了也並不會覺得自己能走動的範圍變大了一點。</p><p>在大多數時候，我覺得它和其它的城市一樣，忙碌且盲目。但突然某些時刻，它會出現一些特質，比如突然在路旁發現的一個典當鋪和充滿了時代感的老市場。這種老市場有那種令人感到熟悉的很大的門面，門前掛着各式各樣的便宜玩具和掃把拖把。裡面並沒有閃爍着燈，外面的光往其中延伸四五米就消失了，留下了深邃的黑色。在我大概很小的時候，家附近也有這樣的店。這種店往往深藏不漏，包含着各種琳琅滿目的東西，蟑螂藥和老鼠夾，窗簾和陶瓷盤子。然後它們就再也找不到了，且不能被想起來，不知道是什麼時候，直到我們又一次見到它。</p><p>上一次看到一個收集老東西的豆瓣小組，他們放出了一張M記的優惠券。大概是一張A4的紙，上面被裁成各種小張，每一個小張上是一個什麼套餐或者單品的優惠券，比如6元的雞塊之類的。小時候覺得這是一個出奇優惠的東西，發給我的傳單我都收下了，壓在桌子板下，並總是覺得什麼時候能用上。但最後可能用掉的也就是那個6元券。但不知道什麼時候，這種券也消失在了世界裡，可能是移動網絡興起的結果吧。</p><p>這些或許才是切實地在變化，並一直在變化，並永遠不會回來。</p><p>「我在那邊看到了一家典當行」我說，我的同伴W回答說，「是的，但是如果典當行，那個人典了什麼東西，幾年後回來了倒閉了怎麼辦？」「這種事情也是有的，銀行也是會倒閉的。」對於物品，人就有這樣的擔憂，即使是對於有生命的貓貓狗狗，人也會想它們過去了，就再不會回來這種事情。或許偶爾會想起關於自己的事情，產生類似的想法，但很快就偷偷溜走了，總覺得時間漫長，且人並不會變化。</p><h2 id="無知與失憶"><a href="#無知與失憶" class="headerlink" title="無知與失憶"></a>無知與失憶</h2><p>這是第二次看這個展，出於尷尬的原因和處於尷尬的立場。總之我有了一個同伴W，去看一個上周周末剛剛拜訪過的建築展。出了地鐵站，一路的景色都很熟悉，是上次走過的道路。即使如此，路邊還是出現了一些新鮮的東西。這些東西我之前並沒有注意到，比如在路旁那個叫「豫園」的園林。我早該想到這個叫豫園的地鐵站旁邊應該有一個叫豫園的建築；在這些古香古色的建築羣中，應該有這麼一個古香古色的豫園。但我第一次並沒有注意到。</p><p>一些事情我不知道，出於無知或者出於善忘。我能夠記住的是展館面前那個巨大的青蘋果，以及青蘋果上面寫着的「永遠の青春へ」。這個淺顯、直白，並且是我第一個嘗試去記憶的東西。我記住了它，它的光澤體積和表面的凹陷。讓我下一次看見了這個蘋果，我會說，「噢，這是那天的那個寫着青春的蘋果！」帶着自豪與愉悅，那是沒有失憶的時候。</p><p>裡面的展品大部分我也記住了，它們的形狀，一些莫名其妙的特徵，比如那個德國雕塑館面前的石柱子。我曾經想了很久那個石柱子是什麼意思，或許這就是雕塑館吧。但我也發現了一些新的東西，我們在復刻的光之教堂中的時候，W突然說，「那對面的柱子正在動。」這個展館外面有一些管風琴一樣的巨大柱體從屋頂垂下，作爲裝飾。我本以爲這是些靜態的東西，但它們切實地動了起來，里外兩排柱子沿着相反的方向移動。但爲什麼。這個事情我能記住，並且出於無知。</p><p>有一些事情，我會忘記得很快。比如一座建築爲何如此，比如裡面如何調動了風、如何調動了光與影。在我看過之後，就忘記了。我本以爲看過一次的展覽，第二遍瀏覽會無聊，但其實並不是如此。我發現了一些新的東西，並想起了一些已經忘記的事情。它們調動着我的感官，讓我覺得有趣。但並不那麼有趣，因爲我理解不了它們，然後迅速地忘記，成爲泡影。</p><h2 id="傳單和斑馬線"><a href="#傳單和斑馬線" class="headerlink" title="傳單和斑馬線"></a>傳單和斑馬線</h2><p>這個行動本身就充滿了巧合，並且違反了我行動的邏輯。但我還是接受了，大概想着這個偶然的事情就在這裡結束了，不會再次到來。</p><p>我這樣想着，往學校走着。這個時候我的眼前出現了一個青年但又有些油膩的人物，他看見我朝着那邊走就立刻走了過來，並高呼着帥哥。我心想着麻煩了，但還是回應了他的喊聲，「請問有什麼事情嗎？」他說自己在辦一個什麼什麼東西，想要加一個微信的好友，但我已經忘了他說的到底是什麼，並且懷疑我根本就沒弄清楚過。他揮舞着自己手上的手機，並挪動着腳步跟着我向前的步伐。我說，「不用了，我有急事」，然後接着往下走。「還差兩個了，就兩個了，你幫我加一個吧。你大幾了？」「不，我趕時間，真趕時間。」然後接着往前走。</p><p>這樣我想起了之前在另一個商圈碰到的一位僧人，他似乎說着廣結善緣之類的話，往我的手裡塞一個什麼牌子，說是開過光的，然後打開了一個功德簿之類的玩意，拿着一支圓珠筆在上面指指點點。這個時候我摘下了我的耳機，試圖聽清楚他在說什麼（雖然我已經大致猜到了）。然後說，「不用了，我趕時間。」說着把那個開光的牌子還回了他的手裡。我想着那個功德簿上面是真的有人捐了那幾百，還是只是托。他後面還糾糾纏纏地說了一陣，我揮了揮手說了句抱歉就徑直走我的路了。</p><p>我想着這個事情才發現這位居然還鍥而不捨地跟着。我看見他那種奮力的樣子，感到爲難，這個時候旁邊路過了一個人，他像找到了救命稻草，撲了過去，饒了我一個人走着。離開這裡吧。我環顧着想找到一輛自行車，就着這個紅綠燈過去，於是找了一輛並解了鎖。然後我被攔在了紅綠燈的這頭。我看見了剛才那位極有毅力的男人在和另一位路人討論着了，揮舞着他的手機。這是一個艱難的時刻，和一個危險的城市。想着不想被他又糾纏上，決定不等這個紅綠燈，然後順着人行道推着車打算去下一個紅綠燈口。這不優雅。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雜記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路邊小屋</title>
      <link href="/2021/03/31/essay/%E8%B7%AF%E8%BE%B9%E5%B0%8F%E5%B1%8B/"/>
      <url>/2021/03/31/essay/%E8%B7%AF%E8%BE%B9%E5%B0%8F%E5%B1%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我像往常那樣騎車來到校門外的大路上，等着紅路燈變綠，注意到路邊的綠化帶中間有一間小屋。</p><a id="more"></a>  <p>我在想那間小屋是什麼時候出現在那裡的。在我的印象里，這幾年這條路都沒有經歷過任何的翻新，自然也沒有對綠化帶改造之類的事情。且這又是我每周必走個五六次的熟路，如若存在翻新的話我應該不會有任何遲疑地想起來這件事。甚至，如果這個小屋在這裡出現了哪怕一周我都該注意到才對。</p><p>這不算是一個隱蔽的小屋。它周圍只有稀疏的灌木叢這樣矮小的東西，整個牆壁都是漆成的白色，在一片綠色背景中尤爲顯眼。靠近我這邊有一扇關着的窗戶，黃色的燈光透過磨砂玻璃映射出來。</p><p>這是一間用來做什麼的屋子呢……我在它周圍稍微轉了轉，沒有找到進去的泥土徑。周圍的同學奇怪地看了我一眼，多半是在想這個人在晃來晃去，看一些什麼東西。他們沒有注意到綠化帶中間的那間屋子嗎？他們不覺得綠化帶中間有一間屋子（窄的可憐）很奇怪嗎？這個時候紅綠燈變成了綠色，我回到了自行車上，像往常一樣進入了校園。</p><p>到了晚飯的時候，C同學約我去南區附近的一家川菜館吃飯。於是我又路過那個路口，那間白色的屋子還在那裡。透過磨砂玻璃，映出黃色的光。可能就是我每天盲目地經過這裡，完全沒有注意到這間小小的屋子吧。但它如此醒目又讓我覺得奇怪。</p><p>上完晚課，我從光華樓出了門，再一次走上了這條熟悉的路，下意識地朝着路邊看了一眼。那間屋子不見了。只剩下低矮的灌木叢和春天快開敗的幾朵紅色的花。那間屋子究竟是爲何出現在那裡的呢，心裡這樣想着，便打算明天接着走那間消失的屋子旁邊的路。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 怪事記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>馬勒、音樂、文字和雜七雜八的東西</title>
      <link href="/2021/03/22/essay/music/%E9%A9%AC%E5%8B%92%E3%80%81%E9%9F%B3%E4%B9%90%E5%92%8C%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
      <url>/2021/03/22/essay/music/%E9%A9%AC%E5%8B%92%E3%80%81%E9%9F%B3%E4%B9%90%E5%92%8C%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>昨天晚上去聽余隆老爺子指揮的馬六。我本來應該寫一篇類似之前的對於這場音樂會的評價，但後面考慮了一番還是沒有動筆。音樂是很抽象的東西，我想無論如何去描述某個晚上聽到音樂的情況，都是非常無力的。或許我說「這場演出糟透了」，「它的銅管都在幹些什麼！」之類的話，或者非常感動，用「天國來的音樂」，「不能聽到第二次」之類的方法去形容它，也非常的單薄無力。</p><a id="more"></a>  <p>馬勒的音樂會令人癡迷，就在於其現場的音效難以用任何我手上有的工具重現出來。我聽着我自己的設備，恍惚間覺着這些錄音已有一些神韻之後去現場，但只要聽哪怕一個小節也會打破這種印象。或許我能描述出的一切是，它們不同。這是一種直觀的、不可動搖的感受。但卻缺乏進一步描述的可能。如果我開始陳述，「它用了那個別致的大錘」，「它出奇地用了兩個定音鼓」之類的，又會陷入毫無意義的討論中——這完全不是我關心的問題。不，沒辦法描述這些內容。</p><p>音樂能夠令人印象深刻的原因非常複雜；音樂的情感大多是晦澀的（對於沒有歌詞的作品）。它是一個複雜的場景的結果。每次我聽着肖邦夜曲的時候，都不免聯想到那一天的事情。站在成都那個大熊貓趴着的寫字樓上，耳邊傳來連綿的鋼琴，眼前是一個小草坪和幾個遮陽傘。於是我常常想，這個場景有什麼寓意嗎？這不是多麼特別的場景，音樂也不來自效果非常好的音箱，但那個聲音就是這樣串聯起了這個場景，出現在我的腦海里。還有當時聽馬九的第四樂章，我癡呆地盯着音樂廳的天花板，看着各種吊頂裝飾。這個場景和我離開同學聚會並在街邊等着公交車時的場景聯繫在了一起，透過這段音樂。但並無邏輯可言。</p><p>就像我說不清楚爲什麼哥德堡變奏曲的主題詠嘆調是如何具有撫慰人心的力量一般，我不知道我如何感知的音樂。有的人會說，透過曲式、對位法和調性。但這些只是經驗：人憑藉自己的經驗得知，這樣排列的音符是具有魔力的，而另一種沒有。這不得不令人沮喪，人調動不了自己的情緒，也不知道它是如何被調動的。像是被牽着鼻子走的牛一般，只感覺前面那個鼻環似乎起着某種作用。</p><p>去音樂會之前，在音樂廳對面的書店呆了一會。畢竟是音樂學院附近的書店，裡面賣着唱片樂譜，甚至擺着一台電鋼琴。同伴上去彈了一個樂章的貝多芬奏鳴曲。這個場景能被我記住嗎？能比我聽說余隆老爺子經常在這家書店旁邊的意大利餐廳吃意大利麵記得更久嗎？合成的鋼琴聲音覆蓋了整個小空間，別的讀者和向我們這樣隨意走走的人進入了這個魔幻的小空間，都停下來，側着耳朵，有的閉着眼睛，聽着那台木頭和金屬的器械發出的聲音。一曲終了，稀稀疏疏還有鼓掌的聲音。這鼓掌聲音自然不能和昨晚馬六演畢的那三次返場時雷動的掌聲相提並論，但擁有着相當的魔力。</p><p>文字或者音樂都是差勁的東西，我們以爲可以藉助它們回到某一個時刻，銘記某一些場景，但大多都是徒勞。當它們重新被閱讀着被聆聽着的時候，已經完全不是記錄時的樣貌了。只有一種特殊的感覺，那種似曾相識卻又不能言喻的感覺能夠留下來。這種感覺既不能寫下也不能變成音樂，它們只在那一個瞬間存在。</p><p>音樂或許更類似這種怪異的感受。它隨着時間的推移消失了，不會再出現。即使是現在熟悉的一個主題，心裡想着，「這一段我很熟」的主題，也會在聽完整部作品後忘得七七八八，直到再一次聽到這段作品。一個音符一旦響過，就不會再次出現。它激起了那麼一點點腦部的電信號，然後杳無音訊，不論再努力地回憶都會竹籃打水，變成一個迷幻的夢境。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手記 </tag>
            
            <tag> 音樂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《全職獵人》觀感</title>
      <link href="/2021/03/13/essay/%E8%A7%82%E6%84%9F/%E3%80%8A%E5%85%A8%E8%81%8C%E7%8C%8E%E4%BA%BA%E3%80%8B%E8%A7%82%E6%84%9F/"/>
      <url>/2021/03/13/essay/%E8%A7%82%E6%84%9F/%E3%80%8A%E5%85%A8%E8%81%8C%E7%8C%8E%E4%BA%BA%E3%80%8B%E8%A7%82%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-rXHcdjbZ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="22742684" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="評價：★★★★☆"><a href="#評價：★★★★☆" class="headerlink" title="評價：★★★★☆"></a>評價：★★★★☆</h3><p>　　本來不打算寫《全職獵人》的觀感的。最近閒來無事，把舊版重新看了一遍。這一次看得更加仔細一些，尤其是「友客鑫篇」。看完這一遍（可能是三刷或者四刷），我終於還是決定寫一篇簡單的觀感。這裡主要的評價對象是《全職獵人》舊版，新版更多作爲對照出現，因此對於「螞蟻篇」也不會有詳細的評價，僅僅作爲對照出現。由於個人看過的漫畫版本只有從「螞蟻篇」結束之後的部分，所以這裡將不會以漫畫作爲對照版本（舊版和漫畫有相當的出入，但個人認爲是良好的出入）。</p><p>　　<strong>注意</strong>：本評價一定會造成劇透。請考慮是否接受劇透後進入。</p><a id="more"></a><h3 id="綜述"><a href="#綜述" class="headerlink" title="綜述"></a>綜述</h3><p>　　《全職獵人》無疑是一篇鬼才之作，在整個篇幅中，風格和描述的對象始終在發生着變化，大體可分爲以下幾部分：</p><ol><li>獵人考試篇：主角四人組。四人組的相遇並考取獵人證書。</li><li>骷骷戮山篇：主角三人組，除奇犽外三人去解救奇犽。</li><li>天空鬥技場篇：主角奇犽和小傑，學習念技術。</li><li>友客鑫篇：主角酷拉皮卡和旅團，兩者交鋒。</li><li>貪婪之島篇（舊版OVA，新版和漫畫）：主角奇犽、小傑和比斯基，攻破遊戲《貪婪之島》。此時舊版由於更換了監督，並且從手繪改爲了電腦作畫，水準大幅度下滑。</li><li>螞蟻篇（僅新版和漫畫）：主角奇犽、小傑，處理奇美拉蟻，小傑隨後失去意識完全癱瘓。</li><li>會長選舉篇：奇犽、雷歐力和金，奇犽拯救小傑，雷歐力精選獵人協會會長。</li><li>豪華遊輪篇（僅漫畫，且在連載停刊中）：除小傑和奇犽外所有勢力。</li></ol><p>　　從獵人考試篇到天空鬥技場篇，包括貪婪之島篇都是熱血青年漫的範疇，樹立了不少獨特的角色。友客鑫篇和螞蟻篇更接近青年漫。會長選舉篇和豪華遊輪篇已經脫離了標準漫畫的範疇，俗稱「小說配插圖」。故事發展從最開始的線性劇情，到後面的大亂鬥，這樣的傾向是越發明顯的，一直到豪華遊輪篇發展到令人髮指的地步。個人以爲最適合的尺寸爲友客鑫篇和螞蟻篇兩部分，而後者有有些過於複雜，導致一些人物不突出（更像是羣像了）。友客鑫篇在其中保持着非常好的分寸，精巧而有序，首尾相扣。</p><p>　　後面分爲情節，人物和設定兩部分簡單評價一下。</p><h3 id="劇情"><a href="#劇情" class="headerlink" title="劇情"></a>劇情</h3><p>　　《全職獵人》作爲一個非典型少年漫，風格變化多端，劇情也相當不落俗套（尤其是後期），想要一一概況是相當困難的事情。所以這裡將重點放在友客鑫篇吧。</p><p>　　友客鑫篇將整部作品真正推向了新高度。這是念能力系統最開始嶄露頭角的篇章，也將常見的單線或者雙線敘述過渡到了多線敘述。在這個篇章中，直接涉及的陣營爲酷拉皮卡、黑幫、旅團、小傑三人組四批。小傑三人組前期游離在主線劇情外，後期和酷拉皮卡合流。前期酷拉皮卡處於黑幫勢力，後期開始單幹。旅團則有二五仔西索。所以表面上是三股勢力的糾扯，但只是雙線敘述是不夠的。這一章節主要是旅團在其中推動，酷拉皮卡伺機而動。二者幾次交鋒可以分爲一下幾節：</p><ol><li>旅團一闖拍賣場，酷拉皮卡的黑幫同事大半被滅，酷拉皮卡搶占先手偷到窩金。</li><li>旅團二闖拍賣場，假裝身死，繼續拍賣，酷拉皮卡在西索告密前渾然不知。</li><li>旅團藉助拍賣掉的火紅眼開始追蹤酷拉皮卡，小傑和奇犽被抓，同時團長被酷拉皮卡抓走。</li><li>雙方約定條件交換人質，以小傑奇犽回歸，團長失去念能力作結。</li></ol><p>　　這整個故事有多個核心在推動其前進，開端是旅團希望偷走寶物、酷拉皮卡希望復仇、西索希望有決鬥機會，隨後是窩金之死和預言詩入場。讓整個章節行雲流水，翻轉也在情理之中，一直演化到最後的交換場面。上面儘管概括出了主要的發展，卻不能夠對於一些精彩的場景進行重現，比如兩次追蹤戰，扣人心弦的緊張氛圍在許多作品中難得一見。</p><p>　　互有勝負，酷拉皮卡一直處在暗處並藉助這個優勢兩次搶到先機，但仍然不能完全對抗旅團的機動力，最後草草結束。這段故事在舊版中，前半截的敘述中心在酷拉皮卡，後半截在旅團（派克諾坦）。酷拉皮卡和派克諾坦在這個章節里互爲映射（螞蟻篇里小傑和蟻王的映射更加明顯），雙方代表各自的利益有自己的掙扎，並選擇了和平解決的道路。幾組勢力的互博充分地展現了富堅極強的情節掌控能力，並將幾乎登場的所有角色的性格立了起來 —— 當然表現的深度層次不齊。</p><h3 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h3><p>　　個人以爲，本作品最大的優點之一是它的人物立得住，並不是依賴強行拔高角色的某一個特點，而使角色看似獨特實則扁平。塑造人物的手段也完全不同，不依賴過分的回憶和人物背景，而是用無數的細節構建出一個完整的人物形象。最直接的方法就是設定一個符合人物性格的能力系統，代表人物就是酷拉皮卡、西索、伊爾迷。伊爾迷的強大控制欲可以直接從他的能力中找到端倪（但這一點有更多更有力的表達方法表現在獵人考試和會長選舉篇中）。</p><p>　　作爲標準混亂陣營的幻影旅團也不是「一羣貼着酷炫標籤的反派」。最能表現這一點的是團長被綁走後的三方心理鬥爭。團長認爲他的團員會放棄他，一派認爲依照團長的命令可以放棄團長，另一派認爲團長不可或缺。這種分立讓不同角色的思考方式和獨立性呈現了出來，同時即使分爲兩派，也存在溫和派和激進派的差異，不可不謂塑造人物的一手妙招。</p><p>　　獵人塑造出來的角色，大概是當我們希望對其進行描述的時候，可以使用一些俗氣的詞彙進行概括，但在概括之後又往往覺得這些詞彙不夠精確。我們可以藉助自己的理解去還原一個作者希望表達的角色，但是不能使用足夠準確的詞表達出來，更不能複製出這些角色的言行。這些角色有着相當獨立的意志和行爲邏輯，而絕非工具人。同時人物的塑造不依賴口癖或者常用語這些往往用力過猛的方法，這一點使人非常欣賞。</p><p>　　舉個例子，小傑是一個反熱血漫的主角設定。他有足夠強的背景、足夠強的學習能力、足夠多的夥伴——這些都是傳統熱血漫具有的特徵，但他「不辨善惡」。「不辨善惡」是一個劇中角色的解說，這並不是傳統意義的貶義說法，而是沒有成見地看待一個事物只是相信自己的判斷。這是一個很有挖掘潛力的設定，正是這種特徵一直延伸到了小傑的最終結局。儘管這個特徵十分突出，卻不足以概括這樣一個角色。我讀過一些劇評認爲小傑「雙標」，或者乾脆認爲小傑最終ooc了。相反我認爲這正是這個角色的魅力所在。</p><p>　　另一個例子，在友客鑫篇，小傑和奇犽被旅團綁走的場景中，信長要求和小傑扳手腕並流淚的一場戲。信長在整個章節中並沒有太多筆墨，但是這一個小小的場景，就塑造了一個複雜的人物，並且藉由這個人物，將整個旅團的特徵樹立了起來。同時爲後面的旅團內部衝突埋下了伏筆。舊版的處理也爲這個章節添色不少，最明顯的是酷拉皮卡的同事達佐孽，一個不算苦大仇深的角色，但有自己的擔當，人物塑造得乾淨利落，恰到好處。</p><h3 id="設定"><a href="#設定" class="headerlink" title="設定"></a>設定</h3><p>　　《全職獵人》的設定相當有趣，畢竟是設計的獨立世界。其中最亮眼的都是念能力系統。（獵人這個職業的設定也相當有趣，但這裡就不展開了。）</p><p>　　常常被稱讚爲動漫中最爲系統的異能力設定。念能力的基礎異能力中常見的生命能量，通過鍛煉或者強韌的意志可以獲得的東西。基於這個基礎設定，演變出了四大行基本功。基本功的結合與融匯發展出了更多的應用技，囊括了觀察（凝）、防禦（堅）、攻擊（硬）、感知（圓）等，這使得所有的角色都可以擁有基礎的行動力。而角色的獨特性則是以四大行中的「發」保持的。根據個人天賦，這個系統可以發展出強化系、變化系、操作系、放出系、具現化系和特質系。前五個方向基本囊括了大部分異能力動漫中使用的能力，最後一個則是爲一些特殊的能力留的後門，例如偷竊他人能力的能力。這六大系統也可以通過後天學習相互轉化，並設定了學習的難度差異等等。是一個具有相當的廣度、規範性以及方便發掘的系統。</p><p>　　相較而言，JOJO的設定則更加粗泛，任何能力都可以被直接設定出，而不用考慮使用的實質等等細節，更加天馬行空，因此總是蘊藏着「這個人物明明有更優的解決方法」的問題。</p><p>　　但果然這個系統最爲令人驚艷的是「誓約與制約」的設定。這是一個簡單的假設：使用更嚴格的約束可以發揮更強的實力。但如此具有魅力和變化的可能。在富堅原作中，基本所有念能力都遵循了這個策略。這裡可以枚舉幾個有趣的誓約與制約。</p><ul><li>小滴 &amp; 凸眼魚：可以吞下一切物質，但以下類別除外：有生命的東西，帶有念能力的東西或者念能力具象化的東西。這是一個簡單的能力，卻有一些有趣的應用：其一，利用這個特性吸收敵方的血液，這並沒有違背誓約的內容，但效果拔羣；其二，在貪婪之島中用這個方法驗明了島中的部分東西並不是具象化的實體，而是實際存在的，從而爲真實世界論提供關鍵證據。</li><li>庫洛洛 &amp; 盜賊的祕笈：可以偷取其他人的念能力，條件不明，但需要被盜取的對象存活。最開始的盜賊祕籍需要一手持打開的具象化的書籍，並翻至對應能力的頁面（即強制性限制一隻手的自由）。沒有什麼特別的，但是誓約內容很有趣。</li><li>酷拉皮卡 &amp; 束縛之鏈：使對方強制進入「絕」狀態，僅能對幻影旅團成員使用，對其他人使用會導致使用者立刻死亡。酷拉皮卡還具有另一個強力誓約「絕對時間」，但這裡先略過。「束縛之鏈」是「制約與誓約」初登場的時刻，酷拉皮卡給定了非常狹窄且強悍的條件並換來了極強的能力。復仇的決心和需要背負的代價僅僅用這個能力的設定就完全展現了出來，一個悲劇的動機早已埋好。</li><li>小傑 &amp; ？？？：用一切爲代價換來了短暫的全盛能力。這一情節是整部作品最爲反套路的點。這是一個難以被預料的發展，直接將主角推向了無底深淵。正是如此，這一部分的張力才被拉到了巔峯，帶出了難以想象的劇情發展和離譜的壓迫感。（新版在這裡使用的bgm尤爲出色，在全部作品中不可多得的亮點，新版絕不可錯過的片段。）</li></ul><h3 id="新舊版對比"><a href="#新舊版對比" class="headerlink" title="新舊版對比"></a>新舊版對比</h3><p>　　個人更喜歡舊版。舊版的BGM基本上無可挑剔，緊迫、黑暗、壓抑種種配置都是恰到好處。友客鑫篇的爵士風和旅團瘋狂又優雅的風格非常搭調，大鼓、管風琴、鋼琴種種樂器的應用和劇情完美匹配。而新版的音樂就一言難盡，一直到貪婪之島篇都是運動會風格，和獵人的風格格格不入。進入螞蟻篇之後，配樂中增加了不少佳作，但遺憾的是數量仍然太少，大多數時候都是重複的音樂使用，顯得疲軟。</p><p>　　分鏡也是舊版更加流暢自然，新版則基本照搬原作分鏡。不少觀衆詬病舊版擅自增加劇情和細節，但就個人觀感而言，舊版增加的細節恰到好處，不如說更加晚上了富堅在創作的時候都沒有處理好的伏筆等等問題。舊版的打鬥動畫也顯得更加流暢，色調和故事內容匹配。對比起來新版就過於開朗明亮、幼齒化。</p><p>　　對於增加的劇情，不得不再提一嘴友客鑫篇舊版中派克諾坦的沉思一段劇情和放貓部分，實在是非常經典的表達方法。回憶和現實的交疊，殺人如麻的旅團的過去，派克諾坦也如此樹立，冷漠卻溫柔，是這一章節的點睛之筆。</p><p>　　P.S. 關於螞蟻篇。螞蟻篇作爲一個非常特別的章節，其實是值得多說幾句的。但由於螞蟻篇只有新版中才有，而儘管新版獵人將大部分精力都用在了螞蟻篇中，還是令人覺得有一些失望，所以這裡先不做評價，等以後有想法了再補上這一節。</p><center><img src="/images/Things/hxh.jpg" width="50%" height="50%"/></center>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 觀感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>觀佛記 - 其二</title>
      <link href="/2021/03/04/essay/tour/%E8%A7%82%E4%BD%9B%E8%AE%B0-%E5%85%B6%E4%BA%8C/"/>
      <url>/2021/03/04/essay/tour/%E8%A7%82%E4%BD%9B%E8%AE%B0-%E5%85%B6%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　距離上次登上峨眉，以及過去了大半年。這個計劃終於還是堅持了下來（或者說完成了，或者說失敗了）。前後兩次情形的不同帶來了一些奇怪的感受，微妙得不知道該從哪裡說起。同行者的改變也讓整個事情像是從一個軌道上脫下，進入了另外一個。</p><a id="more"></a>  <p>　　冰爪插入冰里的感覺非常奇妙。像是一下子扎進了一個柔軟、極具韌性同時堅硬和脆弱的東西，或者說像是穿過玻璃紙然後扎進了乾涸的泥土裡。這時的風景也非常奇妙，完全的黑白，是透過黑白濾鏡失色的世界。在沒有雪的地方是黑色的，有雪的地方是白色的，在閃光燈照到的地方是灰色的。這種景象缺失了某種真實感，只有前面那個等着的燈火通明的旅館和熱氣騰騰的飯菜是真正的真實（事後卻被證明燈火通明和那個飯菜是虛假的）。</p><p>　　不知道是不是有一些心理準備，這一次爬山並不很累。到了最後甚至有一些愜意。在冰雪覆蓋的夜裡爬山本來是上一次四姑娘山的既定事項，卻在這裡找補上了；或者說對應的是這個峨眉山計劃最開始的冰雪之行。最後一節路放着歌並走走停停。原本我認爲陡峭的幾段路出人意料地平緩且距離短，沒有費多少力氣就跨過了它們。幾波人從我們的身邊走過去，消失在了樹林的影子裡。一晃已經九點了。</p><p>　　我的回憶總是在欺騙我，讓我將這一次旅程與上一次的峨眉鏈接在一起，但我發現相似處寥寥無幾。不知道是季節的差異，我的差異，還是同行者的差異。兩次旅程以不同的方式通往了不同的目的地。上一次旅程雖然稱得上順利甚至圓滿，但總覺得哪些地方有所缺陷，從而讓我覺着有些掃興；這一次或許也是如此。或者說我一直都沒有弄清楚，我自己究竟對着這整個事情的什麼部分感興趣。各種事情總是微妙且複雜，在我看着民宿窗外的溪水的時候就這樣想。這個溪水並不大，洪亮的聲音從那個水壩穿過來，虛張聲勢地讓我以爲外面要麼是有大江，要麼是在下雨。這種微妙的景象總是能夠讓我看很久也不厭倦。</p><p>　　噢我忘了說同行的人的事。同行者有二，其一是三弟，我大概有半年沒見過他了。他總是說自己忙着這個忙着那個，我自然是理解的，畢竟我經常也是如此，但不免讓我有些擔心；其二是Nof，最近才因爲COC見過，女生一個人出來爬山或多或少讓我有些敬佩。</p><p>　　就在我盯着溪水看的當口，三弟正脫下短袖換上毛衣。這實在是魯莽的行爲，畢竟外面的門還開着，這樣興許不太雅觀。我過去把門帶上，然後回到了我的陽台繼續看着溪水。一點也沒變，他初中也是這樣的。所以記憶並沒有錯。它在某些場合忽悠了我，又在一些別的場合分外清晰。就像我母親經常說道的一個事情，我記得我在兩三歲的時候去四姑娘上的半途上吐了，然後折轉去了一個附近的農家樂。這件事情我記得非常清楚，但不知道爲什麼。</p><p>　　所以不論我多麼清晰地記着那個坡上就是一大截平地，它還是連綿不斷地往上；以及不論我多麼清晰地記着那個坡是多麼陡峭，如今都顯地欠些火候。我的記憶矇騙了我自己，讓我美化或者醜化了一些是什麼事情。它不能忠實地把所有事情記錄下來嗎……我這樣想。即使藉助文字，這個事情在我的記憶里也會逐漸的發生變化，慢慢地在其中加入一些沒有發生的事情，對於一些發生過的事情卻再無印象。比如我多年後或許會忘記我曾經對那個山頂的玉米大加指責這個事，再一次買一個玉米；或者牢牢地記住這個玉米是一個洪水猛獸，難以下咽之物。</p><p>　　我看見的一切東西都覆蓋上了我的理解，在那個黑夜裡雪地上的腳印里也裝滿了我的理解：這是一個精神抖擻的年輕人的腳印，那是剛才擦肩而過的一家三口的腳印，儘管我沒有什麼理由。我習慣在我能夠兩階兩階往上走的時候就兩階兩階往上走，這沒有什麼特別的理由，但是卻會快出一截。於是這讓我有閒余杵着我的竹竿子，望着旁邊的風景，以及望着後面三弟和Nof。我看着三弟總是在Nof前後一兩階的位置，這是我做不到的事情吧，這種事情我總是沒什麼耐心。這種應該就是某種偏執的觀念，而不是什麼事實。他不可能總是這樣子沒離多遠，最多也只是大多數時候如此，但我就是這樣認爲了。這並沒有什麼不好的。</p><p>　　健忘應該是不錯的事情 —— 有的時候我會這樣認爲。人的腦子總是有限的，我覺着抓住那些值得我記住的事情就可以了，別的就隨風散掉吧；但往往這樣的事情也記不住。我想記憶這個事情，是壓縮事實的信息量的過程，用某些算法把次要的、或者說可以被忽視的信息藏在別的事實里或者直接扔掉。健忘的人應該就是採用了非常激進的壓縮算法，失掉了大部分的信息，留下了權重最大的事實。那這種回憶是極度抽象的、偏激的嗎？這樣子似乎不對。我對於細節總是有離奇的記憶能力，對於一些大體上的觀念卻總是出錯。比如人的行進姿勢比人的臉更容易被記住，於我而言。於是我會記住那些在石頭上面攀登又跳進水裡溼透的猴子，以及從山頂上扔給三弟的那半個果子的樣子，卻會忘記有扔果子這個事情。這些應該是錯誤的記憶，或者也能說是健忘，這樣會驢頭不對馬嘴從而失真。</p><p>　　記憶有的時候自私。因爲三弟和Nof大多數時候在我後面十米左右的距離，每次他們說一些什麼，我總是聽不真切。有的時候我會有的沒的問一下他們在說一些什麼，但總是飛快地忘掉。這些話並不是對着我說的，與我關聯也甚微，出於禮節或者好奇，我問了一下，轉眼就忘掉了，現在一點也想不起來。但這些話題以後被三弟或者Nof又提起來的時候，我可能會拍一下腦袋說，啊，確實有這件事情；或者就一臉茫然。</p><p>　　畫面也是容易記憶的事情，只要稍稍注意久一點點。就像我盯着看了很久的那條幾近乾涸的小溪，它的走勢和兩邊的零落田野我現在還能回憶得清楚。在下山的時候，坐在大巴里。上一次峨眉下山也是坐的這樣的車，當時Y在不斷地給我講着《只狼》裡的細節，甚至還給我放了幾個視頻。這一次的下山就安靜了不少。Nof可能是在前面休息，三弟在旁邊玩NS。大概半小時後，他可能玩累了，就開始眯着眼睛睡覺。人類的睡顏實在是有趣的東西，是只有在沒有防備的時候才會露出的表情。平和且安寧。我盯着他閉着的眼睛和上面的眼睫毛看了一陣，於是我也覺得平和和安寧。這樣的場景我能記憶很久，會和第一次登上峨眉看到的那個鹹鴨蛋一樣的太陽一樣深刻。</p><p>　　旅途中發生了不少的事情，一一講述實在是破費口舌，也不太有趣的，而且因爲我記憶的緣故，多多少少失了真。我不介意失真之類的事情，畢竟當我記下來的時候，它又失了一次真；而是其餘的事情我如果嘗試講述，就會變成更加微妙的命題或者形式化的流水賬。微妙的事情需要耗費更多的精力才能表述的清楚或者拿捏出邊界，而流水賬參見上一次登峨眉的遊記就足夠了。所以就停在這裡吧。</p><p>　　PS.下了山回來，Nof說了關於「溫暖」這個事情的時候，我有些吃驚。這確實是一個雙關，但也是習慣性不經意的一個雙關，我想當事人也沒有注意到才對。果然旅途里三四個人的團體最爲迷人，有一種精巧的平衡構建其中，每個人都用自己的眼睛考量其餘的人，揣測其餘人的想法並把他們連接起來。知道他人眼中的自己和其餘人的關聯也是頗爲有趣的事情。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行跡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蒙塵記</title>
      <link href="/2021/02/11/essay/tour/%E8%92%99%E5%B0%98%E8%AE%B0/"/>
      <url>/2021/02/11/essay/tour/%E8%92%99%E5%B0%98%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　我站在山脊和另一個山脊的交匯點：後面是我攀上來的山脊，右邊是連綿起伏的雪山，左邊是繼續沿着繼續往上的道路。雪山和我站着的地方，距離着一個長着低矮灌木叢的山谷，山谷的泥土地上斑駁地放着些冰雪的白色。這個轉折點立着一個醒目的木牌，上面寫着800m。</p><a id="more"></a>  <h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>　　在山裡走夜路遠沒有想象中困難。晚上的景色非常古怪，雪山罩着一種藍色的光暈，天空中閃着一些星星。四周的光亮除了頭燈發出的光別無其它，也沒有什麼聲響。</p><p>　　我跟在前面三匹馬後面：一隻馱着L，一隻馱着行李，一隻馱着X，嚮導在最前面走着。我時不時覺着我前面的馬匹腳閃了一下，L在上面規律的搖動。我清晰地喊一聲，「不能睡着了，馬上睡着了會摔斷脖子。」對方應答道，「我沒睡。」這是路途上可能會有的聲響。再不然就是伴隨着我的腳步滑落的泥沙的顆粒聲。</p><p>　　山間的小道全部都是踩實的泥地，也是不久前我登上山的道路。想着剛上山不足三小時就往下走，實在是覺着有些難受。我心裡估量着當時自己走到這裡的時候我花了多久，又多麼費力，隨着馬往下移動。</p><p>　　下山的路基本是難走的。在稍平的一些道路，走起來頗爲輕鬆，完全不費力。然而一路上那些嵌着石頭的泥土坡，凹成二十厘米寬、三十厘米深的溝渠，坡度或大或小。但直着往下走是不可能的，只能不斷地側着身子往下面移動。腳踩在這種有石子的路上，滋味非常糟糕。像是不穿鞋子走在那些鋪滿鵝卵石的惡趣味的道路上那樣，那些石頭不斷硌着我的腳。</p><p>　　「嚮導，我休息一下。」嚮導聽到我的話停了下來，開始從馬身上拿水下來；我從背包外層取出我的隨手杯。扭開杯蓋的時候，我覺着蓋子和杯身中間結着一層冰。保溫杯在我的背包里，打開扣子取出水是一件費勁的事情。想着也就喝下了隨手杯中的冰水。只有這種時候能稍稍歇着自己的腳，然後四周看看這黑暗中的景色。不知道走了多久，四周還是低矮的灌木叢。「前面還有多遠。」「大概三小時吧，到旅店的話。」嚮導回答我。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>　　剛剛到山腳下的鎮子，鎮子就建在山腳下。一路上來的時候，司機就指着旁邊的山脊說，這是你們明天要走的路。我並沒有什麼概念。來的一路幾乎都是在雲上的。穿過厚實的雲層和漫長的隧道，到達了這個小鎮。鎮子面對的山上面覆蓋着雪，一些樹上也掛着霜。像大多數村鎮那樣，這個鎮子建在兩山之間的低矮處。</p><p>　　村子的海拔在三千三百米，這裡擁有的是難以理解的靜謐。什麼聲音也沒有，能聽見四周有一種非常低微的燒水那樣低沉的嗚嗚聲。這裡不算冷，天氣也還晴朗。對於爬山是相當不錯的條件了，希望明日也是如此。</p><p>　　到晚上的時候，X架起了三腳架，饒有興趣地對着天空一陣猛拍。我比較在意的是鎮子的斜上方的山脊轉角上，有一個中國石油加油站，這個加油站的黃色光帶在整個黑暗的羣山陰影中顯得非常的突出，多多少少有些寂寥的感覺。夜降了下來，溫度也是。回到旅館吃飯，那個牛肝菌異常美味，菌類特有的香味和彈性在覆着的油光下實在誘人。老闆說這是每年從山上撿的，每年能撿到的時間並不長。以及高原上的白菜豆腐湯也是出乎意料地好喝。</p><p>　　夜深之後，不太適合到處走，景色也沒有明顯的變化，於是我們都回到了房間。這個晚上或許沒有安眠，一方面是對於第二天旅程的各種揣測；另一方面是高原上睡覺是一件麻煩的事。至於後者，是我的同伴們告訴我的。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>　　睡袋的感覺很奇妙，我穿得非常紮實鑽了進去。高原上感冒是一件代價不小的事情，爲此還是穿多點好。我想着嚮導說的話。嚮導說，每年冬天植被稀少，是山上氧氣最缺的時候。上山四五小時侯是高原反應最劇烈的時候，大概在晚上11點。第二天如果能適應高反應該就能登頂。我心裡擔心着X的狀況會不會更惡化。「如果有什麼問題就叫我，我出去叫嚮導，趁夜下山。」我是這麼說的，但也只能這麼辦，儘管我認爲我的體力也很難支撐我走夜路下去。</p><p>　　大家都關了頭燈。在這個烏黑的石頭房裡，那個木質的門框一開一合發出彆扭的聲音。不一會門開了，嚮導出現在門口。「大家先睡吧，明天狀態好我們就去沖頂。」我們簡單回應了一下，嚮導就離開了，走之前用栓子把木門綁上。現在那個吱嘎聲沒有了。「會不會氧氣更少了。」L說。</p><p>　　這個晚上註定不好過。本來我還在對付睡袋逼仄的空間，突然就覺着心率加快。我的心跳聲非常地明顯，無論什麼姿勢都覺着心臟正受到壓迫。同時頭也開始微妙地疼了起來，若有若無，斷斷續續。在我試圖適應這種狀況的時候，旁邊傳來了若有若無的聲音。「幫我叫一下嚮導吧，我覺得我頭要炸了。」是L的聲音。連夜下山的情況我已經預料到了，但L先這樣說還是在我的意料之外的。我答應了一聲，然後又在睡袋裡面躺了一會，決定起身。突如其來的頭疼鑽進了我的腦子，迫使我長長地呼了一口氣。</p><p>　　我戴上頭燈離開了逼仄的石頭房子，進入了大本營的那個平壩。現在這裡安靜且漆黑一片，在這外面我的頭疼也突然得到了緩解。屋子是一棟棟黑影。我迅速地朝着嚮導屋子的方向走了過去。</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>　　棧道比我想象的更加複雜。它看起來是一個輕鬆的選擇，但卻反覆考驗着膝蓋。在進入檢票口以前的一段距離是被棧道負責的。從四姑娘山山底開始，是一截棧道；到了半山腰以後，我們會偏離棧道，進入泥路；最後登頂的路程有一段是石頭路，也是最爲困難的一段。第一天的路程是從山底爬到大峯大本營，距離在17公里左右，從海拔3300抵達4200。也就是今天需要完成的路程。</p><p>　　兩位同伴L和X都是基本沒來過高原的，我在青海西藏都呆過一兩周時間，應該算是能夠接受高原的環境。我試圖找到一個節奏，在棧道上行進。然後我發現兩位同伴的速度略慢一些。這種時候我就杵着我的登山杖，望着還能看得非常清晰的小鎮，等着他們爬上來。這裡的氣候長不了什麼高樹子，所以視線里的都是灌木叢和裸露的地表。再往上一點的山可以很清楚地看見雪的痕跡。</p><p>　　我心裡有了不妙的感覺。斜上方四姑娘山的四座山峯朝着下面看。</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>　　白菜湯出人意料地美味。這個泛白的湯朝着四面八方散發着熱氣，我一不小心喝了三四碗。現在太陽已經完全落下去了，地平線那邊是詭祕的藍紫色，剩下一些細微的地方還留着一丁點紅光。但其實這個場景我一點也看不見，完全是我在這個狹小的黑色屋子裡這樣想象着。這是一個石頭堆成的屋子，除了桌子上懸着的一盞便攜式的燈和嚮導頭上的頭燈，便沒有更多的光亮。</p><p>　　菜很簡單，不過份量很大。吃飯的人是我們一行三人，大本營的負責人和我們的嚮導。我們路上遇見的幾個也是攀登大峯的人不住在這些石頭房子裡，而是附近更高的一個石頭上的帳篷里（他們的處境應該更加窘迫）。能在這個地方吃到熱食確實是令人滿足的事情，感覺身子就突然輕鬆了起來，高原的壓迫也減輕了不少。但情況並不很樂觀。</p><p>　　X的喘息聲在這個逼仄的空間中顯地非常明顯——那種急促、低沉的喘息聲在整個屋子裡遊蕩。X在4000左右海拔的位置就決定騎馬來到大本營，我也是在大本營才再一次見到X。「呀，你嘴脣完全烏啦。」嚮導這樣喊了一聲我才注意到他的嘴，確實是非常不正常的顏色。明天應該不能繼續往上走了，剩下的問題就是今天連夜回去還是明天天亮後再回去。這才讓我覺着冬天來爬這座山是魯莽的行爲，以及在沒有高原經驗的情況下。</p><p>　　無論我覺着這個湯多麼美味，X終究沒有食慾（L則顯地比較正常），很快就結束了晚飯。這個時候我能離開這個黑暗的屋子去外面透口氣，順便看看我想象中的景象。很遺憾的是這個景色比我預計的顏色少了不少。現在太陽已經完全落下去了，只剩下遠遠近近高高低低的山巒邊緣上微弱的光線。四周只有月亮照射的地方反射出藍銀色的光，照出了近處的那個帳篷，一部分平地。黑暗完全掩蓋了我不久前剛剛登上來的路。</p><p>　　我和L勸X多走走，這樣才能適應這裡的環境。X考慮了一陣開始架起他的三腳架，試圖抓住什麼東西。我覺着有些冷，便回了房間。房間裡也是漆黑一片，我很久沒有在這樣黑暗且寧靜的地方呆過這樣漫長的時間了。我想掏出我的電子書看上幾頁，但覺着這樣的溫度里電池會很快耗光，我有覺得有些頭疼，便打消了這個念頭，在黑暗中發着呆。</p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>　　我沒有想到這段路如此漫長，儘管是水泥平路，四周還閃爍着現代科技的路燈，它還是顯得漫長。當我的登山杖觸及到地面的時候，我分明感覺它完全不給我任何支撐地縮短了一截。這個登山杖壞了吧！我心裡這樣想，但我早就知道這個登山杖壞了。我分明覺得腳掌上每一個地方都在喊疼，但是我不能停下腳步。在L說了一句他困了的時候，我才發現我如此清醒。</p><p>　　這本是一段我可以選擇騎馬的道路，但我拒絕了。L和X現在好多了，已經沒有在馬上，而是強打着精神自己走。但他們的步伐比我快多了，我追不上他們。你是一個頑固到了骨子裡的人，我暗罵了自己幾聲，咬牙切齒地，你是一個頑固到了骨子裡的人；這會付出代價——這一點我很清楚。</p><p>　　我沒有心情去留意現在天空的樣子了。昏黃的燈令人感到慰藉又絕望。我看見我拖長的影子在我的前面後面交替閃爍，我如果能有我的影子那樣迅捷的速度就好了，但影子不能比我更快。</p><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p>　　在那個轉角告別了L和X，剩下的路是我一個人的路。這裡大約是14公里的位置，海拔4000左右，距離目標已沒有太遠。手機早已沒有信號，這一路上我們已經消耗掉了所有的水和食物，我的背包中只剩下幾條士力架。</p><p>　　「我的杯子裡還有一兩口水」，我這樣告訴他們，「我大概兩個半小時候就到了。」嚮導爲我指了一下路，說是那山間的石頭房子就是目的地，問我看見了沒有。我滿口說着我看見了，其實我什麼都沒有見着。那邊是兩山交叉的地方，有一條看起來能夠走上去的路。</p><p>　　抵達這裡的時候已經是下午4點了，據嚮導的說法，大部分人這個時候已經接近了大本營，然而我還距離那裡很遠。現在早已離開了棧道，變成了完全的泥地。馬蹄印子深深淺淺，雪也零零落落。路途經過了一兩個寺廟，和播放着防火廣告的電視（這令人非常驚訝，且早就沒有了蹤影）。來的路上偶爾碰到了幾個登去大峯的人，但畢竟每個人都有自己的節奏，沒有聚成同行者的可能，見面聊了幾句之後就各自爬各自的了。</p><p>　　我看着他們騎着的馬遠離了我的視線，曲曲折折地在山脊上遊走，我的道路才真正開始。最後的三公里路。這一段路比之前的更加惡毒，山間的風順着山的一側刮過來，持續不斷。我貪婪地搜索着沒有風的角落，但在我剛剛坐下的時候，一陣更猛烈的風就突然吹了過來。隨着時間的推移，山的陰影開始越來越大，風的溫度也隨之下降。這個時候已經不能長時間的休息了，只需要停上一分鐘，身子就會冷上大半，酸痛和疲勞就會從每個角落湧出來。靠着石頭休息一會吧，半分鐘。</p><h2 id="八"><a href="#八" class="headerlink" title="八"></a>八</h2><p>　　天快黑了，我看見一個登山者靈巧地順着一條窄路往上移動。我應該在剛才他與我擦肩而過的時候向他討一口水喝，就不至於我現在正盯着遠處的積雪想入非非。水是重要的，但冰水恐怕對心臟不利，這不好。我覺得口乾，但沒有任何辦法。或許現在還剩600米了。我往上走兩步，就用登山杖杵着歇一小會。天黑之前我必須走到大本營，不然事情會更加複雜。我側身往下看去，不遠處是那個800米的標牌，旁邊坐着剛剛和我聊過天的另一隊人的嚮導以及那一隊人。他們坐在那裡休息，那裡確實不錯，沒有風，有塊相當大的石頭用來歇腳。我往上望一望，嗯，不遠了。</p><p>　　這恐怕就是口是心非，我大概只知道我需要往上爬，但完全搞不清楚情況。我現在有些頭暈，應該是高原反應的影響吧；兩條腿也開始慢慢不聽使喚，這應該也是高原反應的影響吧。600米。我恍惚間看到遠處的一個山尖上出現了一個人影，他在向我招手。這是L、X還是嚮導？還是說只是我的錯覺？頭疼。</p><h2 id="九"><a href="#九" class="headerlink" title="九"></a>九</h2><p>　　我已經聽見了汽車的聲音，黃色的燈光已經染上了我眼前的區域。很快我就要離開這座山進入現代的世界，然後阻攔在我面前的是一段崎嶇、狹窄、陡峭的下山路。我的同伴已經不見了蹤影，他們並不費力地就消失在了我的視線里。我想起下山的時候，有一段路很陡，嚮導看不了兩匹馬，於是狀況稍好一點的X只能先下馬和我一起跟在馬隊後面。然而X的狀況只是稍好一點，我們只是走幾步路，他就會被黑暗遮住，只剩下頭燈的些微亮光在灌木叢的影子間閃爍。</p><p>　　我現在在他們眼中就是這樣吧，甚至還要狼狽許多。一路上的下山路都是這樣，崎嶇、狹窄且陡峭。我覺得它們磨破了我腳底的每一寸皮，頂破了我的指甲。落腳的時候我覺得麻或者疼。然而這樣的路又一次出現在了我的面前，就在與舒適一牆之隔的地方。每邁出一步我就得嘀咕一些什麼，然後吸一口涼氣。複雜，爬山原來是這麼複雜的事情。我一下子多了許多想要抱怨和咒罵的人和東西，只是因爲我自己的無能、怠惰和執拗。但果然我還是要這樣做，即使我分明地感受到了挫敗。</p><h2 id="十"><a href="#十" class="headerlink" title="十"></a>十</h2><p>　　我的靴子上沾滿了泥土和灰塵，已經和它最開始的樣貌完全不一樣。爬山這樣的事情，我的靴子記得比我更牢，它在一日之內與這座山交談了幾萬次。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>　　完成這篇遊記的時候已經是3月3日了，距離最開始寫作這篇遊記又過去了一段時間，其實一些感受已經淡忘了。我一直在遲疑不定應該講述哪些事情，同時放棄哪些。因爲這實在是一個枯燥且瑣碎的一堆事情擰成一團，但我又不得不認爲這件事情本身有記錄的必要。所以擱置了如此之久，以至於峨眉之行回來後才匆匆結束了這一篇。</p><p>　　希望匆匆了結這篇的另一部分原因是，我在考慮是否需要記錄前幾日峨眉之行（那是另一個複雜的故事）。如果這篇不結束，是沒有辦法做那個考慮的。</p><p>　　我想之後或許還有攀登這座山的機會，儘管我心裡非常清楚這個行程和受苦無異。起名爲《蒙塵記》只是一些自嘲而已，沒有什麼狂妄的想法。那麼就寫到這裡吧。</p><p>2021-3-3，作於家中</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行跡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《金枝》詭言</title>
      <link href="/2020/12/09/essay/%E3%80%8A%E9%87%91%E6%9E%9D%E3%80%8B%E8%AF%A1%E8%A8%80/"/>
      <url>/2020/12/09/essay/%E3%80%8A%E9%87%91%E6%9E%9D%E3%80%8B%E8%AF%A1%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>正式開始閱讀《金枝》，但並沒有什麼特別的目的。也就使抱有好奇心地消磨一些時間罷了。看了沒多久，就發現這是一本充滿了古怪故事和傳統的書。將有趣的地方記下來，應該會很不錯吧。所以這裡記錄的是《金枝》閱讀的過程中收集的有趣的民俗故事。</p><a id="more"></a>  <h2 id="第一章：森林之王"><a href="#第一章：森林之王" class="headerlink" title="第一章：森林之王"></a>第一章：森林之王</h2><ol><li>內米湖旁的祭司：祭司的候補必須殺死祭司才能繼任祭司的職務，祭司會一直擔任這個職務直到死亡。</li><li>森林之王：內米聖殿內有一棵特殊的樹，一般人不能砍下他的樹枝，除了逃亡的奴隸。奴隸能用砍下的樹枝要求與祭司決鬥，一旦成功，他就能繼任祭司的職位，並獲得「森林之王」的稱號。</li></ol><h2 id="第三章：交感巫術"><a href="#第三章：交感巫術" class="headerlink" title="第三章：交感巫術"></a>第三章：交感巫術</h2><ol><li>希望擁有孩子的婦女：在巴伯爾羣島，希望擁有孩子的婦女，需要找到一個多子的男性。這個男性需要做一個布娃娃，讓這個婦女抱在懷中假裝餵奶。然後男性需要將一隻雞舉在婦女的頭上，並念出禱告，希望神接納這個祭品。隨後男性問婦女，「孩子到了嗎？」婦女需要回答，「是的，已經在喝奶了。」隨後需要把雞殺掉，擺上祭壇。四處傳話說這個婦女已經開始分娩了，並請她的女性朋友來賀喜。這是一個祈求生子的儀式。</li><li>懷孕的男巫：達雅克人在婦女難產時，需要找來兩個男巫，其中一個幫助生產。另一個站在門外，把一塊石頭放在自己的肚子上，用布把自己和石頭包裹起來。來回移動自己的石頭，模擬嬰兒的動作，來幫助生產。</li><li>死而復生：在古希臘，如果男子被誤認爲死亡，並舉行過葬禮，那麼他需要：鑽過女人的裙子，洗淨全身，被包裹在襁褓之中送到奶媽那裡。只要這個儀式不結束，他就不能在活人間自由活動。</li><li>治病的鳥：如果罹患黃疸病的人和一隻石鶺鴒對視很久，他的病就會被這隻鳥代爲承擔，因爲鳥的眼睛是金色的。</li><li>生病的醫生：在法國帕奇，如果病人嘔吐不斷，是因爲胃「掉了下來」，需要醫生幫助歸位。醫生採取的行動是，做一些扭曲的動作，將自己的胃也弄脫落，然後繼續扭曲，代表胃的歸位。</li><li>抓捕獵人的陷阱：在柬埔寨，如果一個獵人長時間沒有收穫，他便會脫光自己的衣服，走開一段距離，漫不經心地踩中自己的陷阱，並大叫「哎呀，這是怎麼回事？我被抓住了！」隨後這個網便會被認爲能夠抓到很多獵物。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雜記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>軟件安利（Win10）</title>
      <link href="/2020/12/08/essay/%E5%AE%89%E5%88%A9/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%88%A9%EF%BC%88Win10%EF%BC%89/"/>
      <url>/2020/12/08/essay/%E5%AE%89%E5%88%A9/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%88%A9%EF%BC%88Win10%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一時興起想做這個東西的整理，因爲個人習慣的緣故，會找一些奇奇怪怪的工具挨個嘗試。</p><a id="more"></a> <h2 id="主力軟件"><a href="#主力軟件" class="headerlink" title="主力軟件"></a>主力軟件</h2><p>這一部分是日常中使用最多的軟件集合，基本是在諸多的淘汰篩選後的倖存者。</p><ol><li><strong>Notion</strong>：筆記類工具，模塊化筆記的先驅之一。自從免費帳戶可以在一個工作區內無限創建block的時候開始，這個筆記就穩坐衆多筆記軟件之首（後面多多少少有嘗試過一些別的，但總覺得差一些味道。）能夠輕鬆地公開筆記本，以及導出爲html或者md。自帶的數據庫功能非常驚艷，也是競品沒有的特色。對於它的桌面端，其實就是個網頁的套殼，可以安裝對應的enhancements插件提升桌面端體驗。缺點是離線能力較差。</li><li><strong>Vivaldi</strong>：瀏覽器軟件，多年的瀏覽器主力。Chrome內核。花樣繁多的自定義功能，可以任意調節、隱藏的瀏覽界面。總能夠調整到一個令人滿意的風格。此外，自帶郵件和RSS嗅探等諸多功能。缺點是體量較大，並沒有比Chrome更快。極特色功能是快捷指令。</li><li><strong>VS Code</strong>：編輯器軟件，碼字和碼代碼的主力。自建腳本和異常靈活的快捷鍵都是它的優勢。對於諸多文件格式都有合理的高亮方案。各式腳本也是花樣繁多。常用的包括特殊注釋高亮、AI自動補全、GitLens功能。VSC和GitHub的相性非常出色。同樣帶有Vivaldi那樣的快捷指令。</li><li><strong>Mail</strong>：Win10自帶的郵件軟件，可以很好地使用Outlook和學校郵箱，風格簡單明了，和Win10當然相性是最好的。</li><li><strong>Edge</strong>：PDF閱讀器。流暢的閱讀體驗和極快的打開速度，和Surface的筆也是非常般配，寫寫畫畫體驗甚好。</li><li><strong>便簽</strong>：Win10自帶應用，支持Surface筆，打開迅速。在遇到需要短時間記錄信息的時候使用（就不用新建txt了）。</li><li><strong>Listary</strong>：強有力的文件搜索軟件和啓動器。快速導航到打開文件夾的能力非常強悍。對於程序員而言，能在文件瀏覽器內飛速在當前位置打開cmd是非常必要的功能。</li></ol><h2 id="主力軟件輔助"><a href="#主力軟件輔助" class="headerlink" title="主力軟件輔助"></a>主力軟件輔助</h2><p>這一部分軟件是爲了彌補之前的軟件的一些缺陷而偶爾使用的軟件。</p><ol><li><strong>Chrome</strong>：出於多種原因，這個軟件還是得用。</li><li><strong>Typora</strong>：儘管編輯任務已經全部交給VSC了，偶爾也需要使用Typora查看一下內容或者導出爲特殊風格的PDF。如果只是碼字的話，這個軟件也是非常好用。（但不知道爲什麼會有點慢。</li><li><strong>OneNote</strong>：寫寫畫畫的時候，就會打開這個軟件。</li><li><strong>Aurora Music</strong>：界面美麗的音樂播放器。在不想使用流媒體打擾自己的時候，一個小巧精美的本地播放器總是有用的。</li></ol><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>這一部分是一些輔助工具。</p><ol><li><strong>Snipaste</strong>：截屏工具。可以在任意界面截屏，提取色號，對截屏批註，或者將截屏釘在桌面上。非常實用且簡單的軟件，使用頻率也異常高。</li><li><strong>QuickLook</strong>：快速查看文件的軟件。使用空格可以快速打開md等文本文件，以及圖片文件、音樂文件等等。只是需要瀏覽圖片文件，而不用修改的情況下使用。</li><li><strong>ModernFlyouts</strong>：一個裝飾性軟件。將音量增減、亮度增減、大小寫轉換等空間，用更符合Fluent Design的規格呈現出來。</li><li><strong>f.lux</strong>：自動調節屏幕色溫軟件。在夜晚變得溫暖。</li><li><strong>SSR</strong>：酸酸乳，方便地飛出高牆。</li><li><strong>AutoHotKey</strong>：實現按鍵重映射的軟件。由於個人習慣使用”Ctrl+W”這樣的指令關閉軟件，然而Win10沒有一個方便的修改快捷鍵的方案，所以使用這個軟件重映射。此外一些按鍵也可以通過這個方法凍結。</li><li><strong>Fences</strong>：桌面管理軟件。將桌面的圖標自動歸類到預設的格子中。至少桌面是整潔的。</li><li><strong>SpaceKeteer</strong>：查看文件占用空間的軟件。將文件占用的空間按照餅狀圖呈現出來，並可以下降到更深的文件夾查看更細緻的占用空間情況。方便快速找到占用空間大的無用文件。</li><li><strong>火絨</strong>：防火牆軟件。能查看並阻止具有啓動權限的軟件自啓，還具有管理右鍵菜單種種功能。</li></ol><p>大概就是這樣了。實在是沒啥稀奇的。因爲個人使用習慣的緣故，凡是能塞到Web里的軟件，都交給瀏覽器負責了，所以具有客戶端的軟件大多是小修小補的功能性軟件或者，放不進Web里的大軟件（比如Anaconda，Unity…）。可能真正稀奇古怪的軟件都在手機里吧。以及上述部分介紹實在簡單地過分了點（比如Vivaldi和VSC），這些軟件等到之後在整理的時候補上更完整的表述吧。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安利 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>投子記</title>
      <link href="/2020/11/29/essay/%E6%8A%95%E5%AD%90%E8%AE%B0/"/>
      <url>/2020/11/29/essay/%E6%8A%95%E5%AD%90%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>冬天總是有諸多值得稱讚的優點，空空蕩蕩的周日晚上的光華樓便是其中之一。總是寒冷這樣的東西更有利於思考，熱氣則與之相反。所以我討厭在並不很冷的場合開熱空調的人，但對於那些在夏天開冷空調的人也喜歡不起來。 —— 在回寢室的路上，手上握着一個全家買的飯糰，我不得不這樣想。</p><a id="more"></a>  <p>希望是一種複雜的東西，情感也是。比如晚上學校的林蔭道上，依偎黏糊在一起的情侶到處都是。他們希望從這樣的關係中獲得什麼東西，是類似信賴還是被稱作目標的東西？我想起之前一個朋友說，大學裡是比較孤獨的，人常常會喪失自己的立場變得軟弱起來，這個時候需要一個能夠依靠的人。是這樣的嗎？果然是複雜的東西。 —— 在回寢室的路上，看着在林蔭道上走着的幾對情侶，我不得不這樣想。</p><p>這個時候和我一樣呆在這個教學樓里的人，在想一些什麼事情？在這個寧靜的、有些寒氣的、漆黑的晚上？這裡的人應該各有各的愉悅或者擔憂的事情（它門總是到處都有）。只是這一份寧靜就足以使人感到長久的快樂，但哪怕一點點動靜都會突然破壞這一份美好，變得尷尬起來。 —— 傍晚在教學樓里準備實驗報告的時候，發現整棟樓里沒有幾個人的時候，我不得不這樣想。</p><p>美好的食物是一個事件，而不是一個東西。只有在那個時刻，吃下的那個特定的食物，它的美味才會發揮出來，變成記憶里的某種東西。於是常常聽到，「之前某一次吃的和這一次不一樣，那一次要更加……」這樣的言論，但終於怎麼找尋都遇不到「那次」的食物。莫名地對於這些即將吃下的食物的期許會成爲巨大的負擔，讓第二次被品嘗的食物肩負的責任和第一次迥然不同。它不提供美味，而提供「像那樣的美味」的體驗。從另一個角度來看，被吃下的食物就變化了。所以食物是一個事件，一旦被吃下了，就不會再次到來。 —— 傍晚有朋友給我發來消息，說這一次的烤饅頭，他不小心點多了並覺得不太好吃的時候，我不得不這樣想。</p><p>白天在寢室睡覺的人是奇怪的東西。出於習慣的考慮，或許我並不批評那些午睡的人，也不批評那些晚起的人，也不批評生物鐘顛倒的人。而是在下午三四點、傍晚六七點莫名其妙地睡覺，晚上也睡得充足的人。我不知道爲什麼我會覺得這一部分人奇怪或是莫名其妙，但總之這個事實令人不爽。仿佛生活是這樣困難的東西，就連白天也沒有行動的能力。 —— 傍晚我回到寢室，發現寢室里有人開着空調正在睡覺，我不得不又一次逃離這裡的時候，這樣想。</p><p>快樂也是一種匪夷所思的東西。在揮拍的時候，我並不覺得多麼快樂。球以美妙的弧線和速度落在另一半球場的時候，我也不覺得多麼快樂。球擊中球拍的某個部位，那個部位將震動傳遞到我的手上，然後傳遞給我的大腦，於是我覺着我擊中了球。但這樣就能使人快樂嗎？我是因爲快樂，才此時站在球場上的嗎……或許是類似成就感的東西吧？比起這些勞神費力的工作，今天的明亮的月亮更加令人覺得舒暢。 —— 站在球場上，擊回一顆球並且出界的時候，我不得不這樣想。</p><p>人的喜好總是難以捉摸。有一波人喜歡這樣一些東西，另一撥人喜歡那樣一些東西。對於一部分人索然無味的點，在另一部分人眼中則誘人到異常。越是容易被大衆所喜愛的事物，越是有着廣泛的概念，類似可愛、溫暖這些字眼；越是小衆冷門的事物，框定的範圍就越狹窄。我想當這些廣泛的關鍵詞被使用的時候，或許只是出於慣性地使用了它門，而非真正如此認爲，或者它沒有構成真正表示喜惡的理由，又或者出於語言的匱乏，才如是表達；而當一些狹窄的關鍵詞被使用的時候，或許是出於時髦而使用了它門，而非真正如此認爲……人總是無法稱心如意地創造自己的語言，因爲語言是用來交流的工具。 —— 當我在動漫的彈幕里發現了一大片「可愛」之類字眼的時候，不得不這樣想。</p><p>大多數問題沒法回答也沒什麼價值，但問題都會或多或少使人感到好奇，而沒有答案的問題就會使人沮喪。我自然不希望人是如此容易被理解且無聊的東西 —— 他們應該更複雜多變，但多變或許促使了另外一種無聊的誕生。完。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插件安利</title>
      <link href="/2020/11/20/essay/%E5%AE%89%E5%88%A9/%E6%8F%92%E4%BB%B6%E5%AE%89%E5%88%A9/"/>
      <url>/2020/11/20/essay/%E5%AE%89%E5%88%A9/%E6%8F%92%E4%BB%B6%E5%AE%89%E5%88%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>這裡是一些安利的Chrome插件（新開了「安利」的Tag），從原來的網站頁獨立出來。就是一些古怪的插件而已。</p><a id="more"></a>  <p>由於我使用的瀏覽器 Vivaldi 提供了太多的功能，這些功能部分與一些非常優秀的插件衝突。但出於個人習慣，不對這類優秀插件進行記錄，但歡迎告知。</p><ol><li><a href="https://chrome.google.com/webstore/detail/embark-new-tab-page/aeajehgeohhgjbhhbicilpenjfcbfnpg" target="_blank" rel="noopener">Embark</a>：一個 Tab 插件，新 Tab 爲數字時鐘，背景爲一些風景照。</li><li><a href="https://chrome.google.com/webstore/detail/mainichi/dfekdjmdikicceaiokcmmchenpilglhn" target="_blank" rel="noopener">Mainichi</a>：一個 Tab 插件，新 Tab 爲一個小色塊，裡面是不同的圖片，及其對應的日語平假名、日文漢字及讀音。</li><li><a href="https://chrome.google.com/webstore/detail/幾枝/hfohpokminpknagcgncibpacohagppjn" target="_blank" rel="noopener">幾枝</a>：一個 Tab 插件，新 Tab 爲橫置或豎置的兩句古詩（標註作者和標題），以及一些不算艷麗的波浪做底。</li><li><a href="https://chrome.google.com/webstore/detail/new-tab-startup-quotes/bljnhgkajocmhlflgefahihojeajhjji" target="_blank" rel="noopener">New Tab Startup Quotes</a>：一個 Tab 插件，新 Tab 爲一句企業家的名言、雞湯，背景爲白色。</li><li><a href="https://chrome.google.com/webstore/detail/imagus/immpkjjlgappgfkkfieppnmlhakdmaab" target="_blank" rel="noopener">Imagus</a>：方便快速地查看 Web 中的圖片。</li><li><a href="https://chrome.google.com/webstore/detail/kami-extension-pdf-and-do/ecnphlgnajanjnkcmbpancdjoidceilk" target="_blank" rel="noopener">Kami</a>：閱讀並批註 PDF，可以和 Google Drive 同步。作爲 PDF 閱讀器，功能強大。</li><li><a href="https://chrome.google.com/webstore/detail/minimal-scrollbar/ekopmclclddpoipchmcbhifohhbmjafd" target="_blank" rel="noopener">Minimal Scrollbar</a>：縮小瀏覽器默認的粗大的滾動條。</li><li><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">Proxy SwitchyOmega</a>：管理使用的網絡代理方案。</li><li><a href="https://chrome.google.com/webstore/detail/沙拉查詞-聚合詞典劃詞翻譯/cdonnmffkdaoajfknoeeecmchibpmkmg" target="_blank" rel="noopener">沙拉查詞</a>：網頁上快速查詢英文詞彙，很方便。</li><li><a href="https://chrome.google.com/webstore/detail/爲什麼你們就是不能加個空格呢？/paphcfdffjnbcgkokihcdjliihicmbpd" target="_blank" rel="noopener">爲什麼你們就是不能加個空格呢？</a>：自動給中英文加上空格。注意：這個功能和部分文字框存在衝突（例如 Overleaf。）</li><li><a href="https://chrome.google.com/webstore/detail/nutab/hbflaeaeaoabekejplknlenmohgoaodj" target="_blank" rel="noopener">nuTab</a>：一個 Tab 插件，插件爲一個空白的 Markdown 界面，可以隨時修改。並且可以添加喜歡的網站到該界面方便隨時訪問。（非常適合建立待辦的方法。）</li><li><a href="https://chrome.google.com/webstore/detail/rsshub-radar/kefjpfngnndepjbopdmoebkipbgkggaa" target="_blank" rel="noopener">RSSHub Radar</a>：主動嗅探網頁支持的SSR資源，包括B站漫畫等等。</li><li><a href="https://chrome.google.com/webstore/detail/notion-web-clipper/knheggckgoiihginacbkhaalnibhilkk" target="_blank" rel="noopener">Notion Web Clipper</a>：Notion官方的內容收納工具，不過沒有印象筆記的同樣插件好用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安利 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stopping by Woods on a Snowy Evening</title>
      <link href="/2020/11/17/essay/poems/Stopping%20by%20Woods%20on%20a%20Snowy%20Evening/"/>
      <url>/2020/11/17/essay/poems/Stopping%20by%20Woods%20on%20a%20Snowy%20Evening/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-looWFbdt" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1060914" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>如<em>Out of the Rolling Ocean the Crowd</em>中所言，這裡是接受委託翻譯的原詩，以及個人的拙劣的翻譯。</p><a id="more"></a>  <h2 id="原詩"><a href="#原詩" class="headerlink" title="原詩"></a>原詩</h2><h3 id="Stopping-by-Woods-on-a-Snowy-Evening"><a href="#Stopping-by-Woods-on-a-Snowy-Evening" class="headerlink" title="Stopping by Woods on a Snowy Evening"></a>Stopping by Woods on a Snowy Evening</h3><p>by Robert Frost</p><blockquote><p>Whose woods these are I think I know.<br>His house is in the village though;<br>He will not see me stopping here<br>To watch his woods fill up with snow.</p><p>My little horse must think it queer<br>To stop without a farmhouse near<br>Between the woods and frozen lake<br>The darkest evening of the year.</p><p>He gives his harness bells a shake<br>To ask if there is some mistake.<br>The only other sound’s the sweep<br>Of easy wind and downy flake.</p><p>The woods are lovely, dark and deep,<br>But I have promises to keep,<br>And miles to go before I sleep,<br>And miles to go before I sleep.</p></blockquote><h2 id="翻譯"><a href="#翻譯" class="headerlink" title="翻譯"></a>翻譯</h2><h3 id="駐足林間雪夜"><a href="#駐足林間雪夜" class="headerlink" title="駐足林間雪夜"></a>駐足林間雪夜</h3><p>我想我認識這個林子的主人，<br>他的屋子就在不遠處的村里；<br>他不知道有人在這裡駐足，<br>爲看着他的林子灌上冬雪。</p><p>我的小馬駒必覺得古怪，<br>爲他所停之地，附近沒有農家<br>在林子與結冰的小湖間，<br>在這年最幽暗的傍晚里。</p><p>他晃起他刺耳的鈴鐺<br>問我是否搞錯了什麼。<br>這之外只有細簌聲響，<br>是習風吹拂雪花滑落。</p><p>這個可愛、幽暗而深邃的林子呵，<br>但我還有需要遵守的諾言，<br>在安睡前還有數里路得走呵，<br>在安睡前還有數里路得走。</p><h2 id="遇到的值得推薦的翻譯"><a href="#遇到的值得推薦的翻譯" class="headerlink" title="遇到的值得推薦的翻譯"></a>遇到的值得推薦的翻譯</h2><h3 id="雪夜林駐"><a href="#雪夜林駐" class="headerlink" title="雪夜林駐"></a>雪夜林駐</h3><p>林主我應識，屋舍村中棲。<br>不見我駐馬，獨看雪滿枝。<br>小馬當踟躕，何故停荒隅？<br>今歲最黑夜，幽林間冰湖。<br>擺頸響鈴語，問訊何差池。<br>萬籟皆寂寂，雪軟風依依。<br>佳林何幽深，有約不能遲。<br>前路幾多遠，方到入夢時。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>不太想談對於這首詩歌的理解。倒是想說說翻譯的過程。翻譯這首的難點或許在於原詩的那種微妙的意境，是一層輕薄的紗，一捅就破。讀到後面，仿佛有一種」小橋流水人家「的味道。但又不那麼有力，而是親切地、溫和地滿進來，是哀而不傷的味道。</p><p>這個翻譯的事情挺好玩的。本來只是友人讓我幫忙想想。於是思考翻譯的途中，自己爲了整理思路翻譯了一個版本。既然翻譯出來了，不妨拿來做一做盲評，於是揀選了一些已有的翻譯給大家評價。這個評價的結果姑且不言，整個過程實在是充滿了樂趣。討論的人羣壯大起來，傳來傳去，突然有一種雅集的味道。想想以後或許還能夠組織一點點這樣的趣味活動，解解乏。</p><p>以及我考慮之後聽從了大家的意見，把第二節後兩句最開始的第一個」且「字去掉了。此外由於自己水平不夠，於是完全放棄了對於原詩韻律的呈現，不得不說是一個相當大的缺陷。歡迎讀者也嘗試一下咯。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 詩歌？ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Out of the Rolling Ocean the Crowd</title>
      <link href="/2020/11/17/essay/poems/From%20the%20rolling%20ocean/"/>
      <url>/2020/11/17/essay/poems/From%20the%20rolling%20ocean/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一位友人突然由於翻譯課找到我，邀請我一起翻譯佛洛斯特的詩歌<em>Stopping By Woods on a Snowy Evening</em>，想起了早些時候翻譯的這一首惠特曼的詩。所以放一個原文在這裡當作一個記錄，翻譯稿已經不太找的到了。歡迎有興趣的讀者自行嘗試翻譯。</p><a id="more"></a>  <blockquote><p>Out of the Rolling Ocean the Crowd<br><strong>Walt Whitman</strong><br>Out of the rolling ocean, the crowd, came a drop gently to me,<br>Whispering I love you, before long I die,<br>I have travel’d a long way, merely to look on you to touch you,<br>For I could not die till I once look’d on you,<br>For I fear’d I might afterward lose you.</p><p>Now we have met, we have look’d, we are safe,<br>Return in peace to the ocean my love,<br>I too am part of that ocean, my love, we are not so much separated,<br>Behold the great rondure, the cohesion of all, how perfect!<br>But as for me, for you, the irresistible sea is to separate us,<br>As for an hour carrying us diverse, yet cannot carry us diverse forever;<br>Be not impatient—a little space—know you I salute the air, the ocean and the land,<br>Every day at sundown for your dear sake my love.</p></blockquote><p>這首詩原文很清晰，但恐怕翻譯起來難度不小。就以最後一句爲例，實在是很難搞定這種英文表達帶來的奇妙感受。Anyway，我先嘗試完成佛洛斯特的那首小詩吧。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 詩歌？ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被打斷的馬七</title>
      <link href="/2020/11/16/essay/music/%E8%A2%AB%E6%89%93%E6%96%AD%E7%9A%84%E9%A9%AC%E4%B8%83/"/>
      <url>/2020/11/16/essay/music/%E8%A2%AB%E6%89%93%E6%96%AD%E7%9A%84%E9%A9%AC%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>上海音樂學院歌劇院建成沒有多久，第一次進這個廳。但體驗實在一言難盡。</p><blockquote><p>地點：上音歌劇院<br>時間：2020年11月8日<br>指揮：張亮<br>樂團：上海愛樂交響樂團<br>座位：樂池正前方偏音樂廳後部<br>開始前的食物：港式餐廳</p></blockquote><a id="more"></a>  <p>　　《馬七》本身是一部晦澀的作品，在此之前聽了很多次也不得要領。由於這部作品的冷門，對於這種部作品的討論也很少。令人印象最深刻的果然還是第一樂章最開始的那個標誌性的不和諧音。比較有趣的地方是第一次見識到這麼多配器的同時使用。吉他、曼陀鈴、管鍾、鋼片琴、沙錘、鑼等等。特別是曼陀鈴的聲音，十分獨特有趣。（當時我聽到曼陀鈴的時候想了很久這個樂器是什麼，發現是曼陀鈴之後又在樂池裡找了一陣子。果然我對這個曲目非常不熟悉。）最後的疑惑是，現場的吉他應該是加了擴音器的。但是在馬勒的時代，擴音器也被使用了嗎？如果沒有，後面的觀衆想必聽不見吉它的聲音吧。<br>　　<br>　　但聽完的感悟果然還是我不懂這部作品。不知道它在描繪什麼樣的意境，有什麼樣的故事。雖然其名爲夜曲，在第三樂章依舊十分張揚。我實在沒太懂。樂團現場演繹平平，不過衆多的獨奏沒有明顯翻車還算不錯。</p><p>　　然後是上愛。不知道是不是由於這是新開放的音樂廳，觀衆尚沒有建立起好的禮儀。在第一個樂章結束的時候，竟然傳來了不小的鼓掌聲。甚至有一些沒能及時入場的觀衆在這個時候入場，使第二樂章和第一樂章完全割裂，意境全無。更甚的是，在後面每一個樂章間，觀衆依舊鼓掌，聲音甚至更大了。實在不太能理解。</p><p>　　以及進場的手續問題。爲了進場，經過了檢查健康碼、形成碼、兩次驗票種種繁雜冗餘的步驟，是在給人留下了很糟糕的印象。想上一次聽貝多芬也不是如此場景，實在滑稽。</p><p>　　總而言之，是一場不太妙的演出。也很難給人留下深刻的印象。着實有些失望。最後回寢室的路上。聽見一起去現場的樂迷朋友說，上交的某場演出，有一次因爲觀衆在樂章間鼓掌，指揮轉過身用指揮棒指着那個鼓掌的區域良久。上交的觀衆確實是不鼓掌的，在我印象里。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Joseph&#39;s S8</title>
      <link href="/2020/10/22/essay/Joseph&#39;s%20S8/"/>
      <url>/2020/10/22/essay/Joseph&#39;s%20S8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-CtPgfDgH" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="472141225" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>　　今日他的使命至此終結。把他的自動開機，鬧鈴取消後，關機放在一邊，頓時五味雜陳。從此之後，Joseph 的藍牙配對菜單少了這樣一個朋友。多圖預警。</p><a id="more"></a> <p>　　他的前任是黑莓 Z10，另一個手機巨頭的絕唱。在 2017 年，年初，三星上半年期間 Galaxy s8 發布。那個時代的安卓機統一爲魅族初創的三合一 Home 鍵，蘋果仍停留在粗笨的 iPhone 6 時代的風格。高考結束後不久，這樣一個手機出現在了我的手中。我還記得很清楚，當時坐在地鐵上，我小心翼翼地，把他放在了他的包裝盒裡。父親問我爲什麼不多用用，我不記得我回答了什麼。但那是真正的，滿足的感覺。s8 回應了我的期待。</p><p>　　快四年過去了。這一系列依此發布了 s9，s10，s20 三部。整個手機圈也出現了翻天覆地的變化，國產手機全面崛起，屏下指紋、120 瓦充電、120Hz 高刷，並搶先進入 5G 時代。經歷了薩德事件和 Note7 事件，推出 s8 的三星在 17 年已經在國內市場站在邊緣。如今三星已淪爲了每年年報的 Others 角色，而蘋果僅以自研芯片和 iOS 站穩腳跟。手機的形態也是千變萬化，從三星、小米各自給出一套方案，隨後蘋果發布 iPhone X，將劉海屏推向市場。安卓機淪爲一片劉海和水滴屏的世界，其後挖孔屏和機械結構升降屏也出現在了市場。</p><p>　　非常遺憾。</p><p>　　我的 s8 是當時被稱爲「煙晶灰」的一個顏色，機身通體顏色保持暗銀色，在深沉的光線下會透出紫色。在當時一衆 5.4 寸手機中引入 5.8 寸 18：9 屏幕（當然之前還有突破性的小米 Mix 一代。）鶴立雞羣。流暢的曲面設計和完全對稱的真反面，讓整個手機變成一個深邃的鵝卵石，在平面上幾乎一個可以滾動的水珠。前面板上下邊框寬度完全對稱，左右邊框則被曲面屏隱藏起來，完成了在那一年最爲令人驚艷的作品。我很慶幸當時我做出了正確的選擇，在之後幾年一直至今我從未遺憾。</p><p>　　s8 基本是這段時間陪伴我時間最長的物件。剛拿到手機時會不斷地倒騰各種新奇的功能，開發無數新鮮的玩法。恰好 s8 是一個藏寶系統，即使在我前幾天仍在使用的途中我也能發現新鮮的功能。後面慢慢熱情消卻了，手機更多變成了一個工具而非一個玩具。收發信息、掃碼付款變成了他的常態工作。但是每一次，當我把他放在桌子上的時候，新消息進入了我的手機，他那圓潤的邊框閃爍起一陣流光溢彩，我便能再一次欣賞他的風姿。</p><p>　　兩個月前，我去掉了他的殼子。起因是我希望給後背清清灰，但就是這樣的一個瞬間，我拿起他的時候，仿佛發現了一個新的東西，一種新的體驗。是令人感動的手感和難以置信的輕便，從此他便以這樣的姿態繼續存在在我的生活中。三年多過去了，我還是偶爾會抱怨他突然卡起來，偶爾又掉電迅速。但畢竟已經有些年紀了，我便不爲難他。</p><p>　　「手機」這樣的工具，由於時時刻刻呆在自己身邊，沾染了自己的氣味，變得人性。從圖標到壁紙，系統組件的顏色，各式工具的選擇和搭配，都是手機用戶性格的烙印。每次到晚上十一點時，看見他提醒我去查看明日的日程；到十二點時，他提醒我去休息。儘管我都不太聽他的，但是仍爲他的執拗感到快樂。我今天中午進入食堂的時候在想（那個時候，s8 正放在我的桌子上），他知道自己就要離開我了嗎，他知道自己之後提醒休息的是另一個人了嗎（這部手機之後會交給母親，她或許希望繼續使用，不過這個看她）。我是該爲他知道「我」是我而高興，還是爲他不知道「我」是我而高興呢？</p><p>　　或許之前就是所謂的戀舊吧。我不願意把這個理解爲是我習慣於自己的習慣，而狀況在改變時感受到的不習慣。而是一種更加複雜的東西，或許是一種真摯的喜愛和抱歉的心情。</p><p>　　這麼多年後，我還想得起，當時在三星專賣店，第一次看到它的時候，聽見的那首歌。那一切的場景，都如此生動。啊，哎。很高興遇到你，在那個時候，那個地點。</p><p>　　以下是他陪伴我走過的地方，見證過的風景。</p><center><img src="/images/Things/s8/1.jpg" width="80%" height="80%" />攝於17年9月4日，復旦大學南區，剛剛入校。</center><center><img src="/images/Things/s8/2.jpg" width="80%" height="80%" />攝於17年9月7日，復旦大學南區，住宿區樓下的貓。</center><center><img src="/images/Things/s8/3.jpg" width="80%" height="80%" />攝於17年9月20日，復旦大學本部，社團招新。</center><center><img src="/images/Things/s8/4.jpg" width="80%" height="80%" />攝於17年9月23日，家樂福里的奇怪物種。</center><center><img src="/images/Things/s8/5.jpg" width="80%" height="80%" />攝於17年9月28日，前往張江參加中秋活動，從張江回本部途中。</center><center><img src="/images/Things/s8/7.jpg" width="80%" height="80%" />攝於17年10月01日，遇見我喜歡的專輯。</center><center><img src="/images/Things/s8/9.jpg" width="80%" height="80%" />攝於17年11月11日，去同濟蹭的音樂會。</center><center><img src="/images/Things/s8/10.jpg" width="80%" height="80%" />攝於17年12月11日，正在上大物課的時候往窗外望去。</center><center><img src="/images/Things/s8/11.jpg" width="80%" height="80%" />攝於17年12月12日，爲了給嘉祥的校友加油，在校門前錄像時天氣甚好。</center><center><img src="/images/Things/s8/12.jpg" width="80%" height="80%" />攝於18年1月25日，寒假回家，和三弟重訪三星堆。</center><center><img src="/images/Things/s8/13.jpg" width="80%" height="80%" />攝於18年2月15日，家裡對面的湖，湖旁的櫻花樹開了。</center><center><img src="/images/Things/s8/14.jpg" width="80%" height="80%" />攝於18年3月18日，相輝堂開膛演出。</center><center><img src="/images/Things/s8/15.jpg" width="80%" height="80%" />攝於18年4月27日，去同濟蹭的踢踏舞，坐在第一排正中央。</center><center><img src="/images/Things/s8/16.jpg" width="80%" height="80%" />攝於18年5月4日，復旦旦苑的54套餐，一點也不好吃。</center><center><img src="/images/Things/s8/17.jpg" width="80%" height="80%" />攝於18年7月9日，丹霞地貌，在前往甘肅支教途中。</center><center><img src="/images/Things/s8/18.jpg" width="80%" height="80%" />攝於18年7月18日，調研當地非遺時特意造訪的一個「景點」，其實只有一個小寺廟。</center><center><img src="/images/Things/s8/19.jpg" width="80%" height="80%" />攝於18年8月19日，和同學一起去烏鎮。烏鎮的牆很美。</center><center><img src="/images/Things/s8/20.jpg" width="80%" height="80%" />攝於19年1月17日，期末季結束後去看現代藝術展。</center><center><img src="/images/Things/s8/21.jpg" width="80%" height="80%" />攝於19年5月27日，校慶的那天，食堂里的西瓜。</center><center><img src="/images/Things/s8/22.jpg" width="80%" height="80%" />攝於19年7月5日，去珠三角調研時，一羣人去點都德吃早茶。「菜單上的通通來一份！」</center><center><img src="/images/Things/s8/23.jpg" width="80%" height="80%" />攝於19年7月19日，和Bobby去看《不眠之夜》，我將再去一次。</center><center><img src="/images/Things/s8/24.jpg" width="80%" height="80%" />攝於19年8月1日，抵達新加坡，第一次去魚尾獅。</center><center><img src="/images/Things/s8/25.jpg" width="80%" height="80%" />攝於19年9月8日，第一次聽到管風琴的獨奏。</center><center><img src="/images/Things/s8/26.jpg" width="80%" height="80%" />攝於19年10月10日，新國立Utown的裸眼3D繪畫，應該是一個到處旅遊的畫家畫的。</center><center><img src="/images/Things/s8/27.jpg" width="80%" height="80%" />攝於19年12月4日，將離開新加坡前和Bobby吃的一頓鰻魚飯，芥末很棒。</center><center><img src="/images/Things/s8/28.jpg" width="80%" height="80%" />攝於21年1月7日，返回成都前先前往了哈爾濱。抵達的第一天晚上，民宿小區裡的兔子。這裡一點都不冷。</center><center><img src="/images/Things/s8/29.jpg" width="80%" height="80%" />攝於20年1月8日，前往拜訪聖索菲亞大教堂，可惜它還在裝修內飾。</center><center><img src="/images/Things/s8/30.jpg" width="80%" height="80%" />攝於20年1月10日，和三弟前往滑雪的途中。</center><center><img src="/images/Things/s8/31.jpg" width="80%" height="80%" />攝於20年5月1日，和幾位朋友徒步峨眉山。見到洗象池的時候，剛好兩腿抽筋，跪在了面前。</center><center><img src="/images/Things/s8/32.jpg" width="80%" height="80%" />攝於20年5月2日，峨眉山的日出。</center><center><img src="/images/Things/s8/33.jpg" width="80%" height="80%" />攝於20年9月23日，貝多芬！</center><center><img src="/images/Things/s8/34.jpg" width="80%" height="80%" />攝於20年10月3日，在光華樓附近看到一個眯着眼睛在草地上打滾的貓。</center><p>感謝你，我的 s8。</p>    <div id="aplayer-wfsdLUJy" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5052770" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物志銘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>‘Monster’观感（下）</title>
      <link href="/2020/10/20/essay/%E8%A7%82%E6%84%9F/Monster%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2020/10/20/essay/%E8%A7%82%E6%84%9F/Monster%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>请注意：该版本目前为草稿！请谨慎食用。</p></blockquote>    <div id="aplayer-tNRWjCBe" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="461353" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="评价：★★★★★"><a href="#评价：★★★★★" class="headerlink" title="评价：★★★★★"></a>评价：★★★★★</h3><p>　　这里是 Monster 剧评的后半部分。这一部分主要讨论人物塑造和主题问题。由于讨论内容的特殊性，将不可避免地剧透。请未观看过该部作品的读者一定不要进入后续剧情章节，除非各位觉得剧透并不是那么严重的问题。此外，本文作者没有经过任何仔细研究，本文内容请视为完全主观甚至胡说八道的。</p><a id="more"></a>  <h2 id="一个概述"><a href="#一个概述" class="headerlink" title="一个概述"></a>一个概述</h2><p>　　对于本部分的内容，个人并不希望将人物和其对应的主题区分开；而是以某些角色为核心，在阐述这些人物是如何构造的同时，讨论这篇人物对应的主题。这样的结构之所以可以实现，得益于 Monster 主题的多元性和模糊性。在观看的过程中我不得不认为，不同角色承载的主题是截然不同的，然而其整体又构成了一个大的主题（有的人说是“人性”，但个人并不认为是非常好的概括吧，这个概括太偷懒了。）</p><p>　　此外，不得不承认 Monster 涉及的众多主题，包括小人物身上承载的主题，是难以逐一梳理的。类似博德曼律师承载的“对于正义的执念”，迪特身上承载的“在接下来的日子寻找快乐”，以及 511 院长引出的“爱的教育”。这些小单元都有自己的精彩和值得思考的问题。我们将直接对这些问题放弃讨论。而将注意力放在以下二级标题的四个主题和对应的人物上。</p><p>　　在这一部分结束后，我将试图对于整部作品提出一些有趣的问题。由于这部作品充分留白的性质（我当然指的不是剧情上合理的解释这样的问题），一些问题存在一定思考的空间。在此之后，是对整部作品及本人的评价的一个简单总结。</p><p>　　P.S. 在本章节开始前，我试图部分回收上半部分的观点，对于 BGM 的批评。本作的 BGM 在大多数情况下是合理的，但是也不乏出戏的 BGM。上半部分中可能将这一点说得过重了一点，在此声明。</p><h2 id="葛利马、超人苏坦纳、没有悲喜的"><a href="#葛利马、超人苏坦纳、没有悲喜的" class="headerlink" title="葛利马、超人苏坦纳、没有悲喜的"></a>葛利马、超人苏坦纳、没有悲喜的</h2><p>　　葛利马首先出现在第 40 集，名为“Grimmer 的章节”。以葛利马为题的集数分别为第 42 集“The Adventures of the Magnificent Steiner”，及第 71 集“The Magnificent Steiner’s Rage”。期间自 52 集开始，葛利马承担罪责开始逃亡并进入暗线调查卢恩海姆，一直到 68 集重新进入主线。</p><h2 id="约翰、怪物、没有名字的"><a href="#约翰、怪物、没有名字的" class="headerlink" title="约翰、怪物、没有名字的"></a>约翰、怪物、没有名字的</h2><h2 id="天马、医生、无所适从的"><a href="#天马、医生、无所适从的" class="headerlink" title="天马、医生、无所适从的"></a>天马、医生、无所适从的</h2><h2 id="怪物是谁？"><a href="#怪物是谁？" class="headerlink" title="怪物是谁？"></a>怪物是谁？</h2><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> Draft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兩隻金烏（下）</title>
      <link href="/2020/10/20/essay/%E4%B8%A4%E5%8F%AA%E9%87%91%E4%B9%8C%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2020/10/20/essay/%E4%B8%A4%E5%8F%AA%E9%87%91%E4%B9%8C%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　金烏每日自陰影處起飛，連續飛翔一日到陰影處停歇，凡飛過之處，皆一片光明燦爛。</p><p>　　　　——《華嵇紀-卷三》</p><a id="more"></a>  <h2 id="古怪的畫家（一）"><a href="#古怪的畫家（一）" class="headerlink" title="古怪的畫家（一）"></a>古怪的畫家（一）</h2><p>　　當他從上級那裡接到任務時，很詫異。</p><p>　　他從來都只是一個抓小偷小販的警察，沒什麼能耐，更對不上人們稱呼的「可敬的人民衛士」。除了可以每天每夜在一個地方蹲崗而無抱怨之外，毫無特色。上一次立功，就是因爲在一個酒店的門前，他連續守了兩個月，每日就吃些簡單幹糧過活。當嫌疑人終於大搖大擺出現在他的面前的時候，他差點沒有力氣抓捕嫌疑人。這都是些不足掛齒的事情，但是這次不一樣。他突然覺得有什麼，可以讓他一下子飛黃騰達的機會；但也同樣，可能意味着再也無法升遷。收到上級給他的資料後，他收拾收拾立刻就出門了。今天晚上……他想着這個事情，習慣性地整理了自己的制服，讓它更筆挺了一些。一點差錯都不能有，一點都不能。</p><p>　　他要拜訪的第一位，9 點整，是住在那個臨海的小片區的著名畫家。聽說這不算個不近人情的人，我還是直接去吧。他這樣想着。咚咚咚，他敲響了這棟別致的小房子的門，並喊着「畫家先生」。</p><p>　　伴隨着一些不清晰的嘟囔和開門聲，一個看起來還沒太睡醒的不算年輕的年輕人出現在了門口，他立刻整頓了一下表情，立得更筆直了一些。幾番寒暄後，他擠進了畫家的門。他開門見山，立刻就擊中了這一次希望訊問的東西。「先生，您知不知道那個叫做『金烏』的盜賊？」對方沒有回答，他突然覺得有些不知所措，他也愣在了那裡。看着對方不知道如何形容的表情，他從包里掏出了一張紙，小心地給對方展示了一下。這是最最重要的證物，是串聯起所有東西的物品。絕對不能弄壞，他這樣想，於是只給對方草草地看了一下，連讓對方碰一碰的機會都沒有。</p><p>　　這是上級交給他的物證，從「金烏」的上一個據點裡找到的。爲什麼說那個是「金烏」的上一個據點，是因爲這個空蕩蕩的房間裡寫着「金烏」標誌性的台詞。除此之外有些生活的痕跡，以及在現場找到的這一張剪報和那張有燙疤的紙片。但是這些東西，對於這個尚且木訥的警察來說，並不意味着什麼，唯一的線索就是眼前這個頭髮亂糟糟的畫家。</p><p>　　見到對方表情仍然毫無變化，但做出了一個「看完了」的示意，他不得不收回了這張紙。然後掏出了那份剪報，但這一次，對方甚至沒有把報紙全部抽出來就塞了回去。看來他想起這個事情了，他想，這是乘勝追擊的時刻。在他正想開口的時候，想不到對方先開口了。「那麼，警察先生造訪寒舍，有何貴幹？」他不得不覺得非常窘迫，好像自己的資質淺薄被對方看出來了，他更加緊張地坐直，擺出大勢的樣子，「沒有什麼，想知道您是否知道這位『金烏』？」這一次我要堵住對方，於是立刻又說了一句，「這張紙是從『金烏』逃逸的藏身處找到的。」</p><p>　　對方愣住了。果然我將住了他一軍，他滿意地想着。看着對方起身，他的內心也更加激動。「不，我想我不認識。」如此突如其然的拒絕，他突然覺得線索都斷掉了，只剩下今晚還有機會。對方又在嘰里咕嚕地說些什麼，但他沒聽確切。只是聽到對方好像在詢問自己的意見什麼的，於是立刻拒絕了對方的請求，說了幾句告辭的話，逃也似地離開了那裡。</p><p>　　這是個古怪的畫家，太糟糕了。我什麼線索也沒有找到，他一邊搖頭，一邊大邁步，一邊揮着雙手的時候想着。不，有個事情，我需要確認一下。他停在了路口，走到最近的電話亭，撥下了畫家家裡的電話。這可真是個有錢人。</p><p>　　無人接聽。</p><p>　　這個畫家去了哪裡。在這個短短的時間，這不對勁。這個，這哪裡有問題。契機……頂着一頭亂蓬蓬頭髮的畫家、沒睡醒的畫家、裝作不知情的畫家，在我離開後的這一刻鐘內，離開了自己的房間——爲什麼這麼做，爲什麼這麼做。只有一個事情起了變化，他從我這裡得知了「金烏」的事，他得知了有人拿到了「金烏」的把柄，這個指向「金烏」的線索。</p><p>　　這個畫家他慌忙地離開了自己的房間，原因只能有兩個：他是「金烏」，他害怕地逃離了自己安穩的小房間；他是「金烏」的同黨。是這樣的，是這樣的。這個木訥的小警察抓住了立大功的機會。抓住這個機會，抓住這個畫家！這一切的想法充斥了他的腦袋，甚至在他還沒聽到「無人接聽」的聲音完全消失的時候，他就已經完成了這樣偉大卓越的思考。抓住一切機會，抓緊一切時間。回頭，去找那個古怪的畫家。</p><p>　　他立刻離開了電話亭，朝着剛才來的路風風火火地行進。我不能太誇張，不能太張揚。這樣打草驚蛇，我要鎮定。於是他選擇了用不正常的速度搖擺着雙腿，裝作若無其事地行進的樣子，而不至於跑起來。很快他來到了畫家的房前。他在門口觀察了一小會，確認房間裡暫時沒有活動的痕跡，靠近了一些，從窗戶外里看。裡面果真沒人。他跑啦，還是他去通風報信啦。</p><p>　　「您在幹什麼呀，先生？」他被嚇了一大跳。他趴在窗戶上，看着房間裡的擺設如癡如醉，完全沒注意到聲音的來源，也完全沒注意到自己像個白天裡的賊。「這戶人，這戶人你看見了嗎？你認識他嗎？住在裡面的那個畫家？啊，你認識他嗎？」他甚至沒看見自己在和誰說話，也沒注意到自己的領子也歪了，就吐出了一連串問題。當他說完，還在喘着粗氣的時候，才注意到地上站這個不太高的，掛着報筒的小報童。這個小報童往門前看了一眼，「我知道他看了今天早上的報紙。」報紙？事情變複雜了，這個畫家先看了報紙然後才離開。「你什麼時候送的報紙？」「十分鐘前。」複雜了，好傢夥，這個報紙。「我要一份報紙！」他幾乎是搶一般的，從報童手裡奪過一份報紙。</p><p>　　在看到報紙的標題的時候，他突然快樂了，他破解了一切的謎題，他終於覺得自己不是個愚昧的人。他知道自己應該去哪裡，去找誰，做些什麼。他將報紙的錢和應該找零的錢一下子扔個報童，把報紙塞進了自己的包，離開了畫家的家。</p><h2 id="屋頂的金烏（五）"><a href="#屋頂的金烏（五）" class="headerlink" title="屋頂的金烏（五）"></a>屋頂的金烏（五）</h2><p>　　我握着手裡的報紙，慢悠悠地往博物館走。今天雖然沒有什麼事情，但其實應該畫一些什麼畫的。畫室里還躺着昨天沒有畫完的一幅寫生畫——我正在描摹我的畫室周圍的動人景色。但顯然這個突然發生的事情更加吸引我的注意，所以我正握着我的報紙走在通往博物館的路上。</p><p>　　很快我走到了一個汽車站台附近，等到了一輛電車坐上去，繼續完成我通往博物館的行程。這個時候顯然不是大家出行的時間，電車裡基本上沒有什麼人。司機躲在那個幕布後面安靜地駕駛着這輛車，讓它看起來仿佛是自己動起來的——它確實是自己動起來的，但是它是怎麼自己動起來的？作爲一個藝術家，我是搞不懂的。但我應該動用我的創造力，去想象，它是怎麼動起來的。既然叫電車，應該就是用「電」這種東西吧。「電」從上面那個管子裡輸到車的內部，這個東西通過「某種方式」驅動了輪胎，帶着我們往前走。但「電」究竟是什麼呢？這我就不懂了。</p><p>　　我看着窗外的景色莫名其妙地流動而不知原因，茫然地進行一些無厘頭的思考的時候，我抵達了目的地附近。這是當地最富盛名的博物館，有着號稱全國最多、最全的藏品集，當然也配備着號稱最先進的防盜措施和足夠的安保人員。這樣宏大的規模，即使不是周末也會有諸多遊客和當地的小學組織的春遊隊伍造訪。它總是和醫院一樣，熙熙攘攘的。</p><p>　　這是一棟簡潔明了的建築，有紅色的素麵牆壁，上面貼着白色的瓷磚；整體形狀基本是一個巨大的立方體。不同面牆上有着不同樣式的浮雕，並且也不是完全的平面，而是有輕微地波濤樣的起伏。對於一般人來說，是非常古怪的樣式；但從我的角度來看，這實在是一個別致的建築，兼具着一種古典美和現代性。我曾經伏在這個建築周圍，連續幾天研究牆壁上的圖案流連忘返。裡面的藏品就更不用說了，作爲一個以傳說爲題材繪畫的畫家，這簡直是不可多得的寶地。</p><p>　　但今天吸引我到這裡來的，是別的東西。我注意到今天博物館和往日的情況有着明顯的差異：博物館四周的安保人員並沒有出現，而停着不少的警車。博物館的門儘管開着卻沒有進進出出的遊客樣貌的人，更別說那些吵鬧的、穿着時髦俏皮的小學生了。警車旁和門前都站着些胖大警察，穿着我方才才端詳過的那種制服，三三兩兩地討論一些什麼。這個時候我才注意到，警車外面還拉着一條警戒線，把整個博物館的大門圍出了一個半圓形，半圓形外是幾個拿着筆和紙，正在刷刷書寫着的人。那些應該是記者了吧。我一邊這樣想着，一邊也確認了今天的特殊情況讓我到不了博物館裡。於是我找到了一家能看見大門附近樣子的咖啡館的座位，隨便要了杯咖啡，從書架上拿出來一本不知道什麼國家的作家寫的翻譯過來的書看了起來。</p><p>　　書的內容很滑稽，也不太有趣，講的是一個漁夫，竟然愚蠢地在休漁期開始前的最後一天，睡過了而沒能出海，被他的妻子連着罵了七天七夜的故事。而且我也總是不能很認真地看這本書，因爲隔壁正坐着一個標緻的年輕人（穿着雖然不算名貴但絕對講究），他拿着笨重的鋼筆在一沓紙上發出沙沙的聲音。當然我沒法打斷他，說「你靜靜」。因爲他看起來在做正事，而我只是個遊手好閒地看滑稽劇的人。</p><p>　　當我擡起頭有意無意地看向他的時候，他也突然擡起了頭看向了我。他的眼睛很精緻，眼角略微下垂，是很適合做速寫的那種。「你是畫家先生吧？」他側了側他的腦袋，「剛才，有一位先生告訴我，一位可敬的畫家先生將會到這裡來，並交給了我一張畫家先生的照片。那上面的人像極了你。」我第一次覺得不妙。</p><h2 id="古怪的畫家（二）"><a href="#古怪的畫家（二）" class="headerlink" title="古怪的畫家（二）"></a>古怪的畫家（二）</h2><p>　　在他的面前，突然出現了這樣一個人：一個嚴肅的男人——或許他可以這樣認爲。這個人穿着警察的制服，看起來有板有眼。警察交給他一張乾淨的紙條（神祕兮兮地），紙條上是乾淨的文字。「記者先生，一會這裡會出現一個穿着隨意的還算青年的人，他是一個畫家。他會是今天『金烏』盜竊案的關係人。」紙條後面貼着一張符合這個描述的小照片。就是這麼一段話。作爲一個岌岌無名的小記者（與夢想相悖），從來不曾有什麼驚天大報道這樣的事情（就業以來）。從來都是去一些小打小鬧的地方，採訪一些瑣事。其實今天，他完全不應該到這裡來。只是出於「記者的嗅覺」，他來到了這裡，然後收到了這樣一張紙條。他感激地看着那個離他遠去的可敬的警察先生，並又一次看着手上的紙條。</p><p>　　他現在正坐在路邊的一個咖啡館，正對着那個「金烏」宣揚將要偷竊的博物館（記者的情報總是比大衆來得靈通）。於是他開始預演，這個神祕的畫家和「金烏」的關係。實際上，他只是在一疊稿紙上寫來寫去，但是完全無法集中注意力。以致於他的筆發出的聲音太大影響了周圍的人這一點，他也沒有察覺。他如此投入地進行着自己漫無邊際的假想（這是職業所需！），甚至沒有注意到旁邊的客人已經換了一個。當他終於覺得自己口渴了，想要去抓住桌邊的咖啡時，他注意到了。旁邊的那個桌子上的顧客變了，變成了一個自己從未見過的男性。穿着隨意，還算青年，出現在這裡，這個早晨，和照片上的人非常像。這個人皺着眉頭，露出一副想笑卻有不想笑，一種惱怒卻又謹慎的神情（完全不坦率的人）。</p><p>　　他受驚似的立刻移回了自己的視線，小心翼翼地裝作繼續寫着稿子（不能打草驚蛇），並時不時地朝那邊看去。那個畫家好像看一本書出了神。那是怎樣一本書，這本書和「金烏」的關係是什麼。他知道，在戰爭時期，人們會使用兩本一樣的書作爲密碼本，然後通過標註頁碼和字的位置來傳遞密碼。密碼本。那本書回是密碼本嗎？（這太離譜了）他立刻收回了自己的目光，開始側起自己的耳朵努力地聽那邊的一聲一響。突然他意識到，對方正在擡頭看着自己，他立刻慌張了起來，擡起了頭，看着對方。「你是畫家先生吧？」他儘可能地做出隨意的樣子，以免這樣嚇到對方。於是他意識到自己需要，更加嚴肅地、完整地告訴對方緣由（保持專業素養）。「剛才，有一位先生告訴我，一位可敬的畫家先生將會到這裡來，並交給了我一張畫家先生的照片。那上面的人像極了你。」（愣頭愣腦）他突然意識到自己不該說這麼多，但說到這裡他已經發現那個畫家地表情發生了巨大的變化。是某種抽搐一樣的表情，仿佛白天看見了什麼怪物一般。</p><p>　　就在這個時候，天空中一陣巨大的轟鳴聲。首先是一個灰色的頭從博物館上方露出來，然後聲音越來越大，形態越來越完整，露出了兩個翅膀。這個巨物的頭遮住了剛從雲里鑽出來的太陽照下的光線，四周閃爍着詭祕的光影。頓時從那個巨物上，他感受到了一種壓迫感，他甚至沒能注意到那個畫家的驚詫表情，和遠處正在博物館附近工作人員的混亂情況。直到這個龐然大物慢慢從視線里消失的時候，這種轟鳴中的奇怪寂靜才慢慢消失，對話才成爲了可能。他這個時候才注意到了對面一臉受到嚴重驚嚇樣的畫家（嗯？）。「不過是飛行器，先生不必如此受驚。」（職業素養）他希望自己能夠將話題拉回剛才的對話。就在這個時候，越過畫家呆楞着的肩膀和頭顱，他看見了後面的博物館門前的樣子。</p><p>　　那裡的警察亂成一片。有一兩個警察拿着黑色的盒子喊來喊去，警察開始四處跑動。有的警察手上拿着黃色警戒線，有的警察手上拿着棒子。他們開始無規律地、沿着各種方向地繞着整棟樓行進，留下剩下的一兩個警察操着黑盒子大喊大叫。旁邊的記者羣體不甘寂寞，在警戒線外瘋狂地閃着自己的閃光燈。那邊發生了什麼事情？儘管他這樣急切地希望知道正在上演的一切，也不能撂下這個重要的畫家（畢竟是關係人）。他迅速拉起了畫家的右手，用自己的右手在桌上拍了一把錢，足以付清兩個人的用餐（先這樣吧），迅速超那個方向跑去。</p><p>　　在他拽着還沒回過神來的畫家跑到那羣混亂的人附近的時候（至於這麼吃驚嗎），他只聽見了這樣的幾句話。「『金烏』比預告的時間早來了數個小時，尚未得得知博物館蒙受損失情況，但『金烏』的標誌性留言已經出現在了博物館的一面內牆上。」這顯然是另一個記者正在一邊瘋狂地做着筆記一邊無心念出來的話。</p><h2 id="屋頂的金烏（六）"><a href="#屋頂的金烏（六）" class="headerlink" title="屋頂的金烏（六）"></a>屋頂的金烏（六）</h2><p>　　在我面對着這個奇怪的記者不知道該說什麼的時候，天上似乎響起了一陣轟鳴。嗯，是飛行器的聲音。我感覺到我的頭上產生了一大片陰影。但是……這是什麼樣的感覺呢：被「某個人物」惡意地玩弄。仿佛這個場景我在什麼時刻經歷過，在數年前，或者數天前；或者是精心策劃好的。這個陰影有某種象徵，讓我突然覺得恐懼。就在同一個時刻，我捕捉到了我身後的一些細碎的聲音，是一些人快跑的聲音。<br>　　<br>　　事情的異變我也從正對着我看的那個眼睛精緻的記者那裡看出來了。他似乎說了什麼，但是我完全沒聽清他在說什麼。他直愣愣地看着我，或者說我的背面，他注意到了什麼我也注意到了的事情。於是他立刻拽起了我的手，就在同時站了起來把我順時針拽了九十度。我聽見了遠去的飛行器的聲音、口哨的聲音、人物跑動的聲音、手掌拍到桌面上的聲音、銅幣落地的聲音、有人高喊「金烏」的聲音。我感到我的眼前的光景在不斷地變化，並且感到自己正在任由那個記者的擺布。在我奪回了自己的意識的時候，我發現我已經站在博物館前的警戒線旁了。</p><p>　　我對那個魯莽的記者完全沒有了興趣，我只注意到了這樣的一個現場。一羣亂成一團的警察，以及一羣亂成一團的記者。我發現我很快理解了這裡發生了什麼。「金烏」如同其預言的一樣，來到了這個博物館，拿走了一樣東西。但是與預告不同的是，他出現在了一個不正確的時間，拿走了一個不值錢的東西，留下了標誌性的那一段話，然後消失了。</p><p>　　很快我的耳朵告訴我，現場找到了一張新的紙條。紙條上是另一個預告，市內的另一個博物館，一周之後的同一個時間，他將再次出現。這就是「金烏」麼。我不禁啞然。這是我被拽到博物館前的十分鐘後，我花了這些時間掌握正在發生的一切，以及將要發生的一切。在這十分鐘之後，我才意識到了這樣一個事情。我的左臂被那個記者緊緊地抓住，我的右手周圍突然出現了一個銀色的鐵環。我很快反應過來這是什麼東西。然後看見了這個鐵環，上面有一根鏈子，這個鏈子連到的另一端，是今早拜訪我的、當時身板鐵直、現在滿臉通紅的民警。</p><p>　　如今那個自己被玩弄的感覺越來越明顯。就在我想着這樣的事情的時候，眼前開始出現白色的飛沫，飛沫越來越稠密、覆蓋了我的所有視線。隨後我能看見的彩色的事物都變成了黑色，我完全進入了黑白雪花相間的世界。</p><h2 id="金烏的自白（一）"><a href="#金烏的自白（一）" class="headerlink" title="金烏的自白（一）"></a>金烏的自白（一）</h2><p>　　今天他去迎接那個著名的畫家。畫家因爲蒙受了錯誤的冤屈，被他親手送進了監察室。後來想起，他覺得自己當時實在是過於魯莽，竟沒有對着整個事情有些許懷疑。正當要按照手續對那個畫家開始審理的時候，畫家的嫌疑立刻被洗清了。因爲」金烏「的又一次到訪。這一次」金烏「再一次比他所預告的時間提前了數個鐘頭，搞得警察再一次顛八倒七。但如同上一次一樣，被盜走的既不是博物館最值錢的東西，也不是最有名的東西——只是一些花里胡哨的小玩意。</p><p>　　這完全一樣的手法立刻讓畫家擺脫了冤屈，但是警署里完全亂成了一團。上司怒不可遏，拎起手邊的東西就砸。他嚇壞了，因爲警察這一次部署不周有一部分自己的責任。好在後面上司沒有怪罪下來。今天他接到上司的命令，去監察室帶出畫家先生，並賠幾句禮，表示警方的歉意。</p><p>　　待他走到監察室外面的時候，仿佛畫家已經聽到了自己的聲音。他聽見裡面傳來斷斷續續的聲音。「那張肖像，是你給的嗎？」。他愣在了原地，肖像是指什麼。「那張肖像，是你給的嗎？」「肖像？」「那……看來不是你給的。果然是這樣，呵呵，哈哈哈。」然後是幾句非常侷促乾癟的笑聲。「來吧，你該帶我出去了」</p><p>　　他打開門，看到了門口站着的畫家。畫家看起來神采奕奕，並露出異常嘲諷的表情。畫家的眉毛高高吊起，並伸出一隻手搭在他的肩膀上。「走吧。」他不知道該說些什麼，他完全沒有理解那個所謂的「肖像」是指什麼，於是他忘記了賠禮道歉，只是木訥地沿着警察署的走廊一直往前。走到警察署的門口，畫家收回了自己的手，又咯咯地笑了兩聲，附耳道，「我是『金烏』，你並沒有錯。」然後轉頭出去了，留下他完全地愣在原地，腦中迴蕩着這個畫家的最後一句話，以及那嘲諷的笑聲。他完全不想追上去，再拷上他的手銬，但卻不知道爲什麼。</p><h2 id="《華嵇紀-後記》（未發表）"><a href="#《華嵇紀-後記》（未發表）" class="headerlink" title="《華嵇紀-後記》（未發表）"></a>《華嵇紀-後記》（未發表）</h2><p>　　……</p><p>　　爲了完成這部書，我花了很長的時間閱讀整理文獻，不知多少春秋，約莫半輩子。</p><p>　　某一個時刻，一個靈感進入了我的腦海：我想杜撰一個假的故事，埋在這本書里。我第一個想到的是太陽的形象，於是構想了太陽的某種使者，起名爲了「金烏」。這樣的形象在這個名字下漸漸具體了起來。我把關於這個生物的描述穿插在了一些別的有名的神話生物中間，草草得對這種生物加以勾勒。沒有人質疑這樣的形象，由於這部書其他的部分過於詳實充盈。幾乎所有研究者都將這部書推崇備至，成爲一種典範。以至於從來沒有研究者找到我來詢問我關於「金烏」的事情。</p><p>　　退休以後，我停止了傳說方面的研究工作，接任了一個小鄉鎮的圖書館管理員，偶爾也養養小花。工作很舒適，這個小鎮子的優美環境也令人心曠神怡，是適合偶爾翻翻書的環境。一切都是恰到好處。</p><p>　　……<br>　　<br>　　這部分後記，已囑託我在鄉鎮裡的子女在我去世之後公布。我不太想承擔諸多學者的對於這個事情的質疑和各種批評，但也有些許遺憾不能看到諸位老學究的氣憤神情——那這部書就這樣了，我能夠確認，本書的其餘部分都是依循已有的文獻和實地採風拿到的信息完成的，仍然具有相當的研究價值，這一點還請諸位放心。</p><p>　　——　燈徽氏</p><h2 id="金烏的自白（二）"><a href="#金烏的自白（二）" class="headerlink" title="金烏的自白（二）"></a>金烏的自白（二）</h2><p>　　多年以後我還能回想起發生在博物館那裡的鬧劇，和現場那些驚慌失措的警察的大喊與跑動。我當時還對飛行器對我造成的影響感到詫異，但後來也就發覺了，這是一個笑話。這些事情是我在監察室里想到的，儘管我在那裡並沒有呆上幾天。直到後面我看見一臉歉意的那個看起來死板的民警的時候，更加覺得好笑。他之前並不知道「金烏」是什麼，他將我錯怪成了「金烏」。但是給記者紙條的人卻不是民警（這是我在監察室里知道的信息）。那個給出字條和我的照片的人，或許就是真正的「金烏」，或許什麼也不是。我當然不知道記者那個被塞照片的故事是真是假，也不知道民警矢口否認自己給過紙條和照片這件事情是真是假。但膽大妄爲的「金烏」不久之後開始了新的挑戰。</p><p>　　「金烏」並不是一個獨立的存在，只有扮演「金烏」的和相信「金烏」的人一同存在的時候，「金烏」才有價值。否則缺少任何一方，「金烏」都會變成一個巨大的笑話。然而當這一對冤家就這樣出現的時候，「金烏」就誕生了。但終歸有什麼契機，提到這個莫須有的「金烏」，然後膨脹開來，一發不可收拾。於是人們開始捕風捉影，希望從那些古怪的幻影中抓到「金烏」的影子。於是「金烏」用這種方式活了下來，並逐漸真實而更加被深信不疑。「金烏」的死亡只有所有人都將「金烏」視爲一種理所應當的卻又無趣的存在、而不再被提起的時候，才會真正來臨。</p><p>　　所以這個看起來輝煌的「金烏」，或許那封莫名其妙的信中提到的「金烏」都是合理的「金烏」。它門是同一個概念的東西，有着不同的體現但又擁有同樣的名字。於是我不會感到困擾了。所謂「金烏」，或者一些別的神話傳說，都是建立在這樣的情況下的，無非是這些故事如何誕生、如何被傳遞下來、又如何影響到人羣的認知這些細節上的差異。</p><p>　　於是我回到了自己的畫室里。我忘記了那天晚上我吃的一些什麼，以及如何回到了自己的屋子。在跨進門框的時候，一種新的創造的想法從我的思想里誕生。我走進畫室裡面，着了魔地用着奇怪色彩的顏料，塗抹奇怪的形狀。那是像生物又不像生物的東西，有着深紫色和騰黃色混在一起的羽毛組成的彎曲的翅膀和圓柱體組成的雙腳。這個類似生物的東西，從它類似嘴的器官朝着畫布外面的人喊叫。於是站在畫前的人感到了畫家擁有的幸福。</p><h2 id="《兩隻金烏》後記"><a href="#《兩隻金烏》後記" class="headerlink" title="《兩隻金烏》後記"></a>《兩隻金烏》後記</h2><p>　　實際上，本文的初衷只是爲了諷刺在保研過程中的一些荒唐事情，於是故意起了一堆古怪的名字。比如「兩隻金烏」本就是一個映射性的名字，至於它的內涵在本人動筆之初則完全說不清楚。最開始動筆也只是諷刺了一些自己身上和其它同學身上遇到的這個糟糕事件的經歷（因爲這類事件太多，突然有了寫諷刺小說的念頭。）然而在寫作的過程中間，我似乎感覺到自己的觀念產生了些許變化：最開始我感到滑稽的是一些規定和官方操作，後面不小心發現了遵守部分規定而對另一部分規定不滿的我這種人的滑稽。於是原來那樣簡單的象徵意義就完全不同了，因此我需要一個複雜的矛盾，把一切揉起來，隨後產生了本文的「下篇」。</p><p>　　但這篇胡亂的文章發展至今，已經一定程度地偏離了最開始的想法，並隨着時間的流逝和「兩隻金烏」構思的完成，創作的熱情開始大幅度衰減。然而每一次重新寫，都會覺得「這一次的想法好像和上一次不太一樣」，於是需要花費更多的時間去考慮。文筆越來越抽象古怪也是沒辦法的事情。但所幸最後還是來到了自己希望表達的部分，同時又擔心這樣結尾太過草草，於是機械降神式地生硬地解釋「兩隻金烏」的含義。<strong>但這個結尾並沒有什麼意義。</strong></p><p>　　話說回來，這是本人第一次完成類似這樣的小說。莫名其妙地覺得有趣卻又無聊。或許不在一個合適的契機下，不會有類似的文章出現了。</p><p>　　最後感謝所有能夠忍耐如此無聊囉嗦的文風看到這裡的讀者，並祝願你們不會再一次碰到這樣無趣的作品了。</p><p>　　廙水</p><p>　　2020-12-6</p><hr><p>　　<strong>題外話 3</strong>：這一篇由於種種原因，推進速度慢於預期。可能情況是由於已經產生了較爲完整的構思，反而對細節如何填充完整瞬間索然無味。</p><p>　　<strong>題外話 4</strong>：好像因爲各種各樣的原因擱置了很久。於是再一次提筆續寫發現變得更加困難，看來這個工作不能再拖下去了——恐怕其會變得和冰上行一樣不了了之。</p><h2 id="修訂"><a href="#修訂" class="headerlink" title="修訂"></a>修訂</h2><p>　　暫無</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雜記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>網站安利</title>
      <link href="/2020/10/20/essay/%E5%AE%89%E5%88%A9/%E7%BD%91%E7%AB%99%E5%AE%89%E5%88%A9/"/>
      <url>/2020/10/20/essay/%E5%AE%89%E5%88%A9/%E7%BD%91%E7%AB%99%E5%AE%89%E5%88%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>這裡是一些安利的網站（新開了「安利」的Tag）。基本上是各種奇怪網站的合集，包括一些主流的工具、值得推薦的資源收集。覆蓋面不會很大。</p><a id="more"></a> <h3 id="工具類"><a href="#工具類" class="headerlink" title="工具類"></a>工具類</h3><ol><li><a href="http://mohu.org/info/symbols/symbols.htm" target="_blank" rel="noopener">$ \LaTeX $ 語法快速查詢</a>：一個簡單的網站，用來查突然忘掉的語法。</li><li><a href="https://material.io/resources/color/" target="_blank" rel="noopener">Material Color Tool</a>：支持 Material Design 的組合配色方案。提供一個非常簡單的色盤，用來快速確定自己喜歡的顏色。</li><li><a href="https://feed43.com" target="_blank" rel="noopener">Feed43</a>：用來對網站自建 RSS 的網站。可以手動對一些未提供 RSS 鏈接的網站，通過建立爬取規則生成 RSS 文本，從而在閱讀器中訂閱。</li><li><a href="https://trello.com/" target="_blank" rel="noopener">Trello</a>：老牌看板網站，用來管理團隊項目進展。競品有 Notion 及 GitHub Board。</li><li><a href="https://mubu.com/" target="_blank" rel="noopener">幕布</a>：快速整理寫作的網站。基本思路是利用「層級關係」。</li><li><a href="https://www.remove.bg" target="_blank" rel="noopener">removebg</a>：自動移除背景的網站工具。效果一般，和 PPT 摳圖效果不相上下。支持少量免費的外接 API 用來自動摳圖。</li><li><a href="https://www.photopea.com" target="_blank" rel="noopener">photopea</a>：線上簡易 PS，基本上可以完成大部分圖片操作。</li><li><a href="https://pixlr.com" target="_blank" rel="noopener">PIXLR</a>：線上簡易 PS，比上面那個更加好用。</li><li><a href="https://www.overleaf.com" target="_blank" rel="noopener">Overleaf</a>：線上 LaTeX 寫作，免除手動配置 tex 環境之苦。支持中文，但是中文支持度不夠。</li><li><a href="http://gitd.cc" target="_blank" rel="noopener">GitHub代下載</a>：用來下載 GitHub 的 Release 文件等，不是所有的文件都能下載，但是速度極快。</li><li><a href="https://drive.google.com/" target="_blank" rel="noopener">Google Drive</a>：對於 AI 研究者最大好處，其支持在線上空間運行 python 文件，並提供完全免費的 8GB 的獨立顯卡借用，具有完整的 Torch 等環境用以神經網絡訓練。24 小時重連一次，速度尚可接受。</li><li><a href="https://www.notion.so/" target="_blank" rel="noopener">Notion</a>：筆記類應用的極致，功能簡潔而不簡單，顏值能打，存在大量的模板可供選擇。缺點有二：不支持筆跡，不支持離線。</li><li><a href="https://dida365.com/" target="_blank" rel="noopener">滴答清單</a>：清單類應用最推薦者。支持微信轉發新建任務，支持全平台、免費功能夠用、支持在系統日曆（如微軟 Mail）訂閱。缺點：月視圖收費。</li><li><a href="https://www.innoreader.com/" target="_blank" rel="noopener">Innoreader</a>：RSS 閱讀器，簡潔明了，功能夠強。之前被牆過一段時間，目前又可正常工作了。默認一小時抓取一次。可以和 Feed43 搭配使用。</li><li><a href="https://nipponcolors.com" target="_blank" rel="noopener">日本の伝統色</a>：日本傳統色，UI 和顏色都相當棒的網站。</li><li><a href="https://www.makeamap.cn" target="_blank" rel="noopener">易制地圖</a>：繪製虛擬地圖。</li></ol><h3 id="書籍"><a href="#書籍" class="headerlink" title="書籍"></a>書籍</h3><ol><li><a href="https://zh.d2l.ai" target="_blank" rel="noopener">動手學深度學習</a>：這本書的網絡資源，中文翻譯，支持線上運行代碼，並自帶交流區。</li><li><a href="https://tour.golang.org/welcome/3" target="_blank" rel="noopener">A Tour of Go</a>：Go 語言的線上學習書籍，支持線上運行代碼。風格輕快。（需要梯子。）</li><li><a href="http://www.shakespeares-sonnets.com" target="_blank" rel="noopener">Shakespeare’s Sonnets</a>：莎士比亞十四行詩的線上平台，可以查看所有的十四行詩。</li><li><a href="https://wd.bible/" target="_blank" rel="noopener">微讀聖經</a>：線上聖經閱讀。支持和合本、英王欽定本多版本對照閱讀。</li><li><a href="https://waltwhitman.com" target="_blank" rel="noopener">Walt Whitman</a>：懷特·惠特曼生平及詩集。</li></ol><h3 id="資源"><a href="#資源" class="headerlink" title="資源"></a>資源</h3><ol><li><a href="https://pixabay.com/zh/" target="_blank" rel="noopener">Pixabay</a>：擁有大量優質高清圖片的網站，適合尋找壁紙。主要是照片類別，動物照片尤其多。（頭圖下載自該網站）</li><li><a href="https://wallpapershome.com" target="_blank" rel="noopener">WallpapersHome</a>：擁有大量優質高清圖片的網站，抽象圖片尤其多。有不少從各類操作系統中抽出的系統壁紙。</li><li><a href="http://simpledesktops.com" target="_blank" rel="noopener">Simple Desktops</a>：擁有大量優質高清圖片的網站，多爲抽象簡潔的圖片。主要由純色背景及小圖標組成。</li><li><a href="https://21wallpaper.design" target="_blank" rel="noopener">21 Wallpaper</a>：每數個月由不同設計師設計多組壁紙，提供免費下載的古怪項目。風格差異巨大，目前由於新冠暫停運行，官網上宣稱 21 年重啓該項目。</li><li><a href="http://www.musictool.top" target="_blank" rel="noopener">音樂搜索器</a>：用來在多平台搜索音樂的網站。支持下載網易雲、QQ 等多類流媒體的音樂文件（支持版權限制及僞無損下載）。</li><li><a href="https://cn.imslp.org/wiki/Main_Page" target="_blank" rel="noopener">Imslp</a>：全球最大的樂譜下載網站，古典區必備網站。有多個版本的樂譜，甚至一些手寫稿影印版。</li><li><a href="https://storage.googleapis.com/download.tensorflow.org/data/shakespeare.txt" target="_blank" rel="noopener">莎作全集</a>：莎士比亞畢生作品組成的 txt 文件，可以用來做 NLP 任務。（需要梯子。）</li><li><a href="https://new.shuge.org/view/hong_lou_meng_tu_yong/" target="_blank" rel="noopener">書格</a>：用來搜古籍的地方。網站 UI 很不錯，內容尚待更深入探索。</li><li><a href="https://www.fontsquirrel.com" target="_blank" rel="noopener">Font Squirrel</a>：一個下載免費字體的網站。</li><li><a href="https://www.allhistory.com/map" target="_blank" rel="noopener">All History</a>：一個地圖工具，能找到各個時代的地圖劃分和重要歷史事件，可靠性未知。</li><li><a href="https://airpano.org.cn" target="_blank" rel="noopener">Airpano</a>：一個看各地360度風景的網站。（用來判斷什麼地方適合旅遊？）</li></ol><h3 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h3><ol><li><a href="http://conceptnet.io" target="_blank" rel="noopener">Concept Net</a>：NLP 最大的知識圖譜之一，可以查找沒些詞的同義詞、反義詞、常用詞組等等。該知識圖譜通過計算語言學建立，而非人工標註。</li><li><a href="http://wordnetweb.princeton.edu/perl/webwn" target="_blank" rel="noopener">WordNet</a>：NLP 的重要知識圖譜之一，用來搜索不同詞的各種不同的意象。</li><li><a href="https://demo.allennlp.org/reading-comprehension" target="_blank" rel="noopener">AllenNLP demo</a>：AllenNLP 的一些模型的線上調用，方便查看一些句子的 dependency tree 以及其他。</li><li><a href="https://storage.googleapis.com/chimera-painter/index.html" target="_blank" rel="noopener">Chimera Painter</a>：谷歌使用神經對抗網絡，生成2D或者3D的怪物圖像。（需要梯子。）</li><li><a href="https://deepmoji.mit.edu" target="_blank" rel="noopener">Deep Emoji</a>：一個將文字映射到Emoji的Demo網站。</li><li><a href="https://ai-art.tokyo/en/?ref=appinn" target="_blank" rel="noopener">AI Art</a>：將肖像或者風景藝術化的網站（效果奇佳）。</li><li><a href="https://thispersondoesnotexist.com" target="_blank" rel="noopener">this person does not exist</a>：通過 GAN 網絡生成的世界上不存在的人物的頭像，看起來很逼真。每一次刷新會生成一張新的圖。（擔心隱私泄漏的場合，可以使用上面的圖片代替真人照。）</li></ol><h3 id="奇怪內容"><a href="#奇怪內容" class="headerlink" title="奇怪內容"></a>奇怪內容</h3><ol><li><a href="https://www.casebook.org/intro.html" target="_blank" rel="noopener">CaseBook</a>：一個 Jack the Ripper 相關諮詢的款熱愛好者搭建的網站，內含關於這個事件的相當細節的信息。</li><li><a href="https://lab.magiconch.com/nbnhhsh/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">能不能好好說話？</a>：將現在網絡語言的奇怪縮寫翻譯回正常普通話的網站。對於「xmsl」這些詞彙搞不清楚的，可以在這裡搜一搜，老年人日常學習資源。</li><li><a href="https://nbviewer.jupyter.org" target="_blank" rel="noopener">nbviewer</a>：可以把 GitHub 中的 pdf 文件之類的放進這個網頁，獲得一個新的鏈接。通過該鏈接，可以直接在瀏覽器中打開該 pdf，而避免下載。適合用來放置 CV 等線上資源。</li><li><a href="http://intrologic.stanford.edu/applications/herbrand.html" target="_blank" rel="noopener">Introduction to Logic</a>：奇怪的邏輯學輔助工具。反正我用不來。</li><li><a href="https://www.typingclub.com/" target="_blank" rel="noopener">EdClub</a>：通過遊戲的方式學習正確的打字姿勢。類似闖關遊戲的思路，不斷地學習更正確地使用鍵盤。</li><li><a href="https://femurdesign.com/theremin/" target="_blank" rel="noopener">Theremin</a>：模擬特雷門琴的聲音，在觸屏設備上尤其好玩。此外，可以嘗試不同音階系統的鋼琴。</li><li><a href="https://www.futureme.org" target="_blank" rel="noopener">futureme</a>：給未來的自己寫信。非常簡單。</li><li><a href="https://app.ww.calm.com/" target="_blank" rel="noopener">Calm</a>：白噪聲網站。大部分功能收費，但是簡單的自然環境音仍可以使用。</li><li><a href="http://lotrproject.com/map/#zoom=3&amp;lat=-1684.5&amp;lon=1500&amp;layers=BTTTTTTTT" target="_blank" rel="noopener">Map of Middle Earth</a>：魔戒地圖。</li><li><a href="https://iamthecu.be" target="_blank" rel="noopener">在線魔方</a>：在網頁端里的三階魔方。（好像並沒有什麼用。）</li></ol><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ol><li>新增三個【奇怪內容】。</li><li>新增【書籍】，【工具類】，【奇怪內容】各一項。將AI相關網站獨立。</li><li>新增【資源】*2，【奇怪內容】*1。</li></ol><h2 id="鳴謝"><a href="#鳴謝" class="headerlink" title="鳴謝"></a>鳴謝</h2><ol><li>感謝 Nof 提供【工具類】*1，【資源類】*2，【奇怪內容類】*1。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安利 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题更新Ver 1.0</title>
      <link href="/2020/10/17/tech/Hexo/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0Ver%201.0/"/>
      <url>/2020/10/17/tech/Hexo/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0Ver%201.0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本 Post 用以记录 Ver1.0 涉及的更新内容及其方法：</p><ol><li>增加并修改 Title 图标及颜色。</li><li>新增更新时间及排序方法。</li></ol><p><strong>注意</strong>：该方法对应的文件类型为<code>scss</code>/<code>css</code>/<code>pug</code>/<code>js</code>。可能和以<code>ejs</code>为主的主题存在些微区别，但方法大致相同。</p><a id="more"></a>  <h2 id="增加并修改Title图标及颜色"><a href="#增加并修改Title图标及颜色" class="headerlink" title="增加并修改Title图标及颜色"></a>增加并修改Title图标及颜色</h2><p>首先找到 theme 对应的 style 文件。在本主题中，该文件路径为：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="symbol">\t</span>hemes<span class="symbol">\m</span>aupassant<span class="symbol">\s</span>ource<span class="symbol">\c</span>ss<span class="symbol">\s</span>tyle.scss</span><br></pre></td></tr></table></figure><p>在其中找到 title 对应的部分。这个工作可能不是那么容易，需要先进入<code>index</code>（在我这里是<code>index.pug</code>）文件查看。那么我们同时打开<code>idnex.pug</code>文件。这个文件路径为：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="symbol">\t</span>hemes<span class="symbol">\m</span>aupassant<span class="symbol">\l</span>ayout<span class="symbol">\i</span>ndex.pug</span><br></pre></td></tr></table></figure><p>在其中找到关于 Post 和 Post-title 对应的代码往下找就行了。在我的主题中，这部分文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.post-meta&#x3D;post.date.format(config.date_format)</span><br><span class="line">    if post.categories.length &gt; 0</span><br><span class="line">        span&#x3D; &#39; | &#39;</span><br><span class="line">            span.category</span><br><span class="line">                for category in post.categories.toArray()</span><br><span class="line">                    a(href&#x3D;url_for(category.path))&#x3D; category.name</span><br></pre></td></tr></table></figure><p>从这里得知 style 文件中的应该修改的是在<code>.post-meta</code>这里，对其进行修改、增加风格就可以了。比如对于显示阅读时间的部分，是按如下方式修改的，这只是一个咖啡的图标而已。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.time</span> &#123;</span><br><span class="line">            &amp;<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">                <span class="attribute">color</span>: <span class="number">#9c786c</span>;</span><br><span class="line">                <span class="attribute">font-family</span>: <span class="string">"FontAwesome"</span>;</span><br><span class="line">                <span class="attribute">content</span>: <span class="string">"\f0f4"</span>;</span><br><span class="line">                <span class="attribute">padding-right</span>: <span class="number">0.3em</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里的修改相当地繁琐，故不一一列举，方法都是一样的。</p><h2 id="增加Update时间及按照该时间排序"><a href="#增加Update时间及按照该时间排序" class="headerlink" title="增加Update时间及按照该时间排序"></a>增加Update时间及按照该时间排序</h2><p><code>updated</code>是 Hexo 默认的关键字，可以如同<code>date</code>关键字一样，转化为符合时间格式的特殊数据结构，因而可以用以比较时间。所以为了增加 update 时间，在每一个文件的 title setting 的部分加上一个<code>updated</code>字样即可。</p><p>但是只是这样做是不可以排序的，使用 Config 文件中的<code>order by:</code>也无法达到希望的效果。所以这里借助 top 插件的代码。找到文件<code>generator.js</code>。该文件位置在：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules\hexo-generator-index-pin-top\<span class="class"><span class="keyword">lib</span>\</span></span><br></pre></td></tr></table></figure><p>将这个文件中用来比较的 date 均改为 updated，即可。</p><p>对于后面风格化的设置，参见上一小节的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题更新记录</title>
      <link href="/2020/10/16/tech/Hexo/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0/"/>
      <url>/2020/10/16/tech/Hexo/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Hexo 主题更新记录。本页面用以记录 Blog 主题的累积更新。</p><a id="more"></a>  <h2 id="Ver-0-0"><a href="#Ver-0-0" class="headerlink" title="Ver 0.0"></a>Ver 0.0</h2><p>从<a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">maupassant</a>主题开始。</p><blockquote><p>Maupassant最初是由Cho大神为Typecho平台设计开发的一套响应式模板，体积只有20KB，在各种尺寸的设备上表现出色。由于其简洁大气的风格受到许多用户喜爱，目前也已经被移植到了多个平台上，例如：</p><p>Typecho：<a href="https://github.com/pagecho/maupassant/" target="_blank" rel="noopener">https://github.com/pagecho/maupassant/</a><br>Octopress：<a href="https://github.com/pagecho/mewpassant/" target="_blank" rel="noopener">https://github.com/pagecho/mewpassant/</a><br>Farbox：<a href="https://github.com/pagecho/Maupassant-farbox/" target="_blank" rel="noopener">https://github.com/pagecho/Maupassant-farbox/</a><br>Wordpress：<a href="https://github.com/iMuFeng/maupassant/" target="_blank" rel="noopener">https://github.com/iMuFeng/maupassant/</a><br>Ghost: <a href="https://github.com/LjxPrime/maupassant/" target="_blank" rel="noopener">https://github.com/LjxPrime/maupassant/</a></p></blockquote><h2 id="Ver-1-0"><a href="#Ver-1-0" class="headerlink" title="Ver 1.0"></a>Ver 1.0</h2><p>更新时间：2020-10-16</p><p>更新内容：</p><ol><li>新增<code>Pinned</code>图标及字符，至 Title 栏。</li><li>新增项：<strong>更新时间</strong>及<strong>更新次数</strong>。文章会根据更新时间排序。<ol><li>在 Index 页，若有更新，则显示更新时间及其更新次数，反之显示创建时间。</li><li>在文章内容页，默认显示所有。</li><li>该功能尚有一定缺陷。即，不能使用默认的 Title setting 中的 date 代替 updated 标签。需要手动建立 updated 项。</li></ol></li><li>调整了 Title 栏图标颜色。</li><li>增大了文章标题大小。</li><li>调整了 Title 和正文、文章与文章之间的距离。</li><li>Index 页面文章间增加横线。</li><li>开启 Categories 计数。</li><li>在顶栏增加 Tags 栏。</li><li>调整 Index 界面显示的文章数目；取消 Archive 界面的分页。</li></ol><h2 id="Ver-1-1"><a href="#Ver-1-1" class="headerlink" title="Ver 1.1"></a>Ver 1.1</h2><p>更新时间：2020-10-20</p><p>更新内容：</p><ol><li>Navigator 的顺序修正，使其支持跳转到依据更新的时间的上一篇或者下一篇。<ol><li>修改方法：找到<code>node_modules/hexo/lib/plugins/generator/post.js</code>，将第四行改为“updated”即可。</li></ol></li></ol><h2 id="Ver-1-2"><a href="#Ver-1-2" class="headerlink" title="Ver 1.2"></a>Ver 1.2</h2><p>更新时间：2020-11-20</p><p>更新内容：</p><ol><li>原【Collection】板块易名为【Bookmark】。</li><li>原【Timeline】的icon修改。</li></ol><h2 id="Ver-1-3"><a href="#Ver-1-3" class="headerlink" title="Ver 1.3"></a>Ver 1.3</h2><p>更新时间：2020-12-01</p><p>更新内容：</p><ol><li>将【随笔】分类下的所有文章调整为繁体。由于使用的为简化的转换模型，所以部分繁体字可能会出现用法上的错误，请见谅。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动检测Typo</title>
      <link href="/2020/10/15/tech/Hexo/%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8BTypo/"/>
      <url>/2020/10/15/tech/Hexo/%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8BTypo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Typo 是一个相当烦人的东西（实际上只是自己懒得多次检查 Typo，有的时候就算发现了也会懒得改。）。所以打算自己找一个可以自动检查 Typo 的脚本。我本来以为这是一个技术上成熟的东西，然而并没有。勉勉强强在 GitHub 里找到了一个对付 Typo 的 Repo：<a href="https://github.com/shibing624/pycorrector" target="_blank" rel="noopener">PyCorrector</a>。这个工具是为了中文设计的，是否能对英文使用暂时存疑。</p><a id="more"></a>  <p>我这里暂时不打算多费口舌讨论它的原理，以及是否有更好的竞品之类的问题。（我相信现在的中文 NLP 水平肯定不止如此。）若希望寻求技术细节，请进入上述的链接。直接进入使用环节。</p><h2 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h2><p>这个工具首先需要通过 Pip 安装下述 Package：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install https:<span class="regexp">//gi</span>thub.com<span class="regexp">/kpu/</span>kenlm<span class="regexp">/archive/m</span>aster.zip</span><br><span class="line">pip install pycorrector</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上述两个步骤请不要颠倒，否则可能会出现依赖问题。</p><p>这样就完成了安装。这里粘贴该包的使用的 Demo：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pycorrector</span><br><span class="line">corrected_sent, detail = pycorrector.correct(<span class="string">'少先队员因该为老人让坐'</span>)</span><br><span class="line">print(corrected_sent, detail)</span><br></pre></td></tr></table></figure><p>它会返回纠正过的句子以及哪些部分是需要纠正的。但是它这个工具的准确率实在不行，这个纠正句子基本是不能信的。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>但是上面只是获得了环境，为了更好地使用，不得不写了一个新的脚本。由于这个工具的准确率实在不行，而且速度也并不快，所以为了避免每一次对所有文件的搜索，系统维持了一个名为<code>checked.json</code>的文件，里面存有已经检查过的所有文件。如果你希望重新检查该文件，则从该文件中移除对应的名字即可。此外，每一次检查回将错误信息记录在一个名为<code>log.txt</code>的文件中。这两个文件都会储存在 Hexo 最外层的文件夹中。</p><p>每一次运行该程序都会覆盖<code>log.txt</code>，并且将每一次检查过的新文件加入<code>checked.json</code>文件。具体代码附在该链接中：<a href="https://josep-h.gitee.io/code/analysis.py">Link</a>，请自行下载。该文件中的地址可能需要微调。我将其放在 Hexo 根目录的名为<code>update</code>的子文件夹中。</p><p>最后可以将其加入 update 脚本中，这样每一次更新可以获得新的 log 文件查看是否有 Typo。最后再吐槽一句，它的准确率不行(它甚至使用的还是结巴分词……)。如果各位发现了更好的工具，敬请告知。</p><p>最后三点注意：</p><ol><li>第一次由于所有文件都没有检查过，所以会非常缓慢。请耐心等待。</li><li>该脚本刚开始运行时，会导致系统一点小卡顿，这是加载大型语言模型产生的正常情况，不用慌张。</li><li>如果在写作某篇文章时不希望加上自动 Typo 修正的功能，可以在该篇文章最开始的设定中添加一行：<code>typo: false</code>。该功能我写了，但是没有单独测试。若有问题我之后再改吧。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Monster』觀感（上）</title>
      <link href="/2020/10/12/essay/%E8%A7%82%E6%84%9F/Monster/"/>
      <url>/2020/10/12/essay/%E8%A7%82%E6%84%9F/Monster/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-DTPgZSBT" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="28844056" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="評價：★★★★★"><a href="#評價：★★★★★" class="headerlink" title="評價：★★★★★"></a>評價：★★★★★</h3><p>　　於我而言，這是一部非常獨特的作品。在我有限的觀看過的作品中，本部作品算不上天衣無縫，有很多不可迴避的硬傷（甚至是劇情上的），但並不妨礙這部作品仍在值得推薦的清單中。本來這部作品是打算好好整理之後再完成這篇評價，但是又覺得這部作品中後期帶來的感覺會隨着時間流逝慢慢散掉，所以在此之前抓住這個感覺，先記下來吧。由於內容太長，爲避免過於影響觀感，考慮分爲上下兩篇。上篇是對於 Monster 的批評以及劇情上的討論；下篇會把注意力放在人物和主題刻畫上。</p><p>　　<strong>注意</strong>：本篇內容分爲概述和對劇情討論兩部分。由於提前得知劇情會對觀感又非常大的影響，在概述中我將盡力避免過於直白的劇透；但是請未觀看過該部作品的讀者一定不要進入後續劇情章節，除非各位覺得劇透並不是那麼嚴重的問題。此外，本文作者沒有經過任何仔細研究，本文內容請視爲完全主觀甚至胡說八道的。</p><a id="more"></a><h2 id="總體感受"><a href="#總體感受" class="headerlink" title="總體感受"></a>總體感受</h2><p>　　本部在一個很「黑暗」的氛圍下，用一種使人感到不太愉悅的敘述方式引導主線前進。故事本身並不太新穎，是帶有某種恐怖色彩的偵探抓罪犯的故事，混合着公路片的些許風格。在這個過程中又插入了不少的小插曲，小插曲設計算不上精妙，有些部分甚至有些拖沓和套路。以及和動漫這種呈現形式非常不相稱的惡意和壓抑（相較於大多數作品而言都是。）</p><p>　　最草率的概括可以把故事區分爲三個階段：陰謀的展開；雙方拉鋸；結局。陰謀展開和結局屬於正常的節奏（相較於長篇而言），而在雙方拉鋸則保持着一種詭異的節奏，有一種反覆前功盡棄的挫敗感。這段大概在 30 集左右，加上本部作品各種敘述上的些微問題及特色，基本能勸退大多數觀衆。</p><p>　　但是在這諸多指責之後，我仍然會選擇推薦這部作品。這絕對不是一部用來找樂子消遣的作品；但也不是將立意擺得高大上的作品——至少作品沒有給出一個核心的要旨。作品的態度僅是講一個故事而已，而且我得承認這部作品講故事的方法很高明。</p><p>　　這也絕對不是主流的作品，在中長篇動漫中，主題的選擇更屬於特立獨行的類別。相較於一些熱門的作品來說，能找到的議論這部作品的文段更是少之又少。其中不乏評論認爲，這部屬於「黑深殘」作品或者「故作深沉」。對於這些意見，個人持中立態度。我看見的是一個講故事的野心和這個故事張牙舞爪的鮮明姿態。至於它是否「黑深殘」還是什麼，還是交給諸位讀者評判吧。同樣，也有不少評價說，這是一部講述「人性」的作品。「人性」這種評價實在隔靴搔癢，故本人對這個觀點也持中立態度，還請諸位觀衆自行評判。</p><p><strong>小批評</strong></p><p>　　此外，即使未觀看過該作品，我也希望提前做一個小批評，作爲一個預警，以便更容易接受該作品或者考慮是否直接放棄。該部作品敘事節奏略微拖沓。Monster 的主線劇情展開是順利且乾淨利落的。線索與線索聯繫緊密，基本沒有斷節。甚至大多數時候，是先陳述某人物通過某線索找到了下一個目的地之後才開始補充這些線索的由來。這讓故事整體的節奏自然靈活，有一種壓迫感。</p><p>　　所以我希望指責的拖沓並不是指故事主線的推進，也不是對插曲、倒敘類似部分的指責，而是細節的節奏問題。這部作品擅長放大細節，例如人物的眼神變化、光影的變化等等，不能否認這樣的敘述手段讓更幽暗的環境變得更加瘮人，然而這樣的處理並不總是得體，在某些時候會營造出一種錯誤的觀感，讓劇情內短暫的時間（如十多秒的對峙）被錯誤地渲染，讓一些本來應該緊張的瞬間變得緩慢、鬆弛，緊張感盡失。</p><hr><p><strong>注意</strong>：後部分涉及大量劇透，請未看過該作品的讀者三思後繼續。</p><hr><h2 id="其他指責"><a href="#其他指責" class="headerlink" title="其他指責"></a>其他指責</h2><p>　　上述對這部作品的節奏問題做了一個批評，之後需要先陳述更多的批評。由於後續內容和劇情緊密相關，故移入分割線之後。</p><h3 id="劇情邏輯問題"><a href="#劇情邏輯問題" class="headerlink" title="劇情邏輯問題"></a>劇情邏輯問題</h3><p>　　本部作品劇情存在諸多不合理之處。由於該作品經常使用倒敘的方法——讓一部分事實在故事的後期突然出現，使得一部分不太符合邏輯的內容被習慣性地忽視。這些問題本身是致命的（然而後面我會試圖迴避掉這個嚴重的問題），它們的存在讓故事的推進存在着牽強和不合理之處。最爲不合理的部分集中在約翰和羅伯特上。</p><ul><li>約翰</li></ul><p>　　約翰作爲本作的核心人物，他的個人能力被無限地放大了。其中最費解的是艾斯勒醫院殺人案中，院長三人是如何被約翰殺死的。在這個時刻，約翰處於半昏迷狀態，並完全沒有行動能力，他如何獲得毒藥以及如何預料到院長會吃他的房間的糖果諸多問題都是難以解釋的。</p><p>　　其次是約翰的強大洗腦能力。法蘭茲.撥納帕達的洗腦能力來自於他的心理學知識，以及長期的洗腦教育；而約翰的洗腦能力卻仿佛只需要幾句話就可以完成，甚至讓對方死心塌地。姑且不論那些思想脆弱的殺人犯這樣本來就不安定的因素，劇情中展示了不少次約翰洗腦普通人（或者說生活不那麼順利的人）的過程，總之還是有些費解的，這是些微牽強的設定。</p><p>　　以及約翰的存在感問題。約翰先後換過多次養父母，而這些養父母均在收養約翰不久後被殺害。這一系列事件由於極高的相似性被聯繫在了一起，卻從未有官方人員發現了這個被收養的兒子的事實（即使警官已經發現了這些夫婦都沒有子嗣這個特徵），這並不是合理的現象，只能說是爲劇情服務了。</p><p>　　但約翰相關的劇情邏輯的問題並未那麼嚴重——我們可以將約翰自身視作作品中一個超凡的存在，他的存在是不現實的，而帶有「神」的色彩的。這一系列的不合邏輯，是來自於約翰自身的神性。這和所謂的「主角光環」並不相同。這個作品存在這樣一個預設：「只有怪物才能做到。」於是他做到了。作爲一部動漫作品，我們可以接受出現超自然的誇張的設定，約翰的存在正是如此。</p><ul><li>羅伯特</li></ul><p>　　而另一個難以解釋的角色是羅伯特。羅伯特最大的疑點在於，他如何接近的博德曼律師的。博德曼律師作爲律師界的新星，其合伙人毫無疑問也應該是律師界的大名鼎鼎人物。然而羅伯特在富翁休伯特的案件中被天馬用槍射傷至天馬被捕間約莫一年時間，羅伯特如何獲得這樣的地位並且成爲博德曼律師合伙人的？只能說是另一個費解的問題了。</p><p>　　然而這些不正常的推進，並未影響故事的邏輯主鏈。律師由另一個聽命於約翰的角色頂替也是完全可以的。只能說是作者希望讓故事裡的每個角色有自己的結局吧，就像沒有看到最後的風景的羅伯特那樣。</p><h3 id="不合時宜的BGM"><a href="#不合時宜的BGM" class="headerlink" title="不合時宜的BGM"></a>不合時宜的BGM</h3><p>　　在大多數時候，BGM 都是一部作品的加分項，然而卻不是這部作品的。這部作品的 BGM 並不合適。大多數時候，它的 BGM 都處於若有若無的狀態，這基本符合了 Monster 整體的灰暗畫風。即使完全沒有 BGM，我也不會因此指責。但是很遺憾的，在衆多的 BGM 中混入了一些違和的，過分歡快的音樂。這些音樂出戲到甚至讓我認爲我正在觀看一部別的作品。</p><p>　　這不是指這部作品不能使用歡快的音樂，但在這部作品的任何時刻，都沒有存在純粹的快樂。更多時候仿佛是死亡才能帶來慰藉，而活着的愉悅着的人都遭受着或曾遭受了非人的命運。例如在妮娜和迪特在一起閒逛的時候，這兩個滿身瘡痍的人，互相安慰（並都擔心着天馬）；因爲在這短短的閒暇里獲得了快樂，而使用一個非常歡快的背景音樂，這是非常不合適的。</p><p>　　此外其他的 BGM 並未給我留下非常深刻的印象，比較平庸，或者說這是一部不太需要 BGM 的作品：只要 BGM 不發揮太差，就都可有可無。很遺憾它沒有達到及格線。後面是本部作品中鮮有的兩首配得優秀的作品。</p>    <div id="aplayer-yIVDfoNj" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="461404" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div>    <div id="aplayer-rLmTQduV" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="461406" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="不必要的展開"><a href="#不必要的展開" class="headerlink" title="不必要的展開"></a>不必要的展開</h3><p>　　儘管前面對敘事節奏做了一個批評，但並不是批評的全貌。節奏的失衡不僅僅來自於那種特殊的敘事風格，也在一些展開上有所體現。Monster 塑造了很多生動的人物，或喜或悲的人物有很多，但是是否所有的人物都需要展開？Monster 中出現的人物（尤其是前期）基本上都獲得了自己的一個小歸宿。而這些人物的出現，有的與主線有密切聯繫，而有的只是剛好和「主題」有輕微的呼應。以妮娜的經歷爲例，妮娜打工的咖啡廳老闆羅素先生，身份是一個殺人犯。但問題在於爲什麼需要將妮娜所在的餐廳設計成一個殺人犯，而不是一個普通人？關鍵在於羅素那句「砂糖的味道」。如果這句話沒有出現，那麼這一段背景設定的意義就不存在了。</p><p>　　但相反的，舒克警官出現則是意義不明。作品在舒克警官的登場及遭遇上花費了大功夫，他也很好地起到了一個「工具人」的作用串起了這個案件，但是只是造出了一個和天馬被陷害案相仿的結構，舒克警官自身是沒有立起來的角色，對於故事發展的作用也非常有限。和舒克形象類似的有博德曼律師——博德曼律師大可不這樣費筆墨給出一個背景。</p><p>　　爲了更直觀地表達上述批評的含義，我舉出派特羅夫院長事件作爲對應的例子。私以爲派特羅夫院長和「寶寶」是處理得相當出色的兩次展開，其有血有肉及其登場和退場的方式較舒克和博德曼都是更加自然合理的。　　</p><p>　　當然這個挑剔未免苛刻了點。作爲一個如此宏大的案件，如果牽扯的人物太少反而是一個奇怪的點。（甚至本文出現的衆多巧合，比如葛利馬和羅伯特曾是好友這樣的設定已經有些過於刻意了。）但是這些人物如何登場、如何退場、如何在後續中發揮自己的作用，都是值得費心的事情。私以爲 Monster 並沒有把這一點處理得非常好，使得節奏拖沓問題更加嚴重。</p><hr><p>　　好像前面各種指責，把這部作品批得體無完膚。但並不如此，這部作品具有的特點是那麼獨特，讓我完全可以忽視前面的諸多問題將其納入我的推薦。正如前文所言，其劇情設計、人物設計、敘事手段設計都是獨樹一幟的。我將試圖討論一下這幾個點，之後進入最爲複雜的主題篇章。</p><h2 id="關於劇情"><a href="#關於劇情" class="headerlink" title="關於劇情"></a>關於劇情</h2><h3 id="時間表"><a href="#時間表" class="headerlink" title="時間表"></a>時間表</h3><p>　　以下表格部分根據回憶重現部分劇情，肯定存在錯誤之處。標註黑體爲重要事件。其中，短期支線劇情均省略。</p><div class="table-container"><table><thead><tr><th>標記</th><th>事件概述</th><th>線索</th></tr></thead><tbody><tr><td>暗線</td><td>1950 年代，小鎮屠殺慘劇</td><td></td></tr><tr><td><strong>波納伯塔</strong></td><td>1960 年代，波納伯塔入住紅玫瑰宅邸，舉辦朗讀會</td><td></td></tr><tr><td><strong>511</strong></td><td>1960 年代，511 幼兒之家</td><td></td></tr><tr><td>葛利馬</td><td>1961 年，《超人蘇坦納》在西德開播，持續兩年</td><td></td></tr><tr><td>博德曼</td><td>1968 年，休特芬·博德曼以通敵之罪被捕</td><td></td></tr><tr><td>查培克</td><td>1969，查培克與科拉休會面</td><td></td></tr><tr><td><strong>安娜&amp;休伯特</strong></td><td>1970 年，馬爾戈特·蘭卡與安娜非法越境德國，安娜越境失敗</td><td></td></tr><tr><td>博德曼</td><td>1971、1972 年，博德曼夫婦相繼離世</td><td></td></tr><tr><td><strong>安娜</strong></td><td>1974 年，安娜前往布拉格旅遊，與軍人結婚後爲躲避優育計劃私奔。軍人被捕後殺害</td><td></td></tr><tr><td><strong>安娜&amp;波納伯塔</strong></td><td>1975 年，雙胞胎出生</td><td></td></tr><tr><td><strong>安娜&amp;休伯特</strong></td><td>1976 年，蘭卡寫信給安娜：「三隻青蛙」</td><td></td></tr><tr><td>休伯特</td><td>1977 年，漢斯格魯古·休伯特與蘭卡分別，卡爾出生</td><td></td></tr><tr><td>查培克</td><td>1979 年，米朗·科拉休出逃</td><td></td></tr><tr><td>安娜&amp;休伯特</td><td>1980 年，休伯特前往三隻青蛙，遇到安娜和雙胞胎</td><td></td></tr><tr><td><strong>波納伯塔&amp;妮娜&amp;查培克</strong></td><td>1981 年，雙胞胎之女被查培克和波納帕達帶入紅玫瑰</td><td></td></tr><tr><td><strong>波納伯塔&amp;雙胞胎</strong></td><td>波納帕達策劃紅玫瑰屋慘案。三隻青蛙失火</td><td></td></tr><tr><td><strong>波納伯塔</strong></td><td>波納帕達從捷克到西德</td><td></td></tr><tr><td><strong>約翰&amp;沃爾夫&amp;511</strong></td><td>1984 年，沃爾夫將軍於捷克邊境發現雙胞胎並帶回，並將約翰放入 511</td><td></td></tr><tr><td><strong>511</strong></td><td>1985 年，511 起火案</td><td></td></tr><tr><td><strong>約翰&amp;天馬</strong></td><td>1986 年，李貝特夫婦謀殺案</td><td>故事的起點</td></tr><tr><td><strong>雙胞胎</strong></td><td>雙胞胎居於海德堡佛多拿家，約翰失蹤</td><td>511 之家</td></tr><tr><td>波納伯塔</td><td>1989 年，柏林牆倒塌。波納帕達逃至廬恩海姆，出版《安寧的家》</td><td></td></tr><tr><td>查培克</td><td>彼得·查培克在米朗·科拉休的協助下逃到德國，定居法蘭克福，舉辦朗讀會</td><td></td></tr><tr><td>約翰&amp;休伯特</td><td>1992 年，蘭卡隱退，定居奧芬巴赫</td><td></td></tr><tr><td>約翰&amp;休伯特</td><td>休伯特司機和管家遇害</td><td></td></tr><tr><td>約翰&amp;休伯特</td><td>1993 年，休伯特朋友及競爭對手遇害</td><td></td></tr><tr><td>約翰&amp;休伯特</td><td>1994 年，休伯特會計遇害</td><td></td></tr><tr><td><strong>約翰&amp;天馬</strong></td><td>1995 年，天馬和約翰重遇</td><td>艾娃的目擊</td></tr><tr><td><strong>天馬&amp;約翰&amp;休伯特</strong></td><td>1995 年 5 月，佛多拿夫婦及記者遇害。休伯特園丁遇害</td><td></td></tr><tr><td>休伯特</td><td>1995 年 12 月，蘭卡被殺</td><td></td></tr><tr><td><strong>天馬&amp;查培克</strong></td><td>1996 年 2 月，土耳其街案件</td><td>極右四人（寶寶，查培克現身）</td></tr><tr><td><strong>天馬&amp;約翰&amp;休伯特</strong></td><td>1996 年，慕尼黑，休伯特繼承案</td><td>繪本出現，三隻青蛙，休伯特線結束</td></tr><tr><td>511&amp;天馬</td><td>1996 年，布拉格，511 院長被殺</td><td>511 磁帶，511 線結束</td></tr><tr><td><strong>倫克</strong></td><td>1997 年，布拉格，倫克找到紅玫瑰宅邸</td><td>怪物的情書和安娜的畫像</td></tr><tr><td><strong>天馬</strong></td><td>布拉格，天馬越獄案及艾娃求生案</td><td>休特芬·博德曼之子入場</td></tr><tr><td><strong>查培克&amp;約翰</strong></td><td>艾娃被寶寶和查培克帶至法蘭克福指認約翰</td><td>四人組希特勒計劃</td></tr><tr><td>約翰</td><td>約翰抵達紅玫瑰宅邸，玫瑰宅邸被燒</td><td>46 具白骨</td></tr><tr><td>查培克</td><td>1998 年，法蘭克福連環殺人案，寶寶和查培剋死亡</td><td>查培克線結束</td></tr><tr><td><strong>ALL</strong></td><td>盧恩海姆事件</td><td>波納伯塔線結束</td></tr></tbody></table></div><p>　　以上是結合個人記憶以及參照<a href="https://book.douban.com/review/7459626/" target="_blank" rel="noopener">該鏈接</a>的結果。從一個角度看，上述區分把劇情劃分爲故事開始前和故事開始後兩部分，而整個故事主線是追尋「過去發生了什麼」，或者「怪物是如何誕生的」。所以這個故事是一半在往前推進，另一半在往後推進：一直到故事的結尾，故事的最初推動者才終於現身。所有人的行動是明線，過去發生了什麼是暗線；從另一個角度看，故事的明線是天馬如何追蹤約翰，暗線是約翰如何完成自己的計劃。這條線索是故事的大主線，在這個故事線中，天馬只是故事推動者而非主角；至於天馬線，我們將會將更多注意力放在天馬所承載的主題上，所以劇情部分我們先將其略過不表。</p><p>　　而這條線索核心在於妮娜。妮娜是故事最開始的參與者，妮娜的記憶是走往過去的核心。然而妮娜的記憶被上了幾道鎖：佛多拿，紅玫瑰&amp;查培克，妮娜&amp;波納伯塔。以妮娜爲核心的上述過去的主線順序爲：妮娜被母親放棄，妮娜被波納伯塔抓入紅玫瑰宅邸，波納伯塔放還妮娜，妮娜見到約翰並給約翰講述經歷，妮娜和約翰逃離國境，妮娜被放入 47 號孤兒所，妮娜成爲李貝特養女。其中，被母親放棄的部分，是關於約翰動機的揭示，這是在故事最後的最後才出現的內容；紅玫瑰宅邸由於內心的恐懼不願回憶，在心理醫生多詞幫助下未能成功；和約翰講述經歷的回憶是貫穿全劇的最大的反轉，也是「怪物」誕生的重要契機；逃離國境及其之前的回憶由於李貝特案件而被封鎖。</p><h3 id="幾點補充"><a href="#幾點補充" class="headerlink" title="幾點補充"></a>幾點補充</h3><p><strong>明暗線的連接</strong></p><p>　　關於妮娜的記憶存在一個爭議，主要來自於「妮娜向約翰講述紅玫瑰宅邸」一處。有觀點稱：約翰在接受了妮娜的故事之後，決定自己成爲怪物，將妮娜洗腦忘掉紅玫瑰宅邸事件，然後自我洗腦，讓自己成爲紅玫瑰宅邸事件的親歷者，並代替妮娜成爲怪物。這個觀點個人認爲並不可靠（事實上這裡有諸多的解釋，放在這裡的不是我最開始的解釋，在思考之後認爲目前的解釋更加合理。）</p><blockquote><p>（約翰）內心真正渴望把妹妹的可怕經歷全部承受最後才會以爲那是自己真實的記憶。妮娜也應該是受到了很大的精神創傷所以在講述過程中主客互換，類似希望對面這個傾聽的「自己」才是真正的自己之類的。      ——$S^2$</p></blockquote><p>　　所以約翰在根據自己相信的記憶行動，而這個記憶是屬於妮娜的。這個意義上，正向時間裡，妮娜的明線（尋找自己的記憶）和約翰的暗線是呼應的；約翰在正向時間中的明線是和妮娜過去時間中的暗線呼應的。換句話說，約翰是活在過去的，沒有失去記憶的妮娜。對於這個呼應關係，核心在於「女裝」的約翰。在土耳其街約翰就以女裝的身份出現過，這裡是對這個鏡像的最初提示，和最初的「女裝」約翰對應，一直鏈接到最後章節，母親放棄妮娜，天馬自問<strong>「母親放棄的是誰」</strong>這個問題。請格外留意這個問題，私以爲這是理解約翰線的最爲重要和初始的線索。所以兩組明暗線交織在一起，並借用妮娜回憶的問題不斷反覆，由天馬和倫克發現的物證對應妮娜回憶起的記憶，完整地再現出過去發生的一切。這種敘事結構非常地精巧，讓這種不斷地插敘倒敘的敘事結構也能有序地進展，並且留足了懸念。<br>　<br><strong>OP 與明暗線</strong></p><p>　　說到懸念，不得不提起 Monster 的 OP。這是非常獨特的 OP，甚至一直到中後期之前都無法理解 OP 的含義。OP 中的所有元素，排除掉心驚膽戰、「孤立無援」的天馬，各種元素都是指向的三隻青蛙、紅玫瑰宅邸事件，以及所謂的「最後的風景」。這樣的 OP 是很隱晦的，即使將後面各類事件的關鍵元素湊在一起我們也不能得知含義，這也是敘事結構異曲同工的效果。天馬和倫克發現的物證只能說明當時發生了什麼，例如紅玫瑰宅邸事件的存在性，而不能探尋其動機；而這個動機的部分則存在在妮娜的回憶里。比如那個貫穿始終的斷章取義，「人可以成爲任何東西，但是不能成爲怪物。」相較而言，ED 的信息量不太多，我們就不多琢磨了。</p><p><strong>兩個反轉</strong><br>　　<br>　　以及在紅玫瑰宅邸登場前，出現了一個大 Trick，即 511 幼兒之家。這是一個華麗的障眼法，不僅吸引了觀衆也吸引了天馬的注意力。似乎在 511 幼兒之家故事就到達了一個源頭，然而事後證明這這只是對紅玫瑰宅邸的拙劣模仿。是非常自然且優秀的展開，而 511 幼兒之家的前院長的改過自新也是對應結局的暗示。</p><p>　　關於劇情，最後想要提到的「究竟是誰進入了宅邸」這個大反轉。這個反轉絕對留夠了線索，但是觀衆基本上（或者說我）難以想到。這裡約翰說了一句「夢醒了」，於是立刻毀掉了自己一手建立的黑道銀行，前往盧恩海姆。故事在這裡發生了非常有趣的變化，關於「怪物是誰」的討論也在這裡第一次浮上水面，也是終幕的拉開。</p><p>　　後續關於人物和主題部分，請見本作品劇評（下）</p><h3 id="幾點更新"><a href="#幾點更新" class="headerlink" title="幾點更新"></a>幾點更新</h3><ol><li>爲了方便，將 Anna Liebert 譯爲「妮娜」，而不考慮其本名；約翰同理。Franz Bonaparta 統一譯爲「波納伯塔」，並將該角色的其他名字也用該名字代替。</li><li>附上維基劇集鏈接：<a href="https://en.wikipedia.org/wiki/List_of_Monster_episodes" target="_blank" rel="noopener">List of <em>Monster</em> episodes</a>。</li><li>在思考之後，接受$S^2$對於「關於劇情-幾點補充-明暗線的連接」中妮娜失憶原因的見解，並將原始版本放置在這個位置：關於妮娜的記憶存在一個爭議，主要來自於「妮娜向約翰講述紅玫瑰宅邸」一處。有觀點稱：約翰在接受了妮娜的故事之後，決定自己成爲怪物，將妮娜洗腦忘掉紅玫瑰宅邸事件，然後自我洗腦，讓自己成爲紅玫瑰宅邸事件的親歷者，並代替妮娜成爲怪物。這個觀點個人認爲並不可靠，我更傾向於：妮娜的故事讓約翰自以爲自己是親歷者而變成了怪物（這個觀點的暗示來自於，妮娜講述了幾天幾夜這個故事），妮娜自己出於迴避忘記了紅玫瑰宅邸。但無論如何，妮娜失去了逃離三隻青蛙之前的記憶，而約翰記得哪些事件則是不清楚的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 觀感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo开启RSS</title>
      <link href="/2020/10/11/tech/Hexo/Hexo%E5%BC%80%E5%90%AFRSS/"/>
      <url>/2020/10/11/tech/Hexo/Hexo%E5%BC%80%E5%90%AFRSS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　想了想还是打开 RSS 吧。其实没有什么特别的目的，只是对于一些（我觉得没有）正使用 RSS 的朋友一些方便吧。对于 RSS 感兴趣的，可以点击这个链接：<a href="https://en.wikipedia.org/wiki/RSS" target="_blank" rel="noopener">Link</a>。顺便这里作为一个小小的 Memo，慢慢地记录一些推荐的 RSS 源。</p><a id="more"></a>  <h2 id="关于RSS"><a href="#关于RSS" class="headerlink" title="关于RSS"></a>关于RSS</h2><p>　　这是一个相当有历史感的东西，现在推荐算法之类的东西遍地都是，让这种不太智能、比较僵硬的获取信息的方法显得有点过时（但 Blog 啊什么都是过时的东西了）。但是总有一些信息是希望主动获取的，而这样的信息分布在各种各样的网站，逐个逐个地打开是一件令人烦恼的事情。所以干脆把它们放在一起，这就是 RSS 的初衷。<br>　　然而 RSS 和 Blog 相性并不是很好。Blog 体现着维护这个网站的主人的诸多用心，各种各样的细节都是经过多番考量的结果，是毫无疑问的个人维护的思想的小庄园，通过 RSS 来阅读这些信息未免会失去这片园地的主人希望提供的信息。但无论如何，为了方便还是提供了这样一个链接（因为对于主人来说，打开这个服务并不是困难的事情）。后面也会简单记录一下基于 Hexo 的 Blog 开启 RSS 的方法。<br>　　为了使用 RSS，需要一个 RSS 阅读器和订阅源。<br>　　<strong>关于阅读器</strong>：前段时间，由于某些不太清楚的原因，国内封禁了一批 RSS 阅读器的服务提供者，类似 Feedly 这样的网站，本人原来使用的 Inoreader 并未能幸免。然而最近本人发现 Inoreader 突然恢复了功能，仿佛某个老友突然造访，还是令人高兴。<br>　　<strong>关于订阅源</strong>：订阅源是由各个网站提供的链接，可以用来告诉 RSS 阅读器自己的网站存在了更新。由于 RSS 在国内非常不主流，大多网站也并未提供对应的 RSS 源。搜索有趣的 RSS 源是一件费时间，但是能长时间给人愉悦的工作。本文也希望用该部分内容记录一些优秀的具有 RSS 源的网站。</p><h2 id="RSS源"><a href="#RSS源" class="headerlink" title="RSS源"></a>RSS源</h2><p>本栏欢迎 RSS 用户推荐。</p><ol><li><a href="https://sspai.com/feed" target="_blank" rel="noopener">少数派</a>：挺有趣的科技宅关注点聚集地。</li><li><a href="https://www.theguardian.com/music/classicalmusicandopera/rss" target="_blank" rel="noopener">守护者 - 古典音乐</a>：一些古典音乐的信息。</li><li><a href="http://www.yankodesign.com/feed/" target="_blank" rel="noopener">Yanko Design</a>：设计作品呈现，偶尔能有不错的点子。</li></ol><h2 id="Hexo如何启用RSS"><a href="#Hexo如何启用RSS" class="headerlink" title="Hexo如何启用RSS"></a>Hexo如何启用RSS</h2><p>　　这个工作相当的简单。</p><ul><li>安装 npm 脚本，用以生成富文本 xml 文件。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-feed</span><br></pre></td></tr></table></figure><ul><li>打开 Hexo 最外层的<code>_config.yml</code>文件，在其中添加下述代码：（请仔细观察，文件中是否已经存在此代码。）</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">    <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="comment">#Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>然后在任何一个位置标记上 RSS 源的链接，类似<code>**/atom.xml</code>这样的链接。例如本站的 RSS 是：<code>https://josep-h.gitee.io/atom.xml</code>。（这个链接可以在每篇文章右边的 Links 的最后一排找到。）</li></ul><p>　　这样就可以通过 RSS 阅读器获取信息了。需要注意的一点是，这样拉取的信息是不完整的，例如文内放置的音乐不会呈现在部分 RSS 阅读器中（这个情况在 Inoreader 中存在。）</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兩隻金烏（上）</title>
      <link href="/2020/10/09/essay/%E4%B8%A4%E5%8F%AA%E9%87%91%E4%B9%8C/"/>
      <url>/2020/10/09/essay/%E4%B8%A4%E5%8F%AA%E9%87%91%E4%B9%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　相傳在盤古開天闢地後不久，天地間仍處在某種混沌，在這漫長的時間中誕生的是一種金色的鳥，它被人們稱爲金烏。</p><p>　　　　——《華嵇紀-卷三》</p><a id="more"></a><h2 id="金烏-（一）"><a href="#金烏-（一）" class="headerlink" title="金烏 （一）"></a>金烏 （一）</h2><p>　　「金烏」是我在鄉下採風的時候，偶然從小鎮裡的一個當鋪的老闆那聽來的事情。他顯然不是很清楚金烏具體是什麼，只是神神叨叨地說這是一種不可靠近的神鳥，通體金色，凡靠近之物均不可逃脫灰飛煙滅的命運。看着他一臉的嚴肅，這毫無疑問勾起了我的好奇心，開始在坊間搜索關於這個「金烏」的故事。我發現這裡的像我這樣的年輕人，大都不太知道這個事情；但老人們或多或少都聽過這個故事。他們對於這個事情的表述沒能更加詳細，只是慢慢得知了所謂「金烏」可能是複數的存在，甚至可能是一個「種族」，如果我們能這樣稱呼。</p><p>　　這樣無謂的搜索持續了約莫兩周的時間，也接近了我採風得到的假期的時間的尾聲。儘管期間一直在這周圍打探「金烏」的故事，但總歸覺得這還是在迷霧裡的一個東西，是一個比傳說更爲難以信任的東西。但我相信所謂傳說皆具有某種源頭，而這個源頭就是我感興趣的東西。抱着最後的期待，我走進了當地的圖書館的古籍區，打算在這裡碰碰運氣。</p><p>　　正當我搜索到一部叫做《華嵇紀》的時候，我突然產生了某種靈感，篤定這本就是我一直在尋找的東西了。我順着他的編號朝着書架上尋去的時候，卻發現這本書不在架上。它被借走了？我很失望地回到檢索處。這些小挫折難以擊敗我這樣折騰的人，於是我開始不依不饒地詢問檢索處的工作人員，連珠炮地詢問着，「這本書現在在哪裡？」，「哪裡有它的副本或者有誰知道這本書情況？」等等的問題。工作人員陷入了某種茫然，慌亂地回答着：「它不在書架上嗎？」，「哦哦，我不清楚它的情況，但我認爲圖書管理員或許知道」。然後我追問道，「那圖書管理員現在在哪呢？」。工作人員便又開始吱吱唔唔了。</p><p>　　儘管工作人員的無用超出了我的想象，但還是給我指出了一個方向，「在那邊有個小梯子，那個梯子一直往上，通向一個小閣樓間。閣樓間裡是我們圖書管理員的辦公室，你去那裡問問。」這是我知道的一切新鮮的信息了。</p><p>　　儘管不懷什麼期待，我還是爬上了這個梯子，見到了一個空空的小房間——裡面空無一人。這是一個非常非常小的房間，四處的裝潢也是嶄新的，仿佛家具是剛剛才被搬放至此，沒有任何沾上的灰塵，這對一個閣樓來說簡直難以置信。這裡擺放的東西也讓我認識到這裡的工作人員很快會回來。於是我暫時離開了圖書館，到了對面的一家麵館，打算隨便吃點什麼。但這裡的人山人海的吃飯場景讓我食慾全無。匆匆吃完，發現現在還沒到圖書館上班的時間，不得不在旁邊的一家小茶館裡面整理這段時間採風的成果。然而由於我過於執着於金烏，自己的工作進展反而是一籌莫展，覺得這次的採風終歸是失敗了。</p><p>　　對自己的工作感到失望之後，我再一次回到了那個閣樓里的小房間。「不，我不知道有這本書。哦，或許說我聽說過，但不詳細了解。」，「不，我不是古籍區的管理員，我是圖書館的管理員。」，「你不該來找我，你應該去三樓的那個總管理部。他們或許會知道。」然後我得知了如何到達圖書館三樓——這實在是非常費勁的一條路。</p><p>　　在我找到他們所指的總管理部的房間時（事實上，我在中間繞了很多很多的路，三樓有非常繁複的辦公室設置，每一次我敲開一扇門，都會有一個鐵板一樣的臉出現告訴我，「對，我們是總管理部，但不我們不負責你希望詢問的內容。不是我們這裡，你應該去檢索處問清楚。」），我第一次感到如釋重負。</p><p>　　「請問，我在找一本叫做《華嵇紀》的古籍，請問你們知道這本書現在在哪裡嗎？檢索處告訴我這本書並沒有被借閱，但……」我試圖組織我的語言。「但它不在這裡對吧？」管理人員看着我。「對，我想……」我注意到他直愣愣地看着我，但還是不得不接下去，「我想知道這本書在哪裡，我想立刻借閱它。對，我想立刻借閱它，我趕時間。」</p><p>　　他看了我好一陣子，好像仔細的考究着我的眼睛和鼻子的位置是否正確一樣最終得到了準確的結果一般，終於開口了。「你的情況我清楚了。你希望立刻借走一本沒有被標註爲借出的書，或者他的副本……」此刻他桌上的電鈴響了，然後他結束了到嘴邊的言論，說了句失陪然後快步離開了辦公室。我窘迫地站在那裡。</p><p>　　大概一刻鐘後，管理人員回到了辦公室，在自己的椅子裡坐下，在文件里一陣翻找之後，「對的，對的。我知道了，我今天早上剛剛收到一份整理的古籍清單。清單顯示你要的那本書，在一樓小梯子通往的閣樓里存放着。不過那本書非常破敗了，你可能看不到它。如果你想看到這本書，你需要找那裡的管理員。」「可是我剛剛從那裡過來」，我小聲抗議。「如果可以」，管理人員看着我，「你能告訴我你找那本書做什麼？我看過那本書，或許還記得什麼。」我感到我露出了一個吃驚的表情。「真的？那太好了，我在找關於『金烏』的事情，請問您知道嗎？」「對，我知道，那個『金烏』。」</p><h2 id="金烏-（二）"><a href="#金烏-（二）" class="headerlink" title="金烏 （二）"></a>金烏 （二）</h2><p>　　「如果我沒記錯的話」，他說了這句話後停了下來，開始在文件堆里翻找着什麼東西，儘管我們都知道他翻找的動作並不會幫助他回答這個問題。「《華嵇紀》裡確實有着關於『金烏』的記錄，但還是不甚詳細。有這麼一句話，『相傳在盤古開天闢地後不久，天地間仍處在某種混沌，在這漫長的時間中誕生的是一種金色的鳥，它被人們稱爲金烏。』我記得很清楚。」</p><p>　　我草草地在筆記本上記下這句話，這基本上是這段時間最爲切實、明確的進步了，但還是，存在於語言這種轉瞬即逝的載體之中，甚至我連自己是否有一部分字沒聽清而理解錯誤都全然不清。就在我這樣思考的時候，聲音在這個房間中的混響也結束了，於是我不得不重複一遍他的話以得到確認。他點了點頭，同時示意自己也不記得更多的細節了。「總之你可以去一樓閣樓拿到那本書，如果一切順利的話，它應該在那裡。」</p><p>　　事情發展至此，我不敢認爲關於「金烏」，我能從這本書里找到更多的細節，於是我點了點頭，對他表示感謝，然後離開了。但我很快意識到，在這個小鎮裡，對金烏感興趣的不止我一個。</p><p>　　在我的上次徒勞的搜索後的兩天的早晨，我所居住的賓館前台告訴我有一位女士曾經給我打過電話，關於「金烏」的事情。我很激動地記下那個電話號碼，向賓館道謝後匆匆忙忙走到外面的電話亭，撥下那個號碼。不一會，我聽到聽筒里傳來一個女性的聲音，「請問您是那天搜索那個『金烏』的先生嗎？」「是的是的，請問女士是？」</p><p>　　我明顯感覺到對方有些許遲疑，但還是立刻答道，「我也是搜索『金烏』的人之一，我在小鎮的圖書館裡和檢索處詢問一本叫做《華嵇紀》的時候，檢索處工作人員告訴我，就在兩天前有位先生也問過這部書的事情，她給了我一個電話，於是我遲疑地打了過來，發現接電話的是賓館的前台……所以……」聽到對方這樣說，我不免失望——這意味着對方知道的信息應該不比我更多。我把我收集到的信息一五一十地告訴了她。「這樣吧，我希望再去一次圖書館。我想自己找到那本古籍看看。」我感到些許無奈，但還是只能回答說，「好，我也打算這樣做來着。不然就明天吧？」然後是一些瑣碎的約定。</p><p>　　第二天，早晨八點半的時候，我在圖書館的門口看見了一位端莊的女性，相當文質彬彬。既然是追蹤「金烏」的人，自然是一個研究傳說或者民俗之類的學者了（除了我這種僅僅出於遊手好閒性質的）。我向她揮了揮手，示意她我就是那個搜索金烏的先生。</p><p>　　「哦，早。」「嗯，早。」套路的見面禮結束後，還是有些許尷尬。「那我們進去吧？」在進去的過程中，我再一次簡單地向她說了一遍自己那天在圖書館裡的糟糕經歷。這一次我有了明確的目的地，那個曾向我背誦過《華嵇紀》內容的管理人員。我直覺地知道這是位某種意義上的「該書籍」的最高管理者。</p><p>　　因爲我已經來過了三層的總管理部，這一次我很快找到了這個地方，見到了上一次的那個管理人員。我示意讓女士先進去說明來意，自己也緊跟着進去了。管理人員的回覆和之前並沒有什麼差異，依然是讓我們去一樓閣樓間找圖書管理員。但我們不依不饒地問了許久，管理人員表示自己在下午會給我們一個回復，關於那本古籍現在在哪裡、是否可借閱這種種問題都會一一告知我們。我們心滿意足地離開了三樓總管理部。</p><p>　　「現在我們去哪裡？去一樓閣樓嗎？說不定能直接看到《華嵇紀》。」我點頭表示同意。不久後我們站在了一樓閣樓間的地板上。這裡的一塵不染等等特點完全如同上次，這一次書籍管理員正坐在我們進門正對的那個辦公桌上。上面的檯燈發出橙黃色的光線，讓整個房間的整潔呈現出了一種奇特的氛圍。「嗯……那個……」站在我身旁的女士打算開口，「我們是來詢問關於《華嵇紀》的事情的。總管理部的人說，這部書現在正在你們這裡，請問我們能看一下嗎？我們只對這本書的一部分感興趣。」「啊，很遺憾！我們並不知道這本書在哪裡，正像我們之前告訴過你們的這樣。這樣的書籍不會經過我們管理員之手，而是直接交給古籍管理員。」「但我們怎麼找到這個古籍管理員？」「這個我也告訴過你們了。」圖書管理員很不悅地看着我們兩個。</p><p>　　很快圖書管理員似乎看出她的態度太強硬，便補上了幾句。大概是說她確實不知道情況，這些書不經由她們之手，我們找到古籍管理員一定能要到這本書云云的話。並且對總管理部管理人員記憶的段落表示不予評論，「我沒看過這本書，它壓根沒到我的手上。」然後又緊接着說，建議我們不要接着找這本書給圖書館帶來麻煩云云的話，又表示那本書沒有什麼價值云云。我們簡單地堆笑應付了一下就離開了。</p><p>　　「我查找了這裡的所有文件，關於那本《華嵇紀》的。」管理人員轉動着他的小轉椅，「記錄這有關它信息的，有且僅有我說的那個關於古籍的清單，除此之外，我找到了一些專家。他們有的肯定地表示我的回憶是精確的，但這本書恐怕已經不容易找到了。它或許作爲重點的保護對象保護起來了。」我們正想追問更多的細節，但管理人員露出某種無可奉告的神情，把我們請出了總管理部。</p><p>　　這個時候我才突然想起，「你是爲什麼需要找到這部書？」這位動人的女士回答道，「我是研究民俗的學者。我在研究中發現在一系列討論宇宙生成的傳說記載中，都提到了一個名爲『金烏』的生物，他們表示，這種生物在傳說中的地位不可動搖。但是在我查找一切關於『金烏』的論證之後，發現他們不可避免地引用了這本名爲《華嵇紀》的古籍。然而我跑遍了大半個都城，都沒找到這部神祕的古籍，我一直追蹤至此，找到了關於它的些許線索終於也在這裡斷掉了。」</p><p>　　她停止了講述看着我，似乎想聽聽我尋找金烏的理由。面對這樣認真的學者，我對自己的畫家身份感到羞愧，也恥於告訴這位博學的女士自己僅僅是處於好奇才這樣大費周折的，於是我尷尬地笑了笑，沒有出聲。</p><h2 id="《華嵇紀-卷三》"><a href="#《華嵇紀-卷三》" class="headerlink" title="《華嵇紀-卷三》"></a>《華嵇紀-卷三》</h2><p>　　相傳在盤古開天闢地後不久，天地間仍處在某種混沌，在這漫長的時間中誕生的是一種金色的鳥，它被人們稱爲金烏。</p><p>　　金烏通體金黃，部分呈現赤紅色，故也名赤金烏。金烏呈現鳥的形態，有寬闊的雙翅，展翅可包攬視線中的全部天空。其全身仿佛被火焰包裹，以致耀眼奪目，人類不可長久直視。觀看過久者眼睛會呈現異變，留下黑癍，之後該人若觀察其餘物體，皆會看見一淡黃色重影，並呈現出金烏的輪廓。</p><p>　　金烏每日自陰影處起飛，連續飛翔一日到陰影處停歇，凡飛過之處，皆一片光明燦爛。傳說，金烏非晨起松枝所掛之露珠不飲，非夜雨後拔起之筍不食。後來，金烏漸漸隱去了蹤跡，聲稱自己看見過金烏的人也明顯變少。爲銘記這種神鳥，世人爲太陽起別名爲金烏。（燈徽氏作。）</p><h2 id="現代的金烏（一）"><a href="#現代的金烏（一）" class="headerlink" title="現代的金烏（一）"></a>現代的金烏（一）</h2><p>　　由於各種尋找的嘗試我都碰了壁，再加上自己的假期也已經在不知不覺中用盡，不得不起了歸意。「這個傳說雖然是從這裡被我發現的，卻不意味着這個傳說只有這裡才有。」我一邊把我這幾日的衣服收進包裹里一邊這樣想。我走到旅館的櫃檯，把這幾日的旅費和伙食費一併結了，突然起意想要給那位女士打一個電話。後來想想還是算了，就借旅館的信紙隨隨便便寫了些告辭的文字，放進了旅館門口的郵筒然後就離開了。</p><p>　　後面回到了自己的寓所，卻總是記掛着那個叫做「金烏」的生物。我嘗試找了不少當地的民俗學家、民族學家，但也只能說是一無所獲。有的民俗學家能說出《華嵇紀》的名字，而其他的則都搖頭表示從未聽聞。經過幾日的折騰，雖然繪製的作品還在緩慢地推進，但心思總不在上面。每次畫上幾筆，便覺得索然無味，想要拿起畫板就砸下去。想着「今天就到這裡吧」，就擲下了筆，接着苦惱「金烏」的事情了。</p><p>　　反覆苦惱了幾日，一日在外出吃飯途中偶然發現散落在地上的報紙。報紙上用那種廉價的紙印着誇張的大號字寫成的誇張的標題。我拾起這個報紙，報紙名爲《日新日報（娛樂版）》。反覆翻了幾次。這個報紙的報社（日新報社）是當地非常有名的一家民營企業，除了專門刊登國際或者全國要聞的核心報紙，還有許多八卦花邊、娛樂活動的周邊報紙。我手上的這份《娛樂版》便是報道娛樂周邊的小報。大標題是某某馬術比賽，哪位哪位和哪匹哪匹又奪冠了。我隨便翻了翻，尋人啓事、招聘崗位、治療腳氣的廣告什麼的，真的是應有盡有。我想了想，帶着報紙回到了畫室，試探性地給報社打了一個電話，問了問刊登小邊角啓事的要求和酬金等等。心裡盤算了一下，便聯繫報社，打算在該報的小角落連續登個一周的廣告。</p><p>　　」先生們好，鄙人系某某畫社畫師，日前打算以本地傳說爲題繪製大型主題作品。但在『金烏』這一主題上缺乏素材。望知情人士將信息材料郵寄給本人，經驗證後將重金回報。「後面是我的地址、聯繫方式種種。帶着這個短訊造訪了報社，將之交給了報社之後，我並不期望能獲得什麼新信息，還是就回到畫室接着開始自己不安穩的創作。</p><p>　　報紙所說的」以本地傳說爲題「這個，其實並不是胡謅的，也的確是我目前正在從事的創作。我本次前去採風也是希望搜集這方面的線索。然而七色鹿、玉蟾蜍此類，比起這神祕的」金烏「都突然間黯然失色，也不怪我看着空白的畫布靈感頓失。看着滿屋子混亂不堪的景象，我才反應過來，我現在還餓着肚子。</p><h2 id="現代的金烏（二）"><a href="#現代的金烏（二）" class="headerlink" title="現代的金烏（二）"></a>現代的金烏（二）</h2><p>　　伸伸懶腰，打算出去溜達一下。我習慣性地走到樓下的收信箱，打開收信箱的蓋子，抖出一大堆信件。裡面多是各地畫展的過時的邀約等等，夾雜着一些通過不正常方式塞進我信箱的糟糕小廣告。我把這些信件摞在一起，在桌上震了震，讓它們看起來規整了一點，便準備扔到最近的垃圾箱裡。</p><p>　　這個時候，一個包裹的有點凸起的信件吸引了我的注意力。這封信件不像那些噴着怪異味道香水的邀請函或者小廣告，只是在信封上寫着收件人的姓名和地址。我把這封信挑了出來揣在了衣兜里，把別的都扔進了垃圾箱，然後開始信步四處溜達。</p><p>　　回到畫室，剛剛坐下準備泡杯熱茶，才想起包里還裝了一封奇怪的來信。我把它從衣兜里掏出來，平展在畫桌上，起身去泡了杯熱茶。</p><p>　　「畫家先生敬啓。」</p><p>　　這恭恭敬敬的樣子，和這種看起來不太精緻的包裝，恐怕是哪裡的窮酸書生吧。我用裁紙刀劃開了信件表面，看見了裡面的東西。是一根不明所以的黑色羽毛和一封有着清秀字體的書信。書信寫得密密麻麻，顯得非常缺少紙張的樣子，但是在這衆多的字跡里，我抓住了這樣一個詞：「金烏」。難道說，這個羽毛……？！我擱下了自己的水杯，迫不及待地抓起這封信，全然不顧這封信究竟是從哪裡來的、爲什麼會寄給我，開始了閱讀。</p><p>　　（事實上，我收到這封信的時候，已經是我在報紙上刊登啓事後的一個多月了。儘管對「金烏」的好奇未減，但是出於養家糊口，我不得不把自己的精力重新集中到自己的傳說主題的畫作上。畫作的進展異常地順利，讓我漸漸忘了我在報紙上登過啓事這門子事——這個事實還是在我讀完這封信件，正意猶未盡的時候突然想起的。）</p><p>　　以下是我收到的信件的原文，我承諾信件的內容沒有經過任何修改，一字一句甚至連一個標點都沒有被擅自動過，除了我隱去了信件寄件人及其朋友的姓名，用張三李四這樣的名字代替了。</p><h2 id="現代的金烏（三）"><a href="#現代的金烏（三）" class="headerlink" title="現代的金烏（三）"></a>現代的金烏（三）</h2><p>畫家先生敬啓，</p><p>　　抱歉貿然給您寄來此信。鄙人深知這已經是您在《日新日報》上刊登徵集信息啓事的三周後了。近日您未繼續在該報紙上刊廣告，鄙人以爲您或已經完成了創作，或因沒有足夠信息而未能繼續創作。（鄙人真誠希望事情正如前者發展。）</p><p>　　正如前文所言，鄙人此番來信，是爲畫家先生提供些許關於「金烏」的信息。您也不需要給什麼回報，如若能助力您作出名畫，鄙人便已心滿意足。</p><p>　　餘下不表，鄙人不止在書中見到的「金烏」一詞，而是自己親眼看過幾次。此事回憶起來，已是三四年前的事情。那時間，鄙人費盡心力準備某書塾的考核，成年累月翻閱經書。然枯燥之至，每過幾日，必得起身，至林木蔥鬱之處放鬆身心。其間某日，艷陽高照，恍惚間，天地昏黑，轟響陣陣；狂風大作，芳草皆俯伏，蓋一大鳥自雲間飛過。鄙人見識短淺，竟一時愣在原地。待大鳥飛過，轟鳴漸消，鄙人方得回神。其勢驚天動地，仿佛書中所述「金烏」，然並非金色，而是通身玄黑。</p><p>　　鄙人深覺驚駭，便連連造訪此地。後又見得幾次大鳥。數次後，鄙人以爲，大鳥於太陽升起後數時後飛起，太陽落下前數時飛回。其與《華嵇紀》中所記相差甚大，其雖聲勢浩大，然無令人頂禮膜拜之氣質，與鄙人所想象神鳥相差甚遠。爾後幾日，鄙人雖仍定期造訪該地，但無緣再見到真身。然而，鄙人對此大鳥乃金烏這一觀點深信不疑。</p><p>　　畫家先生必嗤笑鄙人所見絕非金烏。先生請想，書中所記金烏距今已不知多少時日，其豈能千百年間絲毫不變，從未演進？金烏記述漸少，並非金烏隱其身遁其形，只因其演進變化，肉眼凡胎不能辨識之，而神鳥豈需隱身遁形！且以其遮天蔽日、芳草失色之形態，不做他想。</p><p>　　隨信附有鄙人經過多次探訪在博物館中找到的類似「金烏」羽毛樣式的樣本，但顏色和大小與鄙人所見相差甚遠，僅供您參考。此外在另一個包裹中是鄙人在金烏駛過地點拾到的一小片黑鱗，鄙人猜測此爲金烏的爪上遺落，故也隨信寄送。然黑鱗不能放入此信封，遂將其單獨包裝在另一信封中一同寄送。</p><p>順頌時祺，</p><p>張三</p><h2 id="現代的金烏（四）"><a href="#現代的金烏（四）" class="headerlink" title="現代的金烏（四）"></a>現代的金烏（四）</h2><p>　　我看完這封信不禁啞然失笑——這不是現在時髦的所謂」飛行器「這樣的東西嗎？這終究是個每日讀書讀蠢了的書呆子罷了，出去散步竟然以爲自己見到了什麼不得了的東西。這個所謂金烏羽毛的東西，不就是類似螺旋槳的翼片這樣的東西嗎？實在是有點可笑了。想到這裡，便也覺得自己也是值得笑話的角色。哪裡有金烏這樣的東西呢？居然還在最開始對那根羽毛產生了這樣的無端的猜測。算了吧，讓那」金烏「去吧。我把這個之前備受我期待的信件和那根黑色的羽毛揉在一起，丟到了我的廢紙簍里，想到他提及的」黑鱗「，應該是早早就被我扔到收信箱旁邊的垃圾箱裡了。</p><p>　　抿了口桌上的熱茶，我接着完成我的畫作。<br>　　<br>　　這個事件之後，我對金烏的興趣頓時減了大半；加上工作纏身，又任何搜索金烏的進展都碰了壁，完全沒有任何推進。就算是我這樣遊手好閒的角色，也終於奈何不了這個神祕的傳說，只得作罷。往後我的工作波瀾不驚，金烏也完全從我的生活中淡去。幾個月後我從那個小鎮的圖書館那收到了一封明信片，意思是那邊收進了一批古籍，誠邀熱心讀者前往云云。至於這是怎麼回事我也不知道了。</p><h2 id="屋頂的金烏（一）"><a href="#屋頂的金烏（一）" class="headerlink" title="屋頂的金烏（一）"></a>屋頂的金烏（一）</h2><p>　　像往常一樣，我坐在自己的畫布前。然而我畫室的樣子已經完全不同，我用自己主題展賺到的一點錢，在原來城市的隔壁購置了一個新的畫室：這個畫室臨海，其餘兩面爲山。這裡雖然看起來偏僻，但是去最近的城市還算方便。但由於不在城市裡的緣故，前來拜訪的客人還是少了許多，我也幸得個清閒。爲了這裡的美景，我特意鑿通了一面牆，改造成了大玻璃，這樣能一覽外面的美麗風光，順便也讓畫室看起來寬敞了很多。不知道是因爲周圍環境變化了的緣故還是什麼，一時間靈感如噴泉般湧出，所以我也能全身心地投入在創作中。</p><p>　　在我搬了新家後約莫兩三個月的某日早晨，我還在疊放被子的時候，聽見一陣沉穩有力的敲門聲。這個地方、這個點，不太會有人來的。「畫家先生，」我聽見門外有個渾厚的男聲在喊，「麻煩您開下門。」行吧。「好，這就來。」我把剛要疊好的被子就扔在那，帶上臥室的門，走到了客廳旁的玄關。我打開門，還沒來得及詢問對方是誰就注意到了對方的穿着。</p><p>　　門外站着可能有一米九的壯漢，全身站得筆直，穿着淺藍色的筆挺制服，腰上跨了一個四方形的小包，帶着令人愉悅的笑容。這是民警的制服，雖說談不上熟悉，但還是能一眼認出來。我在那裡愣了一小會，「請進，請進，民警先生。」對方鞠了一小躬表示回應，然後走到了客廳的沙發旁邊。我示意他先坐，然後自己去廚房準備一些紅茶。一會後，我回到客廳。「請問民警先生來鄙人的小畫室做什麼？」我一邊將茶杯遞給他。這位熟練地把杯子接過去，喝了一小口，然後把杯子放了下來，前屈自己的身子看着我，「先生，您知不知道那個叫做『金烏』的盜賊？」</p><h2 id="屋頂的金烏（二）"><a href="#屋頂的金烏（二）" class="headerlink" title="屋頂的金烏（二）"></a>屋頂的金烏（二）</h2><p>　　我迅速回想起了半年前的報紙，當時鋪天蓋地地報道着「金烏」的「光榮事跡」，幾乎這附近的所有博物館都曾被他光顧過，然而每次都能逃脫。我當時也產生了一點小興趣——那已經是我停止調查「金烏」後的一年多了。這個「金烏」之所以被稱爲金烏，是因爲他的每一次偷盜的展品的現場牆壁都會抄錄同一段話，這也就是我曾經記下的《華嵇紀》的那一段對於金烏的表述。儘管莫名奇妙，但這個盜賊還是被民間用「金烏」稱呼。<br>　　<br>　　由於警察一時間的束手無策，加上政府的高額懸賞，當時還掀起了一陣「金烏學「研究的熱潮，希望從這個角度揣摩這個高調的盜賊的意圖。然而線索並沒有比我自己搜尋的時候多出什麼，「金烏學」研究愛好者沒多久就銷聲匿跡了。後面關於」金烏「的報道也日益減少了。我揣摩警察局顧着臉面，把一些」金烏「案件藏了起來，或者塞給了別的連環案件，避免被民衆指責爲無能。我很早就注意到了這個盜賊，並開始了調查。但是如同我搜索那本古籍一般，我完全找不着這個盜賊的線索。這也難怪，若我能找到，警察也就真是吃白飯的了。</p><p>　　回過神來，我注意到了正端詳着我的民警，我這才發現他進屋之後只說了那麼一句話。不過，民警拜訪我做什麼？我一動不動地坐在那裡，觀察着這個民警的動靜；這個民警也一動不動地坐在那裡，觀察我的動靜。茶水慢慢開始不冒出白煙，外面的鳥聲也逐漸停歇了。民警看起來是突然想起了什麼，開始不再繼續對我的觀察，而是翻起了他的小腰包，然後從裡面掏出了裝在塑封袋裡的一張皺巴巴的紙。他用彎曲的食指和拇指夾起這個塑料袋的一角，小心翼翼地把它夾着，移動到了我的面前。</p><p>　　這是有些年頭的一張小紙，大概是 10 裡面長寬左右。它的背面（我認爲是背面，因爲上面什麼也沒寫）一片空白，除了各種經過蹂躪收穫的褶皺以外，還有一個黑色的燙疤。這些褶皺看起來都已經稜角不清，應該是在某一個平整的東西下面壓過了不少的時間才恢復成這樣；黑色的燙疤中間基本已經碳化，周圍輻射出棕色的燒痕。我想警察點點頭，示意我看得差不多了，此時警察非常緩慢地轉過了一個角度。在旋轉的過程中，我們明顯注意到在紙的另一半寫着一行小字以及一串數字一樣的東西。警察將其旋轉了一百八十度後再一次靜止了下來，他的手臂呈現出一種非常僵硬的角度。我指指面前的桌子，示意其完全可以把它放下來，但他搖搖頭，等着我再接着觀察那張來歷不明的紙片。</p><p>　　紙片的另一面，正如我前文所說，是一串文字和另一串數字。那串數字我再熟悉不過，儘管我現在已經搬到了新的工作室，但那串熟悉的數字曾作爲我與外界重要的聯繫而存在。上面那串文字則記錄着我更加熟悉不過的東西。我將我的視線移開那張紙，疑惑地看着對面的民警。他的手臂由於維持着這個誇張的姿勢而微微顫抖，但是他什麼也沒有說，他熱切地看着我，我只好揣起手，更加仔細地看這張紙片。</p><h2 id="屋頂的金烏（三）"><a href="#屋頂的金烏（三）" class="headerlink" title="屋頂的金烏（三）"></a>屋頂的金烏（三）</h2><p>　　紙片上清清楚楚寫着的，是我原來畫室的詳細地址以及電話號碼。字體是用那種相對粗、並且很不適合書寫這種語言的鋼筆寫成的，可以看到有一些字體的結構已經粘在了一起，但這不會影響這張紙條傳遞的訊息。這張紙的這一面無疑也有一塊燙疤，只不過顏色更淺一點，基本上只是一片棕色。除此之外，我在這張紙上找不到任何的信息。</p><p>　　我解開了揣着的右手，四指指向民警並掌心朝上微弓，示意他可以把這張紙收回去了。他看見我的動作，點了點頭。將他的彆扭的手腕迴轉了一百八十度，保持着大臂和小臂的角度，將紙條放回了腰包，並從中掏出了另一個用檔案袋包着的東西。不過這一次，他很輕鬆地把它放在了我的桌子上，然後再一次坐直，恢復了之前端詳我的姿態。</p><p>　　我拿起檔案袋，看着他打算詢問是否可以拆開。這位民警用我剛才示意他收回的動作朝着我，示意我打開。我逆時針轉着檔案袋上的棉線，但裡面是什麼，我心裡已經有數了。這是一個很輕的檔案袋，裡面可能塞着四五張 A2 大小的紙。揭開了檔案袋的封口之後我抽出了裡面的東西——準確說是還沒有完全抽出，我看見了「日新日報」四個字之後就又塞了回去，順時針將棉線纏好，打算再一次將它放在了桌子上。民警伸出手，在半空中就接過了檔案袋，放回了自己的包里，然後回到了筆直的坐姿。</p><p>　　我看着他，等着他說些什麼，但誰也沒有打算說話。我起身拿起桌上的兩個茶杯，去廚房添了一輪熱水坐了回來。在我回來的時候，沙發上的凹陷尚未完全恢復。我把接好的熱水推到他的面前，扶了扶自己的眼鏡，「那麼，警察先生造訪寒舍，有何貴幹？」。我感覺民警立得不能更加板正的身姿又直了一些，臉上沒有什麼表情，「沒有什麼，想知道您是否知道這位『金烏』？」。我正想回復一些可有可無的套話的時候，對方打斷了我，「這張紙是從『金烏』逃逸的藏身處找到的。」</p><h2 id="屋頂的金烏（四）"><a href="#屋頂的金烏（四）" class="headerlink" title="屋頂的金烏（四）"></a>屋頂的金烏（四）</h2><p>　　果然，這種戲劇性的發展居然落到了我這個過着平平無奇的人的身上。我不知道是該慶幸還是該咒罵幾句——因爲我突然覺得，這是一個能夠接觸到「金烏」的好機會。不過！？我突然覺得哪裡不對勁。我突然想起了數月以前，和我一同造訪圖書館的那位氣質不凡的女士。總不會是她的，我這樣想。於是我打消了我差點吸一口的涼氣，端起眼前的熱水。熱水上的白煙尚且縈繞，彰顯着它的溫暖。字體，我怎麼都不覺得那個字體是……噢，不對我糊塗了，那個是《日新日報》的剪報，並沒有什麼字體的存在。不過那燙疤像是落下的煙頭造成的，這個時候哪裡有女士抽什麼煙啊。</p><p>　　這樣我打定了結論，看着那個正等着我回復的、面無表情的民警，「不，我想我不認識。」這個時候我的熱水回到了桌子上。「不過」，我果然還是想說些什麼，「我對這個事情很有興趣，或許是我遺漏了什麼細節。如果可以的話，我可以參與你們的行動嗎？如果能在現場看見什麼……」「不行。」說着民警就站了起來，「今日打擾了，謝謝您的茶水，我這就告辭。」我還沒來得及說更多話，就看見他三步兩步走到了門口，向我彎了彎腰表示感謝，然後推門出去了，留下一個我還雲裡霧裡地坐在原地。</p><p>　　這個時候，鳥叫便又清晰了起來。我完全不清楚剛才發生了什麼，以及那個名爲「金烏」的盜賊爲什麼要留下那份剪報。我的門鈴響了。我本以爲我會在門口看見那個僵硬的民警，但是在我打開門後，什麼也沒有出現。我注意到了躺在我門前的一方小小的報紙。今天的報紙——看來剛才的是報童吧。也對，可敬的民警先生根本就沒有按門鈴什麼的。我拿着報紙回到了剛才的桌子旁，實現不由自主地被報紙的標題吸引了：「金烏」向警察發出挑戰，10 月 19 日，他將造訪本市博物館，「盜取」世界名畫。這巧了，就是今天吧。</p><p>　　想着自己沒什麼事情干，於是開始整理自己的着裝打算出門先去附近的餐廳隨便吃點什麼，先去博物館裡面逛逛，看看這個「金烏」到底是對什麼東西感興趣。於是我隨便弄了些早餐就出門了。在我關上門的時候，我分明聽見了屋裡的電話傳來的鈴聲。既然我已經關了門，如果是編輯部的催稿啊什麼的，那請儘管過來吧！於是我一搖一擺的往博物館的方向去了。然後我在路上發現了一兩隻正模仿着我動作的鴿子，也在那裡一搖一擺的。我扇了扇手上的報紙，把它們嚇跑了。</p><hr><p>　　<strong>題外話 1</strong>：到目前爲止，《兩隻金烏》一篇的長度已經超過預期了（囉哩吧嗦將近萬字了吧？），將這麼個長文章放在一起未免太挑戰自己的筆力和讀者的耐心了，故在此階截斷，將後面的部分放置《兩隻金烏》（下）或者（中）繼續。</p><p>　　<strong>題外話 2</strong>：這一部分創作實在是預料之外的事情，感覺我已經一定程度地偏離了初衷，但是希望在朝一個還行的方向發展。本小說的實質是不會變化的，只是呈現的結構發生了預期之外的發展而已。是件好事。</p><h2 id="修訂"><a href="#修訂" class="headerlink" title="修訂"></a>修訂</h2><ol><li>經讀者建議，將「現代的金烏（一）」中的「覓食」一詞改爲「吃飯」。</li><li>將「現代的金烏（四）」及「屋頂的金烏（四）」中的「博物館」改爲「圖書館」。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雜記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode模板</title>
      <link href="/2020/10/03/tech/VSC/VSCode%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/10/03/tech/VSC/VSCode%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Snippets 即快速地插入代码片段的方法。可以通过快捷键或者自动补全生效。这里简单地记叙一下在 VsCode 下使用 Snippets 的方法，以防后日遗忘。</p><a id="more"></a><h3 id="如何配置？"><a href="#如何配置？" class="headerlink" title="如何配置？"></a>如何配置？</h3><p>Snippets 对于不同类别的文件可以使用不同的配置文件。例如对于 Markdown 来说，可以通过选择<code>File -&gt; Preferences -&gt; User Snippets</code>路径进入指令栏，输入 Markdown 进入相应的配置文件。当然也可以通过在命令栏输入<code>preferences: snippets</code>进入。<br>简单的配置文件如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">"newblog": &#123;</span><br><span class="line">"prefix": "nb",</span><br><span class="line">"body": [</span><br><span class="line">"---",</span><br><span class="line">"title: $1 ",</span><br><span class="line">"updated: 2020- $2 13:53:09",</span><br><span class="line">update_ct: 0</span><br><span class="line">"date: 2020- $2 13:53:09",</span><br><span class="line">"layout: page",</span><br><span class="line">"toc: true",</span><br><span class="line">"mathjax: true",</span><br><span class="line">"tags: [ $3 ]",</span><br><span class="line">"categories: [ $&#123;4|随笔, 技巧, 学科|&#125; ]",</span><br><span class="line">"---",</span><br><span class="line"><span class="string">"&lt;!--more--&gt; $0 "</span></span><br><span class="line">],</span><br><span class="line">"description": "create a new blog"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里的<code>prefix</code>便是触发 Snippets 的前置。Body 是主体，其中<code>$0</code>表示光标出现的位置。</p><p><strong>特殊之处</strong></p><ul><li>多光标可以通过<code>$1</code>，<code>$2</code>等表示，其表示先后到达的顺序，可以通过 Tab 键到达下一个光标位置完成修改。</li><li>同时也可以设置<code>${1|A, B|}</code>，获得到达具体位置之后的选项。</li><li>此外可以绑定变量、设置多光标等等，这里暂时用不到故忽略。</li></ul><p>除此之外，我偶然发现了一个可以添加当前时间地点的参数设定的方法，将上面的设定改写为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">"newblog": &#123;</span><br><span class="line">"prefix": "nb",</span><br><span class="line">"body": [</span><br><span class="line">"---",</span><br><span class="line">"title: $TM_FILENAME_BASE ",</span><br><span class="line">"updated: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",</span><br><span class="line">update_ct: 0</span><br><span class="line">"date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",</span><br><span class="line">"toc: true",</span><br><span class="line">"mathjax: true",</span><br><span class="line">"tags: [ $1 ]",</span><br><span class="line">"categories: [ $&#123;2|随笔,技巧,学科,学术|&#125; ]",</span><br><span class="line">"---",</span><br><span class="line"><span class="string">"&lt;!--more--&gt; $0 "</span></span><br><span class="line">],</span><br><span class="line">"description": "create a new blog"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这个修改的版本可以自动读出当前该文件的名字（去除尾缀）作为 Blog 的标题，读出当前的时间。基本上可以完全懒人操作了。更多的设定参考链接 <a href="https://www.clloz.com/programming/assorted/2020/09/14/vscode-snippet/" target="_blank" rel="noopener">如何使用Snippets</a></p><p>以本文为例，获得的结果为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">VSCode模板</span> </span><br><span class="line"><span class="attr">updated:</span> <span class="number">2020</span><span class="number">-10</span><span class="number">-03</span> <span class="number">20</span><span class="string">:13:50</span></span><br><span class="line"><span class="attr">update_ct:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="number">-10</span><span class="number">-03</span> <span class="number">20</span><span class="string">:13:50</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[</span> <span class="string">]</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">[]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Smart-Suggestion"><a href="#Smart-Suggestion" class="headerlink" title="Smart Suggestion"></a>Smart Suggestion</h3><p>不知为何，Markdown 默认是不支持自动调起 VSCode Suggestion 的。解决方法有 2：</p><ol><li>在 Shortcuts 中找到 <code>Trigger Suggestion</code>，通过快捷键手动调起。</li><li>手动地将该设定添加到<code>settings.json</code>中：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"[markdown]": &#123;</span><br><span class="line">    "editor.quickSuggestions": &#123;</span><br><span class="line">      "other": true,</span><br><span class="line">      "comments": false,</span><br><span class="line">      "strings": false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样就没有遗憾了。该方法参见链接 <a href="https://deepns.github.io/tech/enable-quick-suggestions-for-markdown-in-vscode/" target="_blank" rel="noopener">Enable quick suggestions for Markdown in VS Code</a> 。</p><p>更多详情参见：<a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets" target="_blank" rel="noopener">Vscode官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go常用语法</title>
      <link href="/2020/10/03/tech/Go%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/10/03/tech/Go%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>开始正式学习 Go，参考该网站 <a href="https://tour.golang.org/welcome/5" target="_blank" rel="noopener">link</a>。</p><a id="more"></a>  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 C 语言，Go 程序通过调起各种包(Packages)运行，在 Import 中是调起的其他包的路径。除此之外，Go 默认也是从 main 开始运行，所以 main 函数仍然是不可缺少的。</p><p>为引入这些包，需要这样写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"main"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Export"><a href="#Export" class="headerlink" title="Export"></a>Export</h3><p>在 Go 中，大写字母开头的值是视为 Exported 的，可以为外界调用，反之则不是。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如在下述的程序中，<code>math.pi</code>就是不可调用的，并得到这样的报错：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./prog.go:<span class="number">9</span>:<span class="number">14</span>: cannot <span class="built_in">ref</span>er to unexported name math.pi</span><br><span class="line">./prog.go:<span class="number">9</span>:<span class="number">14</span>: undefined: math.pi</span><br></pre></td></tr></table></figure><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>函数定义基本和 C 语法相同，但仍存在一些差异：例如他的形参数据类型放置在形参名字后面，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，当连续多个形参使用相同的数据类型时，可以省略除了该序列中最后一个外的所有数据类型声明，例如上面的例子可以重写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义多返回值的函数也是可以的，形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，可以在函数头上声明返回的值的 name，从而在 return 语句时不加强调。然而这种方法并未得到提倡，因为在很长的函数中，似乎可读性并不强。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数应当返回（7,10），即（x,y）对应的值。</p><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>使用 var 语句声明变量。声明的方法如同函数形参，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且参数是可以定义在 package level 的，即上例中的 c, python…除了简单的声明变量，还可以初始化，变量的数据类型和初始化的数据相关。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br><span class="line">c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br></pre></td></tr></table></figure><p>如果未显式地声明，而仅仅是使用 var 定义，则同时定义不同的数据类型是可以接受的。此外可以使用<code>:=</code>代替这种情况。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">int8</span> <span class="keyword">int16</span> <span class="keyword">int32</span> <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> ...</span><br><span class="line"><span class="keyword">byte</span></span><br><span class="line"><span class="keyword">rune</span> (<span class="keyword">int32</span>)</span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure><p>这些数据类型没有初始化时，会被赋给 0 值，如<code>int</code>对应 0,<code>srting</code>对应空字符串。</p><p><strong>类型转换</strong></p><p>类型转换使用<code>a = T(b)</code>完成，如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure><p>在 Go 中，类型转换是<strong>必须</strong>显式声明的。</p><p><strong>常量</strong></p><p>常量的声明和普通变量相同，但是需要在开头加上一个 const。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><p>需要注意的是，常量不可以使用<code>:=</code>定义。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针的形式和 C 相似，都是通过<code>*T</code>表示。定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> *p <span class="keyword">int</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">p = &amp;i</span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>取地址方法及取值方法也和 C 相同。</p><h3 id="Struct-语句"><a href="#Struct-语句" class="headerlink" title="Struct 语句"></a>Struct 语句</h3><p>声明一个新类型方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">x := v.X</span><br></pre></td></tr></table></figure><p>struct 中的值可以用<code>.</code>获得。也可以通过指针的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v := Vertex(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p := &amp;v</span><br><span class="line">p.X = <span class="number">1e9</span></span><br></pre></td></tr></table></figure><p>理论上需要通过<code>(*p).X</code>访问 X 值，然而 Go 允许，仅仅使用<code>p.X</code>直接对其进行访问。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">"hello"</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure><p>Go 通过这种方式来定义数组。他的访问和赋值都和 C 相同。Array 的长度是固定的，不可以在运行过程中修改的。在上述例子中存在一个类似 C 的初始化方法，在这个初始化中，尽管声明了 6 个整形的空间，但仅仅给了 5 个初始值，则最后的一个元素会被初始化为 0。</p><p><strong>Slide</strong></p><p>与之相关的是一个特殊的数据结构 Slide：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>这个的表现和 C 语言是完全一样的，然而和预期不同的是，这个 Slide 并不储存数据，而是仅仅类似于地址和指针一样的东西。对于 Slide 的更改会导致对于其截取的原数组的更改，并且其他包含相同元素的 Slide 也会立刻应用这些更改（因为他们只是取地址）。</p><p>对于 Slide 的元素截取和 Python 一样，可以使用<code>:</code>符号表示截取范围。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:]</span><br></pre></td></tr></table></figure><p>以上四种表达是等价的。Slide 存在 length 和 capacity 两个变量。前者为 Slide 包含的元素数量，后者为 Slide 所指向的 Array，从 Slide 包含的第一个元素开始计算的元素数。这两个值分别可以通过函数<code>len()</code>及<code>cap()</code>获取。</p><p>特殊的是，我们可以 extend Slide 的范围。对于以下的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line">s = s[:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>其并不是在 Slide s 中重新获得新的 Slide，而是在完成一次 Re-sldie。即<code>s = s[:4]</code>语句是针对最开始的长度为 6 的数组进行的。这仅仅发生在，数组的长度右端超过了 Slide 的长度并小于 Slide 的容量时才会发生，称为 Extend。</p><p><strong>Nil Slide</strong></p><p>空数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"nil!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Append</strong></p><p>类似 Python 的 list，Go 提供了一个可变长的数组。这个数组在元素超出容量时会自动再分配一个空间，然后返回的地址指向一个新的数组。其使用如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// append works on nil slices.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The slice grows as needed.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can add more than one element at a time.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Range</strong></p><p>类似 Python 的，他的 For 循环也可使用 Range 操作。Range 在每一个迭代返回一个计数器和一个对象对应的值。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">"2**%d = %d\n"</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不希望获得对应的值，则可以使用<code>_</code>代替位置。如果只希望使用 index，则只显式地记下一个值即可。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 的 0 值为<code>nil</code>，一个 nil 的 Map 既没有 key 也不能增加新的 key。Map 可以使用 make 函数初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br></pre></td></tr></table></figure><p>其中，string 是键值，Vertex 是 Map 指向的对象。Map 的访问是通过键值访问的，这个设定与 C 及 Python 都一致。下面是一个更完整的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">m[<span class="string">"Bell Labs"</span>] = Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m[<span class="string">"Bell Labs"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Map 还可以如此初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">"Bell Labs"</span>: Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"Google"</span>: Vertex&#123;</span><br><span class="line"><span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者干脆省略 Vertex 声明，改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">"Bell Labs"</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line"><span class="string">"Google"</span>: &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对 Map 的其他操作</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, key) <span class="comment">// 从字典m中删去Key及其对应的值。</span></span><br><span class="line">elem, ok := m[key] </span><br><span class="line"><span class="comment">// 如果ok == true，则字典m中存在键值key；</span></span><br><span class="line"><span class="comment">// 反之则不存在，并返回0值elem</span></span><br></pre></td></tr></table></figure><h3 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum += x</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos, neg := adder(), adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pos(i),</span><br><span class="line">neg(<span class="number">-2</span>*i),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子里，函数 adder()相当于一个“函数模型”，调用这个模型获得的是一个函数的实体即 pos, neg。而这个 sum 是这个函数模型实体的参数，所以会逐渐累加，其效果如同 C 中的 static 变量。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="For-语句"><a href="#For-语句" class="headerlink" title="For 语句"></a>For 语句</h3><p>Go 仅含有这样一种循环语句。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和 C 的语法非常像。同样的，如果不需要这三要素中的某一部分，可以完全空出来，如同 C 的操作。如上第二个或第三个 For 循环。而在 Go 中，并没有专门的 While 语句，有上述第三种 For 循环代替。</p><p>更直接的，如果希望写出一个死循环，则可以如此写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="If-语句"><a href="#If-语句" class="headerlink" title="If 语句"></a>If 语句</h3><p>和 For 语句一样，成分不需要使用括号包含。但是大括号是需要的，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 For 语句，If 语句可以在条件前增加一个初始化语句。该初始化语句的内容，在后面大括号范围内有效。例如下面的写法是有效的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%g"</span>, v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Switch-语句"><a href="#Switch-语句" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><p>Switch 语句和 C 语言相似，然而，Go 的 Switch 语句不会运行后面所有的部分，而仅仅运行满足条件的语句。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// freebsd, openbsd,</span></span><br><span class="line"><span class="comment">// plan9, windows...</span></span><br><span class="line">fmt.Printf(<span class="string">"%s.\n"</span>, os)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的程序仅会运行其中的一项，而非所有。同时这个初始化语句和 If 语句相同，是可以省略的。与 C 不同的是，这里的 Case 语句不需要是 Const，同时也不需要是整型。同时，Switch 是从上往下执行的，他会在任何一个满足条件的 Case 中停下并不再考察后面的 Case。</p><p>特殊的，我们可以声明一个不带有条件的 Switch 语句。此时，这个 Switch 语句的含义是传递一个 True 值。然而我们在 Case 的声明时，仅需要返回 true 或者 false 即可。换句话说，我们可以将其作为一个 if-then-else 的链使用。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good morning!"</span>)</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good afternoon."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good evening."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Defer-语句"><a href="#Defer-语句" class="headerlink" title="Defer 语句"></a>Defer 语句</h3><p>Defer 语句会暂停现在的所有执行，直到它环境里的其他语句执行结束后才会执行（即一个栈）。并且按照后定义的 Defer 先执行的顺序执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"!!"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上式的输出为<code>hello \n !! \n world</code>。</p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>Go 没有类，但是可以在类上定义方法。这类方法的定义和其他函数有些许不同，需要在<code>func</code>关键词到方法名间增加一个 receiver。形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也能为仅仅数据类型构造 Methods，然而它不能为其他 package 里的数据类型如此操作，或者对内建数据类型数次操作。如需要针对内建数据类型，则需要重定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，使用这样的 Receiver，不能对其含有的值进行操作。在我们需要操作其内容的时候，我们需要使用指针的 Receiver，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>对于 Methods 来说，使用实体或者指向实体的指针操作实体中的参数都是可以的。</p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface 一种特殊的数据类型，它是一系列 Methods 签名的集合。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex implements Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In the following line, v is a Vertex (not *Vertex)</span></span><br><span class="line"><span class="comment">// and does NOT implement Abser.</span></span><br><span class="line"><span class="comment">// a = v</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们说一个 Type 实现了一个 Interface，如果它存在 Interface 中声明的函数的实现。这个实现不需要显式地声明，他们的名称相同即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method means type T implements the interface I,</span></span><br><span class="line"><span class="comment">// but we don't need to explicitly declare that it does so.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">"hello"</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述例子中，存在 Interface I，Type T。其中 T 实现了 Methods M，则可以说是 Type T 实现了 Interface I。这样的 Interface 让实现和使用解耦，我们只需要关心 Interface 或者其实现，而不需要两者兼顾。</p><p>从更根本的眼光来看，Interface 是一个元组：<code>(value, type)</code>。它保存一个类型及其对应的值。对 Interface 调用一个 Method，相当于调用其代表的 type 对应的 Method。</p><p><strong>关于 nil 值</strong></p><p>存在这样的情况：Interface 对应的值不存在。但是这种情况的 Interface 并不为空，其保存了对应的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"&lt;nil&gt;"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">i = t</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">"hello"</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，t 并没有被初始化，所以对应的值是 nil 的（因为它甚至只是一个指针。）。而若去掉代码<code>i = t</code>，则 Interface i 就是一个空 Interface，此时调用<code>M()</code>就会报错。</p><p><strong>关于空 Interface</strong></p><p>对于没有声明 Methods 的 Interface 被称为“Empty Interface”。这样的 Interface 可以指向任何一个数据类型。这样的情况被用在处理不确定数据类型的时候。</p><p><strong>关于 Interface 的 Type</strong></p><p>我们有的时候需要知道 Interface 指向的 Type 是什么，此时我们这样调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></table></figure><p>如果 Type T 和 Interface i 的值完全相同，则会返回 i 对应的实体。如果类型不同则会报错。为了得知类型的同时不 raise error，我们采用下面的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure><p>如果 ok 为真，则意味着两种数据类型相同，并返回值 t；若为 false，则数据类型不同，且会返回 T 的 0 值。在这个设定下，我们可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">"Twice %v is %v\n"</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%q is %v bytes long\n"</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"I don't know about type %T!\n"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个语句比较 v 的类型。</p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Error 是一类内建的 Interface。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的函数都会返回一个 error 值，若 error 值等于 nil，则表示成功运行。他可以像上述代码的后半部分那样使用。</p><h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><h3 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h3><p>一个 Goroutines 是 Go 驱动的一个线程。以下语句会调起一个新线程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> f(x, y, z)</span><br></pre></td></tr></table></figure><p>f, x, y, z 的检验都是发现在当前的 goroutine 的，而调起的新函数则会运行在一个新的 goroutine 中。不同的 goroutine 运行在一个相同的地址空间中，所以他们的值是共享的。</p><h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>Channels 是一种类型相关的导管。我们可以通过这个东西接受或者发送值，通过运算符：<code>&lt;-</code>。类似下面的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// Send v to channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// Receive from ch, and</span></span><br><span class="line">           <span class="comment">// assign value to v.</span></span><br></pre></td></tr></table></figure><p>Channels 的定义方法和 Map 及 Slide 类似，需要借助 make 函数，定义方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>默认的情况下，这两个操作都会阻塞当前的 Channels。这样可以完成同步，并不需要显式地锁住线程。下面是一个示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Buffered Channels</strong></p><p>Channels 可以存在 Buffer。通过下面的定义方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>以上定义了 100 个 Buffer。Send 命令会 Block 仅有可能为 Buffer 已满；Receive 命令会 Block 仅有可能为 Buffer 为空。这两种情况会导致死锁错误。</p><p><strong>close</strong></p><p>Send 的过程中，可以主动关闭 Channel，即不再发送数据；Receive 可以检验某个 Channel 是否被关闭。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">v, ok := &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，Close 在这里不是必要的，除非 Receiver 需要明确地知道数据发送已经结束并终结进程。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>失衡的貝多芬</title>
      <link href="/2020/09/23/essay/music/%E5%A4%B1%E8%A1%A1%E7%9A%84%E8%B4%9D%E5%A4%9A%E8%8A%AC/"/>
      <url>/2020/09/23/essay/music/%E5%A4%B1%E8%A1%A1%E7%9A%84%E8%B4%9D%E5%A4%9A%E8%8A%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>回到上海再一次第一次進入東方藝術中心，已是近一年之後。曲目是貝多芬《第二交響曲》及《第五交響曲》。指揮家非常年輕，作爲小澤征爾的弟子，表現值得期待。樂團也是未曾感受過的樂團。</p><blockquote><p>地點：上海東方藝術中心<br>指揮：俞璐<br>樂團：寧波交響樂團<br>座位：樂池正前方偏音樂廳後部<br>開始前的食物：KFC蝦堡套餐</p></blockquote><a id="more"></a>  <h2 id="曲目及演繹"><a href="#曲目及演繹" class="headerlink" title="曲目及演繹"></a>曲目及演繹</h2><h3 id="《第二交響曲》"><a href="#《第二交響曲》" class="headerlink" title="《第二交響曲》"></a>《第二交響曲》</h3>    <div id="aplayer-AqcbSwsw" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="550607355" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p><strong>簡評</strong></p><p>No.2 並不是經常見到的一個表演曲目，一方面它自身不是非常具有特色，另一方面也是它代表着貝多芬第一時期的末端，仍然帶着莫扎特的影子。</p><p>作爲 D 大調的作品，整部作品四個樂章，無一不呈現出明朗積極的特徵。這可能也是本次音樂會被命名爲《命運與希望》（命運自然是指 No.5）的重要原因。但是這部作品呈現出了單調的、一味的積極情緒，使人並不覺得特別審美，而是有一種淡淡的困意（也和本人對這部作品並沒有非常了解有關）。</p><p>整個作品的展開完全在意料之中，抒情的部分也顯得不夠吸引人，唯一能給人留下深刻印象的是第四樂章的第一主題，明亮且有趣，但也僅此而已了。正如前文所言，整部作品透露出濃厚的莫扎特風味，也是貝多芬第一時期的象徵。</p><p>需要注意的一點是，其中第一樂章的一個樂段，在 No.9 再一次忠實地再一次出現，這肯定是貝多芬有意之舉。至於這兩部作品是如何連接在一起的，待考。</p><p><strong>演繹</strong></p><p>這部作品的演繹也中規中矩，沒有特別可以拿出來說道的地方。乾淨利落，毫不拖沓。</p><h3 id="《第五交響曲》"><a href="#《第五交響曲》" class="headerlink" title="《第五交響曲》"></a>《第五交響曲》</h3>    <div id="aplayer-gVItyiHq" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="459860068" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>第五交響曲又名命運交響曲，由於過於出名，甚至於爛俗，以致在國內幾乎見不到現場的演出，演出次數更是遠遠趕不上不那麼出圈的 No.7 &amp; No.8。這是一個相當悖論的事情。</p><p><strong>簡評</strong></p><p>回到作品本身。作品呈現出明顯的鬥爭性，第一樂章那個著名的動機，似幽靈般圍繞整部作品：隨着作品的推進，這個著名的動機，逐漸從一種激烈的憂鬱，變成激昂的四連音，象徵着某種勝利的轉變。</p><p>但是這個勝利是在第三樂章發生的，第一樂章是完全的失敗。「命運」的強力，將故事的主人公擊倒在地，並以主人公的完全失敗作結。隨後進入了多愁善感的第二樂章。儘管第二樂章伊始保留着某種抒情的特徵，但在後半部分，再一次呈現出了強的鬥爭性，然而在現在占據上風的卻是某種光輝的勝利。但我們並沒有得到結論，在鬥爭中進入了第三樂章。</p><p>第三樂章前幾個小節的靜謐氛圍逐漸被到來的鬥爭逼近;隨着逼近的鬥爭聲愈加明顯，我們發現這是變奏的第一樂章中所謂「命運」的動機，然而此時它不再陰鬱，而是光輝、明朗，具備帝王版的威嚴。這是最後一次鬥爭，在第三樂章結束時已然奠定了局面，最後我們迎來了偉大的第四樂章。</p><p>第四樂章高昂，絕對的積極，不留餘地。第三樂章和第四樂章的緊密鏈接讓這種明亮的印象更加令人深刻——命運毫無喘息機會！大概是這樣的感受。這樣的勝利比 No.2 的積極和 No.9 妥協式的勝利更加積極，是純粹得令人感動的氛圍。罕見的作品。</p><p><strong>演繹</strong></p><p>演繹仍然具有相當的水準。美中不足的是其中的短笛，總是比正常的音高高出一小截，而又由於短笛所在的高頻段異常抓耳，第四樂章短笛的每次進入都嚴重分散了我的注意力。音過高的短笛呈現出一種飄忽不定的聲線，致使發聲也不清晰。</p><p>其次是小號的處理。在第二樂章小號聲音過大——在同時奏響的時刻，小號幾乎蓋住了所有的弦樂組，迫使聽衆丟掉了大部分細節。所幸小號在聲音大的同時沒有破音，令人感動。</p><p>圓號發揮非常出色，音色動人圓潤，實在驚艷。在整場演出中不搶眼，但是以自身的過硬實力將自己的部分發揮到了最好。以及巴松也可圈可點，儘管在高音區發揮略有失常（一方面是巴松本來不擅長高音的原因），其餘部分富有彈性的聲音具有相當的美感。</p><h3 id="安可"><a href="#安可" class="headerlink" title="安可"></a>安可</h3><p>本場演出沒有安可。</p><h2 id="總評"><a href="#總評" class="headerlink" title="總評"></a>總評</h2><p>總而言之是值回票價的演出。俞璐指揮的演繹可圈可點。或許師承小澤征爾的緣故，其具有相當豐富的肢體語言。在指揮的同時，動作幅度劇烈，但是富有美感，有一定觀賞性。No.5 的一部分處理讓整體顯得不太勻稱，在某些時刻有被少部分樂器帶偏的感覺，但基本上維持了高水準的演繹。</p><p>兩部作品我個人還是更喜歡爛俗的 No.5，No.2 由於過於明亮讓我有點吃不消……</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>本次的安可並沒有如同預期一般出現，而是出現了俞璐的一段致辭。俞璐簡單地描述了一下自己對於貝多芬的仰慕之情，並且說了一下疫情下古典樂的現狀。最後吐露了一個宏偉的計劃：在五天之內演出貝多芬的九部交響曲。這應當是中國古典樂從未有過的盛況。</p><p>賴於寧波市政府的贊助及 Bilibili 的支持，這樣的行動才能發起。俞璐特別感謝了 Bilibili 的贊助。對於古典樂愛好者，這肯定是一個非常令人激動的信號：這個小衆的羣體也開始進入羣衆的視野。</p><p>在每次音樂會結束後回寢室的路上，一票樂迷總會各抒己見。再一次感受到自己肖斯塔聽得太少了……</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elementary OS双系统安装</title>
      <link href="/2020/09/22/tech/linux/Linux%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/09/22/tech/linux/Linux%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center><img src="/images/screenshot/home.png" width="80%" height="80%" /></center><p>这两日心血来潮给副系统装上了 Elementary OS。这一路配置相当地顺利，除了最后的一步。这里记录一下配置的过程及一些细节问题。</p><a id="more"></a>  <h2 id="录制DD盘"><a href="#录制DD盘" class="headerlink" title="录制DD盘"></a>录制DD盘</h2><p>这次安装的是<a href="https://elementary.io" target="_blank" rel="noopener">Elementary OS 5.1</a>，基于 Ubuntu 18.04 的发行版。在原系统下，上官网拿到了 ISO 之后就可以利用<a href="https://rufus.ie" target="_blank" rel="noopener">rufus</a>将 ISO 烧制到 USB 中。这个也是安装双系统的常用软件了。将 ISO 读出后，选择 DD 模式烧制。烧制结束后准备工作结束。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>安装系统过程非常流畅。插上烧制好的 USB，重启进入 USB 启动。可能这里会进入 Grub，而不是进入 USB。此时需要进入 Grub 中的 Configuration 将 USB 调整为最高优先级，然后重启。</p><p>重启后会进入 Elementary 的安装引导。这一路没有特别需要注意的。最后需要提及的是关于分区部分。Elementary 自动识别出了之前在我的电脑上存在的 Ubuntu 19.04，于是默认选项是在该分区上使用新的系统对其进行覆盖。如果是新的双系统的话会需要重新选择分区。</p><p>到目前为止都是非常顺畅。（请不要连接 WiFi，之后会有时间更新镜像后再 update。）</p><h2 id="进入系统"><a href="#进入系统" class="headerlink" title="进入系统"></a>进入系统</h2><p>作为 Surface Book，安装双系统（或者说 Linux）系统，不能够开箱即用，有三个问题需要解决：</p><ol><li>Linux 会在后台挂起一个不知何物的进程，这个进程会始终占用 90%左右的 CPU。</li><li>Linux 无法自动地在集成显卡和独立显卡间切换，导致耗电极快。</li><li>由于 Surface 的高分屏，Grub 界面字体非常小（尽管 Elementary 内部的分辨率是完全正常的，包括登录界面。）</li></ol><p>为了方便，请现在这个时刻安装一个 vim 吧，后面会用上的。由于 vim 体积不大，完全可以先把换源的事情放在后面，基础设定要紧。</p><h3 id="更换Kernel"><a href="#更换Kernel" class="headerlink" title="更换Kernel"></a>更换Kernel</h3><p>为解决第一个问题，需要更换 GitHub 上大神完成且预编的<a href="https://github.com/linux-surface/linux-surface" target="_blank" rel="noopener">Linux Kernel</a>。找到 Release，获取其中的三个内核文件并安装。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dpkg</span> -i <span class="regexp">*.deb</span></span><br></pre></td></tr></table></figure><p>这样三个内核文件就安装好了。此时重启，在 Grub 界面中找到 Advanced Configuration 并选择 Surface Kernel 即可。</p><p>这个步骤真的是被坑了很久才摸清楚的处理办法。对于其他的 Linux 来说，这个方法也是完全可以使用的。这个 Kernel 理论上提供了对于触摸屏、物理按键，甚至热插拔的特性，但大神预编的版本并不包含触摸屏功能。（但谁会想在 Linux 下拥有触摸屏呢……）所以预编的版本完全没有问题。</p><p>自此那个恼人的后台在重启后就不会出现了。</p><h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><p>这是选择 Ubuntu based Linux 的主要原因。之前使用 Manjaro 的时候，会发现这个步骤非常困难，但在 Ubuntu 下完全可以接受了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ubuntu-drivers <span class="built_in">auto</span>install</span><br></pre></td></tr></table></figure><p>默认的显卡驱动完全没有问题。上述命令运行结束后，显卡驱动就安装结束。为了完全切换为核显，需要先重启（否则软件内部是一片空白）。重启后，打开这个软件的 GUI 界面就正常了，切换一次设定，将之改为核显驱动，随后重启。双显卡问题就此解决。</p><p>这个也是血泪教训。尽管网路上的冲浪人士宣称 Manjaro 或者 Arch 拥有更加方便的驱动配置，但对于我来说不是这样的。</p><h3 id="Grub修改"><a href="#Grub修改" class="headerlink" title="Grub修改"></a>Grub修改</h3><p>Grub 修改完全可以和 Grub theme 的切换一起来完成了。先在<a href="https://www.gnome-look.org/browse/cat/109/order/latest/" target="_blank" rel="noopener">Gnome的主题站</a>上找到合适的 Grub 主题。我这次选择的是这个：<a href="https://www.gnome-look.org/p/1397139/" target="_blank" rel="noopener">Linux Mind</a>。说实话不好看，但是也懒得接着找了。</p><p>将下载好的主题包解压，把他移动到一个特定的位置。为了方便我们先创建一个新的文件夹：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">mkdir</span> /<span class="keyword">boot</span>/grub/themes</span><br></pre></td></tr></table></figure><p>然后把解压后的文件夹移入这个文件夹。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp 主题包名 <span class="regexp">/boot/g</span>rub<span class="regexp">/themes/</span></span><br></pre></td></tr></table></figure><p>然后修改配置文件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/grub.d/<span class="number">00</span>_header</span><br></pre></td></tr></table></figure><p>在最开始的注视内容之后添加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">GRUB_THEME</span>=<span class="string">"/boot/grub/themes/主题包名/theme.txt"</span></span><br><span class="line"><span class="attr">GRUB_GFXMODE</span>=<span class="string">"3000x2000x32"</span></span><br></pre></td></tr></table></figure><p><code>3000x2999</code>是 Surface 的分辨率。这样修改结束后，主题和分辨率就都调整好了。然后更新 Grub 配置文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo update-grub</span></span><br></pre></td></tr></table></figure><p>更新结束后重启。这一个步骤就完成了。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>但现在距离一个好用的系统还有不少的步骤……比如好用的浏览器，舒适的输入法等等。在这些开始之前需要先更换镜像。</p><h3 id="apt换源"><a href="#apt换源" class="headerlink" title="apt换源"></a>apt换源</h3><p>进入文件：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vim</span> /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure><p>如果担心的话可以先做一个备份。然后用下面的内容替代该文件所有内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#清华源</span><br><span class="line"># 默认注释了源码镜像以提高 apt <span class="keyword">update</span> 速度，如有需要可自行取消注释</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-security main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>保存退出就结束了。然后运行一下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> upgrade</span><br></pre></td></tr></table></figure><p>镜像工作至此结束。</p><h3 id="更换输入法"><a href="#更换输入法" class="headerlink" title="更换输入法"></a>更换输入法</h3><p>类似 VS Code 或者 Vivaldi 啥的都非常简单，故不赘述。这里说一下输入法的问题。原配的 IBus 在 Ubuntu 下是能用的，但不知为何在 Elementary 下不能正常使用了。正好，那我换成 Fcitx 好咯。</p><p><strong>注意</strong>：这里遇到了目前位置最为严重的 Bug。在执行这个操作以前，我可以进入”语言及区域“中的”键盘设定“处调整快捷键，但在该操作结束以后，该设定不再能被打开，并且在装回 iBus 后仍然处于不能使用状态。</p><p>Anyway，输入还是重要的，所以为了避免冲突，卸载 iBus，然后下载 Fcitx。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> fcitx fcitx-sunpinyin</span><br></pre></td></tr></table></figure><p>为了使用 Fcitx，这俩就够了。后面一个软件提供中文输入支持。</p><p>输入<code>im-config</code>设定 fcitx 为默认输入法，注销系统然后登入。</p><p>此时在 Application 处搜索 Fcitx Configuration（注意，这个需要搜索，它不会出现在目录中。），然后设定 Sunpinyin 的相关设定。此时即使选择了双拼，但输入的时候看起来仍然是全拼。这个 bug 重启之后就解决了。</p><p>然后是一些微调工作，比如将字体设定为 20 等等。</p><h3 id="Grub-customizer"><a href="#Grub-customizer" class="headerlink" title="Grub customizer"></a>Grub customizer</h3><p>尽管我们已经成功地调整了 Grub 的分辨率以及 Theme，但目前 Grub menu 非常地令人难受。为了仅保留我们需要的选项，grub customizer 作为一个 GUI 工具是一个方便的选择。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> add-apt-repository </span>ppa:danielrichter2007/grub-customizer</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install grub-customizer</span><br></pre></td></tr></table></figure><p>后面的事情就比较直接了。</p><h3 id="Fish-shell"><a href="#Fish-shell" class="headerlink" title="Fish shell"></a>Fish shell</h3><p>这个安装过很多次，应当轻车熟路了。</p><p>首先上<a href="http://fishshell.com" target="_blank" rel="noopener">官网</a>添加 ppa。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">add</span>-repository <span class="keyword">pp</span><span class="variable">a:fish</span>-<span class="keyword">shell</span>/release-<span class="number">3</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> install fish</span><br></pre></td></tr></table></figure><p>安装结束后将 fish 设为默认：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s <span class="regexp">/usr/</span>bin<span class="regexp">/fish</span></span><br></pre></td></tr></table></figure><p>然后 Shell 默认会调起 fish，之后可以使用 bash 暂时回到默认的 shell。</p><p>最后修改 fish 的 greeting messege：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> -U <span class="comment">fish_greeting</span> <span class="comment">"Bonjour! Joseph..."</span></span><br></pre></td></tr></table></figure><p>Fish 的设置结束。更多设置，使用<code>fish_config</code>查看。</p><p><strong>修改 ls 颜色</strong></p><p>此外，由于 Terminal 默认的<code>ls</code>颜色比较难以接受，所以需要手动修改。而 fish 的方法和主流不太相同，这里做一下记录。</p><p>首先需要获得系统的配色方案，在此基础上修改：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">dircolors -p &gt; <span class="string">.dircolors</span></span><br></pre></td></tr></table></figure><p>这样配色方案就存放在文件<code>.dircolors</code>中，对这个文件进行修改即可。规则不一一列举，参见文后链接。为了让这个配色方案在 fish 中生效，需要修改 fish 的设定文件。该文件位置在：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.<span class="built_in">config</span>/fish/<span class="built_in">config</span>.fish</span><br></pre></td></tr></table></figure><p>在该文件中添加：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span> (dircolors ~<span class="regexp">/.dircolors | head -n 1 | sed 's/</span>^LS_COLORS=<span class="regexp">/set -x LS_COLORS /</span>;<span class="regexp">s/;$//</span><span class="string">')</span></span><br></pre></td></tr></table></figure><p>添加结束后重启 terminal 就可以了。</p><h3 id="Autojump"><a href="#Autojump" class="headerlink" title="Autojump"></a>Autojump</h3><p>安装结束 Fish 之后，我们就可以开始配置 Autojump 了，虽然简单，但很有帮助。直接使用 apt 安装 Autojump 是不可以的。需要这样处理：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/wting/autojump.git</span><br><span class="line"><span class="keyword">cd</span> autojump</span><br><span class="line">./install.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p>然后打开文件：<code>~/.config/fish/config.fish</code>，在其中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">    <span class="built_in">set</span> --<span class="built_in">local</span> AUTOJUMP_PATH <span class="variable">$HOME</span>/.autojump/share/autojump/autojump.fish</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -e <span class="variable">$AUTOJUMP_PATH</span></span><br><span class="line">        <span class="built_in">source</span> <span class="variable">$AUTOJUMP_PATH</span></span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后关闭 Shell 再打开，设定就结束了。</p><h3 id="按键重映射"><a href="#按键重映射" class="headerlink" title="按键重映射"></a>按键重映射</h3><p>按键重映射主要是为了让 Win 键代替右 Alt 键，让他发挥一点点小作用。这里需要用到工具 xmodmap。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">xmodmap</span> -e <span class="string">"remove mod1 = Alt_R"</span></span><br><span class="line">xmodmap -e <span class="string">"add mod4 = Alt_R"</span></span><br></pre></td></tr></table></figure><p>其中<code>mod1</code>代指 Alt 键，<code>mod4</code>代指 Super 键。具体的名称可以在后面链接中找到。但是这两个命令是临时的，在系统重启后就会消失。为了避免这个问题，我们需要设定开机自启。开机自启的方法很多，但是众多尝试都失败了。</p><p>这里记录的方法依赖 Gnome 的设定。在 Application 中添加一个用来替换按键的脚本，然后就可以开机后运行了。</p><h2 id="WeChat-amp-QQ"><a href="#WeChat-amp-QQ" class="headerlink" title="WeChat &amp; QQ"></a>WeChat &amp; QQ</h2><p>有的时候这俩软件还是相当必要的。这两个软件都需要 Wine 进行驱动。为了安装这两个软件，我们需要相当繁琐的设定。</p><h3 id="安装Wine"><a href="#安装Wine" class="headerlink" title="安装Wine"></a>安装Wine</h3><p>先添加仓库：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O- http<span class="variable">s:</span>//deepin-wine.i-<span class="keyword">m</span>.dev/setup.<span class="keyword">sh</span> | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>然后安装对应的软件，表格如下：</p><div class="table-container"><table><thead><tr><th>应用</th><th>包名</th></tr></thead><tbody><tr><td>TIM</td><td>deepin.com.qq.office</td></tr><tr><td>QQ</td><td>deepin.com.qq.im</td></tr><tr><td>WeChat</td><td>deepin.com.wechat</td></tr></tbody></table></div><p>使用以下语句安装：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">apt-get</span> <span class="selector-tag">install</span> <span class="selector-tag">deepin</span><span class="selector-class">.com</span><span class="selector-class">.wechat</span></span><br></pre></td></tr></table></figure><p>至此，两个软件都可以正常地运行，但存在三个问题：</p><ol><li>字体由于分辨率奇小无比。</li><li>中文无法正常显示（因为我习惯用英文系统）。</li><li>输入框字体不能正常显示（事实证明，这个原因和 2 中原因不一样。）</li></ol><h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p>为了修正分辨率，我们需要 Wine 主体，但我们还没有安装。</p><p>在安装好了 Wine 之后，我们就开始解决乱码问题。打开<code>/opt/deepinwine/tools/run.sh</code>和<code>/opt/deepinwine/tools/run_v2.sh</code>两个文件;将其中的<code>WINE_CMD=&quot;deepin-wine&quot;</code>改为<code>WINE_CMD=&quot;LC_ALL=zh_CN.UTF-8 deepin-wine&quot;</code>。这样就解决了中文乱码。</p><p>事实上，将系统改为中文也能够解决这个问题，但，嗯……还是英文更好看一些。（以及一些翻译不合理以及不完全的位置让人觉得有点难受。）</p><h3 id="输入框问题"><a href="#输入框问题" class="headerlink" title="输入框问题"></a>输入框问题</h3><p>即使解决了上述问题，微信的输入框仍然处于乱码的状态，这是由于缺少字体。为了解决这个问题，我们将 Windows 中的字体移植到 wine 容器中的 Fonts 文件夹中，这样这个问题就解决了。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>以微信为例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">env</span> WINEPREFIX=<span class="string">"<span class="variable">$HOME</span>/.deepinwine/Deepin-WeChat"</span> winecfg</span><br></pre></td></tr></table></figure><p>会打开一个 GUI 界面用以调整屏幕分辨率。该分辨率需要针对不同的软件分别设置。该数值调整为 192 较为合适。</p><p><strong>注意</strong>：这个步骤应当先打开一次软件，待 Wine 容器初始化之后再进行，而不是在安装了软件之后立刻进行，否则不会有任何变化。</p><p>至此微信和 QQ 的安装工作结束。但是目前没有完成系统托盘的修改。目前两个软件的小托盘图标会独立显示出来，这个问题放在以后调整吧。</p><h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>Elementary 是优雅的，令人爱不释手的。在体验了一天的情况下，并没有出现令人难以理解、严重的 bug。其自带的日历、邮箱软件都充满了优雅的味道。整体的动画流畅舒适，快捷键分布自然高效。毫无疑问，这是一个满足了我目前基本需求的系统，我也愿意在短期内尝试将其作为主力使用去感受一下它的魅力。</p><center><img src="/images/screenshot/apps.png" width="100%" height="100%" /></center><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/w84963568/article/details/78884003" target="_blank" rel="noopener">更换Grub主题</a></li><li><a href="https://www.cnblogs.com/Briddle-ch/p/13369274.html" target="_blank" rel="noopener">在Ubuntu 18.04中安装Wine QQ、微信、TIM</a></li><li><a href="https://blog.csdn.net/yhuiqq788/article/details/104211021" target="_blank" rel="noopener">Wine不能正常显示中文</a></li><li><a href="https://stackoverflow.com/questions/13995857/suppress-or-customize-intro-message-in-fish-shell" target="_blank" rel="noopener">fish修改Greeting</a></li><li><a href="https://www.jianshu.com/p/c405db78091c" target="_blank" rel="noopener">Wine分辨率调整</a></li><li><a href="https://codeyarns.github.io/tech/2014-02-27-how-to-install-autojump-for-fish.html" target="_blank" rel="noopener">Autojump安装配置</a></li><li><a href="https://www.cnblogs.com/yinheyi/p/10146900.html" target="_blank" rel="noopener">xmodmap按键重映射</a></li><li><a href="https://blog.csdn.net/u013045749/article/details/53576868" target="_blank" rel="noopener">Ubuntu ls更改配色方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>論告別之聲</title>
      <link href="/2020/09/20/essay/music/%E5%91%8A%E5%88%AB/"/>
      <url>/2020/09/20/essay/music/%E5%91%8A%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-vszUYmBZ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1418922883" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>　　這裡原來是大三下半學期（即網課期間）完成的通識課《音樂美學與實踐》的期末論文。但是又想到可能以後會對部分音樂做一個評價/體會，所以考慮把這一篇擡過來做一個開頭（因爲裡面確實包含了我對部分作品的真實感受及評價）。個人雖然是一個古典音樂的愛好者，但和門外漢並沒有多少的區別，評價方法也是完全主觀的（甚至不嚴謹的）。至於本篇中頻繁提到的《馬九》有幸聽過現場，奈何時間久遠，現在希望再回憶起細節實在是不太現實的事情。但這也是音樂的特徵之一吧。總之，請將該文當作一篇完全不專業的隨筆觀看。（本篇中提到的作品不會附上鏈接，有興趣者請自行搜索。）</p><a id="more"></a>  <p>【摘要】略</p><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>　　在文學研究中，形式與內容儘管糾纏不清，但仍能一定程度地區分開二者特點，文學中作家意義的表達更依賴於內容；而在音樂中，「樂音的內容就是樂音的運動形式」 ，其形式和內涵具有先天的一致性，於是將一切的內涵都賦給其形式的音樂藝術實踐成爲可能，例如巴赫所作的《賦格的藝術》。但與之相對的，以舒伯特的《鱒魚》爲代表，也存在大量具有明確主題的音樂實踐。<br>　　如同中國詩歌常常以「告別」作爲主題，音樂也是如此。但是與中國詩歌相差甚遠的是，音樂中的「告別」往往不拘束於一個特定的人，甚至不存在一個告別的具體對象，這與音樂本身高度抽象、形式美的特徵是分離不開的，因而藉助音樂實踐對告別場景的建立也具有模糊性。而這種模糊性也使得我們討論的「告別之聲」具備獨特內涵，自然也擁有討論的價值。根據「告別」的形式與對象的不同，這個主題可以產生多樣且複雜的變化。同時，「告別」這一主題也經常和「死亡省思」，「時代變遷」等等主題存在內在關聯。<br>　　「告別之聲」在這裡特別指：藉助音樂這個特殊體裁表達某種告別情愫的形式。事實上，在音樂研究中存在與之相對應的「告別敘事」（Farewell Story）這個固定的提法，並且已經發展出了獨特的內核和理解，該提法在馬勒作品研究中常見 。不過我們避免這個音樂分析上的固有詞彙，從更直觀的角度進行理解。在本文中，我們將結合對應的音樂實例，討論音樂中埋藏的告別之聲。</p><h3 id="二、告別的形式與內涵"><a href="#二、告別的形式與內涵" class="headerlink" title="二、告別的形式與內涵"></a>二、告別的形式與內涵</h3><h4 id="（一）告別的形式特徵"><a href="#（一）告別的形式特徵" class="headerlink" title="（一）告別的形式特徵"></a>（一）告別的形式特徵</h4><p>　　儘管在之前對於「告別之聲」的指代進行了簡單的表述，但是顯得空泛而抽象，所以我們需要先更具體地確定「告別之聲」指代的是哪一種音樂實踐。正如前文所說，這個主題具備相當的複雜性和抽象性，使我們難以找到一個合適的範例作爲出發點。所以在討論更複雜的「告別」的內涵前，我們先試圖從形式的角度理解「告別之聲」，以這個爲切入點再進入音樂的更深內涵理解。這裡我們將分析三部不同的作品，試圖找到「告別」形式上的規律。</p><h5 id="海頓《升f小調第四十五號交響曲》"><a href="#海頓《升f小調第四十五號交響曲》" class="headerlink" title="海頓《升f小調第四十五號交響曲》"></a>海頓《升f小調第四十五號交響曲》</h5><p>　　這部作品第四樂章具有「典型」的形式上的「告別」意味：其中演奏人員變少、樂器逐漸離場、演奏強度漸弱等等設計，從形式上完成了「告別」意義的表達。這裡的告別對象是觀衆，隨着整個華麗繁複的部分慢慢進入兩把小提琴的演奏時，整部作品結束。這裡的告別相當具象化，指「物理意義上」的告別，即將告別的意義全盤交付給形式，因此也容易被理解。而我們所希望找到的告別則是更抽象、模糊的一種音樂實踐。</p><h5 id="貝多芬《降-E-大調第二十六鋼琴奏鳴曲》"><a href="#貝多芬《降-E-大調第二十六鋼琴奏鳴曲》" class="headerlink" title="貝多芬《降 E 大調第二十六鋼琴奏鳴曲》"></a>貝多芬《降 E 大調第二十六鋼琴奏鳴曲》</h5><p>　　這部作品被貝多芬分樂章地標上了題目，分別爲「告別」、「缺席」、「重逢」，並且貝多芬將之題詞獻給自己的贊助人魯道夫大公 ，是典型的主題音樂。所以我們可以把它當作一個相當不錯的關照對象。遵循音樂速度的線索，我們可以找到一個值得關注的關鍵點：對於一部奏鳴曲而言，第一樂章往往採用快板，而貝多芬反常地使用了從柔板到快板的結構，而其餘兩個樂章則保持了傳統的速度規範：「缺席」樂章維持了較慢的速度，渲染出一種憂鬱悲傷的氛圍；而「重逢」樂章則是速度陡升，呈現出了明顯的明朗愉悅。</p><h5 id="馬勒《第九交響曲》"><a href="#馬勒《第九交響曲》" class="headerlink" title="馬勒《第九交響曲》"></a>馬勒《第九交響曲》</h5><p>　　承接上面的分析，貝多芬的這部鋼琴奏鳴曲還有一個值得注意的部分：在該奏鳴曲中前三個音符作爲動機，被標註爲「Lebewohl」 ，這一動機在馬勒《第九交響曲》中被再次使用，於是我們也可以從形式的角度簡單地分析一下馬勒的這部作品。其前三樂章作爲諧謔曲或者迴旋曲這樣的曲式，都以相當快的速度前進，特別到了第三樂章的前半部分，幾近脫繮的野馬，銅管喧天；卻在第四樂章突然戛然而止，將話語權交給了溫柔的弦樂組，進入了作品的尾聲。交響曲中普遍的處理是以快板甚至急板的第四樂章作結，而馬勒在這裡反常地選擇了柔板，這個選擇是具備特殊意義的，正是與其選用的「告別」動機有所呼應。<br>　　不難從上述的分析中找到規律：一種由快速逐漸緩慢、由強至弱、由歡快至沉鬱的過程，是「告別」存在的可能形式特徵。這給了我們一個線索：樂曲的節奏對於告別具有暗示意味。這樣的規則尺度可以變化，即既能對應於一部作品，也能對應於作品的某一個片段。</p><h4 id="（二）告別的內涵特徵"><a href="#（二）告別的內涵特徵" class="headerlink" title="（二）告別的內涵特徵"></a>（二）告別的內涵特徵</h4><p>　　在上面的討論中，我們似乎找到告別的一種特徵，但事實是我們在援引馬勒《第九交響曲》時實際上並沒有嚴格說明，爲什麼這部交響曲是「告別」的，僅使用「Lebewohl」動機作爲解釋並不是非常有說服力。這便需要我們先簡單討論「告別」具備的內涵，及其在音樂中的表現。<br>　　我們確定「告別」具有幾個要素：告別者，被告別者，告別者的自我表達，某種狀態的改變。此外，我們認爲，告別具有時間上的意義，其建立在回憶與遙望之上的。正如李白《送友人》中兩句「此地一爲別，孤蓬萬里征」，「浮雲遊子意，落日故人情。」兩句，分別對應着遙望和回憶。<br>　　對於音樂，其也應當在傳達「告別之聲」時埋藏着這些信息。我們再一次以貝多芬《降 E 大調第二十六鋼琴奏鳴曲》爲例，上述的結構在這部作品中皆有其呼應的成分。這部作品欲揚先抑，描述了從離別到思念，最後重逢而喜的過程。並且其「重逢」樂章不似「孤蓬萬里征」的遙望，而似溫庭筠在《送人東歸》中的「尊酒慰離顏」那般愉快，同樣構成了「告別」的一個重要要素。<br>　　儘管是從內涵進行的解釋，上述的例證中音樂所傳達的告別由於具有具體告別的場景和對象，所以仍然停留在具象的層面，使用的音樂語言意義也簡明了當。然而在「告別」的內涵這個範疇下，情況可以相當複雜繁瑣，特別是對於不同的告別對象，在這其中涉及到一些有趣的討論，我們將更多例證分解到後面的小節中。但是在上述的過程中，我們已經可以找到一些告別可以被討論的內容，例如死亡與生命、鬥爭與妥協種種。我們後面則將不斷變更考察的對象，試圖更深入地考察「告別之聲」在音樂中傳達的價值與意義。</p><h3 id="三、「告別」與馬勒《第九交響曲》"><a href="#三、「告別」與馬勒《第九交響曲》" class="headerlink" title="三、「告別」與馬勒《第九交響曲》"></a>三、「告別」與馬勒《第九交響曲》</h3><p>　　這時我們再次以馬勒《第九交響曲》爲例，討論「告別之聲」 。在前面分析的內容中，我們已經對這部作品的基本結構進行了解釋。而學者普遍認爲這部作品與「死亡」緊緊關聯，並稱之爲「帶有自嘲的屈從」 。這便自然構成了一個特殊的告別對象——「對於生命和世界的告別」。我們試圖藉助這個例子，對其第一與第四樂章加以分析，討論死亡與告別的內在關聯。</p><h4 id="（一）第一樂章：美麗過往和可怖歸宿的鬥爭"><a href="#（一）第一樂章：美麗過往和可怖歸宿的鬥爭" class="headerlink" title="（一）第一樂章：美麗過往和可怖歸宿的鬥爭"></a>（一）第一樂章：美麗過往和可怖歸宿的鬥爭</h4><p>　　第一樂章體現出告別的時間線索。我們拆解出第一樂章幾個重要的主題或者動機。其一是第一樂章開頭由豎琴撥奏的不規則節奏「心跳動機」；其二是由弦樂組完成的優美旋律，我們稱之爲「回憶」的第一主題；其三是呈現崩壞混亂特點的第二主題。<br>　　第一樂章呈現出一種明顯的鬥爭性：美好場景與死亡威勢的相互交替。第一樂章開頭，隨着第一主題的進入，「心跳動機」透露出的不安感便深深植入了整部作品，然後調起了崩壞的第二主題；隨後藉助兩個主題旋律反覆地構建與崩壞，製造出掙扎的場景，使得整個樂章都充滿着危機，渲染出一種末世感。<br>　　在第一樂章中部存在一個微妙的變化，即第一主題變奏的重現，這個更爲積極的第一主題變奏突然出現，以悠揚婉轉的旋律打破了崩壞的旋律，重新將思索拉回了美好的過去。但這樣的美好終難以久繼，很快便被樂章開頭出現的不安動機再次打斷，重新進入混亂的第二主題。在本樂章最後階段的迴光返照式美好的回憶也未能勝利，終於消失在了完全崩壞的音樂中，第一樂章便在這裡結束。</p><h4 id="（二）第四樂章：失敗的「告別」"><a href="#（二）第四樂章：失敗的「告別」" class="headerlink" title="（二）第四樂章：失敗的「告別」"></a>（二）第四樂章：失敗的「告別」</h4><p>　　第一樂章中第一主題對抗第二主題的失敗，意味着所謂回憶向着宿命屈服，已經沒有任何迴轉的餘地，而「告別」則是非做不可的事情。抹去了第三樂章結束時的歇斯底里，第四樂章終於放棄了一切的鬥爭，衆多聲部互相交織、無盡且穩定地向前進展，展現出鋪天蓋地般可怕的音響效果。我們可以將其看作留戀之物的斷絕，並進入最終的平靜，或稱「毫無苦味的告別」 。<br>　　這樣的音響效果一直維持到第四樂章的結束。在第四樂章的結束時，所有旋律開始分崩離析，陷入瑣碎的囈語。作爲第四樂章結束的降 D 大調主和弦，由於樂曲聲響的效果，呈現出似乎沒能成功回到降 D 大調的慘象，仿佛作品尚未真正講述結束時就宣告了終止。在這場「告別」之中不再設想任何將來之事，沒有所謂天堂或者地獄，只是對於自我了結作出宣告而復歸平靜。這是一個不完整的、失敗的「告別」。第四樂章結尾既沒能回到期望的世界，也沒能「告別」這個世界，而是就這樣悄悄地停止了。<br>　　馬勒的這部作品帶有這樣獨特的色彩：在前三個樂章中不斷對抗命運而失敗，終於放棄鬥爭，進入了第四樂章的告別之時，連告別也沒能完成就戛然而止了。死亡和告別是內在相關的：死亡爲告別者提供了絕佳的告別對象，推動着作曲家對於「告別」這一行爲的實現。然而在這部特殊的作品中，帶者一切不舍的回憶與對生命的執着，「告別之聲」終於在那命運將至的悲感下變成了沉默的遺憾。</p><h3 id="四、「告別」與晚期風格"><a href="#四、「告別」與晚期風格" class="headerlink" title="四、「告別」與晚期風格"></a>四、「告別」與晚期風格</h3><p>　　正像之前對於馬勒作品的分析，「告別」在內涵上與「死亡」主題契合，故也和「晚期風格」內在關聯。晚期風格是指作曲家在臨終前突然出現的與其成熟風格迥異的新風格。在之前的討論中，我們都將音樂中埋藏的「告別之聲」賦給了一部作品。但其本身也可以是一個階段的主題。而由於告別、死亡、晚期風格之間互相存在的關聯性，我們便能將「告別之聲」與晚期風格直接聯繫起來，在作曲家的晚期風格中找到「告別之聲」的影子。這裡我們將主要以貝多芬和舒伯特的晚期作品爲例，對其進行更深入的討論。</p><h4 id="（一）貝多芬的晚期風格"><a href="#（一）貝多芬的晚期風格" class="headerlink" title="（一）貝多芬的晚期風格"></a>（一）貝多芬的晚期風格</h4><p>　　貝多芬早中期的作品如《第三交響曲》和《c 小調第八號鋼琴奏鳴曲》，具有顯然的情感意志流露。這些作品構建出了一個強力、積極的貝多芬形象；而貝多芬的晚期作品則更加富有矛盾性，以其最後五部弦樂四重奏作爲代表，呈現出了客觀、晦澀而具有神祕主義的貝多芬風格，這些作品也被稱爲「無表現」的作品。<br>　　這種風格和其另一部晚期作品《第九交響曲》看似不同，但也存在着統一：《第九交響曲》是絕對主觀、強力的，並刻意地向上，其帶有過分積極宏大的願望，並因此帶有明顯的鬥爭性 以及潛藏的鬥爭失敗的預感。而在其後創作的第十三、第十四號、第十五號弦樂四重奏的第一樂章的開頭則更露骨地在不安定與偉大目標間徘徊。<br>　　《第十五號弦樂四重奏》第三樂章中呈現的無限寧靜與溫暖感受，一定程度地勾勒出《第九交響曲》的鬥爭終於成功的未來；但在其《第十四號弦樂四重奏》中，卻帶着明顯的不穩定情緒。這種矛盾性與馬勒《第九交響曲》的第一和第四樂章對應，建立了鬥爭與妥協的關係，構造出了「告別」的結構，從而建立起了「告別」和晚期風格的內在聯繫。</p><h4 id="（二）舒伯特的晚期風格"><a href="#（二）舒伯特的晚期風格" class="headerlink" title="（二）舒伯特的晚期風格"></a>（二）舒伯特的晚期風格</h4><p>　　與之同時，舒伯特晚期風格也帶有這樣的矛盾性。其創作的《第九交響曲》與貝多芬的《第九交響曲》相似，脫離了《第八交響曲》的沉鬱，終於到達了「偉大」的高度；而在一些其他晚期作品中，例如《C 大調弦樂五重奏》、《降 E 大調彌撒》中構造的形象神祕而消極，而這些形象「成爲他在離開這個世界之前的正式告白」 ，最終形成了我們所討論的「告別之聲」的架構。同時在藝術歌曲《幻影》中，「他將主角替換成幻影時，歌曲的重點也從悲痛絕望的失戀轉移到了無處不在的死亡」 ，明顯地帶着舒伯特本人的死亡省思與複雜心理。其晚期風格藉助死亡省思和矛盾性和「告別」聯繫在了一起。<br>　　這些作品本身構成了「告別」，但不同於先前討論的所有作品，這裡的告別是正在進行的：它不會隨着一部作品的完成而結束，他們懷揣着對於死亡的擔憂往前行進，在衆多的作品間搖擺、碰撞，呈現出一種不停頓的鬥爭性，最後接納真正的死亡才復歸「非塵世的寧靜」 。這樣的「告別」正像是背負着《歡樂頌》那樣的願景帶來的無可調節的矛盾，顯得隆重而莊嚴。</p><h3 id="五、結論"><a href="#五、結論" class="headerlink" title="五、結論"></a>五、結論</h3><p>　　在本文中，我們主要將注意力聚焦於音樂中潛藏的「告別之聲」，分別從形式和內涵的角度，由具象至抽象、由微觀至宏觀地對這個問題進行了討論。我們從「告別」的形式出發，對海頓、貝多芬和馬勒等作曲家的作品分別展開了形式上的討論，並認爲「告別」在其形式上具有由快至慢、由強至弱等等特點。<br>　　從內涵出發，我們則討論了具象的「告別」具有的例如時間線索、狀態變化等等特徵；並依照這條線索，進一步對馬勒《第九交響曲》和貝多芬及舒伯特的晚期風格進行了簡單的探究。我們通過建立起了「告別之聲」與死亡觀、鬥爭與妥協的矛盾性、晚期風格等因素的內在聯繫，指出了「告別之聲」存在的與生命相關聯的重要價值與深刻內涵。</p><p>【參考文獻】<br>[1] 王振蒙，《論舒伯特鋼琴小品 D946 No.2 中的「死亡意象」》，黃河之聲，2019 年 11 期。<br>[2] 張晨，《馬勒&lt;第九交響曲&gt;的「告別」敘事》，中央音樂學院學報，2019 年 03 期。<br>[3] 瞿楓：《幻影」之謎:舒伯特晚期藝術歌曲中的死亡書寫》，中國音樂學，2019 年 02 期。<br>[4] 黃鍵，《馬勒音樂中的死亡內涵初探》，交響（西安音樂學院報），2018 年 04 期。<br>[5] 瞿楓，《舒伯特「晚期風格」研究 ：1827— 1828》，上海音樂學院博士學位論文，2015 年，第 38— 46 頁。<br>[6] 伍維曦，《終結與濫觴——舒伯特晚期風格中的死亡意象》，書城，2015 年 01 期。<br>[7] 鄧軍，《貝多芬&lt;第九交響曲&gt;的「歡樂頌」圖景——探究末樂章「音樂」與「詩」對於作品結構的深層意義》，星海音樂學院學報，2015 年 02 期<br>[8] 愛德華·薩義德，《論晚期風格》，閻嘉譯，生活・讀書・新知三聯書店，2009 年。<br>[9] 西奧多·阿多諾，《貝多芬：阿多諾的音樂哲學》，彭淮棟譯. 聯經出版事業股份有限公司, 2009。<br>[10] 孫國忠，《馬勒交響曲的哲理內涵》，中國音樂學，1989 年 04 期。<br>[11] 漢斯利克，《論音樂的美——音樂美學修改新譯》，楊業治譯，人民音樂出版社，1978 年，第 39 頁。<br>[12] 薛毛毛，《貝多芬晚期風格中的「非英雄」性—以晚期五首鋼琴奏鳴曲爲例》，上海音樂學院碩士畢業論文。<br>[13] Vera Micznik, The Farewell Story of Mahler’s Ninth Symphony, 19th-Century Music (1996) 20 (2).<br>[14] Kolodin, Irving (1975). The Interior Beethoven. New York: Alfred A. Knopf.<br>[15] David B. Greene, Mahler, Consciousness and Temporality (New York: Gordon and Breach Science Publishers, 1984).<br>[16] Constantin Floros, Gustav Mahler: The Symphonies, trans. Vernon and Jutta Wicker, ed. Reinhard G. Pauly (Portland: Amadeus Press, 1993).<br>[17] Donald J. Grout and Claude V. Palisca, A History of Western Music (4th edn. New York, 1998), p760.<br>[18] Gustav Mahler: A Study of His Personality and Work, Paul Stefan, trans. T. E. Clark (New York, 1913), pp. 142-43, and 124-25.<br>[19] Rose Rosengard Subotnik, Adorno’s Diagnosis of Beethoven’s Late Style: Early Symptom of a Fatal Condition, Journal of the American Musicological Society (1976) 29 (2): 242–275.<br>[20] Michael Spitzer, Music as Philosophy: Adorno and Beethoven’s Late Style, Musical Meaning and Interpretation, 2006</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看Windows电池容量</title>
      <link href="/2020/09/15/tech/%E6%9F%A5%E7%9C%8BWindows%E7%94%B5%E6%B1%A0%E5%AE%B9%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/09/15/tech/%E6%9F%A5%E7%9C%8BWindows%E7%94%B5%E6%B1%A0%E5%AE%B9%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近有同学让我帮忙查一下掉电之类的问题啊，然后我发现我并不知道如何查看电池电量。查了一下发现这个方法可用，记录一下。</p><a id="more"></a>  <p>使用<strong>管理员权限</strong>的 cmd 或者 powershell 输入：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">powercfg</span> /batteryre<span class="keyword">port</span> /output “C:\battery_report.html”</span><br></pre></td></tr></table></figure><p>这个指令会生成一个电池使用情况的 html 文件到<code>C:\battery_report.html</code>。当然这个地址是可以改的，比如改到桌面上。成功后，终端会返回：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Battery life <span class="keyword">report</span> saved <span class="keyword">to</span> <span class="keyword">file</span> path C:\battery_report.html.</span><br></pre></td></tr></table></figure><p>找到这个文件打开即可。里面包含最大电池容量和当前最大可充入电池容量，以及一些其他的电池使用情况信息。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常用语法 —— 数据结构</title>
      <link href="/2020/09/14/tech/Cpp%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/09/14/tech/Cpp%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为太久没用 C++了，导致很多细节的语法已经记不得了。借着这一次刷的少量题回顾一下 C++的语法，以后总会有时候能用上的。</p><a id="more"></a>  <h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">s.find(s1);  <span class="comment">//找到第一个出现的s1</span></span><br><span class="line">s.substr(pos, n);  <span class="comment">//截取从pos开始的n个字符</span></span><br><span class="line">s.substr(pos);     <span class="comment">//截取从pos开始的所有字符</span></span><br><span class="line">s.replace(pos, n , s1); <span class="comment">//将s从pos开始的n个字符替换为s1</span></span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><div class="table-container"><table><thead><tr><th>语法</th><th>含义</th></tr></thead><tbody><tr><td><code>vector&lt;int&gt; v1</code></td><td>默认为空的 vector</td></tr><tr><td><code>vector&lt;int&gt; v1(v2)</code></td><td>默认 v2 副本的 v1</td></tr><tr><td><code>vector&lt;int&gt; v1(n, i)</code></td><td>默认内容为 n 个元素 i</td></tr><tr><td><code>vector&lt;int&gt; v1(n)</code></td><td>默认内容为 n 个默认元素，以 int 为例，应是构建了包含 n 个 0 的 vector</td></tr></tbody></table></div><h3 id="Vector的基本操作"><a href="#Vector的基本操作" class="headerlink" title="Vector的基本操作"></a>Vector的基本操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line">test.push_back(<span class="number">1</span>); <span class="comment">// 插入新元素</span></span><br><span class="line">test.size();        <span class="comment">// 返回长度</span></span><br><span class="line">test.erase(test.begin()+<span class="number">2</span>); <span class="comment">// 删除第3个元素（下标为2的元素）。但这个操作很慢，不建议</span></span><br></pre></td></tr></table></figure><p><strong>Vector 的迭代器访问</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=test.begin();it!=test.end();it++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p><strong>算法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">reverse(test.begin(), test.end());  <span class="comment">//颠倒</span></span><br><span class="line">sort(test.begin(), test.end()); <span class="comment">//升序排序</span></span><br></pre></td></tr></table></figure></p><p>*<strong>为了降序排序</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(test.begin(),test.end(),Comp);</span><br></pre></td></tr></table></figure></p><p>需要定义一个特殊的比较函数，比较函数的输入为 vector 内含有的元素。对于结构体，可以使用类似的方法定义.</p><p>*<strong>当插入对象是数组时</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> out[<span class="number">3</span>][<span class="number">2</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>,   </span><br><span class="line">             <span class="number">3</span>, <span class="number">4</span>,  </span><br><span class="line">            <span class="number">5</span>, <span class="number">6</span> &#125;;  </span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>*&gt; v1;  </span><br><span class="line">    v1.push_back(out[<span class="number">0</span>]);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h2><p>在进入 Map 之前我们需要先搞定 Pair 类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; test;</span><br><span class="line">pair&lt;int, int&gt; test(1, 2);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;test.first&lt;&lt;<span class="built_in">endl</span>&gt;&gt;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;test.second&lt;&lt;<span class="built_in">endl</span>&gt;&gt;;  <span class="comment">//对pair元素的访问</span></span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>类似 python 的字典（不过灵活度大幅度下降。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map_int;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; map_string;</span><br></pre></td></tr></table></figure><p>其馀的初始化方法和 Vector 雷同，故不赘述。</p><h3 id="Map的基本操作"><a href="#Map的基本操作" class="headerlink" title="Map的基本操作"></a>Map的基本操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; test;</span><br><span class="line">test.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>));  <span class="comment">//插入新元素，使用该方法插入已经存在的键时会报错</span></span><br><span class="line">test[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">//该方法结果和上条效果相同；不存在该键的情况下会新建，反之会覆盖</span></span><br><span class="line">test.size(); <span class="comment">//字典的大小</span></span><br></pre></td></tr></table></figure><p><strong>查找/读值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l_it=test.find(<span class="number">1</span>); <span class="comment">//查找元素，返回一个迭代器；若迭代器指向map的末尾，则不存在该元素</span></span><br><span class="line"><span class="keyword">if</span>(l_it==test.end())</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"we do not find 112"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;l_it-&gt;second&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//由于返回的对象是一个迭代器，而迭代器指向的是一个Pair类型，故可以通过Pair类型的访问方法访问</span></span><br></pre></td></tr></table></figure></p><p><strong>遍历</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = mp.begin(); it != mp.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p><strong>删除</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp.erase(k);<span class="comment">//删除某一个键</span></span><br><span class="line">mp.erase(it);<span class="comment">//删除迭代器指向对象</span></span><br></pre></td></tr></table></figure></p><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a><strong>unordered_map</strong></h3><p>效果和 map 非常相似，但是一般情况下，使用 unordered_map 更快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h2><p><strong>Stack</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.size();</span><br><span class="line">s.empty(); <span class="comment">//判断是否为空</span></span><br><span class="line">s.pop();   <span class="comment">//弹出栈顶元素但不返回</span></span><br><span class="line">s.top();   <span class="comment">//返回栈顶元素</span></span><br><span class="line">s.push();  <span class="comment">// 加入新元素</span></span><br></pre></td></tr></table></figure><p><strong>Queue</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.empty(); <span class="comment">//如果队列为空返回true，否则返回false</span></span><br><span class="line">q.size(); <span class="comment">//返回队列中元素的个数</span></span><br><span class="line">q.pop();  <span class="comment">//删除队列首元素但不返回其值</span></span><br><span class="line">q.front(); <span class="comment">//返回队首元素的值，但不删除该元素</span></span><br><span class="line">q.push(); <span class="comment">//在队尾压入新元素</span></span><br><span class="line">q.back(); <span class="comment">//返回队列尾元素的值，但不删除该元素</span></span><br></pre></td></tr></table></figure><h2 id="Priority-queue"><a href="#Priority-queue" class="headerlink" title="Priority_queue"></a>Priority_queue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq;  <span class="comment">//默认是最大堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq; <span class="comment">//最小堆</span></span><br></pre></td></tr></table></figure><p>其馀操作如同普通的 queue。</p><p><strong>自定义数据结构</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    int x;</span></span><br><span class="line"><span class="class">    tmp1(int a) &#123;x = a;&#125;</span></span><br><span class="line"><span class="class">    bool operator&lt;(const tmp1&amp; a) const</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return x &lt; a.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//方法2</span></span><br><span class="line"><span class="class">struct tmp2 //重写仿函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    bool operator() (tmp1 a, tmp1 b) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return a.x &lt; b.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">int main() </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    tmp1 a(1);</span></span><br><span class="line"><span class="class">    tmp1 b(2);</span></span><br><span class="line"><span class="class">    tmp1 c(3);</span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1&gt; d;</span></span><br><span class="line"><span class="class">    d.push(b);</span></span><br><span class="line"><span class="class">    d.push(c);</span></span><br><span class="line"><span class="class">    d.push(a);</span></span><br><span class="line"><span class="class">    while (!d.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; d.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        d.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span></span><br><span class="line"><span class="class">    f.push(c);</span></span><br><span class="line"><span class="class">    f.push(b);</span></span><br><span class="line"><span class="class">    f.push(a);</span></span><br><span class="line"><span class="class">    while (!f.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; f.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        f.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><p>这里主要使用第一种方法吧：在数据结构重载运算符。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>喧譁記</title>
      <link href="/2020/09/07/essay/%E5%96%A7%E5%93%97%E8%AE%B0/"/>
      <url>/2020/09/07/essay/%E5%96%A7%E5%93%97%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-BoQkTQXy" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3947466" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>　　一早去等校車回本部，再從本部到江灣校區。去找教務處問保研的事情。這個事情攪成一團實在令人感到難受。吃晚飯的中午，教務處恐怕是沒人的，於是我坐在江灣的圖書館，開始回憶前段時間發生的事情，試圖記下那麼一些遊絲。<br>　　<br><a id="more"></a>  </p><p>　　我果然一點也不喜歡接納新的東西。或者說從一個相對舊的地方往相對新的地方移動。這樣空間上的移動給人一種難以理解的落寞感，這既不是懷念我正準備離開的地方，也不是對於目的地的抗拒。只是一種，潛意識裡的對於「移動」的排斥。</p><h2 id="09-06"><a href="#09-06" class="headerlink" title="09-06"></a>09-06</h2><p>　　走出地鐵站，然後我感覺那種令人不爽的溫度照在了我的額頭上。這是典型的、我所熟悉的上海的陽光的感觸，但是我一點也不喜歡。飛機提前四十分鐘到達了我的目的地，我坐在飛機上是這提前四十分鐘的意義，可惜沒有。在降落的時候，我看着下方的景色，但實話說這和我起飛的時刻看見的風景並不二致。難以想象這段短暫地旅程中，某種轉換就完成了。<br>　　在機場前往包裹提取處的一路上，我感覺我自己的步速開始慢慢地提高，感到了一種所謂「pressure」的東西。在機場囫圇點了個 KFC 的套餐，隨後就開始了返校的道路。這完全沒什麼新鮮事可言，除了睜眼看見的四處都有的人，以及閉眼也能想象到的四處都有的人。<br>　　出地鐵站的一瞬間，我或許在期待我眼前所看見的景色能有哪怕那麼一點點的不同，使我認爲，「移動」不完全是無謂的事情。但映入的一起是反胃的相似性。從地點 A 時間 T0 的離開，到達地點 B 時間 T1，隨後在 T2 離開地點 B，在 T3 回到了 A。我期望 T3 的 A 和 T0 的 A 不再是一個東西了。但如此的相似。這讓我覺得，我的 T0~T3 的時間消失了，從故事的一個結局回到了這個故事的開頭，而且這個故事是如此的單調無聊。<br>　　「新加坡的夏天令人厭煩，因爲它的周而復始是以天爲單位的；而正常的情況是以年爲單位的，這或許能讓人舒服那麼一點。」我想起昨日（9 月 5 日）在自行車上移動的時候說的話。事情沒能得到推進——我產生了這樣的印象。<br>　　「我實在是把我的大學過得太無聊了啊。」<br>　　伴隨着再熟悉不過的一切，我回到了自己的寢室。看着混亂不堪的景象，桌面上積攢的厚厚的灰塵，我連撣撣灰的想法也沒有。這個地方不討我喜歡，從最開始就是。狹小逼仄的空間，周而復始的時間。看着從門外進來的室友 S，我問：「走吧，去新寢室轉轉。」<br>　　新寢室也並沒有什麼特別的。但是最詭祕的是，我回到了大一的住宿的旁邊。於是完成了從 A 到 B 再從 B 回到 A 的又一個實踐。但我不覺得這段時間它消失了，我在這段時間裡失去了很多，卻沒什麼收穫。這段時間它沒有消失，它切實地傷害了我。然而這也確實是一種循環，一種反覆的消耗。新寢室莫名地和高中的寢室相似，但在這種相似性中我感受不到親切。自回到四川以後，和老同學的見面變成了一件時常發生的事情。但我說不清緣由。「既然你不喜歡和人打交道，爲什麼在大學裡主動承擔班委的工作呢？」這是一個朋友問我的。我不知道。矛盾性是有趣的東西，但在這一點上我完全不覺得有趣，倒不如說有一種悲劇的特徵。<br>　　我記得自己原來說過，一個人開始經常地回憶的時候，他就老了。出於某種預感，我才做了這樣一個預言吧。假設前方存在的分岔的路，我究竟是想走上那條前往我不知道方向的道路呢，還是那個回到過去的某個節點的道路呢。或許這兩條路是一條路，只是某種錯覺讓我以爲我有的選罷了。<br>　　晚飯我去了一家我之前就常去的茶餐廳。習慣性地點了菠蘿油。在我咬下第一口的時候，我感覺那種甜度、鹹度、溫度都和我記憶里的一模一樣，既是我所希望嘗到的味道，又是我所不希望嘗到的味道。我是出於什麼目的選擇了這樣一種東西呢，這種在我還沒有嘗試的時候就知道了結局的食物。我大概意識到了「膩煩」這個詞的含義，但又終於覺得自己下次還會再來這個餐廳，再一次點下這個菠蘿油，因爲 pattern 就是這樣，這個人的 pattern 就是這樣。就是類似那種「到了一個新的餐廳一定會點它的招牌菜」這樣瑣碎的特徵，構成了這個人的生活。<br>　　回到了自己的寢室，看着亂成一團的景象，開始大費周折地對其進行整理。不斷地找出各種意料之外的東西，各種瑣碎的日常浮現出來，但終究沒有特別的意義可言，這些時間確實沒有給我留下什麼特別值得回憶的事情，仿佛它不曾存在。</p><h2 id="09-05"><a href="#09-05" class="headerlink" title="09-05"></a>09-05</h2><p>　　難得地把三弟約出來了。雖說這次在成都呆的時間非常長，但其實沒見過幾面，好幾次事情都因爲自己或者他有這樣或者那樣的事情被取消了。但雖說是難得的見面，甚至帶有自己給自己送行意味的見面，也沒有特別的不同。除了破天荒地我去了一趟電影院——電影我是一竅不通的，但不影響我欣然接受了這個安排。這可能是一種介入。<br>　　每次吃飯聽三弟談他在學校里的生活之類的，就由衷地覺得很好：他過着一個不錯的生活啊，不像我這樣子。但這不是某種介入；介入在高三最後寢室告別的時候就結束了。<br>　　於是我說起當時在哈爾濱遇到的那對父子的事情。我總覺得我自己所看見的東西太少了，世界太多隱祕的角落我永遠也碰不到；甚至在我渾然不知的時候，生命就結束了——它總有一天會拋棄我去完成自己的工作。「我想，支教、研究員或者做一個軍官都是非常不同的體驗吧。」我說，「我都想試試，但是人生它只有一次，社會也不會允許我貪心地嘗試別的東西」。我想起在當時高考的時候，聽三弟說他有報考軍校的打算。我想那就是截然不同的、但是聽起來令人興趣盎然的道路。雖說最後還是沒去，但終究貢獻了一個相當不錯的可能性。「我當時聽說要 4 點起來跑操，我就不想去了」。我想，就是因爲這個要 4 點起來跑操它才顯得有趣啊。<br>　　這實在是矛盾的事情。我所厭惡的「移動」，我搞不清楚。我厭惡停在某個地方，卻也厭惡離開這個地方。我清楚有許多的事情，我或許會覺得有趣，我或許會想去探查一番，那絕對不是我所厭惡的。但是我能到那裡去嗎？我感覺到有一個巨大的軌道，或者精緻的台本在我的手中。事情依照某種順序和必然性發生。即使有些時候一些巨大的爆發會脫離這樣的軌道，但最終會被拉回來。這軌道大概是我臆想出來的東西吧；這軌道必將通向一個無趣且嘈雜的世界。<br>　　我們討論電影裡關於時間設定的問題。三弟爲了解釋電影裡的一個現象，給出一種假說：逆時間裡的人對於正常時間有更高的干預能力。正常時間的人會因爲逆時間中人物的行爲得到修正。我說正常時間裡的人奉行着自己的 free will 嗎？他回答說是，因爲這些事實是通過這個人所有的時刻的 free will 的疊加組成的，這一切沒有因果而只是事實。那這是他們 free will 的結果呢，還是這個事實的結果呢？這裡的 free will 或許只是某種意義的事實罷了。對於時空悖論的解釋於我而言最終總會進入一種相當消極的解釋。<br>　　或許只是有些事情因爲在軌道之外，它們才顯地有趣；而爲了讓這些事情保留着他們的趣味，軌道才存在。這不是什麼因果關係，而只是事實。我的心裡存在這樣的軌道的同時，也存在好惡。軌道和好惡構成的瑣碎是這個人的性質。或許有的人的軌道並不存在，有的人的好惡並不存在，但是存在別的東西，比如扳手、比如迷宮、比如門。在衆多的喧譁之中，保存着看見的和看不見的事物；扳動這些扳手，遊蕩在着迷宮或者越過那扇門並不是某種特質，這些事物的存在本身是那個特質。即使，這個人離開了這個軌道，也不意味着軌道出現了錯誤，而是軌道隱含着一個分支，這個分支是最開始就存在的，它是事實的一部分。<br>　　我把我的大學過得太無聊了，終究不是大學的性質，而是我的性質：是因爲主角是我，它才顯地無聊。我所排斥的「移動」恐怕是排斥那移動中的我自己吧……</p><h2 id="09-07"><a href="#09-07" class="headerlink" title="09-07"></a>09-07</h2><p>　　我不知道最後我討論到了這個事情上……是一種很難以解釋的鬱悶造成的。就像上文討論的軌道或者好惡之類的事情，本身就具有主觀性，因爲這些成段成段的討論和廢話並無差別。「這不是理所應當的事情嗎！？」或許是吧。其實這些敘述完完全全脫離了我動筆的初衷，但我還是決定忠實地把這些記錄下來，算是給我在成都滯留的大半年生活畫上一個句號。</p><p>廙水<br>2020-09-07<br>復旦大學江灣校區圖書館</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿拉伯数字转罗马数字</title>
      <link href="/2020/08/26/tech/%E9%98%BF%E6%8B%89%E4%BC%AF%E8%BD%AC%E7%BD%97%E9%A9%AC/"/>
      <url>/2020/08/26/tech/%E9%98%BF%E6%8B%89%E4%BC%AF%E8%BD%AC%E7%BD%97%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为近日在准备保研的刷题…所以得看各种奇怪的题目。但事实上由于太久没有写算法了，现在还在康复期，先做些简单的东西好了…其实是我觉得这个东西什么时候可能会用上？</p><a id="more"></a>  <h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">    string = <span class="string">""</span></span><br><span class="line">    ones = [<span class="string">"I"</span>, <span class="string">"X"</span>, <span class="string">"C"</span>, <span class="string">"M"</span>]</span><br><span class="line">    fives = [<span class="string">"V"</span>, <span class="string">"L"</span>, <span class="string">"D"</span>]</span><br><span class="line">    ct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num:</span><br><span class="line">        n = num % <span class="number">10</span></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">            s = ones[ct] * n</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">4</span>:</span><br><span class="line">            s = ones[ct] + fives[ct]</span><br><span class="line">        <span class="keyword">elif</span> n &lt;= <span class="number">8</span>:</span><br><span class="line">            s = fives[ct] + ones[ct] * (n - <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">9</span>:</span><br><span class="line">            s = ones[ct] + ones[ct + <span class="number">1</span>]</span><br><span class="line">        string = s + string</span><br><span class="line">        ct += <span class="number">1</span></span><br><span class="line">        num //= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> string</span><br></pre></td></tr></table></figure><h2 id="阿拉伯数字转罗马数字规则"><a href="#阿拉伯数字转罗马数字规则" class="headerlink" title="阿拉伯数字转罗马数字规则"></a>阿拉伯数字转罗马数字规则</h2><div class="table-container"><table><thead><tr><th>符号</th><th>数字</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>例如以下的对应：</p><div class="table-container"><table><thead><tr><th>罗马数字</th><th>阿拉伯数字</th></tr></thead><tbody><tr><td>III</td><td>3</td></tr><tr><td>VI</td><td>6</td></tr><tr><td>XVI</td><td>16</td></tr></tbody></table></div><p><strong>特殊规则</strong><br>除了上述简单的累计外，还有一条特殊规则：对于$4\times 10^n$或$9\times 10^n$，应该使用特殊的表达方法：</p><div class="table-container"><table><thead><tr><th>罗马数字</th><th>阿拉伯数字</th></tr></thead><tbody><tr><td>IV</td><td>4</td></tr><tr><td>IX</td><td>9</td></tr><tr><td>XL</td><td>40</td></tr><tr><td>XC</td><td>90</td></tr><tr><td>…</td></tr></tbody></table></div><p>在这个规则下，<code>MCMXCIV</code>代表 1994：M：1000；CM：900；XC：90；IV：4。这意味着对于一个阿拉伯数字，最多需要 4 个符号，但基本上还是遵循十进制的规律，所以毫无竞争力可言。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>野士</title>
      <link href="/2020/08/22/essay/poems/%E9%87%8E%E5%A3%AB/"/>
      <url>/2020/08/22/essay/poems/%E9%87%8E%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>只是翻出了高中時期的周記本，想起最後的兩頁記了些「見不得人」的東西。既然找出來了，也就把它記下來吧。當時晚自習實在看不了教材的時候，相較看小說，果然還是看自己的東西更加有趣。</p><a id="more"></a>  <h2 id="野士"><a href="#野士" class="headerlink" title="野士"></a>野士</h2><p>　　棉芯將燃燒殆盡，<br>　　不，別碰那鏡子。<br>　　別碰那些無趣的嘆息，<br>　　讓它們繼續明亮。</p><p>　　卻棄了你手裡的煙火！<br>　　小心它們燃成了灰，<br>　　灼了你的手。</p><p>　　不，別向無物禱告。<br>　　把它們放在地上，<br>　　等待飄忽的風，<br>　　將它們燃盡。</p><p>　　　　——作於某年 12 月 15 日</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 詩歌？ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『ヒカルの碁』觀感</title>
      <link href="/2020/07/16/essay/%E8%A7%82%E6%84%9F/%E6%A3%8B%E9%AD%82/"/>
      <url>/2020/07/16/essay/%E8%A7%82%E6%84%9F/%E6%A3%8B%E9%AD%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-KeGbesXy" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="538824" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="評價：★★★★★"><a href="#評價：★★★★★" class="headerlink" title="評價：★★★★★"></a>評價：★★★★★</h3><p>雖然在完成鋼煉 03 的觀感之後就清楚地意識到了自己不具有寫作觀後感的才能，但終於還是落筆來記錄這一部給我直接震撼的作品。</p><a id="more"></a> <p>距離我第一遍看完這部作品可能已經過去 2 個多月了吧。在這之後，我 開始重複看這部作品；把它的漫畫，揪出來補完了北斗杯；把《北斗特別篇》也完成了。但總有一種意猶未盡的感覺……毫無疑問，這部作品是我到目前爲止看過的一部最爲傑出的作品之一。儘管我一直希望爲它寫一些什麼東西，但總覺得那種感情很模糊，難以構成更具象的文字。</p><p>『ヒカルの碁』直譯過來的話應該叫做《光的棋》，另一個譯法爲《棋靈王》。但私以爲，《棋魂》的翻譯還是更加恰當。這部作品顯然不是講述光一個人圍棋道路的作品，更不是以佐爲和光爲核心的作品。佐爲的離開暗示了關於「傳承」的主題。所謂「神の一手」並不是一個具體的存在，是棋士往下奮鬥的道路。但傳承只是這其中衆多主題之一。</p><p>很難想象一部漫畫作品可以把關於圍棋這種行外看熱鬧的嚴肅主題演繹到這樣的程度。我幾乎是在看過了前幾集之後就篤定這是一部優秀的作品，甚至在期末季連續熬夜看完（特別是名人佐爲兩戰，完全沒有喘息的機會），然後二刷三刷。它所傳達的可怕信念和執念，毫無疑問可以讓觀衆爲之動容。</p><p>這個故事基本上是關於對局和人的故事。圍繞着這個核心，將當時日本棋界的人和事慢慢地抖落出來。以筒井、三谷爲代表的以圍棋作爲愛好的普通學生，以棋士作爲衆生奮鬥的和谷、伊角的院生時代，在棋壇風生水起的新生代（可能也比較老了吧）緒方、倉田，以及當時日本的巔峯塔矢名人。</p><p>整個故事基本上是由幾場重要的對局作爲線索拉開的，對於人物的塑造也幾乎是依賴對局完成的。這其中有關乎劇情發展的重要對局，也有配角們閃爍光芒的「魂」的對局。劇情的發展環環相扣，自然而充滿波折。幾個重要的成長階段也自然合理毫不做作。幾次對局將整部的氣氛嚴肅而積極。我可以清晰地感到這部作品中人物的精神透過方框地屏幕向外湧出，閃爍着他們追求的光。</p><p><strong>佐爲 VS 亮</strong></p><p>佐爲和亮一共對局三次。前兩次使亮產生了巨大的恐懼。從此樹立了追趕光的目標。然而在中學圍棋大賽見到真正的光時大失所望，轉而進軍職業世界。</p><p>亮是一個溫柔的人，但是對於超越自己的對圍棋毫無尊敬的光，展現出了一種毫無動搖的決心。即使是遠比自己強大的，也必須去挑戰，這是通往「神の一手」的唯一道路。</p><p>亮由於自己的名人父親，深深知道棋界的艱難，也對其抱着絕對的尊敬和執着。幾乎可以說是全劇中最爲執着的棋手，具有着遠超光前期決意追趕亮的覺悟和決心。</p><p><strong>佐爲 VS 名人</strong></p><p>佐爲和名人也有三次對局。也是劇情重要的三次對局。其中第一句完成了對於光的引導，讓光產生了「他們對這個如此認真，自己也相認真」的想法。這是光從「隨便玩玩」到「認真對待」的重要對局。儘管這局不了了之，但也爲後面的新初段埋下了伏筆。</p><p>第二局新初段賽，佐爲佐爲棋手的執念在這裡爆發。這一戰的分爲塑造將視角交給了名人和觀衆，通過頂尖棋士的評論，將這一戰的「緊張感」渲染到了極致。</p><p>第三局線上圍棋戰，觀衆變爲了世界的業餘棋手。這一次將上一戰未完成的遺憾結束了，也終於開始了佐爲的離別章節。這一章展現的是名人的意志。「這就是名人的棋，絕不退讓，一定會贏。」。結束之後，名人自嘲 「名人我下出這樣一盤棋，也不算壞吧。」名人也有名人的追求。後面名人擺脫成見，隱退棋壇，遊歷四方，不斷地學習和感受圍棋。完成了對於名人角色的收束。</p><p>第三戰光的發現終於讓佐爲意識到了自己存在的意義，即便認識到了自己可能永遠無法碰到神之一手，但還有後輩在不斷地、不斷地朝着那個方向前進。自己作爲傳承者的使命已經完成了，終於放下了自己對於圍棋地熱情，從而不可避免地邁向了消失的結局。</p><p><strong>光 VS 和谷</strong></p><p>在對局中出現對話是常見的手法。和谷和光之一戰，決定了和谷能否就此走向職業棋士。接受老師鼓勵的和谷拼盡全力，發現自己穩操勝券時，腦中迴響的老師的話。這裡算是一個剛剛將要進入棋壇新人的思想吧。樸實且充滿着希望，然而這一戰輸了。</p><p>哎……實在是太多了。光和伊角兩次對局，光和洪秀英的對局，越智和社的對局。這是一羣人展現的對於圍棋這個事業的執着和熱愛。就是這樣單純的故事也能打動很多很多的人了，對這些棋手自然尊敬起來。</p><p>佐爲的離去是在衆多伏筆下必然的事件；如果作者在之後執意讓離開的佐爲回到這世間，儘管滿足了許多的讀者，卻會成爲這部作品的敗筆。將佐爲的意志寄托在光對圍棋的愛中，是最優的解。佐爲的離開和光的成長是密不可分的，道路總是需要一個人走下去的，對於圍棋的愛也不應當是爲了某個人才堅持下去，這是一條自我的、自私的道路。在光與伊角的一局中，那隻突然出現的手和扇子，讓我整個人愣住了。原來這個謎題是這樣的啊……作者實在是……完全在意料之中的解法，但是在長時間的情感烘托之下呈現絕對的殺傷力。光重新帶者佐爲的執念回到了棋壇。應該是佐爲真正滿意的結局吧。</p><p>「傳承」這個主題在北斗杯再一次托出，完成了光回歸棋壇的結局，留下了無窮的可能。這部作品將棋士的精神很好地展現在了所有讀者的面前，即使作爲一個對圍棋一知半解的門外漢，也不得不感到觸動——爲了一個熱愛的事業竟然能夠如是執着地爲之奮鬥，這是如此值得欽佩的事情！卻在現代的世界中越來越少見，實在是令人遺憾。</p><p>我果然是，很不適合寫觀後感……此刻真切地感到自己完全沒有足夠的能力對自己發自內心喜愛的這部作品做出真正恰到好處或者生動的評價。多年以後，我一定會回到這部作品來，看看自己的人生是不是過得就那樣淒涼而單調。或許每個人都藏着一顆棋士的心，奮鬥且掙扎、不停地挑戰、執着地追求更強的棋士的心，在各自熱愛的領域裡將自己的愛和執着傳承下去……</p><p>這是一部可怕的作品。</p>    <div id="aplayer-LLjRSowJ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="538768" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 觀感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - How to best use Syntax in SRL</title>
      <link href="/2020/07/16/scholar/paper/Syntax_in_SRL/"/>
      <url>/2020/07/16/scholar/paper/Syntax_in_SRL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文讨论如何把句法信息加入 SRL 任务。其中提到了三种方法：使用句法信息作为输入；使用句法信息组成 Multi-task；同时使用上述两种方法，组成 auto-encoder。本文使用 CoNLL’05 和 CoNLL’12 作为训练集进行测试。</p><a id="more"></a>  <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="外部信息"><a href="#外部信息" class="headerlink" title="外部信息"></a>外部信息</h3><p>将外部信息加入 NLP 任务的思想在近几年中趋势越发明显。关于这个问题，有三种主流的做法：</p><ol><li>加入 Input：外部信息作为神经网络的额外输入特征。</li><li>作为 Output：神经网络在训练主任务的同时需要对这些信息进行 Multi-task 训练。</li><li>Auto-encoder：同时将外部信息作为神经网络的 Input 和 Output。</li></ol><p>但是这些研究主要停留在了一些浅层信息，例如将 POS 标签和序列标注任务结合。而那些标注句法依赖等等“较长”句法特征信息则没有被仔细研究。这篇文章就是针对这一点进行一个补充。</p><p>在这篇文章中，主要讨论了三个问题：</p><ol><li>应该如何将句法信息加入作为<strong>word-level featrues</strong>？</li><li>如何最好地表达句法信息？</li><li>句法信息表达的选择对于结果有多少影响？</li></ol><h3 id="SRL-System"><a href="#SRL-System" class="headerlink" title="SRL System"></a>SRL System</h3><p>一个语法标注系统能够提取 predicate-argument 结构。在研究早期句法信息一直是 SRL 的重要组成部分，然而当下的 SOTA 模型并没有显式地包含句法信息。这篇文章希望通过实验证明句法信息对于 SRL 系统的重要作用。</p><p>在这篇文章中，作者将外部信息表示为离散特征向量。其中有三类表示：</p><ol><li>Full-C：全成分树表示</li><li>SRL-C：SRL-specific span 表示</li><li>Dep：依赖树表示</li></ol><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>对于不同的整合方式，在语料库 CoNLL’05 和 CoNLL’12 上进行测试获得结果</p><h2 id="句法表示"><a href="#句法表示" class="headerlink" title="句法表示"></a>句法表示</h2><h3 id="Full-C"><a href="#Full-C" class="headerlink" title="Full-C"></a>Full-C</h3><p>参照 Gomez-Rodrıguez and Vilares 提出的方法，将成分分析树进行向量化。为了表示这个提出下列标注：</p><ol><li>$n(w_i)$：指$w_i$和$w_{i+1}$间的共有父节点的数量。</li><li>$l(w_i)$：编号最小的父节点的 non-terminal 标签。如果是 terminal，则为 S。</li><li>$r(w_i)$：$n(w_i) - n(w_{i-1})$</li></ol><p>通过记录所有节点的上述信息，可以完全还原成分分析树。示例如下：</p><center><img src="/images/Research/Full-c.jpg"/></center><h3 id="SRL-C"><a href="#SRL-C" class="headerlink" title="SRL-C"></a>SRL-C</h3><p>只有一小部分的成分分析树中的成分是发挥了作用的。这意味着将整个成分分析树都进行编码可能不是最优解。因此仅保留最有可能有利于标签分类的成分是必要的一个操作。为此，作者使用了剪枝算法，将其中的部分 argument 收集起来，并将无关的部分滤除。对于滤除的结果使用标准 BIO 标记法标记。</p><ol><li>O：单词在任何一个候选成份外</li><li>B：单词是某一个候选成分的第一个单词</li><li>I：单词在某一个候选成分中</li><li>A：单词在一个介词短语中</li><li>V：正在考察的 predicate 的核心动词</li></ol><p>这个标记在上面例图中已经标明。</p><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p>通过依赖树，编码的仍然是成分信息。其具有下列的标签：</p><ol><li>Left/Right：这个但错左右拥有的依赖数。</li><li>Edge：这个单词是管辖这个词（左边/右边/不是）最依赖这个词的词。</li><li>RG（Relative distance to governor）：这个词与其 Governor 间的距离。</li><li>DL（Dependent label）：指向这个词的 denpendent 标签。</li></ol><p>示例如下：</p><center><img src="/images/Research/Dep.jpg"/></center><h2 id="如何使用外部信息？"><a href="#如何使用外部信息？" class="headerlink" title="如何使用外部信息？"></a>如何使用外部信息？</h2><p>加入外部信息的方法如同前文所说，有三：</p><ol><li><strong>Input</strong>：将外部信息和 ELMo 提供的词向量相连。其中依赖树通过将生成的成分树进行变换得到，以保证两种划分方法的一致性。</li><li><strong>Output</strong>：同时预测 SRL 和句法特征，最后使用的损失函数是这两部分的和。</li><li><strong>Anuto-encoder</strong>：将外部信息作为特征输入，并同时作为 multi-task 训练的对象，使得这个方法呈现出 encoder 的特性。</li></ol><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>实验一共进行了 10 组：“3 种使用外部信息的方法”x“3 种将文本句法特征向量化的方法” + 1 个 baseline。实验在 CoNLL’01 和 CoNLL’12 上进行。</p><h3 id="主要结果"><a href="#主要结果" class="headerlink" title="主要结果"></a>主要结果</h3><center><img src="/images/Research/SRL-res.jpg"></center><p>结果表示，句法信息确实是对 SRL 能力有积极提升作用。其中，Full-C 获得了更优于 Dep 的实验结果。作者认为这是由于成分树更加接近于 SRL 的信息。此外 SRL-C 的方法略好于 Full-C 方法，在集外预测时也更具优势。</p><p>并且使用 Multi-task 在这个任务中并没有体现出非常好的效果，而其馀两种方法效果相当。</p><h3 id="与现有系统的对比"><a href="#与现有系统的对比" class="headerlink" title="与现有系统的对比"></a>与现有系统的对比</h3><p>作者将本次实验中表现最为出色的 SRL-C used as Input 作为对比，和现有的各个工作进行对比。这个方法相较于现在已有的模型有略微的提升，但是结果并未明显胜出 ensemble 方法。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP术语集 - Grammar</title>
      <link href="/2020/07/15/scholar/NLP/Grammar/"/>
      <url>/2020/07/15/scholar/NLP/Grammar/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近开始看 NLP 的论文啊，觉得好多术语都不知道是个什么，就只能一边看一边查咯。</p><a id="more"></a><h3 id="Predicate：谓词"><a href="#Predicate：谓词" class="headerlink" title="Predicate：谓词"></a>Predicate：谓词</h3><p><a href="https://www.grammar-monster.com/glossary/predicate.htm" target="_blank" rel="noopener">Link</a></p><blockquote><p>The predicate is the part of a sentence (or clause) that tells us what the subject does or is. To put it another way, the predicate is everything that is not the subject.</p></blockquote><p>或参照韦氏词典的定义：</p><blockquote><p>the part of a sentence or clause that expresses what is said of the subject and that usually consists of a verb with or without objects, complements, or adverbial modifiers.</p></blockquote><p>简而言之谓词是描述 Subject 做什么或者是什么的一个<strong>成分</strong>，并不一定是一个词。一个谓词的 Core 是一个动词。</p><p><strong>Easy Examples of Predicates</strong></p><ul><li>Adam <em> <strong>lives</strong> in Bangor</em>.</li><li>The telegram <em> <strong>contained</strong> exciting news</em>.</li><li>The girls in our office <em> <strong>are</strong> experienced instructors</em>.</li></ul><p><strong>Real-Life Examples of Predicates</strong></p><ul><li>True friends <em> <strong>appear</strong> less moved than counterfeit</em>. (Greek philosopher Homer)</li><li>Words empty as the wind <em> <strong>are</strong> best left unsaid</em>. (Homer)</li><li>People can <em> <strong>come</strong> up with statistics to prove anything</em>. Forty percent of all people <em> <strong>know</strong> that</em>. (Homer Simpson)</li><li>With $10,000, we would <em> <strong>be</strong> millionaires</em>! We <em> <strong>could buy</strong> all kinds of useful things like … love</em>. (Homer)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>土豆湯製法</title>
      <link href="/2020/07/12/essay/cookbook/%E5%9C%9F%E8%B1%86%E6%B3%A5/"/>
      <url>/2020/07/12/essay/cookbook/%E5%9C%9F%E8%B1%86%E6%B3%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因爲一個人在家，看着家裡有土豆，於是打算就試一次土豆泥。但是土豆泥總感覺味道不如土豆湯，所以打算改做土豆湯，而家裡又沒有用來攪碎蔬果的東西，所以用豆漿機代替。本來戰戰兢兢的，後來發現不僅沒有出問題，而且效果還不錯，而且做法簡單地不可思議。</p><a id="more"></a>  <p><strong>口感</strong></p><ul><li>和西餐廳能吃到的口感相似，不過因爲第一次做多放了水，所以會顯得稀一點。</li><li>顏色呈粉紅色</li></ul><p><strong>材料</strong><br>下述材料是兩人份的。</p><ul><li>正常大小土豆一個</li><li>火腿腸（粗）：1/4 支</li><li>牛奶 250ml</li></ul><p><strong>步驟</strong></p><ul><li>將土豆切丁（很小的類型）</li><li>將火腿腸切丁</li><li>將牛奶導入上述混合物，並加入 50ml 左右的水</li><li>使用豆漿機打碎</li><li>適量放鹽，結束</li></ul><p><strong>實驗失敗經歷</strong></p><ol><li>實驗 001<ul><li>第一次實驗使用了半根火腿腸，發現火腿腸味道太濃，土豆味道不明顯，且湯體成粉紅色，明顯是放多了……</li><li>並且第一次倒入了整碗水，水過多導致土豆湯過稀，應該是使用半碗即可。</li><li>這個事情的後續：豆漿機因此損壞，儘管看起來它好好的。該項目因爲帶來的巨大的經濟損失，將不再被實驗。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 食譜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pip下载Module</title>
      <link href="/2020/07/12/tech/Python/pip%E4%B8%8B%E8%BD%BD/"/>
      <url>/2020/07/12/tech/Python/pip%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Pip 下载东西总是哪里会出一个幺蛾子……即使加上镜像……</p><a id="more"></a>  <p>使用下列指令下载：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip pip install -i https:<span class="string">//pypi.tuna.tsinghua.edu.cn/simple</span> <span class="params">--default-timeout=100</span> <span class="params">--upgrade</span> tensorflow-gpu</span><br></pre></td></tr></table></figure><p>其中<code>--default-timeout</code>项可以避免：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReadTimeoutError: <span class="constructor">HTTPSConnectionPool(<span class="params">host</span>='<span class="params">pypi</span>.<span class="params">tuna</span>.<span class="params">tsinghua</span>.<span class="params">edu</span>.<span class="params">cn</span>', <span class="params">port</span>=443)</span>: Read timed out.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python自动修改格式</title>
      <link href="/2020/07/11/tech/Python/Python%E8%87%AA%E5%8A%A8%E6%8E%92%E7%89%88/"/>
      <url>/2020/07/11/tech/Python/Python%E8%87%AA%E5%8A%A8%E6%8E%92%E7%89%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>偶然发现的一个 Python 自动修改代码风格的工具，感觉挺有用，在此记录使用方法。</p><a id="more"></a>  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先对于安装<code>black</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> black</span><br></pre></td></tr></table></figure><p>注意这个命令需要在 VSC Terminal 所在的虚拟环境中安装。例如如果 Terminal 使用的 conda-base，则该 Module 就应该在 conda-base 里安装。</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>打开 VSC 的 Setting(JSON)，将下列代码粘贴在最后方：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"python.formatting.provider"</span>: <span class="string">"black"</span>,</span><br><span class="line"><span class="string">"editor.formatOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"python.formatting.blackArgs"</span>: [</span><br><span class="line">  <span class="string">"--line-length"</span>,</span><br><span class="line">  <span class="string">"120"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在这个设置下，每一次保存会进行一次自动的格式修改。但由于 Python 的特殊性，这个脚本能够改变的主要是行内代码风格，不能对缩进等进行修改。</p><p>参考连接：<a href="https://zhuanlan.zhihu.com/p/73452541" target="_blank" rel="noopener">link</a></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 脚本工具 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新老Edge并存方法</title>
      <link href="/2020/07/10/tech/%E6%96%B0%E8%80%81Edge%E5%B9%B6%E5%AD%98/"/>
      <url>/2020/07/10/tech/%E6%96%B0%E8%80%81Edge%E5%B9%B6%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>新版 Edge 尽管支持了 chrome 的插件，但是由于主力 Vivaldi 的能力过强，导致新 Edge 继续吃灰。配合 surface pen，老版 Edge 的 PDF 阅读器作为绝对优势的功能也遗憾被删除。为了能够继续使用老版本的 Edge，在网上搜索一番后，发现这个方法可行，于是记录下来。</p><a id="more"></a>  <h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><p>打开网址：<a href="https://www.microsoft.com/zh-cn/edge/business/download" target="_blank" rel="noopener">link</a>，</p><center><img src="/images/Things/edge.jpg" width="50%" height="50%" />如是选择</center><p>这个下载会获得一个名为<code>MicrosoftEdgePolicyTemplates</code>的压缩文件。将其解压可以得到下述文件：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\-</span> examples</span><br><span class="line"><span class="string">\-</span> html</span><br><span class="line"><span class="string">\-</span> mac</span><br><span class="line"><span class="string">\-</span> windows</span><br><span class="line">    <span class="string">\-</span> admin</span><br><span class="line">    <span class="string">\-</span> admx</span><br><span class="line">        <span class="string">\-</span> zn-CN</span><br><span class="line">        <span class="string">\-</span> en-US</span><br><span class="line">        ...</span><br><span class="line">        msedge.admx</span><br><span class="line">        msedgeupdate.admx</span><br></pre></td></tr></table></figure><p>将上述文件的<code>msedge.admx</code>及<code>msedgeupdate.admx</code>复制到文件夹：<code>C:\Windows\PolicyDefinitions</code>中。同时对应于上述的语言文件夹，将其中相关内容复制到对应的文件夹中。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>上述完成之后可以打开<code>gpedit.msc</code>，进入 windows configureation，依照下列路径进入：<code>Computer configuration -&gt; Administrative Templates -&gt; Microsoft Update</code></p><p>双击 Microsoft Update，点击 side-by-side 选项，将该服务 enable。</p><p>* 注意：这个文件夹只有在完成了上述的修改之后可见。</p><h2 id="重新安装"><a href="#重新安装" class="headerlink" title="重新安装"></a>重新安装</h2><p>回到最开始的网站，保持相同的版本号，下载新的 msi 安装文件安装 edge。这个操作不会将老版本 Edge 放入开始菜单，但是可以通过菜单栏中的<code>open with</code>打开 PDF。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - Towards Robust Semantic Role Labeling</title>
      <link href="/2020/07/09/scholar/paper/Towards%20Robust_Semantic_Role_Labeling/"/>
      <url>/2020/07/09/scholar/paper/Towards%20Robust_Semantic_Role_Labeling/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>ACL 2007</strong></p><p>为暑研工作阅读的第一篇论文。暑研工作的三个基石之一：SRL（Semantic Role Labeling）。现在大部分 SRL system 都基于一个数据集完成的训练。作者认为这样会造成过拟合现象。这篇文章提供了一种在特定数据集上标注后迁移到另一个数据集的方法。本篇文章基于 PropBank（很快我也需要完成这篇文章的阅读了。）这篇文章认为语法上的 parser 和 argument 判断可以很容易的迁移，然而 argument classification 不是。</p><a id="more"></a>  <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>SRL 是一种用来表征语法结构的方法。党表征一个句子时，一个好的语法标注器应当能够对句子中的每一个谓词，正确地辨别并标注出其语法 label。在近期的工作中，这个工作是通过监督机器学习完成的。尽管这些工作在数据集上都达到了很高的准确率，但是他们极大地与其训练的数据集相关。这篇文章的焦点就是讨论这样的现象。</p><p>实验基于 PropBank corpus（这是一个 WSJ 的标注数据集）完成。</p><h2 id="语义标注（Semantic-Role-Labeling）"><a href="#语义标注（Semantic-Role-Labeling）" class="headerlink" title="语义标注（Semantic Role Labeling）"></a>语义标注（Semantic Role Labeling）</h2><p><strong>成分分析（constituent parsing）</strong><br>成分解析树将一个句子划分为一棵成分树，树上的非叶子节点是划分成的短语，叶子节点是句子中的单词。</p><p>在 NLP 中，分析方法分为：</p><ul><li>词法分析 lexical analysis</li><li>句法分析 syntactic parsing</li><li>语义分析 semantic parsing</li></ul><p>其中语义分析是指将自然语言句子转化为反映这个句子语义的形式化表达。例如：</p><blockquote><p>我吃了一块肉<br>一块肉被我吃了</p></blockquote><p>在语义上都表示为吃(我，肉）的意思，但句子结构却有不同。句子的语义分析是对句子处理技术更高一级的要求，在信息检索、信息抽取、自动文摘等应用广泛。</p><blockquote><p><strong>SRL:</strong> Semantic Role Labeling (SRL) is defined as the task to recognize arguments for a given predicate and assign semantic role labels to them.</p></blockquote><p>SRL 是浅层语义分析技术，以句子为单位处理为“谓词+论元”的结构。</p><h2 id="语义标注和语料库"><a href="#语义标注和语料库" class="headerlink" title="语义标注和语料库"></a>语义标注和语料库</h2><p>这篇文章通过复现 PropBank corpus 中的语义标注方法完成实验。PropBank 是一个包含 300k 单词的语料库，其中对于除了系词（corpula）外的所有动词都标注了谓词 argument 关系。PropBank 使用了 Arg0~Arg5 作为谓词 labels。</p><ul><li>ARG0: Agent, operator</li><li>ARG1: Things operated</li><li>ARG2: EXplicit patient</li><li>ARG3: Explicit argument</li><li>ARG4: Explicit instrument</li></ul><center><img src="/images/Research/semantic-tree.jpg" width="50%" height="50%" />Semantic Tree</center><p>除了这些基本的标志外，还存在 adjuntive argument（ArgMs），以及 ArgM-Loc，Arm=gM-TMP 等等。对于下面的例子，使用 operate 作为候选词获得的标注：</p><blockquote><p>It operates stores mostly in Iowa and Nebraska.</p><p>[$_{ARG0}$It] [$_{谓词}$operates] [$_{ARG1}$ stores][$_{ARGM−LOC}$ mostly in Iowa and Nebraska].</p></blockquote><p>PropBank 假定对于一个谓词的语义单元只存在一个或多个 nodes。尽管对于大部分的 arguments 树只有一个 node，但多个 node 的情况也是存在的。</p><h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h2><p>在 ASSERT 中，SRL 是通过对于一个 syntactic parse 的组分分配一个 role label 实现的。基本上可以被分到三个步骤：</p><ol><li>Argument identification：对于一个给定的谓词，识别句子成分。对于 parse tree 中的任何一个 node，可以被分类为具有语义表示（Not Null Node）或者不具备任何语义内涵。</li><li>Argument classification：假定已知一个谓词的组成已知，这个步骤将 argument label 赋给这些组成。</li><li>Argument identification and classfication：上述两个任务的组合。</li></ol><h2 id="ASSERT（Automatic-Statistical-Semantic-Role-Tagger）"><a href="#ASSERT（Automatic-Statistical-Semantic-Role-Tagger）" class="headerlink" title="ASSERT（Automatic Statistical Semantic Role Tagger）"></a>ASSERT（Automatic Statistical Semantic Role Tagger）</h2><h3 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h3><p>ASSERT 对每一个谓词生成一组 SRL（不同于 PropBank，系词是考虑在内的）。模型基本的输入是一个句子以及成分分析树。对于每一个分析树中的成分，ASSERT 提取出一组特征，并使用分类器对这个成分指定标签。该模型使用 SVM 方法及“one vs all”构建 n 个分类器，每一个分类器的结果被综合对标签进行判断。</p><p>上述使用的方法有一个缺陷：每一个 argument 的分类是独立的，而没有考虑其他被赋给相同标签的 argument。这样会忽略部分信息。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>使用的特征如下：</p><ul><li>谓词：确定 arguments 所使用的这一个谓词，同时该谓词的形式及语法信息同样作为特征输入。</li><li>路径：从分析树到当前分类谓词的路径。</li></ul><center><img src="/images/Research/tree-path.jpg" width="50%" height="50%" /></center><ul><li>短语类型：比如 PP，NP 等等成分。</li><li>位置：这个成分出现在谓词前还是谓词后</li><li>状态：这个谓词是主动的还是被动的。</li><li>子类？：这个谓词的子节点，例如在上图中：<code>VP -&gt; VBD - PP - NP</code>。</li><li>谓词 cluster：直观是，对于相似的语法结构的动词应该有相似的对象。例如“eat&amp;devour”。动词被分为 64 类，然后通过这个分类作为特征。</li><li>Head word：这个成分的 head。</li><li>Head word Pos：这个 head word 的 pos。</li><li>成分中的 named entity。</li><li>…… 太多了，不一一列举了。</li></ul><p>在实验过程中，对于 Identification Task 和 Classification Task 的有效特征是不同的。对于 IT，有效的特征是 Path 和 Partial Path，而谓词并不是非常重要。而对于分类，更重要的是 Head word，First/Last word 这些词。</p><p>简单的结论是，结构性的特征（如 Path）对于 IT 有积极作用，而更 lexical 的词或语义上的特征则对于分类更加重要。</p><h2 id="鲁棒性分析"><a href="#鲁棒性分析" class="headerlink" title="鲁棒性分析"></a>鲁棒性分析</h2><p>基本上目前的研究都将注意力放在了带有某种相同风格的文本上，对于这些文本集表现得提高可能更多意味着对于<strong>某类文本</strong>的辨识力/拟合，然而 SRL 等工具应当是普适意味的……为了表现这些模型确实不具有很强的迁移能力，引入下列的数据集。</p><h3 id="The-Brown-Corpus"><a href="#The-Brown-Corpus" class="headerlink" title="The Brown Corpus"></a>The Brown Corpus</h3><p>BC 是美式英语标准语料库，包含 1 百万英文文本，收录 2000 多词越 500 个样本。这个数据集用做语言对照分析。</p><h3 id="跨风格测试"><a href="#跨风格测试" class="headerlink" title="跨风格测试"></a>跨风格测试</h3><p>这一个测试表现模型在一个数据集上训练以后迁移到另一个数据集上是训练得到的结果差异。其选择在 WSJ 模型上先完成训练，然后迁移到 BS 上进行对比。我们掠过结果分析部分。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>获得了在 PropBank 上的 SRL SOTA，并使用这个结果在 Brown 语料库上进行检验。事实证明，在 Brown 上的模型表现大幅度下降，作者认为其中 Identification 步骤对模型能力下降影响不大，分类部分是模型能力下降的主要原因。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spaCy模型离线安装</title>
      <link href="/2020/07/08/tech/Python/Spacy%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/07/08/tech/Python/Spacy%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了安装 AllenNLP，不得已更新了 Torch。然后发现 SpaCy 的语言包也需要更新。奈何现在不在国内，更新语言包非常难受。网上的方法大多不济，这里简单记录。</p><a id="more"></a>  <h2 id="排雷"><a href="#排雷" class="headerlink" title="排雷"></a>排雷</h2><ul><li>在国内直接使用<code>python -m spacy download en</code>，一般下载到 50%左右就会断开连接。</li><li>下载了离线包之后，在文件夹执行<code>python setup.py install</code>并没有什么用处，模型仍然不能被正确识别。</li><li>使用<code>pip install *.tar.gz</code>，会导致开始下载模型……</li></ul><p>上述方法都是经过反复尝试并且无效的。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在 github 上找到合适的 en 模型下载并解压，得到一个文件夹：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\<span class="selector-tag">-</span> <span class="selector-tag">en_core_web_sm</span></span><br><span class="line">    <span class="selector-tag">en_core_web_sm-2</span><span class="selector-class">.3</span><span class="selector-class">.0</span></span><br><span class="line">    __<span class="selector-tag">init__</span><span class="selector-class">.py</span></span><br><span class="line">    <span class="selector-tag">meta</span><span class="selector-class">.json</span></span><br></pre></td></tr></table></figure><p>将上述文件放入</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\A</span>naconda3<span class="symbol">\L</span>ib<span class="symbol">\s</span>ite-packages<span class="symbol">\e</span>n_core_web_sm</span><br></pre></td></tr></table></figure><p>替换原本文件，然后即可正常使用。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用数据结构</title>
      <link href="/2020/07/08/tech/Python/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/08/tech/Python/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了准备清华的机考，花了大概半个小时整理了一下 Python 常用的数据结构的技巧（虽然可能存在其他直接的方法……）</p><a id="more"></a>  <h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2><p><strong>栈和队列的实现。</strong></p><p>统一使用 append 压入数字。对于 pop：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a.pop(<span class="number">0</span>)) <span class="comment">#删除第一个元素并返回，用来形成队列</span></span><br><span class="line">print(a.pop()) <span class="comment">#删除最后一个元素并返回，用来形成栈</span></span><br></pre></td></tr></table></figure><p><strong>排序</strong></p><ul><li>普通排序</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = sorted(a, reverse = <span class="literal">True</span>) <span class="comment"># 排序</span></span><br></pre></td></tr></table></figure><ul><li>多个数字排序</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">data = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line">data = sorted(data, key=operator.itemgetter(<span class="number">1</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>其中 operator.itemgetter 可以申明多个数字，是优先级的定义。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><strong>快速创建字典</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = set(range(<span class="number">14</span>))</span><br><span class="line">b = set(range(<span class="number">1</span>, <span class="number">15</span>))</span><br><span class="line">res =  dict(zip(a, b))</span><br></pre></td></tr></table></figure><p>这个方法可以快速组件字典。</p><p><strong>字典的操作</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">res.pop(<span class="number">1</span>, <span class="number">0</span>) <span class="comment"># 右为default值，若没有则返回该值</span></span><br><span class="line">adict = &#123;<span class="string">'a'</span>: <span class="number">12</span>&#125;</span><br><span class="line">res.update(adict)</span><br></pre></td></tr></table></figure><ul><li><code>pop</code>用来删除键，如果要删除的键不存在，则返回申明的第二个参数（这里是 0）。</li><li><code>update</code>用来更新字典，参数是另一个字典。速度比直接创建新字典快不少。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>我发现我几乎没用过 set，可能作为集合每个元素只能出现一次的性质我没太需要用到。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = set(<span class="string">'spam'</span>)</span><br><span class="line">y = set([<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'b'</span>])</span><br><span class="line"></span><br><span class="line">print(x &amp; y)</span><br><span class="line">print(x | y)</span><br><span class="line">print(x - y)</span><br><span class="line"></span><br><span class="line">y.add(<span class="string">'x'</span>)            </span><br><span class="line">y.update([<span class="number">10</span>,<span class="number">37</span>,<span class="number">42</span>])  </span><br><span class="line">y.remove(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><p>上述的功能都很直接，故不赘述。特殊的，如果往 set 里面增加重复的元素，则没有任何事事情会发生，所以可以用来快速移除重复元素；但 set 不会维护输入的顺序，所以不建议在使用 set 的情况下做与遍历顺序相关的操作。一般来说，使用<code>if a in B</code>的操作，set 会比 list 更快。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode连接Python调试</title>
      <link href="/2020/07/04/tech/VSC/vscode%E8%BF%9E%E6%8E%A5python/"/>
      <url>/2020/07/04/tech/VSC/vscode%E8%BF%9E%E6%8E%A5python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>虽然一直用的是 VSC 和 Python 的组合，但是之前都是硬核 print 调试，并且需要从 Anaconda prompt 进入文件夹操作。确实觉得这个方法很难受，于是开始调整 VSC 连接 Python。中途遇到了不少的坑，这里对其进行一个整理。</p><a id="more"></a>  <h2 id="Anaconda环境"><a href="#Anaconda环境" class="headerlink" title="Anaconda环境"></a>Anaconda环境</h2><p>首先需要安装 Anaconda，Anaconda 会默认安装一个带有 conda 命令的 shell，但是在普通的 cmd 和 powershell 里都不能用这个东西。需要在环境变量中添加下述：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\A</span>naconda3</span><br><span class="line"><span class="symbol">\A</span>naconda3<span class="symbol">\S</span>cripts</span><br><span class="line"><span class="symbol">\A</span>naconda3<span class="symbol">\L</span>ibrary<span class="symbol">\b</span>in</span><br></pre></td></tr></table></figure><p>然后重启，这样可以在 cmd 里使用 Ananconda，例如 conda activate base 等命令。然而在 Powershell 里不知为何不能使用。使用<code>conda init</code>方法宣告无效。</p><h2 id="VSC和Python"><a href="#VSC和Python" class="headerlink" title="VSC和Python"></a>VSC和Python</h2><p>VSC 默认的 Terminal 是 Powershell，所以不能正常使用<code>conda</code>命令，所以需要添加 cmd。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"<span class="selector-tag">terminal</span><span class="selector-class">.integrated</span><span class="selector-class">.shell</span><span class="selector-class">.windows</span>": "<span class="selector-tag">C</span>:\\<span class="selector-tag">Windows</span>\\<span class="selector-tag">System32</span>\\<span class="selector-tag">cmd</span><span class="selector-class">.exe</span>",</span><br></pre></td></tr></table></figure><p>这个时候会报找不到 package 的错误，需要在 VSC 中添加 conda 的地址。在 VSC 设置中搜索<code>conda</code>并输入：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\A</span>naconda3<span class="symbol">\S</span>cripts<span class="symbol">\c</span>onda.exe</span><br></pre></td></tr></table></figure><p>同时在设置中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"code-runner.executorMap"</span>: &#123;</span><br><span class="line">  <span class="string">"python"</span>:<span class="string">"<span class="variable">$pythonPath</span> <span class="variable">$fullFileName</span>"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>根据上述的设置，将 Terminal 变为 cmd，然后即可正常 debug。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformers使用</title>
      <link href="/2020/07/04/tech/Huggingface/"/>
      <url>/2020/07/04/tech/Huggingface/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本地使用 Huggingface 的 transformer 挺麻烦的，可能之后还会碰到。这里做一个记录。</p><a id="more"></a>  <h2 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h2><p>模型如果标注了<code>from_pretrain(&#39;&#39;)</code>之类的，则需要加载模型。而不幸的是，官方下载模型的渠道很慢，需要使用离线下载方法。下述以 BERT 作为例子，下载步骤如下：</p><ol><li>进入链接，找到<a href="https://huggingface.co/models" target="_blank" rel="noopener">模型</a>的位置。</li><li>找到特殊的模型，进入<a href="https://huggingface.co/bert-base-uncased" target="_blank" rel="noopener">界面</a>。</li><li>在模型下方找到<a href="https://huggingface.co/bert-base-uncased#list-files" target="_blank" rel="noopener">List all files in model</a>。</li><li>选择其中的’config.json; pytorch_model.bin; vocab.txt’下载到同一个文件夹。</li></ol><h2 id="模型载入"><a href="#模型载入" class="headerlink" title="模型载入"></a>模型载入</h2><p>在开始载入以前，需要将上述下载文件放置到一个文件夹下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\<span class="selector-tag">-</span> <span class="selector-tag">bert-uncased</span></span><br><span class="line">    <span class="selector-tag">config</span><span class="selector-class">.json</span></span><br><span class="line">    <span class="selector-tag">pytorch_model</span><span class="selector-class">.bin</span></span><br><span class="line">    <span class="selector-tag">vocab</span><span class="selector-class">.txt</span></span><br><span class="line"><span class="selector-tag">train</span><span class="selector-class">.py</span></span><br></pre></td></tr></table></figure><p>在 <code>train.py</code> 中的代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertTokenizer, BertModel</span><br><span class="line"></span><br><span class="line">path = <span class="string">'D:/LAB/LAB-last/lex-dis/cont-cont/bert-uncased'</span></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(path)</span><br><span class="line">model = BertModel.from_pretrained(path)</span><br></pre></td></tr></table></figure><p>这里模型载入即结束。使用相对路径不知为何不能成功，需要使用全地址。</p><h2 id="模型使用"><a href="#模型使用" class="headerlink" title="模型使用"></a>模型使用</h2><p>tokenizers 和 model 的使用这里暂时搁置。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文件管理及自动更新</title>
      <link href="/2020/07/04/tech/Hexo/Hexo%E6%96%87%E4%BB%B6%E5%A4%B9%E7%AE%A1%E7%90%86/"/>
      <url>/2020/07/04/tech/Hexo/Hexo%E6%96%87%E4%BB%B6%E5%A4%B9%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于：</p><ul><li><del>Hexo 文件夹系统（已失效）</del></li><li>Blog 在 Gitee 上自动更新</li></ul><a id="more"></a>  <h2 id="Hexo文件夹系统"><a href="#Hexo文件夹系统" class="headerlink" title="Hexo文件夹系统"></a>Hexo文件夹系统</h2><p><strong>注意，该POST已过时</strong></p><p>在某一个Hexo的版本更新时，其原生地支持了子文件夹的读取，所以本节所表述的方法已不在有必要。</p><p><del>因为最近累积的笔记越来越多了，而 Hexo 原生似乎不支持文件夹操作，故决定建立文件夹系统。它的思路很简单，就是在一个别处的文件夹下完成笔记的记录，在需要更新的时候，使用脚本递归地搜索这些文件夹，将所有的 md 文件全部收集到对应的<code>_posts</code>文件夹下。具体脚本如下：</del></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">ori_path = <span class="string">'../files'</span></span><br><span class="line">dst_path = <span class="string">'../source/_posts/'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file</span><span class="params">(path, name, cat)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">        cat_c = cat.copy()</span><br><span class="line">        cat_c.append(name)</span><br><span class="line">        files = os.listdir(path)</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            get_file(path  + <span class="string">'/'</span> + file, file, cat_c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.md'</span> <span class="keyword">in</span> name:</span><br><span class="line">            route = <span class="string">'-'</span>.join(cat[<span class="number">1</span>:])</span><br><span class="line">            shutil.copyfile(path, dst_path + route + <span class="string">"-"</span> + name)</span><br><span class="line"></span><br><span class="line">get_file(ori_path, <span class="string">''</span>, [])</span><br><span class="line">print(<span class="string">'Done!'</span>)</span><br></pre></td></tr></table></figure><h2 id="自动更新Gitee"><a href="#自动更新Gitee" class="headerlink" title="自动更新Gitee"></a>自动更新Gitee</h2><p>由于 Gitee 每一次更新 Blog 后需要访问 Gitee 手动完成 deploy。这个过程是在令人不爽。所以添加一个脚本用来自动完成这一步。具体依赖 selenium。</p><h3 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h3><p>进入谷歌商店，进入拓展商店下载 selenium。录制结束后导出为 py 文件。注意在这个过程中，需要将部分路径改为<code>xpath</code>。此外可能有 xpath 不能生效的情况，此时需要在该语句前添加 flush()。最后，由于 deploy 需要一些时间，所以需要使用 time 函数手动停止一些时间以完成 deploy。代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBlog</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup_method</span><span class="params">(self)</span>:</span></span><br><span class="line">    options = webdriver.ChromeOptions()</span><br><span class="line">    self.driver = webdriver.Chrome()</span><br><span class="line">    self.vars = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teardown_method</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.driver.quit()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wait_for_window</span><span class="params">(self, timeout = <span class="number">2</span>)</span>:</span></span><br><span class="line">    time.sleep(round(timeout / <span class="number">1000</span>))</span><br><span class="line">    wh_now = self.driver.window_handles</span><br><span class="line">    wh_then = self.vars[<span class="string">"window_handles"</span>]</span><br><span class="line">    <span class="keyword">if</span> len(wh_now) &gt; len(wh_then):</span><br><span class="line">      <span class="keyword">return</span> set(wh_now).difference(set(wh_then)).pop()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_blog</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.driver.get(<span class="string">"https://gitee.com/yoursite/pages"</span>)</span><br><span class="line">    self.driver.set_window_size(<span class="number">1514</span>, <span class="number">984</span>)</span><br><span class="line">    self.driver.find_element(By.LINK_TEXT, <span class="string">"Sign in"</span>).click()</span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">"user_login"</span>).click()</span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">"user_login"</span>).send_keys(<span class="string">"email@foobar.com"</span>)</span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">"user_password"</span>).send_keys(<span class="string">"password"</span>)</span><br><span class="line">    self.driver.find_element(By.CSS_SELECTOR, <span class="string">".two:nth-child(3) label"</span>).click()</span><br><span class="line">    self.driver.find_element(By.NAME, <span class="string">"commit"</span>).click()</span><br><span class="line">    self.driver.refresh()</span><br><span class="line">    self.driver.find_element(By.CSS_SELECTOR, <span class="string">".redeploy-button"</span>).click()</span><br><span class="line">    <span class="keyword">assert</span> self.driver.switch_to.alert.text == <span class="string">"Are you sure to redeploy Gitee Pages?"</span></span><br><span class="line">    self.driver.switch_to.alert.accept()</span><br><span class="line">    time.sleep(<span class="number">60</span>)</span><br><span class="line">  </span><br><span class="line">test = TestBlog()</span><br><span class="line">test.setup_method()</span><br><span class="line">test.test_blog()</span><br><span class="line">test.teardown_method()</span><br></pre></td></tr></table></figure><p>完成上述步骤后，结合之前的自动添加空格以及基本的 hexo 操作，我们就可以全自动地完成文件夹整理及 deploy 操作了。如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">C:</span><br><span class="line">cd C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\D</span>ocuments<span class="symbol">\J</span>oseph<span class="symbol">\B</span>log<span class="symbol">\u</span>pdate</span><br><span class="line">python update_file.py</span><br><span class="line">cd C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\D</span>ocuments<span class="symbol">\J</span>oseph<span class="symbol">\B</span>log</span><br><span class="line">textlint --fix source/_posts/*.md &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; cd C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\D</span>ocuments<span class="symbol">\J</span>oseph<span class="symbol">\B</span>log<span class="symbol">\u</span>pdate &amp;&amp; python gitee.py</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 英文文本成分分析</title>
      <link href="/2020/07/03/tech/Python/%E8%8B%B1%E6%96%87%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
      <url>/2020/07/03/tech/Python/%E8%8B%B1%E6%96%87%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了确定句子中从句的位置并将其剥离出来，需要找到一个成分分析的 parser，本文是对使用这个 parser 的一个具体的说明。使用的工具来自 ACL 2018：<a href="https://github.com/nikitakit/self-attentive-parser" target="_blank" rel="noopener">Constituency Parsing with a Self-Attentive Encoder</a>。</p><a id="more"></a>  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这个工具可以和 SpaCy 及 NLTK 一同使用。但是在尝试工程中发现和 SpaCy 的联动除了一些问题，会返回不知道如何解决的错误，但是 NLTK 则运行正常。这里记录 NLTK 版本的安装和使用方法。</p><p>首先，这个模型的运行需要先行下载：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line">nltk.download(<span class="string">'punkt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> benepar</span><br><span class="line">benepar.download(<span class="string">'benepar_en'</span>)</span><br></pre></td></tr></table></figure><p>但是这个下载速度非常地慢。希望离线下载需要访问上述 GitHub 链接，找到对应的<code>benepar_en2.zip</code>包下载。（不知道为何，找不到 benepar_en 包）。将这个压缩包放置在<code>C:/Users/.../AppData/Roaming/nltk_data/models/</code>下。punkt 包也能通过访问 nltk_data 找到对应的压缩包，不过这个包需要放置在上面文件夹旁的<code>tokenizers</code>文件夹下并解压。</p><p>这样就完成了这个模型的安装。如果不存在<code>benepar</code>则可以先 install 一次。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> benepar</span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line">parser = benepar.Parser(<span class="string">"benepar_en"</span>)</span><br></pre></td></tr></table></figure><p>由于我们使用了 nltk 的方法，所以不需要引入 SpaCy 的文件。上面的代码可以获得一个 parser，这个 parser 可以用来完成成分分析。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree = parser.parse(context)</span><br></pre></td></tr></table></figure><p>上述获得的 tree 打印出来效果如下：</p><blockquote><p>Added another executive at a big bank: “We were all a little goosey over the weekend trying to forecast what would happen Monday, but it’s been very quiet.”</p></blockquote><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">SINV</span></span><br><span class="line">  (<span class="name">VP</span> (<span class="name">VBN</span> Added))</span><br><span class="line">  (<span class="name">NP</span></span><br><span class="line">    (<span class="name">NP</span> (<span class="name">DT</span> another) (<span class="name">NN</span> executive))</span><br><span class="line">    (<span class="name">PP</span> (<span class="name">IN</span> at) (<span class="name">NP</span> (<span class="name">DT</span> a) (<span class="name">JJ</span> big) (<span class="name">NN</span> bank))))</span><br><span class="line">  (<span class="name">:</span> :)</span><br><span class="line">  (`` ``)</span><br><span class="line">  (<span class="name">S</span></span><br><span class="line">    (<span class="name">S</span></span><br><span class="line">      (<span class="name">NP</span> (<span class="name">PRP</span> We))</span><br><span class="line">      (<span class="name">VP</span></span><br><span class="line">        (<span class="name">VBD</span> were)</span><br><span class="line">        (<span class="name">DT</span> all)</span><br><span class="line">        (<span class="name">ADJP</span> (<span class="name">DT</span> a) (<span class="name">RB</span> little) (<span class="name">JJ</span> goosey))</span><br><span class="line">        (<span class="name">PP</span> (<span class="name">IN</span> over) (<span class="name">NP</span> (<span class="name">DT</span> the) (<span class="name">NN</span> weekend)))</span><br><span class="line">        (<span class="name">S</span></span><br><span class="line">          (<span class="name">VP</span></span><br><span class="line">            (<span class="name">VBG</span> trying)</span><br><span class="line">            (<span class="name">S</span></span><br><span class="line">              (<span class="name">VP</span></span><br><span class="line">                (<span class="name">TO</span> to)</span><br><span class="line">                (<span class="name">VP</span></span><br><span class="line">                  (<span class="name">VB</span> forecast)</span><br><span class="line">                  (<span class="name">SBAR</span></span><br><span class="line">                    (<span class="name">WHNP</span> (<span class="name">WP</span> what))</span><br><span class="line">                    (<span class="name">S</span></span><br><span class="line">                      (<span class="name">VP</span></span><br><span class="line">                        (<span class="name">MD</span> would)</span><br><span class="line">                        (<span class="name">VP</span></span><br><span class="line">                          (<span class="name">VB</span> happen)</span><br><span class="line">                          (<span class="name">PRN</span></span><br><span class="line">                            (<span class="name">-LRB-</span> -LCB-)</span><br><span class="line">                            (<span class="name">NP</span> (<span class="name">NNP</span> Monday))</span><br><span class="line">                            (<span class="name">-RRB-</span> -RCB-)))))))))))))</span><br><span class="line">    (, ,)</span><br><span class="line">    (<span class="name">CC</span> but)</span><br><span class="line">    (<span class="name">S</span></span><br><span class="line">      (<span class="name">NP</span> (<span class="name">PRP</span> it))</span><br><span class="line">      (<span class="name">VP</span> (<span class="name">VBZ</span> <span class="symbol">'s</span>) (<span class="name">VP</span> (<span class="name">VBN</span> been) (<span class="name">ADJP</span> (<span class="name">RB</span> very) (<span class="name">JJ</span> quiet))))))</span><br><span class="line">  (<span class="name">.</span> .))</span><br></pre></td></tr></table></figure><p>返回的 tree 是<code>nltk.tree</code>的结构，对于每一个 node，其子树或为另一个 node，或者为一个 leaf，一个 leaf 就是一个字符串。可以使用：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> type(node) == str:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>判断对象是一个 node 还是一个 leaf，如果是一个 node，则可以仿照 list 的方式对其进行遍历。此外 tree 结构的每一个 node，对应一个 label，调用的方式为：<code>node.label()</code>，可以获得这个节点的标签，在上面的实例中，”S”就是一个标签，标志着其句子成分。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows上安装LaTeX</title>
      <link href="/2020/07/03/tech/LaTeX/windows%E4%B8%8A%E5%AE%89%E8%A3%85/"/>
      <url>/2020/07/03/tech/LaTeX/windows%E4%B8%8A%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-dEGuJgpd" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1455701955" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>这不是第一次安装 latex 了，但每次安装都会遇到一些问题，消耗搜索的时间，这次对其作一个整理。</p><a id="more"></a>  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先是从 tex live 的官网上下载到最新版的 texlive 并安装。基本上，官网上下到的是一个叫做<code>install-tl-windows.exe</code>的可执行文件。这个文件点开后即可开始下载。下载的时间很长，预计从早上开始下载需要在傍晚才能下载结束。</p><p>不出意外安装结束之后，windows 的“开始”会出现 TexWorks Editor 等等工具。以及 Tex 的路径可以自动加载到系统环境变量中，重启之后即可生效。</p><h2 id="VSCODE"><a href="#VSCODE" class="headerlink" title="VSCODE"></a>VSCODE</h2><p>使用 VSC 可能会比较舒服，但是总有一些小问题。为了在 VSC 中预览 LaTeX，需要下载拓展：LaTeX Workshop。下载结束后 VSC 可以获得高亮 Tex 代码的能力。</p><p>在左侧的工具栏会在选中 Tex 文件时获得新的 LaTeX 标志，其中可以选择编译文件或者在 VSC Tab 中预览文件。</p><p>为了和 VSC 链接，需要打开 VSC 的设置代码，添加下述代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.recipes": [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">    <span class="attr">"tools"</span>: [</span><br><span class="line">      <span class="string">"xelatex"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"xelatex -&gt; bibtex -&gt; xelatex*2"</span>,</span><br><span class="line">    <span class="attr">"tools"</span>: [</span><br><span class="line">      <span class="string">"xelatex"</span>,</span><br><span class="line">      <span class="string">"bibtex"</span>,</span><br><span class="line">      <span class="string">"xelatex"</span>,</span><br><span class="line">      <span class="string">"xelatex"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line">"latex-workshop.latex.tools": [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">      <span class="string">"-synctex=1"</span>,</span><br><span class="line">      <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">      <span class="string">"-file-line-error"</span>,</span><br><span class="line">      <span class="string">"-pdf"</span>,</span><br><span class="line">      <span class="string">"%DOC%"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">      <span class="string">"-synctex=1"</span>,</span><br><span class="line">      <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">      <span class="string">"-file-line-error"</span>,</span><br><span class="line">      <span class="string">"%DOC%"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">      <span class="string">"%DOCFILE%"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line">"latex-preview.command": "xelatex",</span><br><span class="line">"latex-workshop.latex.autoBuild.run": "never"</span><br></pre></td></tr></table></figure><p>上述的代码会将 recipe 加入 build 选项，通过点击编译文件。但在这个设置中，如果文件出现 error，VSC 将会选择终止执行，在终止执行的情况下，虽然可以获得一个 pdf 文件，但是这份文件的一部分内容是有误的，例如 Content 的添加等等，所以这个版本在写作中途可以用来作为参照但并不适合作为最后微调的方法。</p><p>在这个情况下，可以使用 overleaf 或者在文件所在的文件夹下唤起 cmd，使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">xelatex</span> <span class="selector-tag">main</span><span class="selector-class">.tex</span></span><br></pre></td></tr></table></figure><p>忽视中间的错误可以获得生成的文件，在这个文件中 Content 等信息是正常的。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python英文分句</title>
      <link href="/2020/06/30/tech/Python/%E8%8B%B1%E6%96%87%E5%88%86%E5%8F%A5/"/>
      <url>/2020/06/30/tech/Python/%E8%8B%B1%E6%96%87%E5%88%86%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简记 NLTK 对英文文本进行分句的方法。</p><a id="more"></a>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.tokenize <span class="keyword">import</span> sent_tokenize</span><br><span class="line"></span><br><span class="line">sent_tokenize(<span class="string">'this is an example. simply an example.'</span>)</span><br></pre></td></tr></table></figure><p>上述代码返回的结果是包含了两个分句的 list。结束。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSV读写</title>
      <link href="/2020/06/30/tech/Python/CSV%E8%AF%BB%E5%8F%96/"/>
      <url>/2020/06/30/tech/Python/CSV%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>每一次碰到 CSV 都需要单独搜一次做法，还经常出一些小 bug。这里对最简单的 CSV 读写做一个整理。</p><a id="more"></a> <p>csv 存储的内容如：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'data'</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">'index'</span>: <span class="number">0</span></span><br><span class="line">    &#125;, ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="读CSV"><a href="#读CSV" class="headerlink" title="读CSV"></a>读CSV</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.csv'</span>, <span class="string">'r'</span>, encoding=<span class="string">'unicode_escape'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    reader = csv.DictReader(csvfile)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        print(row[<span class="string">'data'</span>], row[<span class="string">'index'</span>])</span><br></pre></td></tr></table></figure><p>注意 <code>unicode_esxape</code> 是对文件中出现了奇怪字符使用的。如果使用 <code>utf-8</code> 仍不能正常解码的时候可以使用。</p><h2 id="写CSV"><a href="#写CSV" class="headerlink" title="写CSV"></a>写CSV</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">fieldnames = [<span class="string">'data'</span>, <span class="string">'index'</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.csv'</span>, <span class="string">'w'</span>, encoding = <span class="string">'utf-8'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    writer.writerow(fieldnames)</span><br><span class="line">    writer.writerow([<span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames)</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;<span class="string">'data'</span>: <span class="number">2</span>, <span class="string">'index'</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>即第一次使用<code>writerow</code>时，需要先写入第一排域名，然后后面每一排则是根据域名排序的 list。</li><li>使用字典和 list 是等价的，哪个方便用哪个。</li><li>写入的时候一定不能标记为<code>unicode_escape</code>，否则会乱码。使用<code>utf-8</code>就 ok。</li><li>需要加上<code>newline = &#39;&#39;</code>，否则每一行后面会接一行空行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch常用训练框架</title>
      <link href="/2020/06/27/tech/PyTorch_%E5%B8%B8%E7%94%A8%E8%AE%AD%E7%BB%83%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/06/27/tech/PyTorch_%E5%B8%B8%E7%94%A8%E8%AE%AD%E7%BB%83%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>现在模型建的比较多了，因此也形成了一套成熟的流程，这里简单的记述一下常用的模型构建的方法，为了后续改进。</p><a id="more"></a>  <h2 id="文件夹架构"><a href="#文件夹架构" class="headerlink" title="文件夹架构"></a>文件夹架构</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\-</span> model</span><br><span class="line">    dataset.py</span><br><span class="line"><span class="string">\-</span> data</span><br><span class="line">    <span class="string">\-</span> images</span><br><span class="line">    <span class="string">\-</span> ori_data</span><br><span class="line"><span class="string">\-</span> preprocess</span><br><span class="line"><span class="string">\-</span> utils</span><br><span class="line">train.py</span><br><span class="line">config.py</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p><code>config.py</code> 保存 train 以及预处理中的超参，但是不建议使用该文件保存模型的超参（除非整个调整结束）。  <code>utils.py</code> 保留操作函数，用来辅助预处理以及数据分析等等功能。<code>data</code>中存储原始数据以及处理后的数据，部分时候有中间生成数据。<code>images</code>保存为了报告生成的图片。</p><p>生成上述结构代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(paths)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">    folder = os.path.exists(path) </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> folder:</span><br><span class="line">    os.makedirs(path)   </span><br><span class="line"></span><br><span class="line">mkdir([<span class="string">'model'</span>, <span class="string">'data'</span>, <span class="string">'preprocess'</span>, <span class="string">'utils'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'train.py'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'config.py'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'README.md'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h2><p>常用的 import 库文件。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> pk</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h3 id="自己的模型"><a href="#自己的模型" class="headerlink" title="自己的模型"></a>自己的模型</h3><p>常用的 Model 架构：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaiveModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(NaiveModel, self).__init__()</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="预训的模型"><a href="#预训的模型" class="headerlink" title="预训的模型"></a>预训的模型</h3><p>使用一些预训的模型使用。有两种魔改方法，其一是替代原模型中的部分层，另一部分是取出模型的某些部分和自己的其他网络组合。</p><p><strong>替换层方法</strong></p><p>以 vgg16 的替换方法为例。其中可以通过<code>model.features._modules[]</code>拿到对应的层，其中输入为 <code>print(model)</code>产生的输出。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VGG</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(VGGTorch, self).__init__()</span><br><span class="line">        model = torchvision.models.vgg16(pretrained = <span class="literal">False</span>)</span><br><span class="line">        init = torch.load(<span class="string">'data/vgg16-397923af.pth'</span>)</span><br><span class="line">        model.load_state_dict(init)</span><br><span class="line">        conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">5</span>, stride=(<span class="number">2</span>, <span class="number">2</span>), padding=(<span class="number">3</span>, <span class="number">3</span>), bias=<span class="literal">False</span>)</span><br><span class="line">        model.features._modules[<span class="string">'0'</span>] = conv2d</span><br><span class="line">        model.classifier = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">25088</span>, <span class="number">20</span>),</span><br><span class="line">            nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        self.model = model </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = x.reshape(x.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>).float()</span><br><span class="line">        x = self.model(x)</span><br><span class="line">        <span class="keyword">return</span> x, x</span><br></pre></td></tr></table></figure><p>上面可以通过<code>pretrain = True</code>拿到预训参数，但是下载很慢，可以复制链接自行离线下载然后通过上述方法导入。</p><p><strong>重新组合方法</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面是使用resnet18作为下采样层的UNet模型，通过将ResNet的层取出获得最终模型。其中还使用了预训参数。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_class)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.base_model = torchvision.models.resnet18(pretrained = <span class="literal">True</span>)</span><br><span class="line">        self.base_layers = list(self.base_model.children())</span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=(<span class="number">7</span>, <span class="number">7</span>), stride=(<span class="number">2</span>, <span class="number">2</span>), padding=(<span class="number">3</span>, <span class="number">3</span>), bias=<span class="literal">False</span>),</span><br><span class="line">            self.base_layers[<span class="number">1</span>],</span><br><span class="line">            self.base_layers[<span class="number">2</span>])</span><br><span class="line">        self.layer2 = nn.Sequential(*self.base_layers[<span class="number">3</span>:<span class="number">5</span>])</span><br><span class="line">        self.layer3 = self.base_layers[<span class="number">5</span>]</span><br><span class="line">        self.layer4 = self.base_layers[<span class="number">6</span>]</span><br><span class="line">        self.layer5 = self.base_layers[<span class="number">7</span>]</span><br><span class="line">        self.decode4 = Decoder(<span class="number">512</span>, <span class="number">256</span>+<span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">        self.decode3 = Decoder(<span class="number">256</span>, <span class="number">256</span>+<span class="number">128</span>, <span class="number">256</span>)</span><br><span class="line">        self.decode2 = Decoder(<span class="number">256</span>, <span class="number">128</span>+<span class="number">64</span>, <span class="number">128</span>)</span><br><span class="line">        self.decode1 = Decoder(<span class="number">128</span>, <span class="number">64</span>+<span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">        self.decode0 = nn.Sequential(</span><br><span class="line">            nn.Upsample(scale_factor=<span class="number">2</span>, mode=<span class="string">'bilinear'</span>, align_corners=<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">32</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">            )</span><br><span class="line">        self.conv_last = nn.Conv2d(<span class="number">64</span>, n_class, <span class="number">1</span>)</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(n_class * <span class="number">224</span> * <span class="number">224</span>, <span class="number">1024</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dropout(<span class="number">0.4</span>),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">2</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="Train"><a href="#Train" class="headerlink" title="Train"></a>Train</h2><p>下面是简化的框架。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> pk</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> model.dataset <span class="keyword">import</span> DataSet</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> model.naive_model <span class="keyword">import</span> NaiveModel</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(args)</span>:</span></span><br><span class="line">    cuda = torch.cuda.is_available()</span><br><span class="line">    <span class="keyword">if</span> cuda:</span><br><span class="line">        print(<span class="string">"CUDA is prepared"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dataset</span></span><br><span class="line">    trainset = DataSet(<span class="string">'train'</span>, transform_train, normal_path)</span><br><span class="line">    validset = DataSet(<span class="string">'valid'</span>, transform_valid, normal_path)</span><br><span class="line">    trainloader = data.DataLoader(trainset, batch_size = batch_sz, shuffle = <span class="literal">True</span>)</span><br><span class="line">    validloader = data.DataLoader(validset, batch_size = batch_sz, shuffle = <span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># model</span></span><br><span class="line">    model = NaiveModel(batch_sz, <span class="number">224</span>)</span><br><span class="line">    <span class="keyword">if</span> cuda:</span><br><span class="line">        model = model.cuda()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># lossfunc and optim</span></span><br><span class="line">    lossfun = nn.CrossEntropyLoss()</span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters())</span><br><span class="line">    </span><br><span class="line">    accs = []</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        <span class="comment"># valid</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            preds, labels = [], []</span><br><span class="line">            <span class="keyword">for</span> idx, samples <span class="keyword">in</span> enumerate(validloader):</span><br><span class="line">                img, label = samples[<span class="string">'img'</span>], samples[<span class="string">'label'</span>]        </span><br><span class="line">                <span class="keyword">if</span> cuda:</span><br><span class="line">                    img = img.cuda()</span><br><span class="line">                pred = model.eval(img, labels)</span><br><span class="line">                preds.append(pred)</span><br><span class="line">                labels.append(label)</span><br><span class="line">            torch.save(model.state_dict(), model_path)</span><br><span class="line">            labels = np.concatenate(labels, axis = <span class="number">0</span>).astype(int)</span><br><span class="line">            preds = np.concatenate(preds, axis = <span class="number">0</span>)</span><br><span class="line">            report = classification_report(labels, preds)</span><br><span class="line">            print(report)</span><br><span class="line">            acc = precision_score(labels, preds, average = <span class="string">'micro'</span>)</span><br><span class="line">            print(<span class="string">"Precision: &#123;&#125;"</span>.format(acc))</span><br><span class="line">            accs.append(acc)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># train</span></span><br><span class="line">        <span class="keyword">for</span> idx, samples <span class="keyword">in</span> enumerate(trainloader):</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            imgs, labels = samples[<span class="string">'img'</span>], samples[<span class="string">'label'</span>]</span><br><span class="line">            <span class="keyword">if</span> cuda:</span><br><span class="line">                labels = labels.cuda()</span><br><span class="line">                imgs = imgs.cuda()</span><br><span class="line">            </span><br><span class="line">            pred = model(imgs)</span><br><span class="line">            loss = lossfun(pred, labels.long())</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            print(<span class="string">'loss: &#123;&#125;'</span>.format(loss), end = <span class="string">'\r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'--pretrain'</span>, type=str, default=<span class="string">'yes'</span>,</span><br><span class="line">                        help=<span class="string">'if pre-train'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--finetune'</span>, type=str, default=<span class="string">'yes'</span>,</span><br><span class="line">                        help=<span class="string">'if finetune'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    train(args)</span><br></pre></td></tr></table></figure><h2 id="模型保存及预加载"><a href="#模型保存及预加载" class="headerlink" title="模型保存及预加载"></a>模型保存及预加载</h2><p><strong>保存</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">torch.save(<span class="keyword">model</span>.state_dict(), PATH)</span><br><span class="line"> </span><br><span class="line"># example</span><br><span class="line">torch.save(<span class="keyword">model</span>.state_dict(),<span class="string">'model.pth'</span>)</span><br></pre></td></tr></table></figure><p><strong>加载</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model.load<span class="constructor">_state_dict(<span class="params">torch</span>.<span class="params">load</span>(PATH)</span>)</span><br><span class="line"></span><br><span class="line"># example</span><br><span class="line">model.load<span class="constructor">_state_dict(<span class="params">torch</span>.<span class="params">load</span>('<span class="params">model</span>.<span class="params">pth</span>')</span>)</span><br></pre></td></tr></table></figure><p>这样就是整个模型的最基础框架搭建。但事实上一个任务真正困难的是在数据预处理策略和最后的调参上，这些就放在别的地方补充了吧。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> PyTorch </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>觀佛記</title>
      <link href="/2020/06/27/essay/tour/%E5%B3%A8%E7%9C%89%E8%A1%8C/"/>
      <url>/2020/06/27/essay/tour/%E5%B3%A8%E7%9C%89%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-CXMtJqFd" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="17685905" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>雖說已經過了快兩個月了，還是想記下那個不那麼特殊的旅途.2020 年勞動節的峨眉山之行。雖說確實沒有太多值得大書特書的細節，但就算當作流水賬一樣地記下來也是不錯的。</p><a id="more"></a>  <p>事實上這個旅程是我從哈爾濱回來以後就一直在考慮的，然而最終因爲疫情的原因沒能在春節附近付諸實踐，實在可惜。然情況總是紛繁複雜，居然到了五一節，我們這些學生還是滯留在自己的窩裡面沒有返校。五一節的幾日長假不得不使人再次萌生了造訪峨眉的想法，於是簡單組織一通後和幾個高中同學一同出發了。</p><p>一早起來，大概九點到了峨眉山腳。當時正逢疫情還在尾聲的時候，每一個關卡都要檢查健康碼之類的東西。不過沒有造成太大的阻礙，我們進山了。在山門口買了個舒適的竹杖。（這確實是救命的東西，不是打猴子，而是作爲另一條腿。）一路上人不算太多，環境也很清幽。走走停停就能看見小亭子之類的東西。風景很難說是絕美，不過與城市的氛圍自然還是迥異。最開始沿着山谷走，能一直看見下面流淌的透明小溪。這種景色總給我一種我曾經來過的感覺，可能是這樣的風景實在是太多了吧。</p><p>一路上碰到一個山大王搶恰巧同行的一個小團隊成員的小挎包。還戀戀不捨地跟了很久，但什麼都沒有搶到。大概是在仙峯寺附近，我的腿開始出現抽筋的症狀，本來是一隻腿，後來不幸另一條腿也開始抽筋。大概像是一條很粗的蟲子在筋肉里穿梭的感覺。雖然感覺到疼但還是得往上走吧，一日登上峨眉算不上那麼容易的事情。中間反覆了幾次，但通過休息和壓腿算是穩定了下來。</p><p>然後仙峯寺之後是令人崩潰的上上下下。每一次站在一個山頭，就看見另一個山頭的小黑頂廟子，意識到那是下一個目的地的同時，得知需要先下山然後再爬到那裡，是真的想罵上幾句髒話，仿佛獲得了前功盡棄的挫敗感。這一路上的風景也相當的一般，沒有想象中的那種壯美，也沒有山大王之流的助興。</p><p>到九嶺岡的時候，整個隊伍已經相當疲憊了。具體什麼時候到那裡的我已經記不確切了，但那個時候着實是懷着是否能在天黑前登上雷洞坪的擔憂。後面我奇蹟般地感覺自己的小腿抽筋消歇了，在鑽天坡一路向上中居然越戰越勇。大家根據情況不同，整個隊伍也逐漸拉長。當時我在第二位，前面和後面的同學都不在了。我看見了洗象池的屋頂的時候，看見了一個寬闊的平台，旁邊的圍欄上立着兩隻互相搔毛的猴子。然後我看見了洗象池幾個字和後面的一列陡峭的階梯。我的兩腿突然傳來一陣劇痛，然後我就地跪了下去。據後面同學說，是聽見了我的慘叫聲。不過總之來到了一個新的節點。</p><p>後面的閻王坡實在震撼人心，長度和陡度都遠超前面的鑽天坡。不久後就走進了夜路，看見道路兩旁藏青色的影子往前進。當到了賓館吃上晚飯的時候已經是 10 點了。那個時候也沒什麼胃口，手機沒電了，可能只是想坐一坐了吧。</p><p>中間的小賣部密集且良心。冰粉實在是天賜美物，中途還買了瓶可樂刺激刺激，但是也懷疑是這個導致體內酸性上升，以致抽筋。小竹棍也是必備之物，後面的路途可能都是靠支着這個小竹棍一點點往上挪的吧。</p><p>好歹，這是第一次完成了一個 41km 的旅途，這是我來沒有想過的東西。我原來想峨眉可能就 20km 吧，我能行。但……總之算是問題不大。第二日起牀去金頂看日出。日出確實是壯麗的。伴隨着衆多舉着相機的人的歡呼聲，像高郵鹹鴨蛋那般的紅色太陽從雲層的那端慢慢露出來，透露出整個鹹鴨蛋黃的金橙顏色，越發地誘人。然後天空呈現出一種絢麗的金色，最後慢慢變成普通閃耀着金光和大菩薩像一樣顏色的太陽了。</p><p>我不太清楚自己是怎麼爬上這個山的。我只記得我在路途的最後一程，我發自內心地想，如果這一路哪怕有一個可以放棄的地方，我可能就結束在那裡了吧。往上走的原因只是既不能停下來，也不能回頭罷了，和意志力什麼的是無甚關聯的東西。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行跡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习的操作们</title>
      <link href="/2020/06/27/scholar/DL_%E8%B0%83%E5%8F%82/"/>
      <url>/2020/06/27/scholar/DL_%E8%B0%83%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>每一次深度模型调参都是让人头疼的东西，总感觉有很多玄学的东西能用，但事实上最后效果都不会太好。这里专门记录一些可能会有影响的调参方法。所以这是一个累积更新的文章。希望之后碰到新的方法和雷区能在这里记下，减少调试时间。</p><a id="more"></a>  <h2 id="有效措施"><a href="#有效措施" class="headerlink" title="有效措施"></a>有效措施</h2><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>数据预处理的效果可能比模型的各种调参来得更加直接有效。对于 NLP 任务可能不那么明显，但是对于 CV 或者 DSP 任务却是立竿见影的。</p><h4 id="数据增广"><a href="#数据增广" class="headerlink" title="数据增广"></a>数据增广</h4><p>计算机视觉中常用的方法。基本是对于图片随机翻转、随机截取、添加高斯模糊、随机遮盖等等措施。其中随机截取和随机翻转是一般都有效的，随机遮盖等则不一定。数据增广可以在模型训练中完成，让模型实时更改数据集内容；也可以在训练前就完成增广；两种方法都用也没有问题。</p><p>对于图片的数据增广方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line">transform = tfs.Compose([</span><br><span class="line">    tfs.Resize((<span class="number">256</span>, <span class="number">256</span>)),  <span class="comment"># 先调整图片大小至256x256</span></span><br><span class="line">    tfs.RandomCrop((<span class="number">224</span>, <span class="number">224</span>)),  <span class="comment"># 再随机裁剪到224x224</span></span><br><span class="line">    tfs.RandomHorizontalFlip(),  <span class="comment"># 随机的图像水平翻转，通俗讲就是图像的左右对调</span></span><br><span class="line">    tfs.RandomRotation(<span class="number">5</span>),</span><br><span class="line">    tfs.ToTensor(),</span><br><span class="line">    tfs.Normalize((<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>), (<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.2225</span>)),  <span class="comment"># 维度和图像的channel相关</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>调用时使用即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = transform(img)</span><br></pre></td></tr></table></figure></p><h4 id="数据标准化-归一化"><a href="#数据标准化-归一化" class="headerlink" title="数据标准化/归一化"></a>数据标准化/归一化</h4><p>即使是非常简单的数据标准化/归一化，就能取得显著的 performance 提高以及训练速度的大幅度提升。对于图像信息，可以使用灰度图均衡化，而对于数字信号或者其他信息，则可以使用 MinMax，标准化众多方法。这个对于模型训练速度的提升可能是数量级上。</p><p>但无论如何，数据标准化几乎应当是数据预处理的必要操作，绝对不能跳过。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直方图均衡化</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.equalizeHist(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准化 - 对于一维数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">std</span><span class="params">(data)</span>:</span></span><br><span class="line">    mu = np.mean(data)</span><br><span class="line">    sigma = np.std(data)</span><br><span class="line">    <span class="keyword">return</span> (data - mu) / sigma</span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><h4 id="损失函数权重"><a href="#损失函数权重" class="headerlink" title="损失函数权重"></a>损失函数权重</h4><p>对于普通的损失函数，对于不同的类加以相同的权进行处理。但是对于类分别不均的训练集/测试集，可以轻微调整模型的损失函数权重，一般权重添加方法是按照训练集的比例强行加权。一般这样就能获得略好的效果。但是还有一定的调整空间。事实上使用这个方法对于一些数据分布不均的方法有非常明显的效果。不过如果实在分布不均的话，可以考虑数据预处理方法解决。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weight = torch.Tensor([<span class="number">1</span>, <span class="number">0.8</span>])</span><br><span class="line">lossfun = nn.CrossEntropyLoss(weight = weight)</span><br></pre></td></tr></table></figure><p>如果使用 cuda 训练，还应该申明<code>.cuda()</code>。</p><h4 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h4><p>原来习惯性用 Adam 也就没有再关心过学习率的问题，但事实上学习率仍然是有影响的。使用过小的学习率前期的训练时间过长而且容易进入一个不太好的局部最优解，相反使用大的学习率在前期能够势如破竹。（甚至是数量级的提升）但是训练到后期的模型 performan 却需要更小的学习率，所以这里引入学习率衰减的方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjust_learning_rate</span><span class="params">(optimizer, epoch)</span>:</span></span><br><span class="line">    lr = <span class="number">1e-4</span> * (<span class="number">0.4</span> ** (epoch // <span class="number">8</span>))</span><br><span class="line">    <span class="keyword">for</span> param_group <span class="keyword">in</span> optimizer.param_groups:</span><br><span class="line">        param_group[<span class="string">'lr'</span>] = lr</span><br><span class="line">adjust_learning_rate(optimizer, epoch)</span><br></pre></td></tr></table></figure><p>传入的 optimizer 参数就是 PyTorch 的模型。对于 Adam 模型，建议使用 $1e^{-4}$ 作为起始训练速率。</p><h2 id="不稳定措施"><a href="#不稳定措施" class="headerlink" title="不稳定措施"></a>不稳定措施</h2><h3 id="添加模型的全连接层"><a href="#添加模型的全连接层" class="headerlink" title="添加模型的全连接层"></a>添加模型的全连接层</h3><p>添加全连接层会大幅度增加模型的复杂度以及参数量，强制减低模型的训练速度，但而提高模型的过拟合能力。所以增加全连接层方法在数据量不足以支撑的情况下是绝对不推荐的。但是有的时候能发挥一定的作用。</p><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>Dropout 不是万能的方法。例如对于最后的分类器叠加 Dropout 反而会使模型的表现变得滑稽。Dropout 的添加是需要通过反复实验的。不过建议在模型的一开始不要使用 Dropout，因为模型自身的能力可能就不够，不能够很好地拟合训练数据。而且增加 Dropout 增加了训练时间，对于判断模型的强度也是不利的。在实验的最后发现过拟合严重可以考虑尝试使用 Dropout 方法。</p><h3 id="Multi-task"><a href="#Multi-task" class="headerlink" title="Multi-task"></a>Multi-task</h3><p>这是一个很不确定的东西。Multi-task 的效果随着设计的多任务而变化。事实上，在我使用 Multi-task 的情况下，几乎都没有得到明显的提升，有的时候甚至会拖后腿使模型的能力下降。所以 Multi-task 是需要仔细思考后使用的。</p><h3 id="加载预训数据"><a href="#加载预训数据" class="headerlink" title="加载预训数据"></a>加载预训数据</h3><p>对于 NLP 任务，使用预训参数是必要的，特别是对于 BERT 等模型，即使固定参数，只训练后面的部分也能获得很好的效果。但是对于 CV 任务这个效果却不是一定的。例如在 COVID-19 分类任务中，我使用了 ResNet18 作为一个模型，并加载了 PyTorch 的预训结果，获得了训练速度的显著提升；然而在语谱图分类时，使用预训的结果并没有明显的优势。</p><p>所以模型的训练对象和预训的数据集应该有一定的共同之处时才能够发挥作用。语谱图是完全和 ImageNet 不同的东西，所以不能发挥作用也是在预期之中的。</p><h2 id="基本无效措施"><a href="#基本无效措施" class="headerlink" title="基本无效措施"></a>基本无效措施</h2>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CV：深度卷积神经网络模型及调参</title>
      <link href="/2020/06/27/scholar/DL_DCNN/"/>
      <url>/2020/06/27/scholar/DL_DCNN/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为连续做了两个使用 CNN 网络的模型训练，所以这里单独开一个记录 CNN 调参的心路历程。</p><a id="more"></a>  <h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>经过众多测试，得到的通用模型如下。基本思想是深的神经网络以及小的卷积核，并且卷积核的 channel 逐渐增加的机制。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperNaiveModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(SuperNaiveModel, self).__init__()</span><br><span class="line">        self.conv0 = nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">64</span>, momentum=<span class="number">0.1</span>),            </span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">        )</span><br><span class="line">        self.conv1 = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv2 = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">128</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),            </span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv20 = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),            </span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv3=torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">512</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">512</span>, momentum=<span class="number">0.1</span>),            </span><br><span class="line">            torch.nn.ReLU(),            </span><br><span class="line">            torch.nn.Conv2d(<span class="number">512</span>, <span class="number">512</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">512</span>, momentum=<span class="number">0.1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.dense = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Linear(<span class="number">512</span> * <span class="number">4</span> * <span class="number">4</span>, <span class="number">20</span>),</span><br><span class="line">            nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = x.reshape(x.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>).float()</span><br><span class="line">        x = self.conv0(x)</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.conv20(x)</span><br><span class="line">        x = self.conv3(x)</span><br><span class="line">        x = x.view(x.shape[<span class="number">0</span>], <span class="number">512</span> * <span class="number">4</span> * <span class="number">4</span>)</span><br><span class="line">        x = self.dense(x)</span><br><span class="line">        <span class="keyword">return</span> x1</span><br></pre></td></tr></table></figure><h2 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h2><p>由于训练资源不够，所以使用一个 5x5 的卷积核代替了应有的两个 3x3 卷积核链接的效果。根据 VGG，<strong>连续使用两个 3x3</strong>可能效果会好一些。</p><p>Batchnorm 是一个玄学的东西，它的功能并不如预期一样稳定，并且没有必要在没一个网络后都接一个 BN 层。事实上，根据实验，在模型的最开始和最后一层添加 BN 层的效果是明显的。ReLU 层作为非线性化的方法，几乎是必须的。</p><p>此外，过多的全连接层是不利的，每多增一个全连接层会对模型造成一定的影响。预测的原因是由于数据量不够支撑全连接层的泛化性，导致容易过拟合，泛化性差，反而不如一层全连接。所以全连接层越多越好不是绝对的。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> ML </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch方法：DataSet</title>
      <link href="/2020/06/27/tech/PyTorch_DataSet/"/>
      <url>/2020/06/27/tech/PyTorch_DataSet/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简单记录一下如何使用 PyTorch 的 DataSet 及 DataLoader 功能。</p><a id="more"></a>  <p>DataSet 的使用通过继承 DataSet 类完成，并在此基础上需要构造三个特殊函数。下例为使用 DataSet，通过访问 json 文件获取数据内容，然后在 gititem 函数中获取数据并返回的例子。</p><h2 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSet</span><span class="params">(torch.utils.data.Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, train_or_valid, transform, path)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        file = open(<span class="string">'data/dataset.json'</span>, <span class="string">'r'</span>)</span><br><span class="line">        data = json.load(file)</span><br><span class="line">        self.datalist = data[train_or_valid]</span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        name = self.datalist[index][<span class="number">0</span>]</span><br><span class="line">        img = Image.open(self.path + name)</span><br><span class="line">        label = self.datalist[index][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"img"</span>: img, <span class="string">"label"</span>: label&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.datalist)</span><br></pre></td></tr></table></figure><p>上述返还的是一个数据字典。</p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>依旧使用上述的例子。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainset = DataSet(<span class="string">'train'</span>, transform_train, normal_path)</span><br></pre></td></tr></table></figure><h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>DataLoader 是 PyTorch 用来调取 DataSet 的一个类，其声明和使用如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"></span><br><span class="line">trainloader = data.DataLoader(trainset, batch_size = batch_sz, shuffle = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>第一个参数是上述生成的 DataSet，后面如同表述。</p><p>但往往上述的结构由于数据不规整不能满足要求，需要自己定义 Batch 函数。如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span><span class="params">(data)</span>:</span></span><br><span class="line">    src_len = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> data:</span><br><span class="line">        src_len.append(p[<span class="string">'wav'</span>].shape[<span class="number">1</span>])</span><br><span class="line">    src_pad = torch.zeros(len(data), data[<span class="number">0</span>][<span class="string">'wav'</span>].shape[<span class="number">0</span>], max(src_len))</span><br><span class="line">    tgt = torch.zeros(len(data))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        p = data[i]</span><br><span class="line">        end = src_len[i]</span><br><span class="line">        src_pad[i, :, -end:] = p[<span class="string">'wav'</span>]</span><br><span class="line">        tgt[i] = p[<span class="string">'label'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'wav'</span>: src_pad, <span class="string">'label'</span>: tgt&#125;</span><br><span class="line"></span><br><span class="line">validloader = data.DataLoader(validset, batch_size = batch_sz, shuffle = <span class="literal">False</span>, collate_fn = padding)</span><br></pre></td></tr></table></figure><p>返回的也是字典，并会使用 padding 函数。</p><h2 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h2><p>上面完成了预先代码的构建，最后是调用的步骤：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, samples <span class="keyword">in</span> enumerate(trainloader):</span><br><span class="line">    wavs, labels = samples[<span class="string">'wav'</span>], samples[<span class="string">'label'</span>]</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>返回的 samples 就是前面 padding 的结果，可以对此进行修改，例如保留原有的长度信息等等。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用系统操作及文件操作</title>
      <link href="/2020/06/27/tech/Python/%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/06/27/tech/Python/%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-YPUkTGMM" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="465149196" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>在预处理文件以及训练模式时经常用到一个文件操作，这里稍加整理。</p><a id="more"></a>  <h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br></pre></td></tr></table></figure><p>OS 操作很常用，用于获取文件夹之类的操作。主要使用<code>os</code>和<code>shutil</code>两个库文件。</p><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.path.exists(path)</span><br><span class="line">os.path.isdir(path)</span><br><span class="line">os.path.isfile(path)</span><br><span class="line">files = os.listdir(path)</span><br></pre></td></tr></table></figure><p>判断路径是否存在，是一个文件夹还是一个文件。对于一个文件夹可以继续使用 <code>listdir</code> 获得文件内容</p><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(path)</span>:</span></span><br><span class="line"> </span><br><span class="line">    path=path.strip()</span><br><span class="line">    path=path.rstrip(<span class="string">"\\"</span>)</span><br><span class="line"> </span><br><span class="line">    isExists=os.path.exists(path)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        os.makedirs(path) </span><br><span class="line">        print(<span class="string">'OK!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Existed!)</span></span><br><span class="line"><span class="string">        return False</span></span><br></pre></td></tr></table></figure><h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.remove(path)</span><br><span class="line">os.rmdir(path)        <span class="comment">#仅能删除空文件夹</span></span><br><span class="line">shutil.rmtree(path)   <span class="comment">#递归删除所有内容</span></span><br></pre></td></tr></table></figure><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p>对于文件夹和文件的操作方法是一样的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.rename(<span class="string">"test"</span>,<span class="string">"test1"</span>)    </span><br><span class="line">os.rename(<span class="string">"test.txt"</span>,<span class="string">"test1.txt"</span>)</span><br></pre></td></tr></table></figure><h3 id="复制和移动"><a href="#复制和移动" class="headerlink" title="复制和移动"></a>复制和移动</h3><p>需要使用 <code>shutil</code> 的库文件操作。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shutil.copyfile(<span class="string">"foo.txt"</span>,<span class="string">"bar.txt"</span>)  <span class="comment"># file only</span></span><br><span class="line">shutil.copytree(<span class="string">"foo"</span>,<span class="string">"bar"</span>)          <span class="comment"># dir only</span></span><br><span class="line">shutil.copy(<span class="string">"foo"</span>,<span class="string">"bar"</span>)              <span class="comment"># both</span></span><br><span class="line">shutil.move(<span class="string">"foo"</span>,<span class="string">"bar"</span>)</span><br></pre></td></tr></table></figure><ul><li>上述的文件的复制方法，存在覆盖能力。文件夹的复制方法则不允许在目标地址存在相应文件夹。</li><li>如果调用<code>.copy()</code>，输入为一个文件和一个文件夹，则会将文件复制入文件夹中。</li><li><code>.move()</code>细节和<code>.copy()</code>相同</li></ul><h2 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h2><h3 id="基本读写"><a href="#基本读写" class="headerlink" title="基本读写"></a>基本读写</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path, <span class="string">'w'</span>, encoding = <span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'foobar!'</span>)</span><br><span class="line"><span class="keyword">with</span> open(path, <span class="string">'r'</span>, encoding = <span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>模式：</p><div class="table-container"><table><thead><tr><th>参数</th><th>效果</th></tr></thead><tbody><tr><td>w</td><td>写文件</td></tr><tr><td>r</td><td>读文件</td></tr><tr><td>a</td><td>追加文件</td></tr></tbody></table></div><h3 id="特殊：json"><a href="#特殊：json" class="headerlink" title="特殊：json"></a>特殊：json</h3><p>JSON 文件是常用的格式，为了方便存储字典型结构的最优选择。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.load(f)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(dataset, f)</span><br></pre></td></tr></table></figure><h3 id="特殊：pickle"><a href="#特殊：pickle" class="headerlink" title="特殊：pickle"></a>特殊：pickle</h3><p>pickle 常用来保存二进制数据结构。基本上是什么都能存。不过对于 PyTorch，还是建议使用 torch 自带的 save 函数，不然 torch 会报 warning。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> pk</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.pk'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pk.dump(data, f)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.pk'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = pk.load(f)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 脚本工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python绘图集</title>
      <link href="/2020/06/26/tech/Python/%E7%BB%98%E5%9B%BE/"/>
      <url>/2020/06/26/tech/Python/%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>每一次写程序为了可视化都避不开 Python 的 matplotlib，干脆整理一下这个东西。以防后面每次需要反复查一样的东西。</p><a id="more"></a>  <h2 id="绘图基础"><a href="#绘图基础" class="headerlink" title="绘图基础"></a>绘图基础</h2><p><strong>导入步骤</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br><span class="line">plt.clr()             <span class="comment">#清空</span></span><br><span class="line">plt.savefig()         <span class="comment">#保存</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**绘制**：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">plt.plot(x, y, label = <span class="string">'name'</span>, color = <span class="string">'blue'</span>, linestyle = <span class="string">'--'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Time'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Acc'</span>)</span><br><span class="line">plt.legend(loc = <span class="string">'upper left'</span>)</span><br></pre></td></tr></table></figure><p>关于上面的位置，有下表：</p><div class="table-container"><table><thead><tr><th>值</th><th>位置</th></tr></thead><tbody><tr><td>upper right</td><td>右上</td></tr><tr><td>lower left</td><td>左下</td></tr><tr><td>center</td><td>center</td></tr></tbody></table></div><p>排列组合……</p><h2 id="特殊图"><a href="#特殊图" class="headerlink" title="特殊图"></a>特殊图</h2><p><strong>混淆矩阵绘制</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_confusion_matrix</span><span class="params">(cm, savename, title=<span class="string">'Confusion Matrix'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>), dpi=<span class="number">100</span>)</span><br><span class="line">    np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在混淆矩阵中每格的概率值</span></span><br><span class="line">    ind_array = np.arange(len(classes))</span><br><span class="line">    x, y = np.meshgrid(ind_array, ind_array)</span><br><span class="line">    <span class="keyword">for</span> x_val, y_val <span class="keyword">in</span> zip(x.flatten(), y.flatten()):</span><br><span class="line">        c = cm[y_val][x_val]</span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">0.001</span>:</span><br><span class="line">            plt.text(x_val, y_val, <span class="string">"%0.0f"</span> % (c,), color=<span class="string">'red'</span>, fontsize=<span class="number">15</span>, va=<span class="string">'center'</span>, ha=<span class="string">'center'</span>)</span><br><span class="line">    </span><br><span class="line">    plt.imshow(cm, interpolation=<span class="string">'nearest'</span>, cmap=plt.cm.binary)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    xlocations = np.array(range(len(classes)))</span><br><span class="line">    plt.xticks(xlocations, classes, rotation=<span class="number">90</span>)</span><br><span class="line">    plt.yticks(xlocations, classes)</span><br><span class="line">    plt.ylabel(<span class="string">'Actual label'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Predict label'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># offset the tick</span></span><br><span class="line">    tick_marks = np.array(range(len(classes))) + <span class="number">0.5</span></span><br><span class="line">    plt.gca().set_xticks(tick_marks, minor=<span class="literal">True</span>)</span><br><span class="line">    plt.gca().set_yticks(tick_marks, minor=<span class="literal">True</span>)</span><br><span class="line">    plt.gca().xaxis.set_ticks_position(<span class="string">'none'</span>)</span><br><span class="line">    plt.gca().yaxis.set_ticks_position(<span class="string">'none'</span>)</span><br><span class="line">    plt.grid(<span class="literal">True</span>, which=<span class="string">'minor'</span>, linestyle=<span class="string">'-'</span>)</span><br><span class="line">    plt.gcf().subplots_adjust(bottom=<span class="number">0.15</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># show confusion matrix</span></span><br><span class="line">    plt.savefig(savename, format=<span class="string">'png'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><strong>子图</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.plot(x1, y1)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(x2, y2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>热力图</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(matrix)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python图像处理</title>
      <link href="/2020/06/26/tech/Python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2020/06/26/tech/Python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这个是对于 COVID-19 分类任务结束的一个回顾。第一次完成这个图像相关的任务，基本上是一头雾水。在这一次过程中遇到了很多处理的方法，在这里列出来，方便后面使用。</p><a id="more"></a>  <h2 id="读取以及格式转换"><a href="#读取以及格式转换" class="headerlink" title="读取以及格式转换"></a>读取以及格式转换</h2><p>图像处理一般使用 OpenCV 及 PIL.Image 两个库。</p><p><strong>导入</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure><p><strong>图像的读取与保存</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"pic.jpg"</span>， flags)</span><br><span class="line">cv2.imwrite(filename, img)</span><br><span class="line"></span><br><span class="line">img = Image.open(filename)</span><br><span class="line">img.save(filename)</span><br></pre></td></tr></table></figure><p>关于 flags：</p><ul><li>cv2.IMREAD_COLOR:读取一副彩色图片，图片的透明度会被忽略，默认为该值，实际取值为 1；</li><li>cv2.IMREAD_GRAYSCALE:以灰度模式读取一张图片，实际取值为 0</li><li>cv2.IMREAD_UNCHANGED:加载一副彩色图像，透明度不会被忽略。</li></ul><p>以及文件名需要声明为 <code>.jpg / .png</code> 类似的格式才行。</p><p><strong>与 Numpy 互换</strong></p><p>事实上，cv2 导出的数据就是 np.array，例如对于彩色图像是(x, x, 3)的矩阵。而 Image 读出的是 Image 数据，需要转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = Image.fromarray(data)   <span class="comment"># 从array到Image</span></span><br><span class="line">data = np.array(img)          <span class="comment"># 从Image到array</span></span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>裁剪</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = img.crop((x0, y0, x1, y1))</span><br></pre></td></tr></table></figure><p>传入的是一个数组，标明左上角 <code>x0, y0</code> 及右下角 <code>x1, y1</code>。而由于 cv2 本质上是 np.array，所以可以使用 array 的操作完成。</p><p><strong>Resize</strong></p><p>Resize 是一个相当常用的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = img.resize((<span class="number">256</span>, <span class="number">256</span>), Image.ANTIALIAS)</span><br><span class="line">img = cv2.resize(img, (<span class="number">256</span>, <span class="number">256</span>), interpolation = cv2.INTER_AREA)</span><br></pre></td></tr></table></figure><p>后面是可选项。</p><h2 id="深度学习相关"><a href="#深度学习相关" class="headerlink" title="深度学习相关"></a>深度学习相关</h2><p><strong>直方图均衡化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <span class="comment"># 先转化为灰度图</span></span><br><span class="line">img = cv2.equalizeHist(img)                  <span class="comment"># 然后均衡化</span></span><br></pre></td></tr></table></figure><p><strong>随机变形</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line">transform = tfs.Compose([</span><br><span class="line">    tfs.Resize((<span class="number">256</span>, <span class="number">256</span>)),  <span class="comment"># 先调整图片大小至256x256</span></span><br><span class="line">    tfs.RandomCrop((<span class="number">224</span>, <span class="number">224</span>)),  <span class="comment"># 再随机裁剪到224x224</span></span><br><span class="line">    tfs.RandomHorizontalFlip(),  <span class="comment"># 随机的图像水平翻转，通俗讲就是图像的左右对调</span></span><br><span class="line">    tfs.RandomRotation(<span class="number">5</span>),</span><br><span class="line">    tfs.ToTensor(),</span><br><span class="line">    tfs.Normalize((<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>), (<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.2225</span>)),  <span class="comment"># 维度和图像的channel相关</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>调用时使用即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = transform(img)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> ML </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - Classification of COVID-19 in chest X-ray images using DeTraC deep convolutional neural network</title>
      <link href="/2020/06/04/scholar/paper/Classification%20of%20COVID_19/"/>
      <url>/2020/06/04/scholar/paper/Classification%20of%20COVID_19/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文为课程项目：“COVID-19 的分类和鉴别”做出的准备工作。由于做的工作类型相似，所以做一篇阅读笔记便于参考。</p><a id="more"></a>  <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>现有的众多方法：</p><ul><li>SVM</li><li>Backpropagation Network</li><li>CNN，作为医学领域最为出众的模型</li><li>Transfer learning。这个方法简单迅速<ul><li>精调（fine-tune）：三类精调：只训练分类层；训练所有参数；训练直到大提升</li></ul></li></ul><p>类分解用来加强低方差的分类器，使在分类边界上更灵活。经常这个方法被用在预处理中提高模型的表现。在医学分析中，类分解经常被用来提高类似随机森林等的分类表现。</p><p>这篇文章使用基于类分解的 CNN 网络，并使用迁移学习方法。对于原数据集中的类，先将其分解为几个完全视为独立的子类，然后对这些子类进行分类，最后组合在一起获得预测结果。</p><h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h2><ul><li>使用基于 CNN 的感知网络检测 COVID-19。</li><li>使用 ResNet 预训的网络分类 CT 图像。</li><li>ImageNet 预训的网络分类 X-ray 抽取特征，然后放入 SVM 中进行分类。</li><li>基于 Transfer Learning 的分类方法，分类 CXR 图像。分为四类：正常、细菌感染、non-COVID、non-COVID 且感染。</li></ul><p>作者认为前面的成果没有讨论数据集的不规则性。这篇文章就讲关注数据的不规则性。</p><h2 id="3-DeTraC-模型"><a href="#3-DeTraC-模型" class="headerlink" title="3. $DeTraC$ 模型"></a>3. $DeTraC$ 模型</h2><p>这个部分讨论整个训练方法的细节。</p><p><strong>3.1 Overview</strong></p><p>整个模型分为三个部分：</p><ul><li>训练从$DeTraC$抽离出的预训的 CNN 模型分离出深层信息，然后使用类分解</li><li>使用复杂优化器进行训练</li><li>使用类组合器去精确分类</li></ul><center><img src="/images/Research/detrac.jpg"/></center><p>类分解器将每一个类分为 k 个子类，并进行单独训练。然后通过类组合器恢复。</p><p><strong>3.2 深度特征挖掘</strong><br>使用 ImageNet 预训的 CNN 模型，通过浅层精调，这样构建特征空间。然后使用 PCA 将高维度信息转换为低维度信息，这对于产生等价类非常有用，并且可以降低空间存储要求，提升效率。</p><p><strong>3.3 类分解器</strong><br>特征空间设为 2D 矩阵$A$，$L$是类别，$m$是特征数量，$k$是类数量，$n$是图片数量。为了完成类分解，使用 k-means 做聚类，将类别划分为等价子类。所有的原标签按照新分出的类别，按照欧几里得距离计算最近的类别然后重新分配标签。这样新获得的数据集称为 $B$。</p><p><strong>3.4 Transfer Learning</strong><br>本论文使用通过 ResNet 预训练的模型，并具有优秀的表现。<strong>作者选择仅变动 low-level 的层数而固定住 high-level 层</strong>。</p><p>参数设定：</p><div class="table-container"><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>学习率</td><td>除最后一层外设定为 0.0001，最后一层设定为 0.01</td></tr><tr><td>批大小</td><td>64</td></tr><tr><td>Epoch</td><td>256</td></tr><tr><td>Weight Decay</td><td>0.01</td></tr><tr><td>Momentum value</td><td>0.9</td></tr></tbody></table></div><p>因为数据很少，使用 SGD 存在不稳定性，所以使用批训练。损失函数为 cross-entropy。</p><p><strong>3.5 Evaluation 与重组</strong><br>在重组阶段，被赋予的新标签会恢复原来的标签，用来衡量模型的性能。这里使用的量为 Accuracy，Specificity, Sensitivity。各自的定义是：（$TN$ 为 <em>true negative</em>。其馀的标记就足够明显了。）</p><script type="math/tex; mode=display">   \begin{aligned}       ACC &= \frac{TP+TN}{n} \\       SN  &= \frac{TP}{TP+FN} \\       SP  &= \frac{TN}{TN+FP}   \end{aligned}</script><p>事实上使用的是多类别的判别方法。</p><h2 id="4-实验部分"><a href="#4-实验部分" class="headerlink" title="4. 实验部分"></a>4. 实验部分</h2><p><strong>4.1 使用的数据集</strong></p><ul><li>数据集包含两个部分：Normal CXRs （80 个正常样本）</li><li>Chest X-ray images，脑筋 105 个 COVID-19 样本和 11 个 SARS 样本。</li></ul><p>经过了数据增强。使用的上下左右翻转等等策略。最后获得了总计 1764 个样本。</p><p><strong>4.2 基于深度学习的类分解</strong><br>使用经过浅层训练的 AlexNet 预训网络，用以抽离原本三个类的特征。然后设定 $k=2$，使用 k-means，对类进行划分，将一个类别进一步划分为 2 个子类。最后得到 norm1, norm2, COVID191,COVID192, SARS1, SARS2 六类。</p><p><strong>4.3 结果</strong></p><ul><li>Acc：95.12%</li><li>SN：97.91%</li><li>SP：91.87%</li></ul><p>使用 70%的数据进行训练，30%的数据进行 Eval。</p><h2 id="5-讨论"><a href="#5-讨论" class="headerlink" title="5. 讨论"></a>5. 讨论</h2><p>训练 CNN 有两种策略。可以使用 end-to-end 的方法，需要大量的标注数据；或者使用迁移学习，仅需要有限的数据就能够完成任务。</p><h2 id="6-读后"><a href="#6-读后" class="headerlink" title="6. 读后"></a>6. 读后</h2><p>感觉是很平庸的一篇文章，将各种预训的结果拼在一起回避数据量过少的问题。唯一可以注意的地方是采用的 decomposition 方法，但这个方法也不是初创的。总体而言像是一个缝合怪。不过就研究方法和使用的数据集构造值得学习。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSP：MFCC计算</title>
      <link href="/2020/05/23/course/DSP/MFCC/"/>
      <url>/2020/05/23/course/DSP/MFCC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-bKRHSCMo" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5173080" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>MCFF（Mel Frequency Cepstrum Coefficient）的计算过程、背景以及相应的<code>python</code>代码。</p><a id="more"></a>  <p><strong>MFCC</strong>：考虑了人的听觉系统特性，将线性频谱映射到基于听觉感知特性的 Mel 频谱上，然后再计算倒谱。声道的 shape 表现为短时间功率谱的包络线（envelope of the short time power spectrum），MFCCs 的工作则是如何准确地表征这种 envelope。</p><h2 id="1-人听觉系统的特性"><a href="#1-人听觉系统的特性" class="headerlink" title="1. 人听觉系统的特性"></a>1. <strong>人听觉系统的特性</strong></h2><p>人听到的声音高低和声音频率不成线性关系，而是成对数关系。</p><script type="math/tex; mode=display">B(f)=2595log_{10}(1+\frac{f}{700})</script><p><strong>屏蔽效应：</strong>人不能听到所有的声音，只有两个频率分量相差一定的<strong>带宽</strong>时，人耳才能区分。否则只有听到一个音调。这个带宽称为<strong>临界带宽</strong>：</p><script type="math/tex; mode=display">BW_c=25+75[1+1.4(\frac{f_c}{1000})^2]^{0.69}</script><ul><li>其中$f_c$为中心频率。</li><li>当$f_c$在 1kHz 以下时，临界带宽基本恒定为 100Hz。</li><li>当$f_c$在 1kHz 以上时，临界带宽呈指数增加。</li></ul><p>模拟上述的听觉特性，可以进行构造模仿人耳的感知特性。</p><ul><li>Mel 频率尺度：对数关系</li><li>Mel 滤波器组：屏蔽效应<ul><li>每一个滤波器的中心频率在 mel 频率域中呈等间隔分布</li><li>每一个滤波器的带宽在其临界带宽范围内</li></ul></li></ul><h2 id="2-MFCC的计算步骤"><a href="#2-MFCC的计算步骤" class="headerlink" title="2. MFCC的计算步骤"></a>2. MFCC的计算步骤</h2><ol><li>输入语音信号 — 语音波谱</li><li>预加重、分帧、加窗 — 分为不同帧的语音波谱</li><li>用 FFT 计算信号频谱 — 不同帧对应的频谱</li><li>计算频谱的绝对值/平方 — 不同帧对应的能量谱</li><li>使用 Mel 滤波器组 — 获得更符合人类听觉的 Mel 谱特征</li><li>取对数 — 为了倒谱做准备</li><li>DCT — 将乘积通过对数转化为加法。</li><li>Delta MFCC</li><li>输出语音特征</li></ol><h3 id="2-1-预加重、分帧、加窗"><a href="#2-1-预加重、分帧、加窗" class="headerlink" title="2.1 预加重、分帧、加窗"></a>2.1 预加重、分帧、加窗</h3><p><strong>2.1.1 预加重</strong></p><script type="math/tex; mode=display">H(Z)=1-\mu z^{-1}</script><p>即通过一个高通滤波器。在时域中写为：</p><script type="math/tex; mode=display">s_m=s_m-\mu s_{m-1}</script><p>预加重的目的是使频谱变得平坦。同时，也是为了消除发生过程中声带和嘴唇的效应，来补偿语音信号受到发音系统所抑制的高频部分，也为了突出高频的共振峰。$\mu$的取值一般为 0.9~1 之间。</p><p><strong>2.1.2 分帧</strong><br>一个窗为一帧。通常情况下 N=256，时间为 20ms~30ms。对于 8kHz 的信号来说，若帧长度为 256 个采样点，则对应的时间为$256 / 8000\times 1000 = 32ms$。</p><p><strong>2.1.3 加窗</strong><br>对每一帧使用汉明窗。通常，$a$取值为 0.46.</p><script type="math/tex; mode=display">w(n)=1-a[1+cos(\frac{2\pi n}{N-1})]</script><h3 id="2-2-FFT"><a href="#2-2-FFT" class="headerlink" title="2.2 FFT"></a>2.2 FFT</h3><p>对每一帧进行 FFT，变换到频率域中。</p><h3 id="2-3-Mel滤波器组"><a href="#2-3-Mel滤波器组" class="headerlink" title="2.3 Mel滤波器组"></a>2.3 Mel滤波器组</h3><p>人的听力像是一组滤波器（见第一节讨论的<strong>屏蔽效应</strong>），听见的声音在频谱上是不连续的;并且在低频上分布更密集（同样参见第一节中人听到的声音特性）。将能量谱通过一组 Mel 尺度的三角形滤波器组，定义一个有 $M$ 个滤波器的滤波器组。</p><center><img src="/images/Single/Mel组.jpg" width="50%" height="50%" /></center><ul><li>中心频率$f_c(l)$在 Mel 频率域中是等间隔分布</li><li>每一个滤波器的中心频率为：<script type="math/tex; mode=display">f(m)=(\frac{N}{F_s})B^{-1}(B(f_l)+m\frac{B(f_h)-B(f_l)}{M+1})</script>其中：$N$为窗口宽度，$F_s$为采样频率，$M$为滤波器数量，通常取 22~26。通过上式可以获得 M 个带通滤波器$H_m(k)$<script type="math/tex; mode=display">H_m(k)=\begin{cases}0 & \text{ k < f(m-1) }\\\frac{k-f(m-1)}{f(m)-f(m-1)} & \text{ f(m-1) < k < f(m) }\\\frac{f(m+1)-k}{f(m+1)-f(m)} & \text{ f(m) < k < f(m+1) }\\0 & \text{ otherwise }\end{cases}</script></li></ul><center><img src="/images/Single/DSP-滤波器组.jpg" width="50%" height="50%"/></center><p>对频谱进行平滑化，并消除谐波的作用，突显原先语音的共振峰。因此一段语音的音调或音高，是不会呈现在 MFCC 参数内，换句话说，以 MFCC 为特征的语音辨识系统，并<strong>不会受到输入语音的音调不同的影响</strong>。此外，还可以降低运算量。</p><p>计算每个滤波器组输出的对数能量。其中$M$为滤波器个数，$N$为窗口大小。</p><script type="math/tex; mode=display">S(m)=ln[\sum_{k=1}^N|X(k)|^2H_m(k)]</script><!-- **MFCC**$$log|S(e^{jw})|=\sum_{m=-\infty}^{\infty}c_me^{-jwn}$$$$S(w)=lim_{N\to\infty}\frac{1}{N}|X(e^{jw})|^2=lim_{N\to\infty}\frac{1}{N}|\sum_{n=0}^{N-1}x(n)e^{-jwn}|^2$$ --><h3 id="2-4-离散馀弦变换（DCT）"><a href="#2-4-离散馀弦变换（DCT）" class="headerlink" title="2.4 离散馀弦变换（DCT）"></a>2.4 离散馀弦变换（DCT）</h3><p>对滤波器组输出$S(m)$，DCT 得到 Mel 频率的倒谱系数$c(n)$。</p><p>DCT 正变换：</p><script type="math/tex; mode=display">   \begin{aligned}       F(0) &= \frac{1}{\sqrt{N}}\sum_{x=0}^{N-1}f(x),~~~u=0 \\       F(u) &= \sqrt{\frac{2}{N}}\sum_{x=0}^{N-1}f(x)cos[\frac{\pi}{2N}(2x+1)u], ~~~u=1,2,3...,N-1   \end{aligned}</script><p>DCT 反变换：</p><script type="math/tex; mode=display">f(x)=\frac{1}{\sqrt(N)}F(0)+\sqrt{\frac{2}{N}}\sum_{u=0}^{N-1}F(u)cos[\frac{\pi}{2N}(2x+1)u], ~~~x=1,2,3,...,N-1</script><p>将$S(m)$作为上式中的$f(x)$，$m$作为$x$得到下式：</p><script type="math/tex; mode=display">c(n)=\sum_{m=1}^MS(m)cos[\frac{\pi n(m-0.5)}{M}], ~~~n=0,1,...,L</script><p>这里的$L$是 MFCC 系数的阶数，通常取 12~16。</p><h3 id="2-5-Delta-MFCC"><a href="#2-5-Delta-MFCC" class="headerlink" title="2.5 Delta MFCC"></a>2.5 Delta MFCC</h3><p>到此为止，MFCC 只是获得了当前帧的语音特征。而相邻帧之间是连续的，可以通过相邻帧之间的变化更好地表达语音的特征。</p><center><img src="/images/Single/DMFCC.jpg"/></center><h2 id="3-MFCC常用参数集"><a href="#3-MFCC常用参数集" class="headerlink" title="3. MFCC常用参数集"></a>3. MFCC常用参数集</h2><div class="table-container"><table><thead><tr><th>参数</th><th>取值</th></tr></thead><tbody><tr><td>$\mu$（预加重参数）</td><td>0.9~1</td></tr><tr><td>$N$（窗口大小）</td><td>256/512</td></tr><tr><td>采样率</td><td>8kHz/16kHz</td></tr><tr><td>帧长</td><td>20ms~30ms</td></tr><tr><td>$M$（Mel 滤波器组数量）</td><td>22~26</td></tr><tr><td>$L$（MFCC 阶数）</td><td>12~16</td></tr><tr><td>$a$（汉明窗系数）</td><td>0.46</td></tr></tbody></table></div><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ol><li>这篇文章将原理解释得挺不错：<a href="https://blog.csdn.net/zouxy09/article/details/9156785/" target="_blank" rel="noopener">梅尔频率倒谱系数（MFCC）</a></li><li>这篇将流程解释得更清楚：<a href="https://blog.csdn.net/class_brick/article/details/82743741" target="_blank" rel="noopener">语音特征 MFCC 提取过程详解</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动给中英混合文本加上空格</title>
      <link href="/2020/05/22/tech/Hexo/%E6%8A%80%E5%B7%A7_%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%A9%BA%E6%A0%BC/"/>
      <url>/2020/05/22/tech/Hexo/%E6%8A%80%E5%B7%A7_%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用 textlint 给文本中英文交界的地方加上空格。对 Markdown 文件或者 txt 文件都会挺有用。</p><a id="more"></a>  <p><strong>安装</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> textlint <span class="comment">--global</span></span><br><span class="line">npm <span class="keyword">install</span> textlint-rule-ja-<span class="keyword">space</span>-<span class="keyword">between</span>-half-<span class="keyword">and</span>-<span class="keyword">full</span>-width <span class="comment">--global</span></span><br><span class="line">textlint <span class="comment">--init</span></span><br></pre></td></tr></table></figure><br>这里使用<code>--save</code>似乎是不行的，无法被程序找到<code>textlint</code></p><p>修改生成的<code>.textlint</code>文件为（似乎不修改也没事）<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"filters"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"rules"</span>: &#123;</span><br><span class="line">        <span class="attr">"ja-space-between-half-and-full-width"</span>: &#123;</span><br><span class="line">            <span class="attr">"space"</span>: <span class="string">"always"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加空格：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">textlint</span> -- fix <span class="regexp">*.md</span></span><br></pre></td></tr></table></figure></p><p>注意，使用这个语法即使写错了也不会报错的。对于 Blog 文件，可以考虑在生成脚本文件最前面，添加一行<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textlint --fix <span class="keyword">source</span><span class="regexp">/_posts/</span>*.md</span><br></pre></td></tr></table></figure><br>这样每一次生成 Blog 的时候就能自动纠错了。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - Departures from Tree Structures in Discourse - Shared Arguments in PDTB</title>
      <link href="/2020/05/22/scholar/paper/Departure_from_tree_structures_in_discourse/"/>
      <url>/2020/05/22/scholar/paper/Departure_from_tree_structures_in_discourse/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了更好地搞清楚自己究竟读过哪些论文，于是决定为读过的论文写一些笔记。这是第一篇笔记，关于 PDTB 中树结构的构建问题。</p><a id="more"></a>  <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>这篇文章关于 Discourse Structure，是指任何超过句子结构以上的结构。尽管在大多数时候，DS 都可以被放在一个树地结构下，但是存在这样一个结构：两棵树会存在交集的情况，即存在一个“daughter”被两个 root 管辖。这篇文章将关注点放在“the shared discourse structure is a <em>syntactically subordinate clause</em> introduced by a <em>subordinating conjunction</em>”。</p><p>关于上述定义：</p><ul><li>syntactically subordinate clause：是指语法上的从句结构</li><li>subordinating conjunction<ul><li>从属连词，a connecting word or phrase that introduces a <strong>dependent clause</strong> and joins it to a <strong>main clause or independent clause</strong>.</li><li>常常被用来加上时间、让步、对比、因果等等条件</li><li>从属连词必须放在 dependent clause 的开头</li><li>例子：because, before, when; even though, as long as, except that</li></ul></li></ul><p>这篇文章考虑的是，从属句可能会作为另一个 DS 的一个 Argument，并暗示了 Syntactic subordication 及 DS 的关联。这篇文章的主张是：尽管在大多数时候，SS 和 DS 是对应的，但是有一些例外的存在。这里讨论这些例外，以及它们的意义。</p><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h2><blockquote><p>a subordinating conjunction is a grammaticization of the rhetorical organization of discourse</p></blockquote><p>一般认为 Sc（subordinating clause）和其他 non-salient discourse 一样，对主题的连续性无关。这些成分被认为是句子的背景，但是他们本身并不能使主题更进一步。依据这种思路给出了做 Summarizer 的思路：移除所有的 non-salient 部分即可以完成概括。而有人指出，Sc 只是作为一个造成 discourse saliency 的原因。<br>这篇文章会通过经验上的方法，去检验句法和篇章之间的关系。</p><h2 id="3-方法及发现"><a href="#3-方法及发现" class="headerlink" title="3. 方法及发现"></a>3. 方法及发现</h2><p>考虑这样一个句型：”X although Y”，其中 X, Y 是 although 的两个 arguments，Y 是从句，假设标注者并不知道这个句子的关系的情况下，遇到了另外一个句子，这时候我们关心的是，Y 是否被选出作为另一个 DS 的一个 argument。</p><blockquote><p>The London index finished 2.4% under its close of 2233.9 the previous Friday, <strong>although</strong> it recouped some of the sharp losses staged early last week on the back of Wall Street’s fall. London was weak throughout Friday’s trading, <strong>however</strong>, on what dealers attributed to generally thin interest…(1505)</p></blockquote><p>在这个例子中，although 是第一个 ds 的一个 argument，同时也是第二个句子的一个 argument。为了方便我们称呼由 however 引导的这个 ds 为 external relation。在 PDTB 中，这样的 subordinating conjunctions 还有 after, although, as, because, …共计 12 个最为常见。在所有的情况中，以全句作为 er 的比例是最高的；其次是使用 matrix clause；最其次是使用 sc 作为 argument。而使用 coordinating conjunctions 作为对比则可以发现，其后两类的比例是几乎一样的。</p><blockquote><p>it does seem to be the case that there is a correspondence between syntactic<br>coordination and subordination on the one hand, and symmetric or asymmetric salience of discourse arguments on the other</p></blockquote><p>几乎可以认为，sc 的 saliency 低于 matrix clause。因此，认为语法和 ds 相关的观点是可以成立的。</p><h2 id="4-讨论"><a href="#4-讨论" class="headerlink" title="4. 讨论"></a>4. 讨论</h2><p>几个例子：</p><blockquote><p>They won’t buy <strong>if</strong> the quality is not there. <strong>Or</strong> if they feel the wine is overpriced. (0071)</p></blockquote><p>这个例子特殊在，尽管”the quality is not there“是一个 sc，并被 Or 判定为 er，但是可以发现整个句子是以 if 作为基础的，这样的例子可以使用树状结构加以概括。这和前文出现的例子不一样，前文的例子是一些并列的关系。于是可能在没有出现明显的嵌入的情况下，我们认为把 discourse 放入某些树结构中没有太多价值。</p><script type="math/tex; mode=display">{X~~IF~~(Y~~OR~~Z)}~~~--5i</script><p>上述式子可以概括原句。我们给一个新的例子：</p><script type="math/tex; mode=display">{X~~ALTHOUGH~~(Y}~~HOWEVER~~Z)~~~--5ii</script><p>我们认为 Y 延续了这个 DS，而再上面那个例子没有。(5i)这样是符合预期的，因为我们不希望一个 sc 去作为句子的主要成分并 continue 一个 DS。而(5ii)则更有意思。所以在什么情况下，一个 sc 会变成推动句子发展的 salient clause？下面是文章的作者们做的一些观察（文章作者声称自己并不仅仅是做观察，并会将系统的分析留到将来数据集更完善的时候（感觉这是我的锅了））。<br>首先，有两种固定的模式：</p><ul><li>这个 sc 总是后置的。例如”The dilligent boy passed the exam because <strong>he studied hard</strong>“，前置或者居中的 sc 是不行的。</li><li>er 总是限定在 - 对比、因果这样的关系中，而例如并列这样的关系则没有。</li></ul><p>以及一些大概率的模式：</p><ul><li><strong>Anaphoric matrix clause</strong>：这个 matrix clause 在原文中有一个很明显的前指。</li><li><strong>Reduced matrix clause</strong>：通过代词等短句很简单地指向了前文。</li></ul><blockquote><p>it may be <strong>because</strong> these shows need all the protection they can get. (<strong>Implicit-CAUSE</strong>) European programs usually target only their own local audience, and often only a small portion of that. (2361)，对应第二种模式</p></blockquote><p>在上述的情况中，主句总是在前文中有一个前置。可以认为是前置提供的信息削弱了后面主句的 saliency，使得 sc 上位。即，如果主句更多的是在照应前文的观点，则使得其从句更加自由，便可以作为承接下文的句子。</p><ul><li><strong>sc 被一个”coordinating-type“的 subordinating conjunction 引导</strong>：特别的，这里指两个词：<em>although</em>和<em>because</em>。这两种词引导的句子经常被用作 external argument，在发现的 349 例中，有 189 例归于上述两个中的一个。</li></ul><p>所以是否在 DS 中使用树结构，还是说在 DS 下使用树结构只是从语法分析上遗留下来的策略？</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章：互连网络</title>
      <link href="/2020/05/21/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap7_%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/05/21/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap7_%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>互联函数</li><li>互联网络的参数与性能指标</li><li>静态互连网络</li><li>动态互连网络<a id="more"></a>  </li></ul><p><strong>互连网络</strong>是一种由开关元件按照一定的拓扑结构和控制方式构成的网络，用来实现计算机系统中节点之间的相互连接。</p><ul><li><strong>节点</strong>：处理器、存储模块或其他设备。</li><li>在拓扑上，互连网络为输入节点到输出节点之间的一组互连或映射。 </li><li>SIMD 计算机和 MIMD 计算机的关键组成部分。 </li><li><strong>3 大要素</strong>：互连结构，开关元件，控制方式。 </li></ul><h2 id="7-1-互连函数"><a href="#7-1-互连函数" class="headerlink" title="7.1 互连函数"></a>7.1 互连函数</h2><h3 id="7-1-1-互连函数"><a href="#7-1-1-互连函数" class="headerlink" title="7.1.1 互连函数"></a>7.1.1 互连函数</h3><p><strong>互连函数</strong>：通过数学表达式建立输入端号与输出端号的连接关系。即在互连函数 f 的作用下，输入端 x 连接到输出端$f(x)$。</p><ul><li>互连函数反映了网络输入数组和输出数组之间对应的置换关系或排列关系。</li><li>互连函数 f(x)有时可以采用循环表示<ul><li>${x_0, x_1, … x_{j-1}}~\to~f(x_0)=x_0, f(x_1)=x_2, …, f(x_{j-1})=x_0$</li><li>$j$称为循环的长度。</li><li>互连函数表示为$f(x_{n-1}x_{n-2}…x_1x_0)$</li><li>$x=x_{n-1}x_{n-2}…x_1x_0$，其中$n=log_2N$。</li></ul></li></ul><h3 id="7-1-2-几种基本的互连函数"><a href="#7-1-2-几种基本的互连函数" class="headerlink" title="7.1.2 几种基本的互连函数"></a>7.1.2 几种基本的互连函数</h3><p><strong>恒等函数</strong>：$I(x_{n-1}x_{n-2}…x_1x_0)=x_{n-1}x_{n-2}…x_1x_0$<br><strong>交换函数</strong>：实现二进制地址编码中第 k 位互反的输入端与输出端之间的连接。</p><ul><li>主要用于构造立方体互连网络和各种超立方体互连网络。</li><li>该函数有 n 种</li><li><strong>立方体互连函数</strong>：当$N=8$，即$n=3$时。</li></ul><script type="math/tex; mode=display">   \begin{aligned}       Cube_0 &= x_2x_1\bar{x_0} \\       Cube_1 &= x_2\bar{x_1}x_0 \\       Cube_2 &= \bar{x_2}x_1x_0   \end{aligned}</script><center><img src="/images/Single/cube.jpg" width="50%" height="50%" />N=8的立方体交换函数</center><p><strong>均匀洗牌函数</strong></p><ul><li>将输入端分成数目相等的两半，前一半和后一半按类似均匀混洗扑克牌的方式交叉地连接到输出端（输出端相当于混洗的结果）。也称为<strong>混洗函数</strong>。直观的来说是将原地址乘 2 取模。</li><li>$ \sigma(x_{n-1}x_{n-2}…x_1x_0)=x_{n-2}x_{n-3}…x_1x_0x_{n-1} $</li><li><strong>第 k 个子函数$\sigma_(k)$</strong>：把 s 作用于输入端的二进制编号的低 k 位。将低 k 位左移一位。</li><li><strong>第 k 个超函数$\sigma^(k)$</strong>：把 s 作用于输入端的二进制编号的高 k 位。将高 k 位左移一位。</li><li>$\sigma^{(n)}=\sigma_{(n)}=\sigma$</li><li>$\sigma^{(1)}=\sigma_{(1)}=f$</li><li>若存在函数使$f(x)\times g(x)=I(x)$则称为$g(x)$是$f(x)$的逆函数。</li><li>逆均匀洗牌函数</li></ul><center><img src="/images/Single/均匀洗牌.jpg" width="50%" height="50%" ></center><p><strong>碟式函数</strong></p><ul><li>把输入端的二进制编号的最高位与最低位互换位置，便得到了输出端的编号。</li><li>$\beta(x_{n-1}x_{n-2}…x_1x_0)=x_0x_{n-2}…x_1x_{n-1}$</li><li><strong>第 k 个子函数$\beta_{(k)}$</strong>：将输入端第 k 位（编号 k-1）与编号 0 交换。</li><li><strong>第 k 个超函数$\beta^{(k)}$</strong>：将输入端第 n-k 位与编号 n-1 交换。</li><li>$\beta^{(n)}=\beta_{(n)}=\beta$</li><li>$\beta^{(1)}=\beta_{(1)}=f$</li></ul><center><img src="/images/Single/蝶式函数.jpg" width="50%" height="50%" /></center><p><strong>移数函数</strong></p><ul><li>将各输入端都错开一定的位置（模 N）后连到输出端。</li><li>$\alpha(x)=(x\pm k)~mod~N$</li></ul><p><strong>PM2I 函数</strong></p><ul><li>一种移数函数，将各输入端都错开一定的位置（模 N）后连到输出端。</li><li>$PM2_{+i}=(x+2^imod)N$</li><li>$PM2_{-i}=(x-2^imod)N$</li><li>该函数互联网络具有 2n 个不同的互连函数。</li></ul><center><img src="/images/Single/PM2.jpg" width="50%" height="50%" /></center><h2 id="7-2-互连网络的结构参数与性能指标"><a href="#7-2-互连网络的结构参数与性能指标" class="headerlink" title="7.2 互连网络的结构参数与性能指标"></a>7.2 互连网络的结构参数与性能指标</h2><h3 id="7-2-1-互连网络的结构参数"><a href="#7-2-1-互连网络的结构参数" class="headerlink" title="7.2.1 互连网络的结构参数"></a>7.2.1 互连网络的结构参数</h3><ul><li>网络通常是用有向边或无向边连接有限个节点的图来表示。</li><li>互连网络的主要特性参数有：<ul><li><strong>网络规模 N</strong>：节点个数，连接的部件数量</li><li><strong>节点度 d</strong>：与节点连接的边数（通道数）</li><li><strong>节点距离</strong>：从一个节点出发到另一个节点终止所需要跨越的边数的最小值</li><li><strong>网络直径 D</strong>：距离的最大值</li><li><strong>等分宽度 b</strong>：把 N 个节点切成节点数相同的两半需要的切除边数的最小值<ul><li>线等分宽度：$B=b\times w$</li><li>w 为通道宽度</li><li>反映了网络最大流量</li></ul></li></ul></li></ul><h3 id="7-2-2-性能指标"><a href="#7-2-2-性能指标" class="headerlink" title="7.2.2 性能指标"></a>7.2.2 性能指标</h3><p><strong>通信时延</strong>：指从源节点到目的节点传送一条消息所需的总时间，它由以下 4 部分构成：</p><ul><li><strong>软件开销</strong>：在源节点和目的节点用于收发消息的软件所需的执行时间。<ul><li>取决于节点处理消息的软件内核</li></ul></li><li><strong>通道时延</strong>：通过通道传送消息所花的时间。<ul><li>通信时延 = 消息长度 / 通信带宽</li><li>有瓶颈的通道带宽决定</li></ul></li><li><strong>选路时延</strong>：消息在传送路径上所需的一系列选路决策所需的时间开销。<ul><li>与路径的节点数相关</li></ul></li><li><strong>竞争时延</strong>：多个消息同时在网络中传送时，会发生争用网络资源的冲突。为避免或解决争用冲突所需的时间就是竞争时延。</li></ul><p><strong>网络时延</strong></p><ul><li>通道时延与选路时延的和</li><li>由网络硬件特征决定，与程序星为和传输状态无关</li></ul><p><strong>端口宽带</strong></p><ul><li>对于互连网络中的任意一个端口来说，其端口带宽是指单位时间内从该端口传送到他端口的最大信息量。</li><li>在对称网络中，端口带宽与端口位置无关。网络的端口带宽与各端口的端口带宽同。</li><li>非对称网络的端口带宽则是指所有端口带宽的最小值。</li></ul><p><strong>聚集带宽</strong>：网络从一半节点到另一半节点，单位时间内能够传送的最大信息量。<br><strong>等分带宽</strong>：与等分宽度对应的切平面中，所有边合起来单位时间所能传送的最大信息量。</p><h2 id="7-3-静态互联网络"><a href="#7-3-静态互联网络" class="headerlink" title="7.3 静态互联网络"></a>7.3 静态互联网络</h2><p>互连网络通常可以分为两大类：</p><ul><li>静态互连网络：各节点之间有固定的连接通路、且在运行中不能改变的网络。</li><li>动态互连网络：由交换开关构成、可按运行程序的要求动态地改变连接状态的网络。</li></ul><p><strong>线性阵列</strong></p><ul><li>一种一维的线性网络，其中 N 个节点用 N-1 个链路连成一行。</li><li>端节点的度：1</li><li>其馀节点的度：2</li><li>直径：N－1</li><li>等分宽度 b=1</li></ul><p><strong>环和带弦环</strong></p><ul><li>环<ul><li>用一条附加链路将线性阵列的两个端点连接起来而构成。可以单向工作，也可以双向工作。</li><li>对称性</li><li>节点的度：2</li><li>双向环的直径：N/2</li><li>单向环的直径：N </li><li>环的等分宽度 b=2 </li></ul></li><li>带弦环<ul><li>增加的链路越多，节点度就越高，网络直径就越小</li></ul></li><li>全连接网络</li></ul><center><img src="/images/Single/带弦环.jpg" width="50%" height="50%" /></center><p><strong>循环移数网络</strong></p><ul><li>通过在环上每个节点到所有与其距离为 2 的整数幂的节点之间都增加一条附加链而构成。</li><li>即如果$|j-i|=2^r$，则 j 与 i 连接。<ul><li>节点度：2n-1</li><li>直径：n/2</li><li>网络规模：$N=2^n$</li></ul></li></ul><center><img src="/images/Single/循环.jpg" width="50%" height="50%" /></center><p><strong>树形和星形</strong></p><center><img src="/images/Single/树形.jpg" width="50%" height="50%" /></center><ul><li>树形可靠性较差，具有较高的节点度</li></ul><p><strong>胖树形</strong></p><p><strong>网格形和环网形</strong></p><ul><li>网格形<ul><li>对于$n\times n$的网格<ul><li>内部节点的度 d=4</li><li>边节点的度 d=3</li><li>角节点的度 d=2</li><li>网络直径 D=2（n-1）</li><li>等分宽度 b=n</li></ul></li><li>一个由$N=n^k$个节点构成的 k 维网格形网络（每维 n 个节点）的内部节点度 d=2k，网络直径 D=k(n-1) </li></ul></li><li>Illiac 网络<ul><li>把 2 维网格形网络的每一列的两个端节点连接起来，再把每一行的尾节点与下一行的头节点连接起来，并把最后一行的尾节点与第一行的头节点连接起来。</li><li>对于$n\times n$的网格<ul><li>所有节点的度 d=4</li><li>网络直径 D=n-1</li><li>Illiac 网络的直径只有纯网格形网络直径的一半。 </li><li>等分宽度：2n</li></ul></li></ul></li><li>环网形<ul><li>把 2 维网格形网络的每一行的两个端节点连接起来，把每一列的两个端节点也连接起来。 </li><li>将环形和网格形组合在一起，并能向高维扩展。 </li><li>一个 n×n 的环网形网 <ul><li>节点度：4</li><li>网络直径：2×(n/2)</li><li>等分宽度 b=2n </li></ul></li></ul></li></ul><center><img src="/images/Single/网格形.jpg " width="50%" height="50%" /></center><p><strong>超立方体</strong></p><ul><li>一个二元 n-立方体由$N=2^n$个节点组成，它们分布在 n 维上，每维有两个节点。</li><li>为实现一个 n-立方体，只要把两个（n－1）立方体中相对应的节点用链路连接起来即可。共需要 2n-1 条链路。</li><li>n-立方体中节点的度都是 n，直径也是 n，等分宽度为 b=N/2 。 </li></ul><p><strong>带环立方体（3-CCC）</strong></p><ul><li>把 3-立方体的每个节点换成一个由 3 个节点构成的环而形成的。</li><li>带环 k-立方体（简称 k-CCC）<ul><li>k-立方体的变形，它是通过用 k 个节点构成的环取代 k-立方体中的每个节点而形成的。</li><li>网络规模为 N=k×2k</li><li>网络直径为 D=2k-1+k/2</li><li>比 k-立方体的直径大一倍</li><li>等分宽度为 b=N/（2k）</li></ul></li></ul><center><img src="/images/Single/带环立方体.jpg" width="50%" height="50%" /></center><h2 id="7-4-动态互连网络"><a href="#7-4-动态互连网络" class="headerlink" title="7.4 动态互连网络"></a>7.4 动态互连网络</h2><h3 id="7-4-1-总线网络"><a href="#7-4-1-总线网络" class="headerlink" title="7.4.1 总线网络"></a>7.4.1 总线网络</h3><p>由一组导线和插座构成，经常被用来实现计算机系统中处理机模块、存储模块和外围设备等之间的互连。</p><ul><li>每一次总线只能用于一个源（主部件）到一个或多个目的（从部件）之间的数据传送。</li><li>多个功能模块之间争用总线或时分总线</li><li>特点：结构简单、成本低、带宽窄</li></ul><p><strong>一种由总线连接的多处理机系统</strong></p><center><img src="/images/Single/总线系统.jpg" width="50%" height="50%" /></center><ul><li>系统总线在处理机、I/O 子系统、主存储器以及辅助存储设备（磁盘、磁带机等）之间提供了一条公用通路。</li><li>系统总线通常设置在印刷电路板底板上。处理器板、存储器板和设备接口板都通过插座或电缆插入底板。</li></ul><p><strong>带宽窄的解决</strong></p><ul><li>多总线是设置多条总线，有两种做法：<ul><li>为不同的功能设置专门的总线</li><li>重复设置相同功能的总线</li></ul></li><li>多层次的总线是按层次的架构设置速度不同的总线，使得不同速度的模块有比较适合的总线连接。 </li></ul><h3 id="7-4-2-交叉开关网络"><a href="#7-4-2-交叉开关网络" class="headerlink" title="7.4.2 交叉开关网络"></a>7.4.2 交叉开关网络</h3><p><strong>单极开关网络</strong></p><ul><li>交叉点开关能在对偶（源、目的）之间形成动态连接，同时实现多个对偶之间的无阻塞连接。</li><li>带宽和互连特性最好。 </li><li>一个 n×n 的交叉开关网络，可以无阻塞地实现$n!$种置换。 </li><li>对一个 n×n 的交叉开关网络来说，需要 n2 套交叉点开关以及大量的连线。当 n 很大时，交叉开关网络所需要的硬件数量非常巨大。</li></ul><p><strong>C.mmp 多处理机的互连结构</strong></p><ul><li>用 16×16 的交叉开关网络把 16 台 PDP-11 处理机与 16 个存储模块连在一起</li><li>最多可同时实现 16 台处理机对 16 个不同存储模块的并行访问<ul><li>每个存储模块一次只能满足一台处理机的请求</li><li>当多个请求要同时访问同一存储模块时，交叉开关就必须分解所发生的冲突，每一列只能接通一个交叉点开关。</li><li>为了支持并行（或交叉）存储器访问，可以在同一行中接通几个交叉点开关。 </li></ul></li></ul><center><img src="/images/Single/mmp.jpg" width="50%" height="50%" /></center><h3 id="7-4-3-多级互联网络"><a href="#7-4-3-多级互联网络" class="headerlink" title="7.4.3 多级互联网络"></a>7.4.3 多级互联网络</h3><p><strong>多级互连网络的构成</strong></p><ul><li>MIMD 和 SIMD 都采用多级互联网络 MIN（Multistage Interconnection Network）</li><li>一种通用的多级互连网络 <ul><li>由 a×b 开关模块和级间连接构成的通用多级互连网络结构</li><li>每一级都用了多个 a×b 开关<ul><li>a 个输入和 b 个输出</li><li>在理论上，a 和 b 不一定相等，然而实际上 a 和 b 经常选为 2 的整数幂，即 a＝b＝2k，k≥1。 </li></ul></li><li>相邻各级开关之间都有固定的级间连接</li></ul></li></ul><center><img src="/images/Single/多级互连.jpg" width="50%" height="50%" /></center><ul><li>最简单的开关模块：2x2 开关</li></ul><center><img src="/images/Single/22开关.jpg" width="50%" height="50%" /></center><ul><li>各种多级互连网络的区别在于所用开关模块、控制方式和级间互连模式的不同。<ul><li>控制方式：对各个开关模块进行控制的方式。<ul><li>级控制：每一级的所有开关只用一个控制信号控制，只能同时处于同一种状态。</li><li>单元控制：每一个开关都有一个独立的控制信号，可各自处于不同的状态。</li><li>部分级控制：第 i 级的所有开关分别用 i＋1 个信号控制，0≤i≤n－1，n 为级数。</li></ul></li><li>常用的级间互连模式：均匀洗牌、蝶式、多路洗牌、纵横交叉、立方体连接等</li></ul></li></ul><p><strong>多级立方网络</strong></p><ul><li>多级立方体网络包括 STARAN 网络和间接二进制 n 方体网络等。<ul><li>两者仅在控制方式上不同，在其他方面都是一样的。</li><li>都采用二功能（直送和交换）的 2×2 开关。</li><li>当第 i 级（0≤i≤n-1）交换开关处于交换状态时，实现的是 Cubei 互连函数。 </li></ul></li><li>一个 N 输入的多级立方体网络有 log2N 级，每级用 N/2 个 2×2 开关模块，共需要 log2N×N/2 个开关。</li></ul><center><img src="/images/Single/多级立方网络.jpg" width="50%" height="50%" />一个8个入端的多级立方体网络</center><ul><li>STARAN 网络采用级控制和部分级控制。<ul><li>采用级控制时，所实现的是交换功能；</li><li>采用部分级控制时，则能实现移数功能。</li></ul></li><li>间接二进制 n 方体网络则采用单元控制。<ul><li>具有更大的灵活性。</li></ul></li></ul><p><strong>Omega 网络</strong></p><center><img src="/images/Single/Omega网络.jpg" width="50%" height="50%" />一个8×8的Omega网络</center><ul><li>一个 N 输入的 Omega 网络<ul><li>有$log_2N$级，每级用 N/2 个 2×2 开关模块，共需要$Nlog_2N/2$个开关。</li></ul></li><li>每个开关模块均采用单元控制方式。</li><li>不同的开关状态组合可实现各种置换、广播或从输入到输出的其他连接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧克力奶茶</title>
      <link href="/2020/05/20/essay/cookbook/%E5%B7%A7%E5%85%8B%E5%8A%9B%E5%A5%B6%E8%8C%B6/"/>
      <url>/2020/05/20/essay/cookbook/%E5%B7%A7%E5%85%8B%E5%8A%9B%E5%A5%B6%E8%8C%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文簡單記敘一下巧克力奶茶的做法，爲提高下一次水準做準備。</p><a id="more"></a>  <p><strong>口感</strong></p><ul><li>呈現巧克力牛奶般的顏色</li><li>口感粗糲，不算非常順滑，略苦</li><li>可能會因爲巧克力過多而蓋過茶味，這個還需要探索</li><li>黑巧克力可能並不合適，和奶茶自身的味道些許衝突，沒有展現各自的優勢</li></ul><p><strong>材料</strong></p><ul><li>純牛奶一盒：250ml</li><li>紅茶葉若干：大概小半把，煮沸後占 1/4 個碗</li><li>冰糖：15 顆以上</li><li>黑巧克力：20g。如果放整條那茶味會被蓋過去</li></ul><p><strong>步驟</strong></p><ul><li>冷水煮沸，冷水量不能太多，兩碗以內。</li><li>放入茶葉，小火熬製一段時間，會聞到「番茄味」，水會變成棕紅色。</li><li>倒入牛奶、冰糖、巧克力，小火熬製。煮沸後靜置一段時間</li><li>可以按照相同的辦法，但是不放巧克力就變成普通的奶茶</li></ul><p><strong>實驗失敗經歷</strong></p><ol><li>實驗 001<ul><li>使用了 40g 黑巧克力</li><li>三碗水，水似乎放多了</li><li>使用冷水煮紅茶，效果不理想</li><li>結果：巧克力味道過重，幾乎蓋過了茶味，呈現巧克力牛奶的味道</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 食譜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『鋼の錬金術師』03版觀感</title>
      <link href="/2020/05/19/essay/%E8%A7%82%E6%84%9F/%E9%92%A2%E4%B9%8B%E7%82%BC%E9%87%91%E6%9C%AF%E5%B8%8803/"/>
      <url>/2020/05/19/essay/%E8%A7%82%E6%84%9F/%E9%92%A2%E4%B9%8B%E7%82%BC%E9%87%91%E6%9C%AF%E5%B8%8803/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-aqLQmHwh" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="636907" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="評價：★★★★☆"><a href="#評價：★★★★☆" class="headerlink" title="評價：★★★★☆"></a>評價：★★★★☆</h3><a id="more"></a><p>　　在相對高壓的接近期末季的時候，看完了鋼之鍊金術師 03 版，就簡單地記一下觀感吧。（這真的似乎是我很不擅長的方式，不過不妨一試）<br>　　整體而論，03 版敘述了一個更小的故事，但是述說了更真實的故事；09 版敘述了一個巨大的陰謀，但是結局顯得過於樂觀。僅就故事節奏、完整性種種考慮，個人認爲 09 版優於 03 版。許多人認爲 03 版較 09 版更爲深刻，這一點本人暫無法苟同，但不可否認 03 版本的嚴肅壓抑氛圍對於這樣一個故事時是更得體的，09 版顯得太歡樂。</p><blockquote><p>人は何かの犠牲なしに、何も得ることはできない。何かを得るためには、同等の代価が必要となる。<br>人沒有的犧牲的話就什麼也得不到，爲了得到某些東西，就必須付出同等的代價。</p></blockquote><p>　　在觀看 03 版之前先看的 09 版，毫無疑問的是 03 版的氛圍比 09 版沉重了很多。03 版很大的問題是在後期脫離原作基礎的情況下，事件發生的邏輯鏈開始頻繁斷裂，人物在場景間的移動和出現往往突兀得不講道理。此外許多人物的謝幕方式也顯得莫名其妙，例如被 Sloth 被 Wrath 坑掉，大總統被兒子坑掉。毫無疑問此二人這樣的結局是<strong>相當具有意味</strong>的，也是我很欣賞的部分，但是非常生硬地讓之前的伏筆串在一起打出結局，效果終於是不太理想。</p><p>　　不過除開上述描述的嚴重缺陷，03 版做得相當出色的一點是對於「等價交換」原則的討論，這是一個逆否命題。整部作品中，有至少兩點是被討論到了的。第一點是：付出了代價是否就能獲得同等的回報。第二點是：這個原則本身是否就是可信的？</p><blockquote><p>痛みを伴わない教訓には意義がない、人は何かの犠牲無しには何も得ることには出來ないのだから。しかし、その痛みに耐え乘り越えた時、人は何物にも負けない強韌な心を手に入れる、そう鋼のような心を……<br>不伴隨着痛楚的教訓就沒有意義，因爲人若無犧牲，就不會有收穫。然而，當戰勝這痛楚時，人就將獲得不屈服於任何事物的堅強之心，是的，鋼鐵般的堅強之心。 ——09版</p></blockquote><p>　　在 09 版中，「等價交換」這一原則是不容置疑的，整部作品也沒有違背這一點。在故事的最後，兄弟二人耗費了多年的時間，換來了一顆堅毅的心，這是對於等價交換的總結。但是在 03 版中，對於等價交換的詮釋構成了問題的核心。等價交換原則是被兩兄弟堅信的一點，也是二人被但丁嘲笑的一點。這是一個很現實的問題，正像在劇裡面提到的「人生而不平等」問題在當今社會是顯然的，一個人可能付出百倍的努力獲得的回報只是另外一部分人付出一倍努力的結果，我們稱之爲天分或者運氣。這個問題在 03 版並沒有得到解答，是一個「失敗」的結束，對於所有人來說都是。努力復活母親的兄弟最後只能親手再殺一次人造人；企圖恢復手臂的愛德華，不僅沒有成功，反而永遠與弟弟分離；希望奪取大總統之位的大佐最後被流放。這是一個對於幾乎所有人都是「失敗」的結尾，然而世界還是依舊地運轉。</p><p>　　不過在這樣的悲哀之中，主人公還是抓到了渺小的希望：有一些獲取的東西，是不需要付出代價的，這是被稱爲「愛」的東西。這是一個樸素的答案，卻照亮了整部陰暗的作品。03 版的故事是關於「愛」的故事，它隱藏了行動的動機，卻強調了行動造成的不可挽回的後果，省略了「愛」帶來的溫暖或者企圖讓它們看起來理所應當。但事實上這才是真正的動力，讓所有人行動並堅強的唯一的理由。（聽起來挺怪的，但這一部對於這一點的詮釋挺棒的。）</p><p>　　03 版的部分人物處理得比 09 更爲富有內涵。斯卡自不必說，從一個復仇者最後變成一個殉道者，整個過程 03 版較 09 版來得更爲自然而有人性。03 版設定下的人造人的記憶也是令人造人出彩的點，Rust 在這個版本裡如若新生，找到了自己最後的價值。但是大總統較 09 而言差了很大一截，人物顯得略有扁平化，09 版的大總統有血有肉，是一個塑造地成功太多的角色。有一點最後想說一下，許多人在劇情後期指責阿爾聖母心壞事，愛德華行事拖沓；但事實上，人善良而弱小，這不是罪，而是<strong>現實</strong>。</p><p>　　PS：03 整部覺得最爲最爲令人感動的細節：在修斯准將殉職的那一集，黑色底的報幕。節制而真誠。</p><center><img src="/images/Things/鋼煉.jpg"/>鋼之鍊金術師03劇場版</center>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 觀感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章:IO系统</title>
      <link href="/2020/05/15/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap6_IO/"/>
      <url>/2020/05/15/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap6_IO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ol><li>I/O 性能</li><li>I/O 可靠性</li><li>廉价磁盘冗馀阵列 RAID</li><li>总线</li><li>通道处理机</li><li>I/O 与操作系统</li></ol><a id="more"></a><h2 id="6-1-I-O系统性能与CPU性能"><a href="#6-1-I-O系统性能与CPU性能" class="headerlink" title="6.1 I/O系统性能与CPU性能"></a>6.1 I/O系统性能与CPU性能</h2><ol><li>IO 系统包括 IO 设备与 IO 设备和处理机的连接</li><li>IO 系统是计算机的一个重要组成部分</li><li>IO 系统可分为存储 IO 系统及通信 IO 系统</li><li>系统响应时间：从用户输入命令开始，到得到结果需要的时间。由 IO 系统响应时间和 CPU 处理时间组成</li><li>评价 IO 系统的参数：连接特性/IO 系统容量</li></ol><h2 id="6-2-I-O系统的可靠性、可用性、可信性"><a href="#6-2-I-O系统的可靠性、可用性、可信性" class="headerlink" title="6.2 I/O系统的可靠性、可用性、可信性"></a>6.2 I/O系统的可靠性、可用性、可信性</h2><p><strong>系统可靠性</strong>：系统从某个初始参考点开始一直连续提供服务的能力，用<strong>平均无故障时间 MTTF</strong>来衡量。</p><ul><li>MTTF：Mean Time To Failure</li><li>MTTF 的倒数是系统的<strong>失效率</strong>。</li><li>MTTR：平均修复时间<br>计算系统可靠性的方法：将不同部件的失效率相加求倒。</li></ul><p>提高系统部件可靠性的方法：</p><ul><li>有效构建方法：消除故障隐患</li><li>纠错方法：即使出现故障也能正常工作</li></ul><p><strong>系统的可用性：</strong>系统正常工作的时间在连续两次正常服务间隔时间中所占的比例。</p><script type="math/tex; mode=display">可用性=\frac{MTTF}{MTTF+MTTR}</script><p>平均失效间隔时间 MTBF：MTTF+MTTR</p><p><strong>可信性：</strong>服务的质量。多大程度上可以合理地认为服务是可靠的。这是不可以度量的。</p><h2 id="6-3-磁盘冗馀阵列RAID"><a href="#6-3-磁盘冗馀阵列RAID" class="headerlink" title="6.3 磁盘冗馀阵列RAID"></a>6.3 磁盘冗馀阵列RAID</h2><p><strong>磁盘阵列 DA（Disk Array）</strong>：使用多个磁盘（包括驱动器）的组合来代替一个大容量的磁盘。</p><ul><li>多个磁盘并行工作。</li><li>以条带为单位把数据均匀地分布到多个磁盘上。（交叉存放）</li><li>条带存放可以使多个数据读/写请求<strong>并行</strong>地被处理，从而提高总的 I/O 性能。<ul><li>多个独立请求可以由多个盘并行地处理：减少了 IO 请求的排队时间</li><li>如果一个请求访问了多个块，就可以多个盘一起处理：提高了单个请求的数据传输率</li></ul></li><li>增加磁盘数量会导致磁盘阵列的可靠性下降</li><li>磁盘阵列组成<ul><li>细粒度：<strong>优点：</strong>所有 I/O 请求都能够获得很高的数据传输率；<strong>缺点：</strong>在任何时间，都只有一个逻辑上的 I/O 在处理当中，而且所有的磁盘都会因为为每个请求进行定位而浪费时间。</li><li>粗粒度：多个较小规模的请求可以同时得到处理。对于较大规模的请求又能获得较高的传输率。</li></ul></li><li>设置冗馀需要解决的问题：<ul><li>如何计算冗馀信息：奇偶校验码</li><li>如何将信息分布：将信息存放在几个盘中；将数据均匀分在所有盘中</li></ul></li></ul><h3 id="6-3-1-RAID0"><a href="#6-3-1-RAID0" class="headerlink" title="6.3.1 RAID0"></a>6.3.1 RAID0</h3><center><img src="/images/Single/RAID0.jpg" width="50%" height="50%" />RAID0</center><ol><li>非冗馀阵列</li><li>将数据切分为条带，交叉地进行存放</li></ol><h3 id="6-3-2-RAID1"><a href="#6-3-2-RAID1" class="headerlink" title="6.3.2 RAID1"></a>6.3.2 RAID1</h3><center><img src="/images/Single/RAID1.jpg" width="50%" height="50%" />RAID1</center><ol><li>双备份磁盘：将数据写入镜像磁盘</li><li>特点：<ol><li>能实现快速读取</li><li>写性能由最差的磁盘决定</li><li>可靠性高</li><li>昂贵</li></ol></li></ol><h3 id="6-3-3-RAID2"><a href="#6-3-3-RAID2" class="headerlink" title="6.3.3 RAID2"></a>6.3.3 RAID2</h3><center><img src="/images/Single/RAID2.jpg" width="50%" height="50%" />RAID2</center><ol><li>存储式磁盘阵列，使用汉明码</li><li>特点<ol><li>每个数据盘存放所有数据字的一位（位交叉存放）</li><li>各个数据盘上的相应位计算汉明校验码，编码位被存放在多个校验（ECC）磁盘的对应位上。</li><li>冗馀盘是用来存放汉明码的，其个数为 log2m 级。m：数据盘的个数（也就是数据字的位数）</li><li>并未被广泛应用，目前还没有商业化产品。</li></ol></li></ol><h3 id="6-3-4-RAID3"><a href="#6-3-4-RAID3" class="headerlink" title="6.3.4 RAID3"></a>6.3.4 RAID3</h3><center><img src="/images/Single/RAID3.jpg" width="50%" height="50%" />RAID3</center><ol><li>位交叉奇偶阵列</li><li>特点<ol><li>采用奇偶校验</li><li>写数据时需要写入校验盘</li><li>读数据时可以通过校验盘恢复数据</li><li>采用的带宽比较小</li><li>校验空间开销小</li></ol></li></ol><h3 id="6-3-5-RAID4"><a href="#6-3-5-RAID4" class="headerlink" title="6.3.5 RAID4"></a>6.3.5 RAID4</h3><center><img src="/images/Single/RAID4.jpg" width="50%" height="50%" />RAID4</center><ol><li>块交叉奇偶校验</li><li>采用比较大的条带，可以同时处理多个小规模访问请求</li><li>特点<ol><li>访问只需要访问数据所在的磁盘</li><li>只有在故障时才会读取校验码并进行重建</li><li>对于上图的设定，写数据需要两次磁盘读和两次磁盘写</li></ol></li></ol><h3 id="6-3-6-RAID5"><a href="#6-3-6-RAID5" class="headerlink" title="6.3.6 RAID5"></a>6.3.6 RAID5</h3><center><img src="/images/Single/RAID5.jpg" width="50%" height="50%" />RAID5</center><ol><li>块交叉分布奇偶校验磁盘阵列</li><li>无需冗馀盘，将奇偶校验分布在所有盘上</li></ol><h3 id="6-3-7-其他RAID"><a href="#6-3-7-其他RAID" class="headerlink" title="6.3.7 其他RAID"></a>6.3.7 其他RAID</h3><ol><li>RAID6：P+Q 双校验磁盘阵列：使用两个校验位，检验空间开销是 RAID5 的两倍；可以容忍两个磁盘出错</li><li>RAID10：先进行镜像再进行条带存放</li><li>RAID01：先进行条带存放再进行镜像</li></ol><h2 id="6-4-总线"><a href="#6-4-总线" class="headerlink" title="6.4 总线"></a>6.4 总线</h2><p>优点：成本低、多样性<br>缺点：不同外设分时共享，限制了 I/O 的吞吐率</p><h3 id="6-4-1-总线的设计"><a href="#6-4-1-总线的设计" class="headerlink" title="6.4.1 总线的设计"></a>6.4.1 总线的设计</h3><ol><li>难点<ol><li>总线上信息传输收到物理因素限制：总线的长度、设备的数目、信号的强度</li><li>I/O 既要快又要高吞吐</li></ol></li><li><p>分离事务总线</p><ol><li>又称流水总线、悬挂总线</li><li>多个主设备时，可以通过打包技术提高总带宽：将事务分为请求和应答。再请求和应答之间，总线可以供给其他 I/O 使用</li><li>分离事务总线有较高的带宽，但是数据传输延迟更大<center><img src="/images/Single/总线.jpg" width="50%" height="50%" />分离事务总线</center></li></ol></li><li><p>同步总线：包含一个供总线上所有设备使用的时钟，并且这些设备是基于该时钟按照一个固定的协议来发送地址和数据的。 </p></li><li>异步总线：没有统一的参考时钟，每个设备都有各自的定时方法。采用握手协议 。</li></ol><h3 id="6-4-2-与CPU的连接"><a href="#6-4-2-与CPU的连接" class="headerlink" title="6.4.2 与CPU的连接"></a>6.4.2 与CPU的连接</h3><ol><li>I/O 总线的连接有两种方法：连接到存储器上；连接到 Cache 上</li><li>I/O 总线连接到存储器总线上</li><li>CPU 对 I/O 设备的编址<ol><li>存储器映射 I/O，将存储器地址分给 I/O 设备，使用 load 和 store 进行读写。将一部分存储空间空出用于设备控制</li><li>为 I/O 设备设置单独的 I/O 指令用于访问设备</li></ol></li></ol><h2 id="6-5-通道处理机"><a href="#6-5-通道处理机" class="headerlink" title="6.5 通道处理机"></a>6.5 通道处理机</h2><p><strong>通道处理机（简称通道）</strong>：专门负责整个计算机系统的输入/输出工作。通道处理机只能执行有限的一组输入/输出指令。</p><h3 id="6-5-1-通道的作用"><a href="#6-5-1-通道的作用" class="headerlink" title="6.5.1 通道的作用"></a>6.5.1 通道的作用</h3><ol><li>程序控制、中断和 DMA 方式管理外围设备会引起两个问题：<ol><li>所有外设的输入/输出工作均由 CPU 承担，CPU 的计算工作经常被打断而去处理输入/输出的事务，不能充分发挥 CPU 的计算能力。 </li><li>大型计算机系统的外设虽然很多，但同时工作的机会不是很多。 </li></ol></li><li>一个典型的由 CPU、通道、设备控制器、外设构成的 4 级层次结构的输入/输出系统。</li><li>通道的功能 <ol><li>接收 CPU 发来的 I/O 指令，并根据指令要求选择指定的外设与通道相连接。</li><li>执行通道程序：从主存中逐条取出通道指令，对通道指令进行译码，并根据需要向被选中的设备控制器发出各种操作命令。</li><li>给出外设中要进行读/写操作的数据所在的地址。如磁盘存储器的柱面号、磁头号、扇区号等。 </li><li>给出主存缓冲区的首地址：该缓冲区存放从外设输入的数据或者将要输出到外设中去的数据。</li><li>控制外设与主存缓冲区之间的数据传送的长度：对传送的数据个数进行计数，并判断数据传送是否结束。</li><li>指定传送工作结束时要进行的操作。例如：将外设的中断请求及通道的中断请求送往 CPU 等。</li><li>检查外设的工作状态是否正常，并将该状态信息送往主存指定单元保存。</li><li>在数据传输过程中完成必要的格式变换。例如：把字拆分为字节，或者把字节装配成字等。</li></ol></li><li>通道的主要硬件<ol><li>寄存器：数据缓冲寄存器，主存地址计数器，传输字节数计数器，通道命令字寄存器，通道状态字寄存器</li><li>控制逻辑：分时控制，地址分配，数据传送、装配和拆分等</li></ol></li></ol><h3 id="6-5-2-工作过程"><a href="#6-5-2-工作过程" class="headerlink" title="6.5.2 工作过程"></a>6.5.2 工作过程</h3><ol><li>通道完成一次数据输入/输出的工作过程<ol><li>在用户程序中使用访管指令进入管理程序，由管理程序生成一个通道程序，并启动通道。<ol><li>用户在目标程序中设置一条广义指令，通过调用操作系统的管理程序来实现。</li><li>管理程序根据广义指令提供的参数来编制通道程序。 </li><li>启动输入/输出设备指令是一条主要的输入/输出指令，属于特权指令。</li></ol></li><li>通道处理机执行通道程序，完成指定的数据输入/输出工作。通道处理机执行通道程序与 CPU 执行用户程序是并行的。 </li><li>通道程序结束后向 CPU 发中断请求。</li></ol></li><li>时间关系</li></ol><center><img src="/images/Single/通道时间.jpg " width="50%" height="50%" />通道时间示意</center><h3 id="6-5-3-种类"><a href="#6-5-3-种类" class="headerlink" title="6.5.3 种类"></a>6.5.3 种类</h3><ol><li>字节多路通道<ol><li>为多台低速或中速的外设服务。</li><li>以字节交叉的方式分时轮流地为它们服务。</li><li>字节多路通道可以包含多个子通道，每个子通道连接一台设备控制器。 </li></ol></li><li>选择通道<ol><li>为多台高速外围设备服务。 </li><li>在一段时间内只为一台高速外设独占使用。</li><li>选择通道的硬件：寄存器/格式交换部件/通道控制部件</li></ol></li><li>数组多路通道<ol><li>适用于高速设备。</li><li>每次选择一个高速设备后传送一个数据块，轮流为多台外围设备服务。</li></ol></li></ol><h3 id="6-5-4-重要：流量分析"><a href="#6-5-4-重要：流量分析" class="headerlink" title="6.5.4 重要：流量分析"></a>6.5.4 <strong>重要</strong>：流量分析</h3><ol><li>通道流量：一个通道在数据传送期间，单位时间内能够传送的数据量。所用单位一般为 Bps。  <ul><li>又称为通道吞吐率、通道数据传输率等。</li><li>通道最大流量：一个通道在满负荷工作状态下的流量 。</li><li>参数的定义 <ul><li>$T_S$：设备选择时间。从通道响应设备发出的数据传送请求开始，到通道实际为这台设备传送数据所需要的时间。</li><li>$T_D$：传送一个字节所用的时间。</li><li>p：在一个通道上连接的设备台数，且这些设备同时都在工作。</li><li>n：每台设备传送的字节数，这里假设每台设备传送的字节数都相同。</li><li>k：数组多路通道传输的一个数据块中包含的字节数。在一般情况下，k &lt; n。对于磁盘、磁带等磁表面存储器，通常 k = 512。</li><li>T：通道完成全部数据传送工作所需要的时间。</li></ul></li></ul></li><li>字节多路通道：<ol><li>传送过程：通道每连接一台个外设，只传送一个字节，然后又与另一台设备连接，并传送一个字节。</li><li>为 p 个设备传送 n 个数据需要时间：<script type="math/tex; mode=display">T_{BYTE}=(T_S+T_D)\times p \times n</script></li><li>最大流量：<script type="math/tex; mode=display">f_{max}=\frac{pn}{(T_S+T_D)pn}=\frac{1}{T_S+T_D}</script></li><li>实际流量：连接在这个通道上所有设备的数据传输率之和</li></ol></li><li>选择通道<ol><li>在一段时间内只能单独为一台高速外设服务，当这台设备的数据传送工作全部完成后，通道才能为另一台设备服务。 </li><li>为 p 个设备传送 n 个数据需要时间：<script type="math/tex; mode=display">T_{SELECT}=(\frac{T_S}{n}+T_D)pn</script></li><li>最大流量：<script type="math/tex; mode=display">f_{max}=\frac{1}{\frac{T_S}{n}+T_D}</script></li></ol></li><li>数组多路通道<ol><li>为 p 个设备传送 n 个数据需要时间：<script type="math/tex; mode=display">T_{SELECT}=(\frac{T_S}{k}+T_D)pn</script></li><li>最大流量：<script type="math/tex; mode=display">f_{max}=\frac{1}{\frac{T_S}{k}+T_D}</script></li><li>选择通道和数组多路通道的实际流量就是连接在这个通道上的所有设备中数据流量最大的那一个 。</li><li>各种通道的实际流量应该不大于通道的最大流量</li></ol></li></ol><h2 id="6-6-I-O与操作系统"><a href="#6-6-I-O与操作系统" class="headerlink" title="6.6 I/O与操作系统"></a>6.6 I/O与操作系统</h2><ul><li>在用硬件实现的 I/O 技术中，哪些会实际被采用，是由操作系统来决定的。 </li><li>I/O 操作主要是在外设和存储器之间进行，所以操作系统必须保证这些 I/O 操作的安全性。</li></ul><h3 id="6-6-1-DMA与虚拟存储器"><a href="#6-6-1-DMA与虚拟存储器" class="headerlink" title="6.6.1 DMA与虚拟存储器"></a>6.6.1 DMA与虚拟存储器</h3><p><strong>DMA 是使用虚拟地址还是物理地址？</strong></p><ol><li>使用物理地址进行 DMA 传输，存在以下两个问题：<ul><li>对于超过一页的数据缓冲区，由于缓冲区使用的页面在物理存储器中不一定是连续的，所以传输可能会发生问题。 </li><li>如果 DMA 正在存储器和缓冲区之间传输数据时，操作系统从存储器中移出（或重定位）一些页面，那么，DMA 将会在存储器中错误的物理页面上进行数据传输。 </li></ul></li><li>解决这些问题的方法 <ul><li>使操作系统在 I/O 的传输过程中确保 DMA 设备所访问的页面都位于物理存储器中，这些页面被称为是钉在了主存中。</li><li>“虚拟 DMA”技术：允许 DMA 设备直接使用虚拟地址，并在 DMA 期间由硬件将虚拟地址转换为物理地址。在采用虚拟 DMA 的情况下，如果进程在内存中被移动，操作系统应该能够及时地修改相应的 DMA 地址表。 </li></ul></li></ol><h3 id="6-6-2-I-O和Cache数据一致性"><a href="#6-6-2-I-O和Cache数据一致性" class="headerlink" title="6.6.2 I/O和Cache数据一致性"></a>6.6.2 I/O和Cache数据一致性</h3><ol><li>Cache 会造成两个副本</li><li>把 I/O 连接到存储器上会出现以下情况：<ul><li>CPU 修改了 Cache 的内容后，由于存储器的内容跟不上 Cache 内容的变化，I/O 系统进行输出操作时所看到的数据是旧值。（写直达 Cache 没有这样的问题）</li><li>I/O 系统进行输入操作后，存储器的内容发生了变化，但 CPU 在 Cache 中所看到的内容依然是旧值。 </li></ul></li><li>把 I/O 直接连接到 Cache 上：<ul><li>不会产生由 I/O 导致的数据不一致的问题。 </li><li>所有 I/O 设备和 CPU 都能在 Cache 中看到最新的数据。</li><li>I/O 会跟 CPU 竞争访问 Cache，在进行 I/O 时，会造成 CPU 的停顿。 </li><li>I/O 还可能会破坏 Cache 中 CPU 访问的内容，因为 I/O 操作可能导致一些新数据被加入 Cache，而这些新数据可能在近期内并不会被 CPU 访问。  </li></ul></li><li>解决内容一致性问题的方法（不管 Cache 是采用写直达法还是写回法）<ul><li>软件的方法：设法保证 I/O 缓冲器中的所有各块都不在 Cache 中。<ul><li>把 I/O 缓冲器的页面设置为不可进入 Cache 的，在进行输入操作时，操作系统总是把输入的数据放到该页面上。</li><li>在进行输入操作之前，操作系统先把 Cache 中与 I/O 缓冲器相关的数据“赶出”Cache，即把相应的数据块设置为“无效”状态。   </li></ul></li><li>硬件的方法<ul><li>在进行输入操作时，检查相应的 I/O 地址（I/O 缓冲器中的单元）是否在 Cache 中（即是否有数据副本）。</li><li>如果发现 I/O 地址在 Cache 中有匹配的项，就把相应的 Cache 块设置为“无效”。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>番茄炒蛋</title>
      <link href="/2020/05/12/essay/cookbook/%E7%95%AA%E8%8C%84%E7%82%92%E8%9B%8B/"/>
      <url>/2020/05/12/essay/cookbook/%E7%95%AA%E8%8C%84%E7%82%92%E8%9B%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>雖然這是道家常菜吧，但也不經常做。偶爾有一次效果不錯，所以記一下。<br><a id="more"></a><br><strong>口感</strong></p><ul><li>甜味爲主的風格</li><li>顏色可以算是鮮艷，絕對不用蔥子，導致色調只有紅色和黃色。</li></ul><p><strong>材料</strong></p><ul><li>一個雞蛋</li><li>一個番茄</li><li>少量姜</li></ul><p><strong>步驟</strong></p><ul><li>打蛋放鹽，放置一段時間</li><li>番茄滾刀切成大塊，撒上白砂糖放置一段時間，儘量將白砂糖塗抹均勻</li><li>放油炒熱，多放些油避免粘鍋</li><li>倒入雞蛋，儘量攤開</li><li>迅速倒入番茄，炒</li><li>用鏟子把番茄切開，小火炒，讓番茄逐漸變軟</li><li>待到顏色看起來像樣子了就能起鍋</li></ul><p><strong>實驗失敗經歷</strong></p><ul><li>按照上述方式，成功完成一次，可喜可賀</li></ul>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 食譜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语音频谱处理</title>
      <link href="/2020/05/10/course/DSP/%E8%AF%AD%E9%9F%B3%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/10/course/DSP/%E8%AF%AD%E9%9F%B3%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>叠加原理</li><li>卷积同态系统</li><li>复倒谱和倒谱</li><li>复倒谱的计算</li><li>语音信号的倒谱分析</li><li>计算 MFCC 系数<a id="more"></a>  </li></ul><h2 id="1-广义叠加原理"><a href="#1-广义叠加原理" class="headerlink" title="1. 广义叠加原理"></a>1. 广义叠加原理</h2><p>对于线性系统，使用卷积或者乘法代替线性系统的叠加原理，即：</p><script type="math/tex; mode=display">H[x(n)]=H[x_1(n)*x_2(n)]=H[x_1(n)*x_2(n)]=y_1(n)*y_2(n)=y(n)</script><h2 id="2-卷积同态系统"><a href="#2-卷积同态系统" class="headerlink" title="2. 卷积同态系统"></a>2. 卷积同态系统</h2><p>卷积同态系统由三部分组成：</p><ul><li>特征系统：$D_*[]$</li><li>线性系统：$L[]$</li><li>逆特征系统：$D_*^{-1}[]$</li></ul><p><strong>$D_*[]$</strong><br>输入是若干信号的卷积，输出为若干信号的加法组合。有以下的特性</p><script type="math/tex; mode=display">D_*[x(n)]=D_*[x_1(n)*x_2(n)]=D_*[x_1(n)]+D_*[x_2(n)]=\hat{x}_1(n)+\hat{x}_2(n)=\hat{x}(n)</script><p><strong>$L[]$</strong><br>服从叠加原理：</p><script type="math/tex; mode=display">L[\hat{x}(n)]=L[\hat{x}_1(n)+\hat{x}_2(n)]=L[\hat{x}_1(n)]+L[\hat{x}_2(n)]=\hat{y}_1(n)+\hat{y}_2(n)=\hat{y}(n)</script><p><strong>$D_*^{-1}[]$</strong><br>变换回卷积组合：</p><script type="math/tex; mode=display">D_*^{-1}[\hat{y}(n)]=y(n)</script><p>卷积同态的实现方法。利用 Z 变换，可以将卷积组合变为乘法，利用对数特性，将乘法组合变为加法，用此构成同态系统的特征系统$D_*[]$。其逆同态则是将取对数转化为指数运算。</p><center><img src="/images/Single/逆卷积.jpg" width="50%" height="50%" /></center><p><strong>同态系统的用途</strong></p><ul><li>将二个信号通过卷积（或乘积）合成的信号分开，是一种非线性处理方法。</li><li>对语音信号来说，同态处理的目的是将激励和声道分开，然后再分别进行研究<ul><li>对激励进行研究，可以确定语音片段是清音、浊音及浊音的基音频率等特征</li><li>对声道进行研究，可以确定声道特性及共振峰等特征</li></ul></li></ul><h2 id="3-复倒谱和倒谱"><a href="#3-复倒谱和倒谱" class="headerlink" title="3. 复倒谱和倒谱"></a>3. 复倒谱和倒谱</h2><p>设信号$x(n)$的 Z 变换为$X(z)$，其对数为$\hat{X}(z)=lnX(z)=ln[z[x(n)]]$。<br>那么$\hat{X}(z)$的逆变换为$\hat{x}(n)=z^{-1}[\hat{X}(z)]=z^{-1}[lnz[x(n)]]$</p><p><strong>复对数的多值性问题</strong><br>在复倒谱分析中，Z 变换得到的是复数，所以取对数涉及复对数运算，存在相位多值性问题，称为<strong>相位卷绕</strong>。</p><blockquote><p>例如：对于a为正实数，b为负实数，$ln(ab)=ln(a|b|e^{jk\pi})=ln(a)+ln(|b|)+jk\pi$。</p></blockquote><p>在计算复倒谱时，应保证复对数函数的单值性，满足广义叠加原理，且要选定<strong>收敛域</strong>以保证逆 z 变换的唯一性。</p><p><strong>注意</strong><br>在计算倒谱的情况下，信号经过同态处理的正、逆特征系统后，不能还原自身！因为此时只有幅值信息，丢掉了相位信息。对语音信号分析来说，因为人的听觉系统对频谱幅值敏感，对相位不敏感，所以倒谱分析可以用于语音信号。</p><p>如果对$X(e^{jw})$的绝对值取对数，得</p><script type="math/tex; mode=display">\hat{X}(e^{jw})=ln|X(e^{jw})|</script><p>求出的倒谱频称为<strong>实倒谱</strong>，即</p><script type="math/tex; mode=display">c(n)=\frac{1}{2\pi}\int^{\pi}_{-\pi}ln|X(e^{jw})|e^{jwn}</script><h2 id="4-复倒谱的计算方法"><a href="#4-复倒谱的计算方法" class="headerlink" title="4 复倒谱的计算方法"></a>4 复倒谱的计算方法</h2><p>设信号为$x(n)=x_1(n)*x_2(n)$，<br>则其傅里叶变换：</p><script type="math/tex; mode=display">X(e^{jw})=lnX_1(e^{jw})+lnX_2(e^{jw})</script><p>其幅度为：</p><script type="math/tex; mode=display">ln|X(e^{jw})| =ln|X_1(e^{jw})|+ln|X_2(e^{jw})|</script><p>相位：</p><script type="math/tex; mode=display">\phi(w)=\phi_1(w)+\phi_2(w)</script><p>这被称为相位缠绕。</p><h3 id="4-1-微分法"><a href="#4-1-微分法" class="headerlink" title="4.1 微分法"></a>4.1 微分法</h3><p>信号$X(n)$和倒频谱$\hat{x}(n)$的计算方法：</p><script type="math/tex; mode=display">j\frac{d}{dw}X(e^{jw})=\sum nx(n)e^{-jwn}</script><script type="math/tex; mode=display">j\frac{d}{dw}\hat{X}(e^{jw})=\sum n\hat{x}(n)e^{-jwn}</script><script type="math/tex; mode=display">\hat{X}(e^{jw})=lnX(e^{jw})</script><p>有：</p><script type="math/tex; mode=display">    \begin{aligned}        j\frac{d}{dw}\hat{X}(e^{jw})        &= j\frac{d}{dw}[lnX(e^{jw})]\\        &= \frac{j\frac{d}{dw}[X(e^{jw})]}{X(e^{jw})}\\        &=\sum n\hat{x}(n)e^{-jwn}    \end{aligned}</script><center><img src="/images/Single/int.jpg" width="50%" height="50%" /></center><p>这样就避开了复对数运算。但<strong>缺点</strong>是，$nx(n)$的高频分量较$X(n)$更多，按照原采样频率进行分析回导致频率混叠问题。</p><h3 id="4-2-最小相位信号法"><a href="#4-2-最小相位信号法" class="headerlink" title="4.2 最小相位信号法"></a>4.2 最小相位信号法</h3><p>被处理的信号$x(n)$是<strong>最小相位信号</strong>：Z 变换的全部几点和零点都位于 Z 平面单位元内部的信号，本质上是指具有<strong>最小相位延迟的序列信号</strong>。在实际应用中，许多信号是最小相位信号，或可以看作是最小相位信号。语音信号的模型就是极点都在 z 平面单位圆内的全极点模型，或者极零点都在 z 平面单位圆内的极零点模型。</p><p>设$x(n)$为最小相位信号，则$\hat{x}(n)$为因果稳定序列。</p><script type="math/tex; mode=display">\hat{x}(n)=\hat{x}_e(n)+\hat{x}_o(n)</script><script type="math/tex; mode=display">\hat{x}_e(n)=\frac{1}{2}[\hat{x}(n)+\hat{x}(-n)]</script><p>则有：</p><script type="math/tex; mode=display">\Phi[\hat{x}_e(n)]=\frac{1}{2}[\hat{X}(e^{jw})+\hat{X}(e^{-jw})]=\hat{X}_R(e^{jw})</script><p>该式不包含相位信息。</p><p><strong>注</strong>：原序列的实偶对称序列的傅里叶变换等于原序列的傅里叶变换的实部。</p><script type="math/tex; mode=display">    \begin{aligned}        \hat{X}(e^(jw))        &= \hat{X}_R(e^{jw})+j\hat{X}_I(e^{jw})\\        &= ln|X(e^{jw})|+j{arg[X(e^{jw})]+2k\pi}\\    \end{aligned}</script><p>则$ln|X(e^{jw})| =\Phi[\hat{x}_e(n)]$。<br>又由于：$\hat{x}_e(n)=\frac{1}{2}[\hat{x}(n)+\hat{x}(-n)]$且$\hat{x}(n)$是一个因果序列，可得</p><script type="math/tex; mode=display">    \hat{x}(n)=\left\{    \begin{aligned}    0,~~~n<0 \\    \hat{x}_e(n),~~~n=0\\    2\hat{x}_e(n), ~~~n>0    \end{aligned}    \right.</script><center><img src="/images/min.jpg" width="50%" height="50%" />最小相位法求复倒谱原理</center><h2 id="5-语音信号的倒谱分析"><a href="#5-语音信号的倒谱分析" class="headerlink" title="5. 语音信号的倒谱分析"></a>5. 语音信号的倒谱分析</h2><p>根据语音信号产生的线性模型，语音信号由激励信号与声道冲激响应<strong>卷积</strong>产生的，<strong>解卷积</strong>就是将卷积分量分开，可采用同态解卷积的方法。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语音信号 -&gt; 同态解卷积分析 -&gt; 分离出激励信号和声道冲激信号相应</span><br></pre></td></tr></table></figure></p><ul><li>对声门激励信号进行分析，以判断浊音、清音以及浊音的基音频率</li><li>对声道冲激响应进行分析，以判断声道特性及共振峰</li></ul><p><strong>5.1 声门激励信号的倒谱</strong><br>声门激励信号（浊音）：$e(n)=\sum_{r=0}^M\alpha_r\delta(n-rN_P)$<br>对其进行Z变换得：</p><script type="math/tex; mode=display">E(z)=\alpha_0\Pi_{r=1}^M[1-\beta_r(z^{N_P})^{-1}]</script><p>* <strong>此处的$\beta 可以通过\alpha 求得$</strong></p><script type="math/tex; mode=display">\hat{E}(z)=ln[E(z)]=ln\alpha_0-\sum_{r=1}^M[-\sum_{k=1}^{\infty}\frac{\beta_r^k}{k}(z^{N_P})^{-k}]</script><p>求 z 反变换获得倒谱：</p><script type="math/tex; mode=display">\hat{e}(n)=loga_0\delta(n)+\sum_{k=1}^{\infty}\beta'_k\delta(n-kN_P)</script><p>一个周期冲激的有限长度序列，其倒谱也是<strong>周期冲激序列</strong>，且周期长度是$N_P$不变，只是信号长度成为无限长，振幅随 k 增加而衰减。当声门激励为浊音时，其倒谱只在$kN_P$诸点上不等于 0，其它均为零，那么第一个非零点和原点的距离就是<strong>基音周期</strong>。</p><p><strong>5.2 声道冲激响应的倒谱</strong><br>用极零点模型描述声道响应，其 Z 变换如下：</p><script type="math/tex; mode=display">X(z)=Az^{-r}\frac{\Pi^{M_i}_{k=1}(1-a_kz^{-1})\Pi_{k=1}^{M_o}(1-b_kz)}{\Pi^{N_i}_{k=1}(1-c_kz^{-1})\Pi_{k=1}^{N_o}(1-d_kz)}</script><p>a, c为单位圆内零极点；反之为单位圆外零极点。$z^{-r}$：序列相对于时间原点的延迟。<br>单位圆内的零极点形成复倒谱的右边；单位圆外的零极点形成复倒谱的左边；在原点的值取决于增益。复倒谱通常是双边的，且是比例因子为1/n的衰减指数之和。<br>$\hat{X}(z)$的复对数为：</p><script type="math/tex; mode=display">\hat{X}(z)=ln(A)+ln(z^{-r})+\sum_{k=1}^{M_i}ln(1-a_kz^{-1})+\sum_{k=1}^{M_o}ln(1-b_kz^{-1})\\-\sum_{k=1}^{N_i}ln(1-c_kz^{-1})-\sum_{k=1}^{N_o}ln(1-d_kz^{-1})</script><p>我们希望上式逆 Z 变换是稳定序列，即绝对可求和，即使<strong>ROC</strong>包括单位圆。$\hat{X}(z)$的 RoC：</p><center><img src="/images/Single/Roc.jpg" width="50%" height="50%" />Roc</center><p>其复倒谱：</p><script type="math/tex; mode=display">    \hat{x}(n)=\left\{    \begin{aligned}    ln[A],~~~n=0 \\    \sum_{k=1}^{N_i}\frac{c_k^n}{n}-\sum_{k=1}^{M_i}\frac{a_k^n}{n},~~~n>0\\    \sum_{k=1}^{M_o}\frac{b_k^{-n}}{n}-\sum_{k=1}^{N_o}\frac{d_k^{-n}}{n}, ~~~n<0    \end{aligned}    \right.</script><h2 id="6-基于听觉特征的MEL频率倒谱系数"><a href="#6-基于听觉特征的MEL频率倒谱系数" class="headerlink" title="6. 基于听觉特征的MEL频率倒谱系数"></a>6. 基于听觉特征的MEL频率倒谱系数</h2><p>一种常用的语音特征：<strong>MFCC</strong> （mel frequency cepstrum coefficient）</p><p>人耳能在嘈杂的环境中分辨各种声音 -&gt; 耳蜗起到重要作用 -&gt;耳蜗相当于滤波器组 -&gt;作用：在对数频率尺度上进行滤波 -&gt;对低频信号敏感。基于上述原理，得到类似与耳蜗的滤波器组：Mel 频率滤波器组。Mel 频率：$f_{mel}=2595\times log(1+f/700)$</p><p><strong>MFCC 计算</strong>:</p><ul><li>分帧 -&gt; 预加重 -&gt; 加汉明窗 -&gt; 短时傅里叶变换 -&gt; 得到频谱；</li><li>求频谱平方，即能量谱，用 M 个 Mel 带通滤波器进行滤波；</li><li>对每个滤波器的输出取对数，得到相应频带的对数功率谱，并进行反离散馀弦变换，得到 L 个 MFCC 系数，一般 L 取 12 ~ 16 个左右。MFCC 系数为：<script type="math/tex; mode=display">C_n=\sum_{k=1}^Mlogx'(k)cos[\pi(l-0.5)n/M],~~~n=1, 2, ..., L</script></li><li>将直接得到的 MFCC 特征作为静态特征，再做一阶和二阶差分，得到相应的动态特征。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致我的第一幅眼鏡</title>
      <link href="/2020/05/08/essay/%E7%9C%BC%E9%95%9C_%E7%89%A9%E5%BF%97%E9%93%AD/"/>
      <url>/2020/05/08/essay/%E7%9C%BC%E9%95%9C_%E7%89%A9%E5%BF%97%E9%93%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-gplDXSsR" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="401804976" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>雖然勉強還能繼續使用這副眼鏡，但他已經在修補之後一個月不到的時間之後又裂開了。他可能累了吧。我想這麼多年過去了，他的使命差不多可以在這裡結束了？<br><a id="more"></a>  </p><center><img src="/images/Things/glasses.jpg" width="50%" height="50%" />我的眼鏡</center><p>這幅眼鏡是我的第一幅眼鏡，外觀相當樸素，從初中開始一直到現在大三的時候，中間從未換過。儘管中途因爲升度數換過幾次鏡片，但鏡架總沒有換過。也不是只有這一副眼鏡，但平時大多數時候帶的都是這一副，備用的眼鏡總覺得這裡那裡不舒服。本來是全黑的一副眼鏡，卻因爲戴的時間長，眼鏡腿什麼的已經差不多磨成透明的了。尤其是中梁那裡，可能是個人習慣性推鏡架吧，那裡變得尤其的光滑而透明。之前有同學表示過難以置信：這居然原來是黑色的部分。現在他的鏡框折了，鏡片總希望從裡面逃出來。我想他差不多能休息了吧，遇上這麼一個主人。</p><p>想起最早的時候，我總是把他放在眼鏡盒裡，直到上課前才拿出來，用眼鏡布反覆擦拭幾遍，然後小心地戴上，一到下課便立刻取下來又放回原來的盒子裡。但是後面慢慢度數高了，便也只能一直戴着，慢慢地擦拭得也少了，眼鏡盒也不翼而飛……後面我知道不應該用眼鏡布擦，於是用水沖洗。直到最近我端詳它的表面的時候，已經發現了不少細密的紋路覆蓋在眼鏡片上。我想這對視力可能不太好吧？</p><p>這副眼鏡陪我看過了很多的東西——可能我所知道的一切事務中的一半，我的眼鏡也知道吧…真的是很長的一段時間…幾乎現在是我身邊陪伴我的時間最長的東西，特別是對於一個熄燈後才摘下眼鏡，一睜眼就帶上眼鏡的人來說。</p><p>感謝你替我看見的世界。請休息了吧！</p><p>—— 致我的第一幅眼鏡</p><p>廙水</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物志銘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX在Hexo中的渲染</title>
      <link href="/2020/05/03/tech/LaTeX/%E5%9C%A8Hexo%E4%B8%8B%E7%9A%84%E6%B8%B2%E6%9F%93/"/>
      <url>/2020/05/03/tech/LaTeX/%E5%9C%A8Hexo%E4%B8%8B%E7%9A%84%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>该段落处理$\LaTeX$无法顺利在 Hexo 中渲染的问题。以下为上一次尝试且成功的步骤。<br><a id="more"></a>  </p><p>Hexo 默认的渲染引擎为 hexo-renderer-marked，这里将其更换为 hexo-renderer-kramed，该引擎在前者的基础上修复了一些 bug，具体操作：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">uninstall</span> hexo-renderer-marked <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-kramed <span class="comment">--save</span></span><br></pre></td></tr></table></figure></p><p>修改 marked.js。具体修改方式，用编辑器打开 marked.js（在./node_modules/kramed/lib/rules/inline.js 中）<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([<span class="string">\\`*&#123;&#125;\[\</span>](<span class="link"></span>)# +\-.!_&gt;])/, //替换掉</span><br><span class="line">escape: /^\\([<span class="string">`*\[\</span>](<span class="link"></span>)# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure></p><p>同时<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">em: /^<span class="symbol">\b</span>_((?:[^_]|__)+?)_<span class="symbol">\b</span>|^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,  //替换掉</span><br><span class="line">em:/^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br></pre></td></tr></table></figure><br>这样应该就能成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX常用语法</title>
      <link href="/2020/05/03/tech/LaTeX/%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/05/03/tech/LaTeX/%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为最近一段时间有使用$\LaTeX$写公式的需要，所以专门在这里整理一些常用的公式写法，防止后面反复查询。<br><a id="more"></a>  </p><h3 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h3><ul><li><code>\infty</code>: $\infty$</li><li><code>\ge</code>: $\ge$</li><li><code>\le</code>: $\le$</li><li><code>\pm</code>: $\pm$</li><li><code>\int</code>: $\int$</li><li><code>\prod</code>: $\prod$</li><li><code>\arg\mathop{\max}_{\theta}</code>: $\arg\mathop{\max}_{\theta}$</li></ul><h3 id="常用等式"><a href="#常用等式" class="headerlink" title="常用等式"></a>常用等式</h3><p>连等式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">    A &amp;&#x3D; B+C\\</span><br><span class="line">    &amp;&#x3D;C+D\\</span><br><span class="line">    &amp;&#x3D;D+F</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">    \begin{aligned}        A &= B+C\\        &=C+D\\        &=D+F    \end{aligned}</script><hr><p>大括号等式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X_p(w)&#x3D;\left\&#123;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">    \frac&#123;1&#125;&#123;2j&#125;,~~~w&#x3D;\frac&#123;\pi&#125;&#123;2&#125; \\</span><br><span class="line">    -\frac&#123;1&#125;&#123;2j&#125;,~~~w&#x3D;-\frac&#123;\pi&#125;&#123;2&#125; \\</span><br><span class="line">    0, ~~~otherwise</span><br><span class="line">    \end&#123;aligned&#125;</span><br><span class="line">\right.</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">    f(x)=    \begin{cases}        0& \text{x=0}\\        1& \text{x!=0}    \end{cases}</script><p>$$</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>簡單的坡縣遊歷</title>
      <link href="/2020/04/27/essay/tour/%E5%9D%A1%E5%8E%BF%E6%B8%B8/"/>
      <url>/2020/04/27/essay/tour/%E5%9D%A1%E5%8E%BF%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在坡縣交流了一學期，這裡是提交給學校的坡縣經驗的副本，先做一個小記。可能以後會突發奇想補充一個更自由一點的記敘，如果我還有那個時間的話。如果有什麼當時留下的照片什麼的也先留在那個版本裡吧。</p><a id="more"></a><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>因爲 CSC 的緣故，被禁足在了新加坡本地，所以沒有機會去馬泰遊玩，不過在本地的生活也是很愜意的。</p><h3 id="住"><a href="#住" class="headerlink" title="住"></a>住</h3><p>據說 NOC 的同志因爲學校 NUS 宿舍裝修種種原因不能住在校內，於是我們大部分人都住在離學校有一些距離的 MDIS，需要早上坐大概半小時的車到 NUS 校區。樓下有一個食閣，但是周末幾乎不開，幸好附近步行一刻鐘處有一個社區的食閣，周末能去吃。除此之外，其他的東西都還算方便，不過剛到寢室的時候，還是不免一陣吐槽，畢竟大家都是抱着體驗單人間的生活入住的 hhh。</p><p>新加坡無盡的夏日還是讓人頭疼的，雖然可以一直穿涼鞋短袖也很爽。不過長袖幾乎是必備的東西，因爲室內的空調溫度相當的低，比如 Science Lib。</p><p>這裡和中國的文化差異並沒有想象中的那麼大。但這確實是個多元的地方，有各種各樣的宗教文化、飲食文化並完全不用顧慮歧視種種問題。</p><h3 id="食"><a href="#食" class="headerlink" title="食"></a>食</h3><p>食物開銷是除了住宿以外的大頭。新加坡的食物很多樣，但算不上太好吃，驚艷者甚少。作爲學生，最常接觸的是食閣，幾乎 NUS 校區每個片區都有一個，裡面囊括了各個地方的食物，西餐、雜菜飯、海南雞米飯、叉燒面、日料是幾乎每個食閣都有的東西。不過水準價格皆參差不齊。全校最好的是 UTown 的兩家，但是略貴一點。一般在校內一餐消費在 4 刀到 10 刀不等。在校外消費的話，普通食閣 5 刀左右，下館子得 15 刀起步。</p><p>新加坡當地的食物，可以算是十分奇特。<strong>釀豆腐</strong>，一種白水煮豆腐，裡面可以加蔬菜、肉製品煮成一團，一些可以加辣醬和叻沙調味，這個東西的價錢是按「件」算的，比如一塊豆腐就是 5 毛。<strong>叻沙</strong>，一種調味料？大概是一種椰汁熬出來的辣醬，完全不能被我所接受，但是似乎有不少同學喜歡？這個東西傳出的魚腥味能散布整個商場。最早一次是在新加坡的 Changi Airport 見到這個東西，被它的味道勸退了。<strong>辣螃蟹</strong>，十分昂貴的一種食物，大多是遊客來吃的。不過味道很有趣，值得一試。甜辣甜辣的，類似國內一些菜品。此外還有肉骨茶等一些食物，沒有嘗試就不多說了。</p><p>然後是新加坡的中國菜。新加坡或許能偶爾找到挺正宗的中國菜館，但大抵會讓人失望。這邊主要是火鍋和港式/廣式的茶餐廳，仔細找找能找到不錯的。這邊幾乎每個食閣都有叉燒面和雜菜飯。叉燒面穩穩全食閣最價廉主食，一般是面上放幾塊叉燒；雜菜飯和復旦的食堂相似，爲自選菜。火鍋有點貴，香天下和海底撈等都有，還有一些本地的火鍋。</p><p>此外，日料、馬來菜、印度菜、西餐都很多。坡上似乎有不少不錯的日料，我在讀期間找到了一家網紅鰻魚飯，吃完滿滿的滿足。還有日語課老師安利的迴轉壽司之類的，好店需要自己多找找。</p><p>本地有吃完飯和飲料的習慣。所以每個食閣都會有飲品店，賣的一般是 Koppi（馬來語的咖啡，還有些類別，比如 Kopi O，Kopi Kosong 等等），還有各種鮮榨果汁，薏米水，還有一個叫 Milo 的飲料，味道和高樂高很像，深受當地人歡迎。令人疑惑的是一瓶可樂賣 1.9 刀，但是在 711 打折的時候，也有 1 刀的，並長期處於打折。</p><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>騎車是不可能騎車的。坡縣不愧坡縣，一路都是上上下下，在校區內更是不能騎車，因爲學院大都建在山包包上。共享單車類似摩拜有，但是非常少，幾乎不可用。有共享電動車，但是看起來非常危險，我聽到過新加坡同學吐槽這東西有多危險。</p><p>主要出行是靠公交車。公交車需要自己按按鈕下車，前方到站是不會在車內通報的，需要自己留意。一趟公交車並不便宜，在 1 刀左右，有起步價和同站換乘優惠。坡縣內公交車網路非常密集，幾乎可以利用公交車到大部分位置。</p><p>坡縣地鐵還是挺便利的，不過線路密度不如上海，很多時候還是靠公交車方便。地鐵價格和公交車相似。</p><p>步行也是相當友好的。新加坡的道路旁一般建有走廊，走在下面不會被太陽曬也不會被雨淋，很舒適。校內連廊四處都是，樓與樓之前幾乎不會有雨淋的風險。</p><p>校內通行主要靠小車.校車有專門的 app，如果選課不幸四處都有的話，坐校車就會是家常便飯了。因爲每個學院都是分得比較開，所以不同學院的課一般避不了校車。不過很多 Tut 的選項會有不同的位置可選，所以儘量選自己方便的 Tut 上吧。</p><h3 id="浪"><a href="#浪" class="headerlink" title="浪"></a>浪</h3><p>新加坡好玩的地方不算太多，就那幾個，一會就能逛完。不過可以趁着兩次 Recess Week（期中和期末的一周複習周，學校強制不能在複習周中安排作業）去周圍的國家轉轉。也可以和同去的小夥伴約在東海岸燒烤，同時坡縣有諸多可以徒步的地方。此外新加坡的音樂會雖然不太多，但是票價便宜容易買到。就算是只提前一周也能買到低價的 5~8 排的黃金座位。</p><p>此外這裡的建築相當有特色，各種奇形怪狀，並帶有誇張色塊的建築隨處可見。而且植被非常之好，很多樓頂或者樓內都攀爬着綠色植被。就算是在 NUS 裡面也是充滿了綠色植被，甚至學校中央是一片有野猴子和野雞出沒的小山包，無愧花園城市之名。</p><p>如果是秋季來可以趕上聖淘沙萬聖節的鬼屋活動和國慶煙花，都是可以去湊熱鬧的不錯的選擇。</p><h2 id="學習"><a href="#學習" class="headerlink" title="學習"></a>學習</h2><h3 id="關於選課"><a href="#關於選課" class="headerlink" title="關於選課"></a>關於選課</h3><p>選課上限 5 門。最開始可能自己申請的課都會被踢掉，但是不用擔心，後續的申請很寬鬆，想要的課一般都能拿到。雖然上限只有 5 門課，但是並不輕鬆。以日語課爲例，一周有 2h 的 lecture 和兩次各 2h 的 tutorial，以及對應的課程作業，預計一周的工作量接近 8~10h。</p><h3 id="專業課"><a href="#專業課" class="headerlink" title="專業課"></a>專業課</h3><p>專業課分爲偏應用的和偏理論的。理論課程會有很多的例子，一般一個公式就會跟着大量的例子去說明（不過很多時候說明挺累贅的，如果懂了就可以自己看着走。）實踐課程會有很多 lab 和 pj，不過這些項目描述都很成型，基本沒有歧義，按着老師的要求做就能做出不錯的東西，當然還可以在此基礎上繼續發揮。期末考試不算太難，平時認真應該就不會翻車。</p><h3 id="語言課"><a href="#語言課" class="headerlink" title="語言課"></a>語言課</h3><p>NUS 的語言課真的超良心。以日語課爲例，課程由一周一個 lecture 和兩個 tutorial 組成。Lecture 是老師講解知識點，tutorial 是由助教老師帶領同學互相對話，調整發聲和學習句子的使用等等。Tutorial 人數一個班十個人左右，因爲不斷換着換着 partner，所以氛圍超有愛。到課程後半段之後就大家邀請老師一起愉快聚餐 Utown，中間還有兩次蹭到了高貴的 Yale 學院的伙食，大家吃飯時聊天的話題也和國內完全不一樣。</p><h3 id="自習"><a href="#自習" class="headerlink" title="自習"></a>自習</h3><p>自習一般不愁找不到地方。在 CS 樓附近是 Central Lib，雖然我在的期間在維護，但還是很大了，插座也很多。Lib 裡面自帶午休室和小躺椅。然後是 Science 附近的 Science Lib。這個 Lib 並不好找，需要專門尋覓一下，在某棟樓的四樓。該 Lib 人不多，異常地冷，插座不多，有的時候會找不到空的插座。其次是 Utown 的各個 Commons，PC Commons 和 Mac Commons 都是好去處，安靜，並且有配好的台式機能用。問題是座位很少，周末一般找不到（除非去很早）。所有 Lib 都是周六開放半天，周日不開，平時也關的很早，可能是建議大家不要只是學習吧？並且 Central Lib 和 Commons 都是打印文件便利的地方。因爲我在實驗室板搬磚，所以也常常在實驗室里的小工位幹活。</p><h2 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h2><h3 id="進組"><a href="#進組" class="headerlink" title="進組"></a>進組</h3><p>到了 NUS 後不久，還沒開學之前，我就聽學長的建議開始在 CS 學院裡找合適的 Prof，希望加到 Prof 的實驗室做一些事情。於是大膽地寫了一封郵件附帶一個完全沒有經歷的 CV。萬幸的是，我發的第一個 Prof 就回復了我，讓我自己在組裡找一個自己喜歡的項目加進去。於是找來找去聯繫了以爲中國的學長，幾封郵件來往，相談甚歡，於是就進組啦。整個學期都在和另一位 master 一起做 NLP 的事情。</p><h3 id="困難"><a href="#困難" class="headerlink" title="困難"></a>困難</h3><p>儘管很順利地進組了，但還是有諸多的問題。其一是國外的交流環境和國內很不一樣，很多東西都是不斷地請教學長菜慢慢摸清楚；其二是組會裡面大家討論的問題用的語速比上 lecture 的 Prof 快了不止一點，真的常常聽不懂。</p><p>最大的問題其實是時間平衡和心態調整。泡實驗室真的很耗時間，一般我作業做完了的周末或者課少的工作日都是泡在實驗室調代碼看數據，自己的時間確實很少了。中途沒有去太多地方玩，也沒能去馬泰一圈。甚至到了期中季也只能請到幾天的假，我期末季剛結束的那個周末就再次回到崗位了。並且就算是花了這麼多時間，也不一定會有成效，經常在實驗室泡了一天心態真的挺崩的。我還記得有一次和 master 一起調代碼到了凌晨五點，是真的辛苦。不過每一次看到有一點點進步都會是由衷的喜悅。</p><h3 id="體驗-amp-收穫"><a href="#體驗-amp-收穫" class="headerlink" title="體驗&amp;收穫"></a>體驗&amp;收穫</h3><p>儘管前面說得這麼辛苦，但還是覺得實驗室值得一去。而且交流期間進組很容易的，一般給老師說一下，他們都不會拒絕。但是做多少事情，大多就是靠自覺。Prof 很親和，會邀請你在組會上提出問題，偶爾也會問你幾個問題。每次組會整個組會一起去附近的食閣聚餐，吃飯完後 Prof 會請客一人一杯飲料。</p><p>也深刻體會到了科研生活的艱辛和不易，也算是完成了一個科研周期吧。總之收穫頗豐，代碼能力、越讀論文的能力、思辨能力都提升了不少。如果不像把這個學期用在四處遊山玩水上，泡在實驗室會是不錯的選擇。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>做一個簡單的總結吧。這是一個交流的好去處。不太大的文化差異、輕鬆的氛圍、各式各樣值得體驗的新鮮事物、難得的實驗室搬磚經歷都讓我在現在敲打這些文字時懷念這個美麗的城市。要說我唯一希望有所變動的地方，是那裡永不結束的夏季。</p><p>廙水</p><p>2020-04-27</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行跡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章:存储系统</title>
      <link href="/2020/04/24/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap5_storage/"/>
      <url>/2020/04/24/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap5_storage/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>存储系统的大纲。主要内容是 Cache 的特性及优化。</p><a id="more"></a><h2 id="5-1-存储系统基础"><a href="#5-1-存储系统基础" class="headerlink" title="5.1 存储系统基础"></a>5.1 存储系统基础</h2><ol><li>存储系统的层次结构<ol><li>要求：容量大、速度快、价格低</li><li>但是这三个要求相互矛盾</li><li>解决办法：采用多种存储器技术，构成多级存储层次  <ol><li>利用程序的局部性原理：时间局部性&amp;空间局部性</li></ol></li><li>存储系统要达到的目标：整个存储系统的速度接近于最快的访问速度，而容量和单位价格接近于最大的存储器</li></ol></li><li>性能参数<ol><li>考虑两层存储层次<br>| $M_1$ | $S_1$（容量） | $T_1$（访问时间） | $C_1$（每单位价格） |<br>| ——- | —— | —— | —— |<br>| $M_2$ | $S_2$  | $T_2$  | $C_2$  |</li><li>整个存储系统的容量即为第二级存储器的容量，即$S=S_2$。</li><li>每单位价格$ C=\frac{C_1S_1+C_2S_2}{S_1+S_2} $。</li><li>命中率<ol><li>$ H=\frac{N_1}{N_1+N_2} $</li><li>$ N_1 $：访问$ M_1 $的次数</li></ol></li><li>平均访问时间$ T_A $<ol><li>$ T_A=HT_1+(1-H)(T_1+T_M)=T_1+(1-H)T_M $</li><li>不命中开销：$ T_M=T_2+T_B $。从向$M_2$发送访问请求到把整个数据块调入$M_1$所需的时间。</li><li>传送信息块的时间：$ T_B $。</li></ol></li></ol></li><li>三级存储结构<ol><li>三级存储系统<ol><li>Cache</li><li>主存储器</li><li>磁盘存储器</li></ol></li><li>“Cache-主存”层次和“主存-辅存”层次<ol><li>前一个层次弥补速度不足，由硬件实现</li><li>后一个层次弥补容量的不足，主要由软件实现</li></ol></li></ol></li></ol><h2 id="5-2-Cache基础"><a href="#5-2-Cache基础" class="headerlink" title="5.2 Cache基础"></a>5.2 Cache基础</h2><ol><li>基本构造和原理<ol><li>存储空间分割和地址计算</li><li>Cache 和主存<ol><li>Cache 是按照块进行管理的。其被分割为大小相同的块。</li><li>主存块地址：用于查找该块在 Cache 中的位置。</li><li>块内位移：用于确定数据在该块的位置。</li><li>地址串 = 块地址|块内位移</li></ol></li><li><img src="/images/Chap5-storage/cpuToCache.jpg" alt=""></li></ol></li><li>映像规则<ol><li>全相联<ol><li>空间利用率最高、冲突概率最小、实现最复杂</li></ol></li><li>直接映像：每一块只能放在 Cache 的一个位置<ol><li>空间利用率低、冲突概率高、实现简单</li></ol></li><li>组相联映像：分组<ol><li>低位被称为索引（对应组相联的组数/直接映像的块大小）</li><li>相联度 n</li></ol></li></ol></li><li>查找算法<ol><li>确定 Cache 中有需要的块</li><li>通过查找目录实现<ol><li>目录表：<br><img src="/images/Chap5-storage/menu.jpg" alt=""></li><li>并行查找：<ol><li>相联存储器：根据查到的组内块地址，从 Cache 中读出一个发送给 CPU</li><li>单体多姿存储器+比较器</li></ol></li></ol></li></ol></li><li>容量：$Cache=2^{index}\times 相联度\times 块大小$</li><li>过程<ol><li>写缓冲器：如果在进行写入操作时，写缓冲器不满，则可以把数据及完整地址交给写缓冲器。</li><li>读不命中：向 CPU 发送暂停信号，从下一级存储器调入数据块</li></ol></li><li>替换算法<ol><li>当新调入一块，而 Cache 又已被占满时，替换哪一块？</li><li>主要替换算法：随机法；FIFO；LRU</li><li>LRU 的实现：<ol><li>堆栈法：用一个堆栈来记录组相联 Cache 的同一组中各块被访问的先后次序。<ol><li>这个方法需要为每一个相联组准备一个小堆栈。</li><li>该方法速度低成本高</li></ol></li><li>比较对法<ol><li>让块两两组合，每一个比较对用一个除法器的状态表示所相关的两个块最近一次被访问的远近次序。</li><li>需要的硬件<ol><li>与门，数量等同块数目</li><li>触发器，和两两组合的比较对的数目相同 $=n(n-1) $</li></ol></li><li>当组内块数较多时，可以使用多级状态位技术减少所需的硬件量。</li></ol></li></ol></li><li>写策略<ol><li>写必须再确认命中之后才可以进行</li><li>写操作可能导致 Cache 和主存内容不一致</li><li>两种写策略：写直达法和写回法</li><li>两种策略的比较：写回法地速度快，使用的存储器的带宽较低；写直达法易于实现、一致性好</li><li>写直达法中，CPU 必须停顿，这个称为“CPU 写停顿”。（可以采用写缓冲器进行优化）</li><li>写操作的调块：写时取，先把所写旦苑所在的块调入 Cache；绕写法，直接写入下一级存储而不调块</li></ol></li><li>性能分析<ol><li>不命中率：与硬件速度无关</li><li>平均访存时间：平均访存时间 = 命中时间 + 不命中率 × 不命中开销</li><li>程序执行时间：CPU 时间 = ( CPU 执行时间 + 存储器停顿周期数 ) × 时钟周期时间<ol><li>存储器停顿周期数：“读”的次数 × 读不命中率 × 读不命中开销＋“写”的次数 × 写不命中率 × 写不命中开销</li><li>存储器停顿周期数＝访存次数 × 不命中率 × 不命中开销</li></ol></li><li>$CPI_{execution}$越低，固定周期数的 Cache 的不命中开销的相对影响就越大；在计算 CPI 时，不命中开销的单位是时钟周期数。因此，即使两台计算机的存储层次完全相同，时钟频率较高的 CPU 的不命中开销较大，其 CPI 中存储器停顿这部分也就较大。因此<strong>Cache 对于低 CPI、高时钟频率的 CPU 来说更加重要</strong>。</li></ol></li><li>改进 Cache 的性能<ol><li>平均访存时间 = 命中时间 + 不命中率 × 不命中开销</li><li>从三个方面改进性能：降低不命中率；减少不命中开销；减少 Cache 命中时间</li></ol></li></ol></li></ol><h2 id="5-3-降低Cache不命中率"><a href="#5-3-降低Cache不命中率" class="headerlink" title="5.3 降低Cache不命中率"></a>5.3 降低Cache不命中率</h2><p>提高 Cache 性能的方法是降低不命中率。本节介绍 8 种降低不命中率的方法。需要降低不命中率的方法都会增加命中时间或者不命中开销。因此，使用时需要综合考虑。</p><ol><li>三种类型的不命中<ol><li>强制不命中：第一次访问一个块，其不在 Cache 中。这种不命中称为冷启动不命中或访问不命中。</li><li>容量不命中：执行程序所需要的所有块不能同时调入 Cache，在程序运行时需要被重复调用。</li><li>冲突不命中：太多块映射到同一组，被重新访问的情况。</li><li>相联度越高，冲突不命中就越少；强制不命中和容量不命中与相联度无关；强制性不命中与 Cache 容量大小无关</li></ol></li><li>增加块的大小<ol><li>增加块的大小：增加了空间局部性，减少了强制不命中；同时减少了 Cache 中块的数目，导致冲突不命中上升；会增加不命中开销</li><li>当第二个作用超过第一个作用时，不命中率会上升</li></ol></li><li>增加 Cache 容量：该方法会增加成本，并增加命中时间</li><li>提高相联度<ol><li>8 路相连和全相联一样有效，故超过 8 的方案实际意义不大</li><li>2：1 经验规则：容量为 N 的直接映像 Cache 的不命中率和容量为 N/2 的两路相联的 Cache 的不命中率相似</li></ol></li><li>伪相联 Cache<ol><li>又称为列相联。获得多路相联的低不命中率，又能保持直接映像的命中速度。<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 先按直接相联的方式进行访问，如果命中则返回</span><br><span class="line">   <span class="number">2.</span> 如果不命中，则会检查另一个块上是否匹配</span><br><span class="line">      <span class="number">3.</span> 如果命中，则发生伪命中</span><br><span class="line">      <span class="number">4.</span> 如果不命中，则访问下一级存储器</span><br></pre></td></tr></table></figure></li><li>如果许多时候，命中发生在伪命中，则速度会变慢。一种简单的方法是，发生伪命中时交换两个块的位置。</li><li>这个方法会使 CPU 流水线设计复杂化，因此一般使用在离处理器较远的 Cache 上。</li></ol></li><li>硬件预取<ol><li>指令和数据都可以在处理器提出访问请求之前预取，可以将其放在 Cache 中或者放在访问速度较快的外部缓冲其中。</li><li>指令预取：一般由 Cache 之外的硬件完成。在一次不命中时，取出相邻的两块指令数据。被请求指令返回时放入 Cache，而预取的指令则放入高速缓冲器。下一次 Cache 访问不命中时，则可能可以通过访问高速缓存器获得信息。</li><li>预取建立在空闲带宽上。如果它影响了对于正常不命中的处理，则有可能会降低性能。可以利用编译器减少不必要的预取。</li></ol></li><li>编译器控制的预取<ol><li>它不是通过硬件预取，而是由编译器在程序中降入预取指令来实现的，这些指令在数据被用到之前，就将它们取到寄存器中去。</li><li>分为：寄存器预取；Cache 预取。</li><li>也可分为：故障性预取，如果出现虚地址故障或者违反保护权限，则会异常；非故障性预取，如果出现故障，则会放弃预取变为空操作</li><li>预取不会改变指令和数值之间的逻辑关系。</li><li>编译器预取的目的是要在执行指令和读取数据能重叠进行。循环是预取优化的对象。每一次预取需要消耗一次指令的开销。</li></ol></li><li>编译优化<ol><li>对于软件进行优化降低不命中率。这个方法的特点是不需要对硬件做出改动。</li><li>程序代码和数据重组：<ol><li>将程序中的过程重新排序，减少冲突不命中；将基本块对齐</li><li>如果编译器知道分支指令很可能转移，则可以<ol><li>将转移目标处的基本块和紧跟着该分支指令的基本块进行对调</li><li>把该分支指令换为操作语义相反的分支指令</li></ol></li><li>同时也可以对数据进行变换，例如调整顺序以改善空间局部性</li><li>编译优化技术包括数组合并、内外循环交换。数组合并是将本来相互独立的多个数组合并为一个复合数组；循环融合是把独立的循环融合为单个的循环</li></ol></li><li>内外循环交换：程序中包含的嵌套循环，并不是按照存储器中存储的顺序进行访问，这时需要交换嵌套关系。</li><li>分块：提高时间局部性来减少不命中。在一次循环中既有对行的访问，也有对列的访问</li></ol></li><li>牺牲 Cache：在 Cache 和下一级存储器的数据通路上增设全相联的小 Cache。这个 Cache 存储因为冲突被替换出去的块，当不命中发生时，在访问下一级存储器之前，先检查牺牲 Cache</li></ol><h2 id="5-4-降低Cache不命中开销"><a href="#5-4-降低Cache不命中开销" class="headerlink" title="5.4 降低Cache不命中开销"></a>5.4 降低Cache不命中开销</h2><p>随着技术的发展，Cache 不命中开销随时间不断增加。</p><ol><li>采用两级 Cache<ol><li>本技术不会印象 CPU</li><li>令第一级 Cache 和 CPU 的时钟周期匹配；第二级 Cache 足够大，能够捕捉大部分到达主存的访问</li><li>平均访问时间公式：<br>$平均访存时间 = 命中时间_{L1}+不命中率_{L1} \times 不命中开销_{L1}$<br>$不命中开销_{L1} = 命中时间_{L2}+不命中率_{L2}\times 不命中开销_{L2}$<br>即，访存时间为$平均访存时间 = 命中时间_{L1}+不命中率_{L1}\times(命中时间_{L2}+不命中率_{L2} \times 不命中开销_{L2})$</li><li>$局部不命中率=该级 Cache 的不命中次数/到达该级的访存次数$；$全局不命中率=该级 Cache 不命中次数/CPU 发出的访存次数$</li><li>对于第二级 Cache，其命中次数小于第一级 Cache，所以其重点放在减少不命中次数上，导致了更大的容量、更高的相联度和更大的块大小；第二级 Cache 不会影响 CPU 的时钟频率，因此设计有更大的考虑空间。</li></ol></li><li>读不命中优先<ol><li>对于写直达，每一次访问需要对主存进行写入。为了提高性能，设置一个写缓冲器，但是这个操作会导致储存访问的复杂化，因为所读单元的最新值可能正在写入</li><li>最简单方法是推迟对读不命中的处理，直至写缓冲器清空。而这个增加了读不命中的开销。</li><li>另一种策略是，检查写缓冲器，如果没有冲突则继续访问</li><li>对于写回 Cache 法，也可以利用写缓冲器。读不命中将替换一个修改过的储存块时，将被替换的块临时复制到一个缓冲器中，从存储器调块，再写入存储器</li></ol></li><li>写缓冲合并：对于写缓冲器。在写缓冲器不为空的情况下，需要将这一次写入地址和写缓冲器中地址进行比较，寻找匹配项：如果有地址匹配而对应的位置是空闲的，则将要写入的数据和该项<strong>合并</strong>。</li><li>请求字处理技术<br>本方法不用增加硬件。从存储器向 CPU 调入一块时，往往只有一个字是立刻需要的。请求字处理技术，就是着眼于这个特性，在 CPU 的请求的字到达后，CPU 不需要等待整个块调入，就将 CPU 重启并继续执行。有两种策略：<ol><li>尽早重启动：一旦请求字到达，就立刻发送给 CPU，CPU 重启继续执行</li><li>请求字优先：调块时先传递 CPU 需要的请求字，让 CPU 继续执行。<br>这个方法有效需要块相对大才能生效；以及下一个指令没有访问同一个块。</li></ol></li><li>非阻塞 Cache 技术<br>Cache 在不命中时仍允许 CPU 进行其他的命中访问，能处理部分的访问，减少了实际不命中开销。</li></ol><h2 id="5-5-减少命中时间"><a href="#5-5-减少命中时间" class="headerlink" title="5.5 减少命中时间"></a>5.5 减少命中时间</h2><p>直接印象时钟频率的高低。</p><ol><li>容量小、结构简单的 Cache：硬件越简单，速度越快；应让 Cache 足够小，以便可以和 CPU 放在同一个芯片上。</li><li>虚拟 Cache<br>采用虚拟存储器的计算机中，每一次访存都必须进行虚实转换，将 CPU 发出的虚地址转换为物理地址，这个一般是由存储部件 MMU 完成的。<br><strong>物理 Cache</strong>：使用物理地址访问的传统 Cache。其标识存储器中存储的是物理地址，地址检测使用的也是物理地址。CPU 需要访问时，先给出一个虚拟地址，由 MMU 转换为主存物理地址，再使用这个物理地址访问 Cache。<strong>缺点</strong>：地址转换和访问 Cache 是串行进行的，访问速度很慢。<br><strong>虚拟 Cache</strong>：可以直接用虚拟地址进行访问的 Cache，存储器中存储的是虚拟地址，检测的也是虚拟地址。当 CPU 访问存储器时，虚拟地址同时送给 MMU 和 Cache，Cache 找出相应的指令。如果 Cache 不命中，则需要 MMU 读出物理地址进行访问。虚拟 Cache 的优点是命中时不需要地址转换；并且不命中时也是并行的，速度更快。<br>但<strong>并不是</strong>所有的计算机都是用虚拟 Cache。其在进行切换时，需要清空 Cache，因为新进程的虚拟地址可能和原进程使用的地址相同。解决这个的方法可以是增加一个 PID，用于标识进程。在 PID 被重用的时候，仍然需要清空 Cache。<br>虚拟 Cache 没有流行的另一个原因。操作系统可能对一个物理地址有多种虚拟地址访问，这可能会导致虚拟 Cache 存在两个副本。</li><li>虚拟索引-物理标识方法<br>优点：兼得虚拟 Cache 和物理 Cache 的好处。<br>局限性：直接映像 Cache 的容量不能超过页面的大小。$Cache 容量\le 页大小\times 相联度$<br>直接用虚地址内的页内位移作为访问 Cache 的索引，但标识是物理索引。CPU 在发出访存请求后，在进行虚实转换的同时，可以进行标识的读取。在完成地址转换以后再比较物理地址和标识。其局限性是为了实现大容量 Cache，又能使索引数比较少，可以采用提高相联度的方法。</li><li>Cache 访问流水化：不能减少命中时间，但能增加带宽</li><li>追踪 Cache：存放 CPU 执行的动态指令序列</li></ol><h2 id="5-6-并行主存系统"><a href="#5-6-并行主存系统" class="headerlink" title="5.6 并行主存系统"></a>5.6 并行主存系统</h2><p>主存的性能主要用<strong>延迟</strong>和<strong>带宽</strong>衡量。第二级 Cache 很大，对主存带宽有一定要求。并行主存系统就是<strong>一个访问周期内能并行访问多个存储字的存储器</strong>，其能有效提高存储器的带宽。<br>对于一个单字宽普通存储器，其字长与 CPU 字长相同，每一次只能访问一个存储字。设其访问周期是$T_M$，字长为$W$，其带宽为：</p><script type="math/tex; mode=display">B_M=\frac{W}{T_M}</script><p>在相同器件条件下，为提高主存带宽，可以采用并行存储器结构：单体多字存储器和多体交叉存储器</p><ol><li>单体多字存储器。<ol><li>对于一个单体 m 字存储器，该存储器可以在每个存储周期读出 m 个 CPU 字，将其带宽提升为原来的 m 倍。但是由于程序执行访问的数据具有一定的随机性，所以实际带宽比最大带宽小。</li><li>优点是实现简单，确定是效率不高：<ol><li>如果提出的指令含有分支指令，且分支成功，则有一部分指令是无效的</li><li>当前指令所需要的多个操作数不一定在一个长存储字中</li><li>必须凑齐 m 个数才一起写入存储器。如果只写个别的字，则需要把相应的长存储字取出，放到数据寄存器中，再修改一个字放回存储器</li><li>如果独写数据在一个长存储字内时，读写操作无法在一个存储周期内完成</li></ol></li></ol></li><li>多体交叉存储器<ol><li>多体存储器由多个单体存储器构成，每一个体有自己的地址寄存器等电路。</li><li>设有 m 个体，每个体有 n 个存储单元。对于计算机使用者来说，存储器是按照顺序线性编址的，如何在二维矩阵和线性地址之间建立对应关系，就是多体存储器编址问题。</li><li>有两种编址方法：高位交叉编址和低位交叉编址。低位交叉编址才能解决访问冲突问题。高位交叉编址能方便地扩展常规存储器的容量<ol><li>高位交叉编址<ol><li>对存储单元矩阵按列优先方式进行编址，即先给第 0 列的各单元按从上到下的顺序依次赋予地址，然后按第一列赋予地址。对于同一个体的高$log_2m$位都是相同的，这就是体号。</li><li>对于第 i 行第 j 列，其地址为$A=j\times n+i$</li></ol></li><li>低位交叉编址<ol><li>先给第 0 行编码，然后从左到右赋予地址</li><li>同一个体的低$log_2m$位是相同的，这是体号</li><li>需要分时启动 m 个存储器。如果每个存储体的访问周期是$T_M$，则各个存储体的启动间隔是$t=T_M/m$。</li><li>采用低位交叉访问能大幅度提高存储器的带宽。由于访问冲突，实际加速比小于 m</li><li>$B=\frac{1-(1-\lambda)^m}{\lambda}$，$\lambda$为转移指令成功的概率。当$\lambda=1$时，并行多体交叉的实际带宽同单体单字并没有区别。由于数据的随机性，单纯依靠增大 m 来提高并行的带宽是有限的。对于标量运算，一般取$m\le8$</li></ol></li></ol></li></ol></li><li>避免存储体冲突<ol><li>体冲突：两个访问要求访问同一个存储体。</li><li>解决这个问题的方法是采用许多体去减少体冲突的次数。体冲突问题可以通过硬件解决也可以通过软件解决。</li><li>软件方法：循环优化法/拓展数组大小，使之不是 2 的幂次</li><li>硬件方法：使体数为素数。体内地址为$地址<del>mod</del>存储体中字数$</li></ol></li></ol><h2 id="5-7-虚拟存储器"><a href="#5-7-虚拟存储器" class="headerlink" title="5.7 虚拟存储器"></a>5.7 虚拟存储器</h2><ol><li>基本概念<br><strong>“主存-辅存”进一步发展的结果。</strong>由小主存储器和大的辅助存储器组成，在管理下像一个单一的、可以直接访问的大容量主存存储器。程序员可以使用地址码对整个程序进行编址，不需要考虑实际主存空间的大小。<br>虚拟存储器可以分为<strong>页式</strong>和<strong>段式</strong>。页式存储器把空间划分为<strong>大小相同</strong>的块，称为页面；段式把空间划分为<strong>可变长</strong>的块，称为段。此二者各有优劣。许多计算机采用段页式，每段被分为若干个页面。</li><li>快速地址转换技术<br>页表放在主存中，每一次访存会引起两次访问，第一次是访问页表，以获得数据的物理地址；第二次是访问数据。这个效率是不可用的，一般采用翻译后备（TLB）解决这个问题。<br><strong>TLB</strong>是一个专用高速缓存器，用于存放近期经常使用的页表项。TLB 是页表部分内容的一个副本。只有在 TLB 不命中时才会进入主存页表查询。TLB 中的项由两部分组成：标识和数据。标识放的是虚地址的一部分，而数据部分存放的是物理页帧号、有效位、使用位等。操作系统需要保证 TLB 中没有该页表项的副本。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冰上行</title>
      <link href="/2020/01/11/essay/tour/%E5%86%B0%E4%B8%8A%E8%A1%8C/"/>
      <url>/2020/01/11/essay/tour/%E5%86%B0%E4%B8%8A%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-UJukXPpR" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1210185" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>　　我原以爲冰是某種堅硬而強大的東西，可是在它遇到溫暖的時候，卻逃掉了。</p><p>　　這是在冰城的第六天了。這一小段時間，放在我在上海的生活，根本不值一提，它會顯得平庸單調而乏味；但在這裡，卻像是從宇宙誕生到終於坍縮那樣漫長而混亂。如果現在我試圖從任何一個角度去逼近在這幾日裡的自己所處的某一個瞬間，都會覺得匪夷所思，像是積累了很多年的頑疾在這一刻突然張牙舞爪，像是目睹了一個明知是自己編織的偉大夢境的崩壞。</p><a id="more"></a><p>　　坐在哈工大的一個藏在角落裡的咖啡廳，我決定把這幾日的事情記下來。我要記下來的或許不是什麼重要或者意義深刻的事情，而是僅僅是一些我沒有記在隨身小日記上的別的事情，甚至只是那些瑣碎平白的語言的補充。儘管我這樣費力地鋪墊這幾日中發生事件是如何地危險可怕、或者平凡無趣，但終究它是一場普通的旅程：這段旅程不論對於我還是別的什麼人，都是如此。</p><p>　　早上，我居然很早就起來了，比我平時起牀的時間早了不知道多久，我不想躺在牀上。我想站起來。外面依舊沒有下雪，但是雪滿滿覆蓋着每一個屋頂。我擡起我的手機想看些什麼，卻意識到我拿起的這部手機沒有連接網絡，連接着網絡的那台手機上沒有我想看的東西。想起這幾日尚未填寫的日記，再一陣肚子小痛，便拿着我沒有連着網絡的那部小手機小心翼翼地進了廁所。</p><p>　　我從房間門出來，看見隔壁正睡得舒適的三弟。他側向有太陽射着的一面，他的被子皺成一團，很好地蓋住了上半身，兩隻腿卻從被子下支了出來，幾縷稀疏的頭髮很亂地疊在頭上。我不打算吵醒他——在他醒了之後便要工作了，還是讓他多睡會吧。於是悄悄地，我進入了廁所開始補上前幾天的日記。</p><p>　　補完日記的我再一次躺在了牀上。很安靜的空間，很自我的空間。我盯着天花板上的燈發呆，想着這不是我昨天盯着的燈。我再一次瞥了一眼外面那一片擁有着雪頂的屋子，於是我終於決定還是起來了。想起昨天承諾的今天做出回復，於是便掀起電腦開始閱讀昨天僅僅是草草讀過的一部分文本。這個房間的設計很是成問題，從我所正坐着的的沙發的位置，沿着時鐘一點的方向看去便正好能看到主臥的樣子，便是三弟安詳的睡容。他換了一個姿勢，面向了背光的一側，頭枕在彎曲的右手臂彎上，輕微地蜷縮着，繼續着他的睡眠。我很高興剛才沒有不小心吵醒他。但我又在沙發上想着如果我移到他的房間，立刻用某種粗魯的辦法就這樣把他把吵醒，或許對於我來說會成一種趣味。但終於我還是沒有動，請他再睡一些時間吧。任由這幾日的折騰，他雖然嘴上不說，我想也總是疲憊的。</p><h2 id="第五日"><a href="#第五日" class="headerlink" title="第五日"></a>第五日</h2><p>　　疲憊這種東西可能是險惡的世界沒藏好自己的全部而露出來的不易察覺的尾巴。不論是前進或是後退，或者停在原地，合着各種五顏六色的情緒一同出現的是恐怖的疲憊。這是我在咖啡廳的想法。此刻我已經結束了上午的滑雪而回到了哈工大，坐在哈工大的某個咖啡廳了，等着一羣我認爲不會再出現在我的世界中的人，三弟現在的室友們。</p><p>　　點了一杯熱可可，然後開始百無聊賴地看着 COC 模組，雖然心裡想着，這終於是沒有機會的，但還是慢慢地用手機那種小得可憐的屏幕查看這種費勁複雜的文本。在我翻來覆去地看了很多遍之後，終於放棄了。我想趴在自己的手臂上，就在這咖啡廳里睡上一個不管什麼用的覺，因爲我覺得累。但是又同時覺得不好意思，便一隻手當作枕頭，側着臉倒在那桌子上，像個醉漢。我想到底是因爲我總是讓別人看見一個虛假的自己而感到抱歉，還是因爲我總是嘗試扮演出來的一個積極有爲的青年而感到費勁。我在這樣的地方呆了很長一段時間，我並不清楚確切地過了多久，感到時間正在以詭異的速度流逝。儘管我早已預料到某些事情已經不會如同計劃那樣向前展開了，我還是坐在那個地方，等着那個被告知這個結局的時候。</p><p>　　終於，我聽到似乎有叫我名字的人。然後三弟走了進來。他問我其他兩個人呢，我只能說還沒來。儘管我想着他們已經不會再來了。請告訴他們如果不特別想來今天就先算了吧，我也累了。但是我是因爲什麼事情而感到疲憊的呢。終於下了這個決策，我們就朝着住宿的地方走去了。</p><p>　　現在雖標着零下 20 攝氏度這樣嚇人的標籤，冰城屋外的夜晚卻出奇地不那麼冷。兩個人便這樣走在哈工大的校園裡，看着四周不斷改變着光彩的冰雕。校園裡已經沒有太多人，四處行動的是各式各樣結成伙的三五人或者成雙成對的小情侶，大多數人是不會在這樣的晚上還到處走的。我想把剛才那段我想的關於疲憊的話說出來，或許我正在想着這麼一個打算的時候，我的嘴就已經開始行動了。我可能若有若無地說了幾句。三弟可能是誤以爲我是因爲滑雪而感到累，而我或許矢口否認了幾句什麼滑雪使人累這種事情，滑雪這樣的東西是不會這麼傷人的。我想他終於還是不理解我到底想說什麼吧。可能我自己也不知道自己想說些什麼，以及是不是要讓立在我身邊的三弟知道這樣一些荒唐的想法，於是倉促地岔到了別的話題。經過一番費力地掙扎，我終於又回到那疲憊中去了。</p><p>　　雖然維持這樣的狀態已經足以可以使我感到愉快，但卻心底里明白，這樣的時光就如同浮游一般，在剛浮上水面的時候，就預示着它的生命快要消失了。我想我的旅程也快要結束了，但是另一場更大的旅程才剛要開始。從一個旅程跳到另一個旅程，就像是下了一趟火車然後趕上另一輛，終於喪失了所有熟識的人，再一次到一個不知所云的目的地去。我和三弟抱怨說，或許我喜歡的旅程正是那種在一個小湖邊，住在一個木房子裡，什麼也不干，就在裡面呆着，這樣的生活吧。他說，梭羅就是這樣的。我想，我沒有梭羅那種底氣吧，更沒有梭羅那樣的氣節，我只是一個中國衆多普通人中的某一個罷了，也是千千萬萬個爲今晚的月亮感到疲憊而受傷的人中的某一個罷了。</p><p>　　今天這月亮就很圓，雖然小，但是仔細看看，可以看到月亮上的灰藍色的陰影和乳白色的外皮，架在城市高樓頂上那種泛着紅光的燈之間。我說，這月亮很圓。是，哈爾濱雲很少。三弟這樣回答。</p><h2 id="第四日"><a href="#第四日" class="headerlink" title="第四日"></a>第四日</h2><p>　　我早早地出發前去一個叫做關東古巷的地方。到了才發現，這是一個和關東或者和古巷都無甚關係的地方，一個純粹的商業街，卻打着 AAA 級景區的稱號，這實在是費勁。我希望在這裡吃一頓午飯，卻終於沒有找到合適的東西。便到了全中國都可能有的地方去尋覓我想要的東西。進了一家東北菜的餐廳，隨意地點了兩份菜，卻發現東北的菜的分量果然是名不虛傳，我不小心點了兩個人都吃不完的份。此時手機提示我我收到了些什麼消息，我簡單地掃了一眼，又出奇地立刻回復了幾句，就把它撂在了一邊了。</p><p>　　然後便出發去今天的另一個目的地，中國木雕館。我是不知道中國木雕館分爲木雕館和金絲楠木館的，於是我稀里糊塗地走進了金絲楠木館。我剛進展廳，便看見一個青褐色的小柜子。柜子大概有一米五高，分爲上下兩個部分，上半部分是豎着的一些密緻分布着的等距的長方體木條，圍滿了上半部分的三邊，而留出了面向我的這一邊。下半部分是兩扇對開的木門，也是呈青褐色，這青褐色上淺淺地游離着一些金色的波浪般的紋路。整個柜子呈現出輕微的上窄下寬。</p><p>　　就在我端詳着這一個精巧的柜子時，一個年輕的女性便走到我旁邊開始做簡單地介紹。現在木雕館很空，除了我這樣遊手好閒的零零星星的幾個遊客，便沒有別的人了。她開始很熱情地和我聊天，介紹各種各樣的木料的來歷、構造、設計等等，還講了些什麼清代家具和明代家具的不同什麼的。爲了解釋這個柜子的木門設計之巧妙，她特意無視了「請勿觸摸」的標誌，將木門拉開，然後等它自動合上。這確實是我從未見過的精巧的設計。</p><p>　　我儘可能做出自己很感興趣的樣子，讚賞了明代家具設計的典雅大氣，適當地問了不少的問題，卻沒想到這位更加熱情，開始講述更多的事情。到最後終於不再講解和木雕相關的事情，而是講到了自家魚缸里養的叫銀龍的兩條魚。在這樣的一個多小時後，她似乎不小心因爲什麼我不清楚的緣由當我是一個從事藝術相關工作或者事業的人，然後以這個爲假定說出了：想必你也是搞這方面相關的（木雕或者繪畫，我也不甚清楚她所說的相關爲何物）……然而她正要再往下接着說更多的話時，我最後還是忍不住在這裡稍稍地打斷了一下她道，我是學計算機的。</p><h2 id="第五日-1"><a href="#第五日-1" class="headerlink" title="第五日"></a>第五日</h2><p>　　坐在從亞布力滑雪場往哈爾濱的高鐵上。我們退掉了之前計劃的下午五點返程的票，改成了車程一個小時的下午兩點出發的動車，代價便是從坐票變成了站票。於是四個人站在狹小的動車車門附近過道那裡。一路上聊一些稀奇古怪的東西，講一些稀奇古怪的故事。我不知道自己爲什麼要講某些事情，或者對某些聽到的事情保持興趣。我想你是學文科相關的吧，三弟的某一個室友終於還是問了。是，三弟幫腔到。不是，我是學計算機的。幸好只有一個小時，不需要再繼續消耗那麼多的精力去構想一些有趣的、可以使這裡悶熱擁擠的空氣不至於沉默的事情。就在我以爲還有一段時間才會到站的時候，我們到站了。一路上，我沒有機會看見窗外的景色，我的視線里的，是三弟的臉，三弟的一個室友的臉，和另一個室友正彎着腰趴在某一個座椅上睡覺的身影。</p><p>　　我暗自想到，他們的關係真的很好，可以肆無忌憚地開一些奇怪的玩笑，什麼頑劣的、過分的玩笑都可以。我想起我自己在大學的室友們，就像是不太認識的一些人，連酒肉之交可能都不太稱得上。每個人做自己的事情，有自己的奇怪笑點。我不理解他們有時突然在深夜裡爆發的大笑是什麼意思，就是那種一會咯咯咯一會哈哈哈的大笑，也沒有那種精力去一一詢問原由，我知道就算我知道了那麼一兩個答案，也只會陷入更深的不解之中。最初我在來到這個新的寢室的時候，我還會裝模做樣的詢問一兩句，後來便算了吧，他們或許對我是不是關心這樣的事情感到無所謂，正如同我對關不關心這樣的事情也無所謂一樣。我不知道他們的大笑的意味，是想激起那些不知道他們爲何而笑的人的注意力，或者僅僅是想大笑而已，這兩種原因對我而言都是莫名奇妙的。</p><p>　　我也想發自內心地笑的，但是我找不到機會，更找不到原因。我怎麼能期望找到那種可以真正令人愉快的事情。我明明清楚，愉快本身本是與不愉快相對的東西。只有在不愉快的存在下，愉快才顯得彌足可貴；而比不愉快更不愉快的時候，愉快才真正地呈現了愉快本來的含義。如果隨便一個什麼人，一日日地都充滿了愉快的話，我只能認爲他是分不清愉快和不愉快的人了。像是把黑與白混作一灘一樣，搞不清楚自己是否真的愉快，生活在一個自認爲美妙的灰色的世界裡，並稱這種灰色爲每日的愉快。但這樣，當我們終於分辨出愉快和不愉快是什麼東西的時候，愉快本身便不會那麼愉快了，因爲我們總是在愉快之中的時候意識到這樣的被稱爲愉快的場景終將很快地逝去，否則這樣的生活會變成某種日常而不再被人所珍視，而愉快會淪至單調無聊這樣的意義，從而變成另一種不愉快。</p><p>　　所以我想：愉快本身性質是消極的。處在愉快之中，或者朝向愉快，或者背離愉快的時候，都是令人難受的，這比處在不愉快這樣的環境裡更讓人難受，像是證明了愉快這種東西的無力。或者說或許愉快是在不愉快的大洋中扔進去的一顆石頭，它所激起的每一個波瀾都在敲打人逐漸麻木遲鈍的神經，用這種微不足道的衝擊喚起人對於不愉快的每一份回憶。所以可能對我而言，真的笑或者假的笑，都和哭沒有多大的區別吧，只是嘴角的弧度不太一樣罷了。</p><p>　　於是這一趟列車就是這麼個東西，它是到達愉快和遠離愉快的一個分界線，是我旅程的中點，也是下一趟旅程的預告。就在這麼一種中間的點，神經不由得緊繃着，承受着一種龐大的、飄渺的感受，承受着這種不懷好意的漣漪。</p><h2 id="第四日-1"><a href="#第四日-1" class="headerlink" title="第四日"></a>第四日</h2><p>　　我走進了一家名爲果戈里書店的地方，這是冰城這裡著名的書店。看着裡面充滿了俄羅斯風情的裝修，五顏六色的玻璃面板，和橙黃色的燈光，相較於外面的銀白色，這裡顯得相當溫暖而舒適。經過一個兩層的小樓梯，一個規模不大的書店進入了我的眼帘。這個小書店被一個五六階高的小樓梯劃分爲了兩部分。前面一個較低的平台，裡面擺着兩排挺矮的書架，以及一兩張裝飾繁複的椅子。順着這個平台正前方的樓梯而上，便到了第二塊平台，這個平台沿着第一個平台的四周延伸，形成了一個不完整的高起的迴廊。迴廊兩邊都是書架，但是就這樣一眼看去，就可以清楚這裡沒有多少書的。再回頭看一眼，看見剛來的樓梯其實可以再往上，但是已經打上了 VIP 的標籤。看來我所可以涉獵的知識，便在我面前的兩塊平台之內了。</p><p>　　我不是漫無目的地進入一個書店，我希望在裡面找到一本名爲《罪與罰》的書，一是我想到自己一直沒有機會再把這本書看一遍，自己當時讀這一本書的時候便是感到雲裡霧裡的；二是我想到今年三弟的生日因爲自己身在新加坡，也還沒有送他什麼書，我考慮着《罪與罰》是不是一個合適的選擇。於是以這一本書爲目標，我開始在這不大的更像是咖啡廳的書店裡尋找它。我本來想着，這家名爲果戈里的書店，應該或多或少有托爾斯泰、果戈里或者陀思妥耶夫斯基的書吧？可是我一本也沒有找到，我希望找的《罪與罰》便自然落了空。我想輕微地譴責一下這家名爲果戈里書店的書店，這讓我覺得如果我要想瞻仰這些書的真容，非要什麼擁有 VIP 名號的大人物不可。當然是我無端地譴責，畢竟就算是對於 VIP 這樣的大人物而言，也不一定會有這些書的存在。</p><p>　　於是我兩手空空地從書店出來，透過路旁的街牌，發現自己在一個名爲果戈里大街的地方。然而這裡爲什麼叫果戈里大街呢？這條道上什麼也沒有特別的，和我見過的每一座城市的樣貌一摸一樣。我或許想在這裡搜尋一些和果戈里相關的東西，或者和東北相關的東西，但我最後卻走進了一家日本的拉麵店。一進門聽到不太標準的日式歡迎光臨，就在那一個瞬間，我想到如果我不知道什麼樣的歡迎光臨是標準的，我或許就不會在意什麼，也不會因爲這一點小小的差異而攪了興致，正如去那果戈里書店一樣。我在果戈里大街上遊走着時，想着可能三弟的考試快結束了，還是等着他一起吃晚飯吧，但終於在這樣的考慮中四處溜達了一個小時以後放棄了，最終進入了那一家拉麵店。拉麵館最先迎接我的，是糊了我一眼鏡的霧氣。</p><h2 id="第三日"><a href="#第三日" class="headerlink" title="第三日"></a>第三日</h2><p>　　中央大街是真的名不虛傳。裡面充斥着各種各樣的俄羅斯風格的建築，特別是那些各種深淺的綠色房屋，在耐克、以及 H&amp;M 這些店的標誌下顯得更爲雅致而別具一格。一條熙熙攘攘的大街，在我到的時候，天已經差不多黑下來了。街兩旁的行道樹上掛着黃色的燈，將兩邊的房屋連接了起來，在夜幕下顯得溫馨。但這溫馨是假的，寒風轟擊着我的全身，讓我感到我當時在雪山之中都尚未感受到的寒冷。路兩旁放着許許多多的冰雕，這些冰雕自然比哈工大裡面放着的顯得更加精緻複雜，但也終究是會在不久之後就化掉的藝術，而第二次被造出的時候，這些冰雕也就不是這些冰雕了，只是那些存在過的冰雕的複製品。並這些冰雕耐人尋味多的是那些被成爲折衷主義或者巴洛克風格的房子。</p><p>　　我頻頻地掏出手機想要抓住那些印在我眼睛裡的那些五彩斑斕的令我讚不絕口的建築，直到自己的手失去了手的感覺也沒有停下來。然後再一次抓住我注意力的是兩個食物，一個是烤紅腸、另一個是冰棍。雖然這名爲馬迭爾冰棍的、售價 15 元每根的冰棍我早有耳聞，也知道這是必然會在之後嘗試的東西，但是這寒風勸阻了我立在那數十人的後面爲一根冰棍排隊的衝動。我只是站在那賣冰棍的地方之外，遠遠地望了一眼，假裝自己有所遲疑地停留了一小會，然後繼續前進了。</p><p>　　然後是紅腸。我想起在這學期在新加坡的日語課上，老師在最後一節課上問寒假的安排時，我說，我要去哈爾濱。同學們說，那個地方的冬天很冷吧。但我說，那裡有很多好吃的。他們問有什麼呀。我說，一種叫紅腸的東西。現在這個東西真正地出現在了我的眼前，10 元每根。但是在我正走近它想要買下一根來實現之前的回答的時候，我再一次莫名其妙地猶豫了。認爲這不過是旅遊景點常見的套路罷了，像這樣的東西，別的地方也是有的，只是以不同的名字，不同的身份，出現在各個攤販的名錄上，並標着各種正宗云云的名號。於是我擡起的手被我放回了溫暖的口袋裡。就這樣在冰城最出名的城市建築羣里呆了一段時間之後，我決定去尋找我的晚飯，以及拜訪聖索菲亞大教堂。</p><h2 id="第四日-2"><a href="#第四日-2" class="headerlink" title="第四日"></a>第四日</h2><p>　　我看着呈上來的拉麵中飄着的鳴門卷，它飛起的熱氣又一次糊了我的眼鏡。在到了這裡之後不知道第幾次抱怨眼鏡是多麼不方便的同時，慢慢的消耗了這一碗拉麵。就在這一碗碳水化合物被我全部吃下去的時候，我看見一條新的信息。三弟考完了，他說他好了，開始問吃晚飯的事情。這樣的事情也是有的。這樣巧合而令人啼笑皆非的事情也是有的。</p><p>　　我想，這個時候，我應該怎麼辦呢。如果是我的話，如果是我自己考完了的話，我會想招呼上幾個酒肉朋友，或者比酒肉朋友稍好那麼一些的零星的幾個朋友，在一個可能比平時吃飯的地方略微好上那麼一點卻又不至於讓我承受不起的餐廳吃上一頓，作爲慣例式的別過。然而這樣的慣例並不使人愉快，它既不是愉快的一部分，也不是不愉快的一部分，而是慣性的一部分，無關乎情感，僅僅是一種慣例。自然這樣的飯局甚至會顯得比愉快的飯局更爲自得，就像是平時隨便吃的一頓飯一樣。雖然它有着某種儀式上的標籤，卻終究沒有某種儀式的感受。</p><p>　　我想，這樣的慣例或者儀式對於每個人來說，應該也是必要的吧，對三弟這樣社交圈裡如魚得水的典範來說，應該會更爲重要吧。於是我給出了這樣的提議：請不用管我吧，叫上自己大學還好的朋友一起吃一頓吧，就當是別過了，後面再想抽出時間就很難了。然而最後他還是沒有接受這個提議，或許會覺得難爲情吧。確實或許會吧，像是將一個木雕館裡那種老房子拆下的板材製成的柜子擺在充滿了明亮並帶有玻璃現代風格的展示廳里那樣不能稱爲和諧的場面，我也會在不能夠搭上話的氛圍里被擊潰。畢竟歷史和正在發生的已經是兩碼子事了，歷史發生的一切都是某種執念留下的幻覺，或真或假，伴隨着主觀的某些微不足道的想法而變形。於是便覺得他做出這樣的決定不可不謂明智吧。</p><p>　　於是我最後也接受了三弟的決斷，抱着再吃一頓夜宵的想法前往剛剛得知的約定的地點。就在推開門的那一瞬間，寒風從外面撲進來問候我，但是剛剛拉麵店所賦予我的熱的感覺還沒有消散，我就在這樣的寒風中突然想起來剛入肚的拉麵，同時覺得溫暖。</p><p>　　我需要四十分鐘到那裡，我這樣回復了三弟。</p><h2 id="第六日"><a href="#第六日" class="headerlink" title="第六日"></a>第六日</h2><p>　　在吃完午飯後告別了三弟，便第二次朝着中央大街前進。這一次，我是奔着之前被自己放棄的馬迭爾冰棍而前往的。這一次我從中央大街的腰部的某一個支道上進入了主道，隨便選了一個方向，然後篤信着我所尋找着的馬迭爾冰棍就在前方。當我再一次看向那些我曾經讚不絕口的建築以及房屋，卻總覺得缺了那麼些味道，我想是這或許不夠寒冷的緣故，也可能是現在還沒有進入夜晚的緣故，還是說因爲我知道我將離去而遇見了一些別的感受。我說不清楚。這些即使在白日中也點亮着的霓虹燈招牌，間雜在這些富有着歷史感的建築間閃閃發光。我這一次無心再一個接一個地端詳那些冰雕了，我只想找到那個驅使我再一次來到這裡的馬迭爾冰棍。</p><p>　　我這樣盲目的往前前進着，但是卻發現我已經走到了中央大街的盡頭，便終於意識到自己在十字路口選擇了一個沒有馬迭爾冰棍的方向。這讓我感到懊惱，於是我轉頭開始往回走。然後我立刻發現了一個我上一次便看見但是卻沒有進去仔細觀察一番的建築，中央書店。沒有在果戈里書店找到的《罪與罰》，這裡應該會有的吧，我這樣想着，進入了書店。這個書店和果戈里書店完全不一樣，沒有果戈里那種高雅溫馨的氛圍，裡面密密麻麻的是走動着人羣；也沒有像果戈里書店那樣坐在地上看書的羣衆，也沒有停在走廊上拍照的人羣。這個書店天花板很高，整個寬闊的房間也幾乎沒有什麼裝飾，幾列一進門就能看見的書架，和左右向上一直延升到了天花板的書櫃。這意味着這裡有許許多多的書。我想着我計劃里的書或許終於有着落了。於是我埋頭進去，尋找我想要的書。</p><p>　　不久，我在那裡找到了我正在尋找的書。書很厚，封皮很薄，不像是近段時間常見的把經典或者不經典的書都統一用又硬又厚的封皮包起來那樣的做法，而只是在書上包了一層簡單的封面就放在書架上了。它甚至連腰封都沒有。很中我意。封面和封底都是是完完全全的猩紅色，從前到後都是大片的猩紅色。正面用端正的某種楷體的變體豎着寫着黑色的「罪與罰」三個漢字，以及橫着寫的 crime &amp; punishment 幾個英語字母。懸在這一系列字上方的，是一把被手握着的黑色的斧頭。在剩下的空處標着陀思妥耶夫斯基和譯者曾思藝的大名。很中我意。</p><h2 id="第五日-2"><a href="#第五日-2" class="headerlink" title="第五日"></a>第五日</h2><p>　　鬧鐘在五點半準時地把我叫了起來，今天得立刻就離開牀鋪，我拉開了自己房間的門，示意三弟自己已經醒了，然後穿上衣服出了自己的臥室。透過那扇就在我的臥室旁邊的門，我知道三弟也已經起來了。他正坐在自己的牀上彎着腰發呆，上衣尚還沒有穿上，腰上和肚子上的少些贅肉略微地鼓了起來。而被子被推在一旁，形成了一個突起的泡沫。三弟還是像高中那樣每每起牀之後就要盯着某個怪異的方向，神志不清地發會不明所以的呆，同時也是比高中的時候胖了一些。</p><p>　　想罷這些我就移步去了衛生間洗漱去了。我再一次出來的時候，三弟已經穿好了衣服開始給室友打電話叫他們起牀了。待到我們兩人都準備妥當的時候，便出了門。預約的師傅搞錯了我們上車的地方，不過總算是順利坐上了車。本以爲車上不會有別的乘客，沒想到這一次還是受到了冰城出租車亂象的搗亂，車上坐着另一位去哈爾濱火車站的乘客。不巧的是，另外兩名並未來得及準備妥當，而那個沒在我們預期之內的乘客的火車在我們的火車之前，着急着去趕自己的車。我們並不占理，就只能先舍下兩位室友友人，繼續乘着這輛車前往火車站。</p><p>　　然而就在我們到達火車站之時，卻發現火車的出發時間比我們原以爲的早了二十分鐘。而三弟的室友們便沒了這個趕上這班車的機會，他們可能得買新的票了。</p><p>　　安穩地坐在了火車上之後，就開始處理那兩位室友的行程，好在目前尚有別的車可以到達目標。就在三弟處理着這些我非常不擅長對付的事情的時候，我開始觀察車廂之外的情況。外面是一大片被枯樹弄得支離破碎的雪原，在這些枯樹的間隙里，有着幾片不大不小的類似田壟的東西。我之所以可以知道那些是田壟，是因爲在那潔白的雪地之中留着規則的被犁過的平行的痕跡。在這些田壟之上，極有規律地堆着些要麼圓柱形的、要麼三角錐形的谷堆。有的陽光會穿過枯樹照在雪地上，使雪地看起來被什麼東西踩過一樣。遠處的山，迷迷濛蒙，說不清楚是被霧罩着還是什麼，呈現出一種很深很暗的藏青色，就像是只調了一點水的花青色。時不時我們會路過一些屋頂上堆滿着雪的屋子，卻沒有見到幾個在雪地里行走的人，只看得見地上偶爾稀稀疏疏的腳印。就在我觀察着這些平日難得見到的北國風光時，三弟那邊的事情也處理結束了。</p><h2 id="第一日"><a href="#第一日" class="headerlink" title="第一日"></a>第一日</h2><p>　　在不知原因地三次延誤了航班之後，終於在比原計劃晚了三個小時的時候，我到達了冰城。在我假想出的寒冷的空氣的威逼下，我準備好了手套、圍巾以及兩層襪子，卻發現外面遠沒有想象的寒冷。趕上了從機場到火車站的大巴之後，便注意到了坐在一旁的一對父子。雖說是注意，但不是我的眼睛看見了他們，而是我的耳朵抓住了他們交談的聲音。兒子坐在了我左邊的座位上，而父親則是站在或者蹲在兒子的旁邊。父親之所以這樣是爲了和兒子說話這一點我很清楚，但我也不願起身離開我的座位而給父親一個方便，因爲車已經開始移動了。</p><p>　　從這對父子零零星星的對話中我大概了解到，這個兒子在廣州某地讀書，年齡大概在十餘歲，聲音尚未變得富有男性的特點。這一次是從讀書的地點回到哈爾濱旁的某各小城市裡過年。父子會在哈爾濱住上一晚上，然後第二天就趕回家。令我感到奇怪的是兒子讀書的內容。我只大概聽到兒子這一年的課業是背誦《論語》；下一年的課業是背誦《孟子》，再之後是背誦《易經》和《黃帝內經》。</p><p>　　你要記下老師講的所有的東西，父親這樣說道，它們以後都很有用。爸爸我沒有什麼學問，我不懂什麼《論語》，但是知道這些東西很有用，你把這些東西給爸爸記牢了，永遠都不要忘記。兒子支支吾吾地回答，他不覺得有什麼用，自己在生病的時候，老師給扎針也沒有治好。於是父親又重複了一遍上面的話。接下來父親開始挨着挨着詢問課業的事情、生活的事情。最後說，爸爸下次再帶你回一次家，再下一次你就該自己回來了。你也大了，該自己走了，這個不難。旁邊的乘客也幫腔到，對的，這個不難，都是這麼過來的。兒子先是小聲地回答自己不行，後來才慢慢地問着父親自己能不能有一支手機，這樣就可以自己回來了。後面父親又反反覆覆地交待了不少的事情。</p><p>　　我一邊有心無心地偷聽着這一對父子的對話，一邊看向窗外。窗外沒有什麼景色，在黑夜裡面，無非就是在高速道旁往後滑墜的立着的樹，這些樹都沒有葉子，光禿禿的，這些光禿禿的樹使人感到平靜。你早點休息吧，我這邊應該不會有什麼問題了，我編輯了這麼一條信息發給了三弟，然後再一次把視線轉回了窗外。</p><p>　　直到下車的時候，我瞥到了這一對父子。雖然看不清楚他們穿了些什麼衣服，但確實地看見他們一起下了車，朝着我不會再遇見他們的方向前進。沒事，你再適應適應吧，三弟這樣回復到。原來他還沒有睡啊。</p><h2 id="第七日"><a href="#第七日" class="headerlink" title="第七日"></a>第七日</h2><p>　　我終於踏上了回去的路途。然而就在這回去的一天的夜裡我一點也沒有睡着。房間裡牆上鐘的聲音在不停地刻板地踢踢踏踏，時不時也傳來冰箱的些許噪聲，房間之外的馬路上尚有不少的汽車正在道路上行駛着，出租車「有人的」黃色標牌在夜色里拉成一條長線。三弟今晚回到自己的寢室收東西去了，這個二室一廳一衛一廚的屋子裡現在就躺了我這麼一個人。</p><p>　　我不知自己出於什麼樣的目的，沒有和三弟訂下一起返回成都的飛機，而是古怪地晚了那麼兩個小時。在這一天之前的晚上，三弟勸我還是自己走吧，不用起那麼早了，可以多睡一會。我拒絕了這個提議。於是便還是決定一起去機場。然而我正住着的並不是什麼繁華的地段，沒有特別多的住戶，嘗試多次以後，我也沒能預約到合適的出租。那走去地鐵站吧。我想，凡人的偏執乃是危險的東西，而這一個決心是我已經下好了的。於是我就在這樣踢踢踏踏的聲音里，看着時間從 2020 年 1 月 11 日的 11 點一點一點劃到了 2020 年 1 月 12 日的 5 點。我起身去洗漱，零零碎碎地吃一些東西，再檢點了一遍有沒有忘記了的東西，順便檢查了一下三弟的房間有沒有留下什麼他忘記的東西。在仔細地確認這些無誤以後，我開始坐在客廳的小沙發上發呆。</p><p>　　這樣，我在這寒冷的地方的旅途就竟然就要結束了。我終究沒有吃馬迭爾冰棍或者是紅腸，更不要說別的什麼的東西。但是我又沒有固守沒有人的城池這樣的想法，或許這就是時候離開了吧。我心裡暗想到，三年後的這一個時刻，我可能會再一次坐在現在我所在的房間裡，思考一些相似的問題。想到這個，我不免覺得奇怪，原來我還要回到這裡來呀，對，三年之後，我會再到這裡來，可是那個時候我或者這裡的人們都是什麼樣了呢？</p><p>　　就這樣坐在黑暗裡，我終於下定了決心出門。把要是小心翼翼地放在了桌子上，再環顧了一下這個不大的空間。一個雙開門的冰箱，一個只能坐下兩人的小桌子，坐下兩人的小沙發，一台大電視，一個小巧的廚房以及浴室，幾面牆上都掛着的小畫。於是我再這樣望了一眼，出門將門關上。</p><p>　　我是在將來真的會回到這裡來，還是會到一個別的什麼地方去呢？</p><h2 id="第二日"><a href="#第二日" class="headerlink" title="第二日"></a>第二日</h2><p>　　在時隔上一次見面將近一年這樣的時刻，我站在哈工大校門的廣場那裡豎着的巨大的校慶的冰雕的旁邊，看見了耳朵被凍得略微泛紅的三弟。這個時候正是哈工大的學生從寢室或者圖書館出來尋覓午飯的時候，在滑溜溜的地板上，小心翼翼地走着許多帶着羽絨帽子並把手揣在兜里的人。在我左前方立着一個高大的冰雕，冰雕的下面刻着哈工大的校徽，以及 2020 的紀年的數字，在我的右邊是一個用冰砌成的國旗的圍欄。我向三弟打了一個簡單的招呼然後問我們現在去哪裡。</p><p>　　很快，我們抵達了哈工大的食堂。哈工大的食堂是一個怪異的物種。從外面看過去完全不像是在營業的樣子，作爲一個闖入的外來人，我或許有可能永遠都不知道在那垂着的重重的帘布一樣的黑色空間之後，藏着一個賣粥與餃子的地方。</p><p>　　於是在這裡，熱氣第一次撲向了我的眼鏡。三弟提議吃餃子之後，接着問我要多少，我說二兩。他露出了怪異的表情，眼睛瞪得很圓以表示難以置信，然後再一次確定了我的答案，端給了我一份二兩的餃子。盤子裡的餃子大多不太完整，也不太大。這些餃子不像是平時吃到的餃子那樣中間鼓起，而更是呈現出一個扁平的狀態。說是二兩的餃子，估計一下也就是十個左右的數量。這樣我就知道爲什麼三弟奇怪地看着我了，原來二兩的餃子是如此分量微小之物。</p><p>　　於是後來我又去補了一杯粥。本來我是想要一杯豆漿的，然而這裡中午沒有豆漿。我自作主張地給三弟也要了一碗，儘管他之前說過自己不要豆漿了。這粥是不太甜的那種，不是我喜歡的味道。在若有若無地聊着天的時候，我終於決定去加糖。然而加糖這種事情是不可以一步到位的，在折騰了來回幾趟之後，我才終於仰起頭，將碗裡的黑粥一飲而盡。</p><p>　　待到我放下碗，才第一次認真的注視着三弟的面貌。畢竟也是有將近一年沒見了，雖然說不清楚具體哪些東西發生了變化，我卻感覺到一些不一樣的地方。我指的不一樣，自然不是指他的頭髮如何地變換了形式，或是眼睛如何地望向不一樣的方向，而是一些別的東西，一些我的視線抓不到卻可以感受到的東西。他可能也趁着在這個時候注視着我吧，我想。</p><h2 id="第五日-3"><a href="#第五日-3" class="headerlink" title="第五日"></a>第五日</h2><p>　　走進門，把隨身的東西都撂在一邊，然後走進自己的房間把圍巾和外套都丟在了牀上，折回了客廳，然後攤在了沙發上。疲憊的影響力，真的是不容小視。我就這樣茫然地架在沙發上，三弟卻看起來很精神。我確實是短時間內沒有力氣再說一些新的話，於是就任由我的身體稀里糊塗地倒在沙發上。然後我開始很仔細地，試圖盡力地消耗着剩餘的所有力氣那般，盯着頭頂的燈。燈是三層藍色的荷花葉子一樣的圖案的組合。每一層之間都很好地錯落地分部，不至於擁擠。每一朵花瓣都是向外舒展的、完美的、圓滑的弧線。它從那裡發出柔和的光，我接觸不到它，它離我太遠了。三弟坐在一側開始試圖找些有趣的東西來看，我在旁邊繼續倒着。</p><p>　　我想，這一趟旅程就這樣快要結束了吧。就像一頓火鍋已經下完了所有的肉一樣，後面的期待也如同撈起來的一塊塊肉一樣，終於寡淡了。也並不完全是這樣一個事情。在剛才從咖啡館回到住宿的路上，三弟和我說他在和老闆交接任務的時候，知道了明日自己需要加個班，完成一個儀器的調試。我聽着三弟這樣一段話，心想自己去冰雪大世界以及二訪中央大街的計劃就這樣被取消了一大半。</p><p>　　我看着自己呼出的水汽在空氣中凝結成一片飄搖的白霧，在我伸手抓到那段白霧以前，它們就沒影了。如果不是哈工大這片路燈的照耀，這片白霧也就不會出現在我的視線里了。一路上依舊沒有什麼行人，許多店鋪也早早地關了門。我想這些店鋪就算開着，也不會有很多人去了，這裡已經放假了。我就在這樣想着的時候，越發覺得身上正承載着的疲憊的真實與複雜。</p><h2 id="第四日-3"><a href="#第四日-3" class="headerlink" title="第四日"></a>第四日</h2><p>　　畢竟是晚高峯，放在哪裡，晚上七點應當都是晚高峯。就晚上來看，忽略掉路旁的冰以及行人穿着的厚衣服，這裡的晚上和上海的晚上或者成都的晚上都沒有特別的差異。路兩旁排了一列閃亮着的燈，燈前排了一列匆促行走在人，匆促的人前排了一列公交車站，公交車站前排了一列等車的人，人前面排了一列排隊的公交車。就是很樸素的夜晚的景觀，放在中國哪座城市裡都是的那種晚上的景觀。縱使是冰城，也不可能四處都是冰雕，總會有些不那麼哈爾濱的時候的。</p><p>　　終於經歷了一路走走停停，我到了目的地。就在我快要到達的時候，手機上的新消息告訴我三弟也到了。時間正好。走進約定的烤肉店再轉到二樓，就在進門不遠的地方，我見到了三弟。之後就是觀賞菜譜的時間。雖然我總是不願意擔當起點菜的重任，但總有些事情不能順心如意。三弟就是這樣，每次在我看着菜譜的時候，他總是要讓我也點一些什麼東西，不論我怎麼推脫掉這份差事。於是我只能打開菜譜，逐頁地翻着。這確實是相當厚的菜譜，我很久沒有看見這麼厚的菜譜了。裡面的菜也很有意思，比如一個叫大串的東西。就在我計劃隨意點兩串的時候，我被三弟制止了。於是我想起了中午在東北菜館的尷尬境地，終於還是縮減了點的東西。然後將菜譜讓給了三弟。這些事情還是交給他吧。</p><p>　　這家店不知爲何，據說今天的人特別的多，也就使我們上菜的速度很慢。一道菜往往等不到下一道的到來便早早地投了地府，我本以爲肚子裡占着碗拉麵和章魚丸子便不會吃什麼東西，但還是老老實實地吃下了一頓飯的分量。不過三弟定然是沒有吃飽的。我們又追加了一份什麼榴蓮烤餅，但它終於沒有被端到我們的桌子上。粗心的服務員忘記了我們的加餐，於是我們坐在桌子上聊了很長一段時間的天——上一次並沒有來得及聊到這麼多的東西，但所謂聊天，也就是些瑣碎的話題，沒有什麼中心，也沒有什麼重要的話題。我大概描述了一下我在新加坡的生活，三弟大概描述了一下他在哈工大的生活。</p><p>　　與這頓被服務員忘掉榴蓮烤餅的美中不足的晚飯不同的是，三弟的生活聽起來很幸福。</p><h2 id="第一日-1"><a href="#第一日-1" class="headerlink" title="第一日"></a>第一日</h2><p>　　終於，我離住宿的地方近了。我剛到冰城的時候，這裡就下起了雪。我在雪裡等着出租車，旅途遇到一羣推銷着住宿的人。倉促地攔了一輛車，不太顧砍價的，我逃離了這個地方。還好這裡離住宿的地點不太遠。一路上師傅開始與我交談，和我聊着哈爾濱的各種事情。他似乎沒有看出我是外地人，先是用本地的話和我攀談起來，發現我沒有完全聽懂的時候，他便開始試圖說一些更類似普通話的語言。他問我是來做什麼的，我說我是來看親人的。這句是我出於自我保護而說的一句謊話，後來想想卻的確如此。我若不是來看親人的，又是來看誰的呢。</p><p>　　我被司機放在了小區的正大門前，按照之前房東的說法，我順利進了這個小區。小區很是安靜，在這個稍微偏一點的地方顯得很舒適。四周實在是安靜，地面上由於正下着雪，已經滿滿地鋪了一層。樹上掛着黃色的燈，也是這裡唯一的光源。這裡唯一不和諧的是我這個就算在雪裡也隆隆作響的箱子的聲音。</p><p>　　我的前面是一條潔白的長路，在黃色的光的照耀下也呈現出些許黃色。我忍不住回頭看我走來的路，在我來的那一邊，它本也應如同我前方的道路一樣整潔，現在卻烙上了一串凌亂的腳印以及不連貫的糾纏着的兩條長線。拖着箱子、破壞着着安靜與整齊的我，在這個時候很清楚地知道：我不屬於這裡，我只是造訪這裡，拜訪一位親人，然後再從這裡離開。</p><p>　　我之所以在這裡停住，恐怕不是由於掌管生命的神這樣對我說：請停留在這裡。私以爲，我之所以停留在這裡，是因爲我決定如此，而不是其它什麼花里胡哨的原因。這件事情的發生既不是我的計劃，也不是像我的某個人所構造的計劃，它根本就稱不上什麼計劃。儘管我在甚至離開上海前往新加坡以前就如此打定了我要來一趟哈爾濱的主意，甚至是在前年的夏天，我就做出了這樣的打算。但它仍然算不上是一個計劃，這趟旅程毫無理性的成分，既不考慮支出，也不考慮時間。只有「到這裡」是重要的，這是計劃的一部分；但是計劃也沒有別的部分了。被問起我爲什麼來這裡，我謊稱自己是因爲自己想感受一下寒冷，或者是自己是對東正教教堂頗有興趣。但我清楚地知道這是敷衍別人以及自己的理由，我知道理由就只有一個，而且正是爲了達成這個理由，僅有「到這裡」才是重要的，也是必要的。</p><p> 　　這裡寄寓着我的一部分生命，我必須到這裡，將這一塊回憶填上。</p><h2 id="第四日-4"><a href="#第四日-4" class="headerlink" title="第四日"></a>第四日</h2><p>……</p><h2 id="第五日-4"><a href="#第五日-4" class="headerlink" title="第五日"></a>第五日</h2><p>　　站在雪板上，我感受到了最大程度的惡意。我沒有任何移動的可能，我所能做的就是坐在哪裡，或者任着向下的衝動終於把我一直拽下去。我停不下來，也改不了方向。我所駛向的地方既不出於我的意志，也不違抗我的意志，它獨立於我的意志。決定我方向的，終究就是我在踏上這個路途上那一瞬間受到的力。除此之外，再無他物。</p><p>　　我總以爲，在不斷掙扎的時候，我能夠通過某些途徑改變自己行進的方向，然後到達我所期望到達的地點；但終於發現這是個徒勞。於是我就停在了我意識到了這一點的那裡，感到挫敗。我想，如果將這個傾斜的雪道變得水平，那麼我所面臨的另一個困境便變成了：我只能留在原地，而不是像現在那樣向下滑去。或許那個時候，維持移動的唯一便是慣性本身，它既不是無形時刻存在的重力法則，也不是我渺小的意願。這個雪板就會載着我各式各樣的胡思亂想，沒道理地一直往前，直到這個巨大的船隻撞上了什麼東西，終於再也不能移動。</p><p>　　就像這樣，我要麼在雪上倉皇地四處亂撞，要麼就倒在雪地里。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>　　這篇羅嗦的，也沒記下很多東西的後記是在第五日受到清華某友人的啓發後打算寫下的。本來是計劃完成一份詳盡一些的、3w 字左右的文本，但終於在離開了冰城以後完全喪失了繼續完成它的氛圍和意念，就如同我在離開那個城市時所擔心的那樣。所以終於大部分內容都停留在了停留在哈工大小咖啡館的內容，只是後面草草再補了一些東西。</p><p>　　這篇文本也並應該包含太多的深意，甚至有很多相當重要且關健的事件出於各種考慮以及個人的懶惰終於沒有添加進來。簡單來說，這或許是因爲離開了那裡而被迫腰斬的一篇小文章。或許是到了後面越發覺得自己的筆之沉重，終於不能再將原本定下此題的勇氣重現出來。</p><p>　　更多是對當時一些思緒的整理，就沒有更多的東西了，且當作胡亂作文的結果吧。</p><p>2020-1-11，作於冰城哈爾濱</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行跡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公開信-給YT的第二封回信</title>
      <link href="/2019/11/12/essay/letter/%E5%85%AC%E5%BC%80%E4%BF%A1_%E7%BB%99Yuting%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%B0%81%E5%9B%9E%E4%BF%A1/"/>
      <url>/2019/11/12/essay/letter/%E5%85%AC%E5%BC%80%E4%BF%A1_%E7%BB%99Yuting%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%B0%81%E5%9B%9E%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-YNyPfBYD" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="438562829" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>YT，</p><p>　　想起來這一封信也是，好像好幾次打算開始，都沒能完成，真的是非常抱歉了。想着上一封回信被我從上海帶到廣州，又從廣州帶回上海，再從上海帶到新加坡，若不是一個契機，恐怕又要被我從這裡帶回去了。時間太久，恐怕之間好些事情已經有變化了吧。在這一次的追加之前，是在我 11 月動筆之前遺留的信的內容。這之後的事情，就留在這部分之後吧。</p><p>7-29 日書：</p><p>　　很抱歉已是拖沓了如此之久了。一段時間以來，我常常想起，或許我應該提起筆來寫這一封信，如同每日起牀時我想起我的琴，但每當太陽落下的時候，這種感覺就喪失殆盡。以至於當我意識到，過了這麼久了，我居然都快要離開中國的時候，我還沒有真正開始寫這麼一封信，就感到一陣無奈。倒不是爲事情本身無奈，而是爲我自己無奈。</p><p>　　這一個學期發生了不算多、但也不算少的事情。除卻學業自接近半期開始初露爪牙這些事情，還有出國一條線時顯時隱。個人的心境在這長期中，似乎受了些擾動。或許這是無法提筆的根本原因吧。但這些擾動的原因或者影響，我都是說不清楚的。</p><p>　　首先是對上一封信件文風的回應吧。說一個人的文字有些許味道，是很高很高的讚揚了；或許我的信的風格是變化的，是不穩固的，所以我並不知道自己的風格是什麼，所以更沒有什麼有心之舉了。或許我的部分語言結構受日本文學翻譯那一脈，或者日本文學那一脈影響很深吧。在高一那段時間，可以說是瘋狂地看各種書。當時，除了忙社團和班級活動一堆事情，也就只想看書。那段時期看的書，最多的就是日本文學了。並不是說自己對日本文學有多麼深厚的喜愛，而是那種溫馨與悲涼交錯的感覺，讓人覺得真實而深刻。</p><p>　　YT 的文風就和我迥乎不同了，有一種細緻明媚的感覺。僅就一系列常見的語氣詞，用法及效果差別都很大。因爲拖欠了如此之久的回信，又時不時想着要回，所以這封信我也是看了好幾遍了。而每一次的閱讀體驗都是相對一致的，雖說內容或各種變化，卻有一種穩定含蓄的積極情緒。雖說我寫了很多信了，但是真正的回信這卻是第一份，這封回信還是出乎意料地長。巧的是，就在這不久後，我接到了另一位同學的回信，不過這是另一個詭祕事情了。</p><p>　　聽 YT 談麵包，我想到或許自己更喜歡做一個廚師勝過做一個研究者。或許因爲下廚只是因爲興趣，而且也不經常，所以可能對美食的製作有一種自然的好感吧。仔細想想，爲了一道小菜圍着鍋爐轉一兩個小時還是有點累的。所以乾脆做個品嘗者好了，見識到沒見過的食材和做法永遠都是令人激動的事情，雖說常常標新立異的菜並不合人胃口。說起麵包，我倒是一直認爲越丑的麵包味道越好，那種形狀奇絕，渾身疙瘩的麵包估計就是我的最愛了。</p><p>　　回信中 YT 也對後悔有了一個表述，於是我更清楚地意識到，我確實離這種感情太遙遠了。於是說起我的好朋友的事，如果以「如果……就好了」這樣的評判去評價當時的那一次選擇，我是不後悔的。我有一個非常值得懷念的高中生活，我的朋友也和我一起度過了很多事情。但這不是我不後悔的理由，這不後悔並沒有什麼理由。這些事情只是恰如其分地發生了，然後事情總會繼續往下發展的。至於那個或許「有意味」的團建就是如此，我只是在零零落落的瞬間中意識到了道路的分叉。分叉不是被哪一次偶然構建在那裡的，而是一直都在那裡的。所謂聯結，或許不是執着於道路的方向是否一致，而只是一種聯結罷了，一個名字或者一種理念。至於爲什麼會有一些惋惜之類的情緒呢？猶如一塊巧克力，咬下這一塊的人都會意識到，這一塊巧克力的一部分喪失了，一種味道在被獲取的時候喪失了另一部分味道。當巧克力的一部分味道被知曉的同時，其他千千萬萬種味道就喪失了。惋惜或許就是如此吧。</p><p>　　不過說來也巧，YT 居然有極爲類似的經歷，只是發展方向截然不同。YT 在信裡面有很多的推測與猜想，這確實是一件有意思的事情，只是我不太擅長做出這些假設。</p><p>　　還是很羨慕 YT，不論順或者不順，生命中都有如此多有意思而重要的人。我聽了很多人的故事，其中不乏有如小說般出人意料、走向戲劇化的故事。但最後還是更喜歡恬靜美好的故事，YT 的故事就已經很是恬靜美好了。我或許嚮往一個恬靜美好的生活吧，但是自己的生活又是恬靜得過分，可以算波瀾不驚了。安穩着安穩着，又想來些猛烈的東西，然而這樣的東西又使人感到恐懼。所以就在這樣安穩，而嚮往着波瀾的生活中避免着波瀾，繼續着安穩。</p><p>　　說到這些事，說來也怪，我碰到的感情事項不算多，但都是以詭祕而單調的模式出現的。想來也是無聊的些許生活瑣事，真要談起怕是枯燥之至，若想要聽，我再抽時間談談吧。總之就是如此。說到這裡，可以大概談談之前有提到的「朋友」的事了。對我而言，友情是一個非常廣闊的概念，但是卻僅僅適用於一小波人。無疑，我對「朋友」是看得很重的。這裡當然指的金蘭之交以上的朋友；無論在誰的眼裡，這樣的朋友恐怕屈指可數吧。我也說不清楚一個朋友在我的生活中會扮演怎樣的角色，有時我覺得他們是我的一部分，有時我又覺得，他們或許遠離我會更好。這倒也並不是一種飄忽不定。對很多東西我都是變化無常，但是朋友卻不是。我說不清楚這是一種尊重還是什麼，更多來說，與朋友的相處就如呼吸一般正常，如同張開自己的嘴，或者揮動自己的手臂。有如自己思想的延升，感受到了一些自己感受不到的快樂與痛，然後有了一種一同體驗的感覺，便是如此。</p><p>　　以上便是之前的內容了，上一次差不多也快到了結束的位置。我再看了一遍，大概小改動了一兩處吧，別的便是如舊了。其中的幾點，可能現在 YT 會有不一樣的感受吧。特別是我給出的「積極」、「明媚」、「恬靜美好」這樣的描述。不過還是希望生活大部分時間都會如此。那麼我先大概講一下我這邊的情況吧。正如我在前一部分描述的如此，儘管某些細節發生了很大的改動，生活還是如同往日一樣前進。更離譜的是，由於這裡常年夏天的氣候，連天氣的轉變都不明顯。每一日的區別便更加地小。</p><p>　　或許你會對這邊我做的科研有一點興趣吧。這邊做的工作是自然語言處理的一個小分支工作。研究的是句子間的聯繫。簡而言之的話，語言學家基本認爲大部分句子間的聯繫可以分爲四大類：下文是上文的展開或收束、下文與上文形成反差或對比、上文與下文構成因果關係、上下文間具有時序關係。這些關係大概有句子間具有關聯詞和不具有關聯詞兩類。句子間沒有關鍵詞的這一類的判斷非常困難，這就是我這邊的工作了。本來以爲九月份可以結題，因爲已經做了一段時間了。後來發現最初的設想不夠有效，於是只能轉變方法。後面又嘗試了一兩種新的想法，還是差一點。最後的思路大概在一個半月前提出，然後在一段時間的工作之後認爲這個方法有效，但是距離本任務的最佳成績有非常細微的差距。在這個情況下掙扎了很長時間，知道上一周周末終於有了突破性進展。想起來在這段時間裡，好長一段時期就是有空就到實驗室看樣例分析句子結構，也是很辛苦了。科研這邊的情況大概就是這樣了。</p><p>　　然後是日語的事情。我也沒想到居然自己會修日語這一門課。這確實是一門挺有意思的語言，也學到了不少東西。今天這剛考完口語，看着日語老師在我離開後在房間裡面收東西。我想，這門語言在以後會以如何的形式存在在我的生活里。大概就是那一瞬間的事情，我大概意識到我的交流生活就快結束了。然後熟悉的感覺便再一次到來了。就是那種說不太清楚的難受的感覺，像是現在某些東西往往如此的平淡，總因爲種種原因而在生活里消失了。在日後回憶起的時候，一種模稜兩可的氣息就會湧起來。像是懷疑起自己經歷過的歲月是自己的還是像自己的某個人的，像是自己暫時保管着這樣一份回憶，覺得這個事情居然真的發生過那樣，感受到恐懼。這種恐懼或許是我生活中最執拗的情感了。發現自己不小心扯到這裡來了。</p><p>　　那接着這個問題談吧。YT 看起來是最近遇到了一些「瑣碎」但是卻難以消解的壓抑情緒吧？既然現在不是很清楚 YT 指的是什麼，那先談談我的吧。我之前應該也說過，自己並不是一個十分積極的人。我之前懷疑過自己有沒有抑鬱，我想用復旦的心理測試那裡試一試，但是它的網絡頻繁崩潰，後來也不了了之了。我想自己如果還有那麼幾個真心的朋友，情況或許就不會太遭。我現在沒有太懷疑這個問題，可能是我已經忘了吧，也可能是我覺得不重要吧。</p><p>　　啊啊…這後面一段我反覆改了好多次，但終於沒有找到很合適的東西寫下來。抱歉…這一部分我可能不太能直接接下去。我想我在說下去會更多地把一個悲觀的世界觀展現出來，這個話題我這邊先就此打住吧。可能每個人有着自己的痛苦與解脫的方式吧。說起上一次推薦的《荒原狼》，儘管很可能是誤讀，但我覺得最驚異還是那種態度。那種意識到人生無從尋找價值卻仍然創造一種價值的態度。這樣的表達不是很合理，但我想，大概就是這樣了。</p><p>　　那麼，我這邊的情況就是這樣了。很難說是一個積極的回應，不過還是希望 YT 能夠把壓抑或者難受吐露一些出來。說不定我只是不擅長處理我這邊的。再者，不論怎麼說，我都慢慢開始意識到這個時代內在的一種無奈。我感到不是說選擇怎樣變多，或者說生活如何充滿物質、人的生活如何的空虛，而是那種使生活延展下去的動力顯得越來越模糊。（一種偏激且極爲悲觀的看法吧）所以容我先胡亂猜測，也許某些東西，我們所有人都需要找到解決得方法。</p><p>　　回到這個話題早開始的起因吧。電影的話我真的不太能推薦出來，畢竟自己看得十分有限。小說的話，如果《荒原狼》現在還沒有來得及讀的話，我會再推薦一次。可能再推薦的話，我可能會給卡夫卡的《審判》吧，如果從不同於法律的角度考慮，說不定可以發現新的東西。按照之前，我還是附上推薦的音樂。這一次，在這個狀態下，我可能推薦的其一是《馬勒第九交響曲》。至於原因，我很難說清楚。它的張力在不同人的面前定會有不一樣的感觸。其二是過於有名的巴赫的《恰空舞曲》（BWV1004-5），理由同上。不過也有可能這兩組都聽過了吧……</p><p>　　那麼，這一次先如此了。再一次爲自己的不守時感到抱歉，以及希望使用電郵不會顯得過於隨意。最後，希望在你回信的時候，你會感到更快樂一些。</p><p>　　廙水</p><p>　　順頌清安</p><p>作於 2019 年 11 月 12 日。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 書信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>給LZ回信</title>
      <link href="/2019/06/23/essay/letter/%E7%BB%99Luzhi%E7%9A%84%E5%9B%9E%E4%BF%A1/"/>
      <url>/2019/06/23/essay/letter/%E7%BB%99Luzhi%E7%9A%84%E5%9B%9E%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Sorry, password needed.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="aba7924aa7d20a2220001e0f835ce6d76b3e6afc480301c53f3fb4201c97bcb0">06ec672228af806f6ec08d793425ade0bec8dda191b67fafbc7cc886a506766d43c90893053957757ca7b34cda971242fdb387f1ffbe7ee7889944e0f89a9bc93c98cf203492c4ef62da7d8750dc3323577fb91ba42283ed553df858a3ac7745d26fef8b12c8cfe6c2f40c5f4440b554949a470049caa9a1f60731f23bedc5776819a269ab1c4b964612260166b593ce49ade2a187a6b1dd050c738f2cb689428329f7baef41bbaa200f90aab5dfa0fa36b648e4d2bb759eaa33741b705a2085fb432856b900c534ab04720a70aabc2225b840d34506c1b1856f19df0ea39f86d37a7de36e52fa30ac0699c09d7d51ffe1a9dea960bd576a3d0d84104f605ee3ea514e4e69db1aeb343481846ab3c1ecf154be1bca676afb00e72f4b243418c0145a72d04a088a478b3804ec6fba844cb7079b17250b523cf817bc6225e3d26dcb5011a80b25bb7552056bd531934ad952222195a00272bd1c57e49991c711dd020adf792339b179bdebeba49b286a2bb5a253d09d7013ac376db53eddd1511d6a83c534f05fa4d4fd2e62d7da55f2fd928021e9cba2d7988e5d91f6357bbe1ca7eb8b7a60a1cebb710b048d6e1035add317a73c263b36f4f40915802a0e89820d7c576dfff6f50d3d5213a23591c03a9ba749a57ae40588227c21102895c768a2853f8d6eec98ea7f76ad0390e826b4e36492a2d703a9faef6bfeb420f38ecf2642d6de62c1f22249e20a13c0032f1a16af1c148b7a9d314adc034807e1ebc5dd6bdf8c28d1b9156e5a49c455ca070d7c0cdeef1c44b006b64acc28a80eecd82e164280d10108acc32082921d750c78d7ad50c6f1ef69b1dbacc3ed4328de6eb802bd94e16ee81d8bf8fdbd2b180bbe61ad53b890045d88d4fd2d25af693c8e5ca6a4a6692911133e651f4d7749ced42ab9c5a14ccb8c17a068285cd0e68a391de16eca90ddf1249fd3df2ae6a584ae3f10e33e12212ccd4c2c5ab11aa060505d589da16ce68948003442ebd38e0fd8bb862b486d0e3b297c1b01dd2dfacf9e871e58177f420311c13d606b7f7515c14cc9d80924d01fb96e8c2338cf328479d61a35a44e7fd243e593ec6f6ff002a6cd847275532c6807387998df876bd4ebf2ed454a1e553d9fa2cf064205c1b4a0b57768de6bafc187034f96055e84d34fccaa6a91801798e1d1cf01c8c2d783b5562d29f28fceacf35340ffce5d38e29d507d41d811de80338c47e9e21aa6c6e3020f123c7029ca533e0c0a73d307f3301ec3bc303cfc020f1aac163cc1232e33f514a7a5a0b6c21528cfa3f04bb9410a61a40b3465b2c3e620160a8db568d622f007f56a2dfb6a12772622434ab3e53d0a77a728dfb7bacd8c4d9e2936309c75c06c5eaafb986c78a9f7180b446304af75860689aacbeb67fa039e88d1aaaab83655fdfd8b1bf59e0fe1834fc6acdfc063e45b2ee84147bebe71aed35dc9e865a8f923438521872661d8fa0fcfdaa3e8d4d35b30cdb32afe8b3d93df75c183a56c52b8982cd86e16c239ae963c3641023024d73f806bd40fcef6f079d9a7283b3283c34d0bfe97c14a846f96a981a28d71a9453879f856f91e9b99fc5ae1716d758c0c944e682b69ecbf162bf2c858ad6a5c899ddf841415d7918e3a49086e8dc89b489bf0671d8a760434bb7fb90ef10f488c19028b4017df1cce351d2ea2d75ed2fd217bf65c48903dcd67364b0cddc9fa42fafd3cc24358c4572d79d33746002ed3b65e06d437119837cde80f2909b5c5a5bc938f05d7ca2fa882a29f6765aa2d24568f5f9c1177077a3e2b79899e2966910dc4012c142e7bb603ad1ab797e5440d393d7ba11ac74076902a570bdfe4b8d3b07c91c35c3c8a2d73f0090d3b43d9795251ca3a55b7d8004f946b31ad3f6463a28bf1468639907f5edc1776a3e0c7e0c391788ff4dc57de07f8009fc2e36d83d9444a0d22636490efdc4f30d4280aac0eb969ff63167552b829446748b24e88af45349f91616623a2773c50588e10d22e4b40208103cba355749d77359e4d4c712e8f6d36ce39957bd209ffae7f5512659a5ecc73f46ff0fa0627a1571ae266c78957765f9b9f7b2df02f764ed4f774fc414c16bb048f1d6bf916dfc6e4332a215d5b61c769935f01cc9c940f208f1cd3348967332028907d49ce5e366171aa47f4b478133b2c07630554c39caf1c1f8eb69af5e7cc9115d94e0c7fb075b50a393e2c7ffa17e6aab4031012298251df444dc91441cbb31647bfffc859326cc7a3c994f2fa081ac2b9b7b777d157a8cd2da6b2edc37b447583d5012a2dc6d871adfc2f82f264d17612d57186ce11ff67c9c16867ba27752fed5fb33eadb168d6a158ad61d3c1f700551d95f1aaac97dea9e3ddc181ae5d04cd84e6142caed9510a30176d4bb78dfa064c1948dbe12863e765cf13215944401e7f461ff35d101edf66be61301bcf0ea268298165965dfb5a8e7a32902107bf2d7ad9f1032ee0cb2c05e2427c3dfba18dc285f597a673bce359f4fc61c5c2a55291e33aebbaeae60ede68b73995b076fae37df7563fa491dee83cd94e4158c3bdc471b82877110676c2b1ef21cfcd553c46206fc729c00f9657bb4bcb2764a98914d808f04bde3d9a341159b7a459165ddea6a64852e96badeb7a04d873694d496095bfdb153e552f877e41616d7c5f0f3bc42a6ec0edae85b7add0cb99d515e370f91a495339224b75d4dfd552124a2b8e0b332c3a2b5738ef5f938422a0f992908ab51809890940f3592d050cf282d34dbbfb4ea6902a0b226382b08dec3bb402df5f3ff48257423a8a5cfe48a87f5a08b158efda4422acd52ae614fc24a41491bb1ea6e20a4903840019d5fcaa741af56c668488501ec3466cd7218e26d578639ac75cce6068db42a86a507b5cf9d7deec371672e618c8ac9942bb50060aed11c742949f2a09f01e849135aa739477c063ef4b9b432dcbd8805447242ad77d5d7613d729ce8914c1ba25deae8ae40fe7f7b04f5362c6cc4be9f6ed4b1c5f57504cf8c34ea0fc95983dffa9d5b3501b0e67e2327a9b88d08d258809f5874a36461cafceb7c320c17cb8f0a77710b52151553e27ada417800296fba5e4f15f8f6255f4c4d0b2a58227c53ed0a83dc544e5de357d8d6e1c3e9ccc5877e46cb9c57c6b0a42f7910e2c58ed0183b5cb4ed688f9e129732dff4da1cb9f69c5242cc9a81edc5005ae87d54e7b947c0b7c6673a502734902518df45d0e4115baa896b8c623065b48738616c560a3b6892aa3a37a6336f335c561a68106b16f6f70d7ccca25558f0fee31db2bf798f349c267c91163ee80f3c43a401fb7705cbcac0cea25a133d3b3bd743daf64f7f1a99b265764e0c2a7a244826efdb874e8eb9a0055c84374b32c0c9e39bea14309acdf64b2b1b7d819fe0908256f7bf6909d1d2401acd9e67f9f1cd82ab3ea9459b599e8b348b0b5cd89292e9519ca919fa6a274fe456e22bfaf91ff87d39a38d21605acdf8aeac65d298bdbda1309c821c5893db5749d3aaf952792ed03117d7f8d03ceaa5e06129618fc66f478ace7b18bedc4bd89ef698f216a5c6ecd3edca127f0c5cbe22d2ccfa4047e673b9f3ad7c7c68d7f0b83bccb35be22a782f1f3396d65c9a5618270676b3121c3788ca4115c828d012320f21ef1494aea1866cbf8119da87f70404e1c485932de58cfb368eeafac591d73641ead509b7235a602cb7281a812c4d2cd7460f2ccf01d60a3fa872925aac350c266db5be4a60695a244f4a686e86b7e0d26cf122121ffae9675a6bbe41f4c3e804ee65385e5fff80710f3c888e37358ae4f77161954b7d5d30fc1e67989e15f9ff35f8c40f2215c5a1a829cbae43f414fa06222f68c26faadadb07de54bb7c85cc2af2667934ed9a4c86dbc549c2e43c746752f8dc1a7691a4d39b9cddf565a98ddaf09fb33d83b8126c285d3ecedfe99fc8140e1845355bcffadc0a73b24e64870d89e50d492965e2aee1fdd2391d9ff5b943f1b25481b5ed21ecd62efa3279c9437c15d304d1ffd0c89716fac41dcefb908dd6f5466a19cbb3e291f844d333f5df0da36073581c9074fd02b819d3e539a53c29f00a5c4b45dce7ceddc0e96b6c4c03cdc7a85e0cfd4f4f50b35d8d343b193fd07fd5caa83bcc7cd278b8049da3990641e62dbb61d3db0ffafd5d5f1609c343016cfec9bde2fa06da95f83da2984e34cc3bc6508b38608d6f3d34fb0274192acd610643aa3a48fe7a52633e09fcb2e2052e66d09dc4b14223534a49e55d9f925b9c17409c02733d7815f9be6539d087f724791d01b8428ebfa3b180bcffbbedd4f86e683b6add671c4f5f7b182293477cbe0a838e3997d8c6fb67226cee025c0e0be50f97d1d964d8d7155f1384f542270b7d2a1ef51cec7ea829a9fdbb0236ce29afc27559ede344632ccd66862a26e7ccf62f355248c56826df578bca2e011d882c7ccca00f964b284126b8259c19662cd7d126b8b4105dfcde522a5bc0867626d197440df77bf1b6e0d997e59934a6cb67375fed7def9d2357d3a369dcc2fb17b0f5223083005af91311663076724143f936632611cc89741ca4e3d0d6945c1949005b0eef4ce7307afcbc11aa54763b63cf8fa339f12d9b54dfcb1a43be4aa91104f316c740957614d0cba39e0a342f5173c0a4caf7924d7aed3010fa9c872280a9d47335c63737f81a3c363ac02e3961d6d831a1011474e31da4310c43e28bf0d2a7c884f7fe89ca36ab597405a2cee3c393e22d4b68513505849ff7b030c134fe92ddc70bb3f67e1d4b51f7d4d73cb8f36f5fed50fbf972bb21b3d5e5a1f7895d869a71b635fa1560ddda40ac57cef5ebca6e58d30fd17ffcf1caa619d1eaed44ba47403d2fa2a14a2e0a553b56ae1acb1bc4af271d7364e26fd5da5c17a675b56b8000bc9e1c1f0fe769ed4ac5a82ac2825626a2ac49c6a804664dc67a8db292fbbf2b20b5b828649fadf0cf0720c627b93c3547994ca12cc47221e96ab84a6e83627f7c51cbf91bfd44b6f427f8da5a968f96e208d4a78799f54749f1190070ea8e86dec3ba8639a7398334772792e6eb346470b43ebc736e757fc8ee716433aadb6bd1293704ed458dec30f73194401e4bc55066dfd37c5c5cb5ff9842a8e2ac8f906a4bb4915b5c358996689630f54c43bdcd2a138efa996fbd2668c00fc5ea3f215c98c0141ee6911d7b2b294059960526a8cd70a69839d79ee52aea0bfafa36f2a40f00379232298ef5f7cf4c2fcc32dc0f2e114fbd1d00cea8bc24ae17d2b40fab1860816f525d7c989d4558fbea05daee272a4b696c5921d59faba5c975ec27d8d96d2c6465bc534f96efd17f0c61459e9cc886d9ef402990b52b7aa924b030e4aff108c815013480e381f2c3a810fc07ea73a7c60881b3a47ed6ac09c242ba215293c30715b6108641399898c1bf84de836d87e37ffdad0e3411343423b660ef0c031c92ce022a1600f6157e79cfa90d636c9685a5572c356b444eb0aa0dd6977d10c2dbd58eb6600f79f9961b132ad8931de13f10d22f2179673219343b87215efd842645446829556c7f22bbe1143c786a38cd125345aa5d5740475d5e016b0997fadf63d3f8411994b3ff669f5a99409a5393a15940a2c9c6d56589b74d90e9cdcb88919c8e6fdf71709291f2d67ec9dfbed8a52c6cf64bb6707b494fb9bfa0ced9a35a76d2e547c224c111f1470baa6146b6d4a78332dfb2df1a6246472fa5250ce9921ef0e6001de8fc89d3a67f3d72ce05a1969f80bb71aaaee446f6772834d7b0621c82833111f8fe944ed103cd9e492271471504cb514870431e8351e4043ebe1c8a9ad7edf52dd610fc889d38b8f405307bc2c1afeedcb1104b3c1ca9da6c119e897201ec585c84480b217ccb681327c111ebfc486484fdc4d35ef1b9dee30edc730a6e3143f371b69f3caf1b9ba3d67cc2aa19dc682e3e6d16000eceba300029d9507dcf82b19bfc462f5bf6e596a5c287a7d806ff81f74143023101a2e71df6e25e2ebb6e3ad48ebfc8115038dd2d5255c9dd736aa40a1f35a7ee046d2af5d71025ff2a6ab1dae5331591007ee8aa105dad4707f990e0c5a1b3a38d7c9d9d1d219f2275ad6d33ac8cf5dc34217b22cf7bb623e2daa73035bba290142a90d51cf6e7d7284b91d6f5ab162db073cd133aafa3d0cf40e85b4f7d0e153e8e73bb3a41fd11b33b0f7be9b154f90032a1f021d93133ba5e9c8e4db5d1f0159f70c68ec0331714eb00f225017cb47fbaf2091f0697c1beba8de9cb48ba672a8272c4e7b90588fc9035f52592dcc981f6d37268dd44e76992cbad7ed9184d142a1035ad16470d526003dec7c14840fac0e9b0d812d10766e92db6c838932516d57345cf9b8</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 書信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公開信-給YT的回信</title>
      <link href="/2019/03/03/essay/letter/%E5%85%AC%E5%BC%80%E4%BF%A1_%E7%BB%99Yuting%E7%9A%84%E5%9B%9E%E4%BF%A1/"/>
      <url>/2019/03/03/essay/letter/%E5%85%AC%E5%BC%80%E4%BF%A1_%E7%BB%99Yuting%E7%9A%84%E5%9B%9E%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-JJPVoGwH" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1422978054" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>YT，</p><p>　　至於怎麼稱呼，居然想了好一陣子。希望這樣叫不會顯得尷尬？算起來，好久不見了。上一封信遺失了真是遺憾，推薦書和音樂這些只能期待有可能出現的這封信的回信了。剪紙也就沒有辦法了。事情是因爲殘缺才富有詩意的嘛，不過這也是我喜歡信這種交流方式的原因。如果是郵遞的信，這種意味也就更重了一些吧。那種發出去就可能杳無音訊的東西，真是蠻有意思的，這也是信的命運吧。</p><p>　　其他的事情暫時先撂着，我嘗試一下回答那三個問題吧。初次看到三個問題，以爲第一個是最難的，但仔細想想是最後那一個，也不存在什麼隱私之類的事啦。那我就嘗試從這個最難的問題開始解決吧。</p><p>　　之所以說這個問題比較難，是覺得幾個形容詞兩個形容詞離我蠻遙遠的。我查了一下「懊惱」的定義：「因委屈或愧悔而心裡不自在。」給的例句是「即使被別人誤解，他也並不懊惱」。遺憾的意思我倒是知道。但是這個最字就很難了。說我是一個沉悶的人倒是可以，但是這兩種感情似乎離我很是遙遠。怎麼說呢，感覺，如果什麼事情發生了，我也難得激起這樣子的想法。委屈我是很難感到的，似乎也沒碰到什麼讓我委屈的事，或者說我心大吧？至於愧悔，這個事情就更少見了。我很少後悔什麼事情。至於後悔就是覺得當初應該做什麼而不應該做什麼之類云云，可能一瞬間會有這樣的想法，但是很快就消失掉了。正如小徑分岔的花園，一條道路在某個地方分叉，便構成了一個新的世界。我選擇了其中一個，也就這樣成爲了自身；另一條道路上的怕不是我吧。所以這樣子的心態讓我不太產生後悔這種情緒；同時我也接受缺陷之類不完滿的因素。所以遺憾的心情若要產生便更是困難了。倘若用時下流行的話來說的話，差不多就是「佛系」了吧。但是又很奇怪的，我自以爲自己是一個看起來大大落落，但是還算敏感的人，不應該沒有這些細微稠密的情感才是。但在仔細的思索之後，我覺得沒有什麼。</p><p>　　但這樣子也未免會讓現在的讀者感到索然無味。所以說一個可能和這種心情有關係的事情吧，然而我也早就釋懷了。即使曾經有過可能類似的感情，現在或也早已不在了。</p><p>　　是初中和高中時候的事。我小學六年級和中學時代都是在一個成都的私立學校里度過的，這個學校在當地挺有名的，也有很高的直升率。所以從小學一直到高中都在這個學校就讀並不是什麼奇怪的事。於是在這個階段里我有很多七八年的朋友或者同學，但是在直升的過程中也會存在之前的好友分到同一個學校兩個班的情況。雖然叫很多情況來說已經再好不過了，但總是叫人遺憾。於是你或許大概知道我要說什麼樣的故事了，但是爲了避免感到無聊，請先打消自己的猜想吧。</p><p>　　其實上面的背景並沒有描述完。這裡再補充一些東西。我中學時代在的學校一直都有精品班這種東西，即使小學也是。我當時是小學五年級稀里糊塗地通過筆試（這是另一個詭異的事了）進入這個學校，然後進入了初中部的兩個精品班中的一個。時間很快到初三了，這個時候也是決定直升的時候了。然而高中很特殊的是，他的兩個精品班是兩個等級，分爲更優秀的和一般優秀的。既然這樣說了，這個故事就更平常不過了。</p><p>　　下面可以開始正是講這個事情了。當然是說關於我和我的好朋友的事。下面以 L 君代替他的名字吧。我們是從小學六年級開始做同學的，初中也是一個班。怎麼說呢。我是那種不太外向的人，平時也喜歡孤零零的做事情（直到現在也是）。加上初中學校實行的是住宿制，然而我是走讀的。所以從哪個角度都是和同學關係更疏遠一點的那種，於是很容易想見我並沒有太多的交心的朋友。L 君是其中的一位。前面的事情就不多說了，總之我一直感到很幸運能有 L 君這樣子的朋友。非要說的話，其實已經結拜兄弟了……總之這之前的事情瑣瑣碎碎，就跳過吧。</p><p>　　雖然我初中很划水（我一直屬於很划水的那種），但還是勉強又可以進入更好的精品班的資格。遺憾的是 L 君沒有。然後，當時我說服了我的父母，我的班主任和年級組長，選擇放棄進入最好的那個班的資格進入後面那個。每一個年級一共有一百來個人直升，這麼多年來也沒有人這樣子幹過。我很難說是不是因爲 L 君的緣故，但是坦白來說，極大程度是因爲這個。對於我這樣的人，能找到一個朋友是很難的。所以這一番努力之後，也就能繼續和 L 君做同學了。後來高中快要開學了，然後軍訓、開學。拉拉雜雜一堆。當我走到我的新教室的時候，我的初中同學及高中同學告訴我，因爲我選擇退出最優班，以及兩三個直升的同學違背直升協議去了期中，於是通過最後在直升期間內的先導課的結業考試中的三個優秀同學升入其中。他告訴我那場考試我是考的最好的，但是我自己選擇退出了，所以並沒有通知我。然後我就知道了，L 君進入了最優班。這個時候，我正好看到了他，確認了這個事情。他大概給我解釋了爲什麼沒和我說這個事，然後抱歉地笑了笑。</p><p>　　事情就是這麼詭異，可能其他人看來這巧合也過分了點。所以自然而然的這裡會產生這個故事中應當會出現的後悔的傾向，也是我講這個故事的原因。在那很久之後，我都覺得很難受。倒不是因爲他去了另一個班，而是我在這一個班。我爲他能去哪一個班而感到高興，他可以有更多優秀的同學、獲得學校更多的幫助，是真心的高興。同時覺得自己如果當時什麼也不做就好了，這樣還能繼續是同學。於是這樣，在高一上的時間內，因爲不在一個班，寢室也不在一層樓，平時難得見到面，也就上操之類的能打個照面。於是當我在爲高一藝術節寫班級節目的話劇劇本的時候，不免覺得遺憾。這種心情真是難以描述、更難以消解。這種心情持續了一個學期，他是知道的，但也沒有說什麼。</p><p>　　然後到下半學期的時候，我們高中有一個類似於團隊建設的大型活動，有一個下午是戶外活動。那個時候是夏天，最後是那個翻牆的活動。就是一些人作爲支柱把另一些人托上高牆然後再上牆之類的。我想你也玩過。當時我們分到了一個組裡面，但也沒有說什麼，就是坐在一起看其他人四處跑啊跳啊。然後我們就在那坐了很大一陣子。後來爬牆開始了……最後我找到 L 君的時候，白體恤上就全是泥巴腳印子了。然後緊接着的校運動會，L 君是學生會的人，自然要負責紀律啊什麼東西。然後我在學校里瞎溜達，去了趟小賣部買了瓶水給他。</p><p>　　後來我大概就知道了。這件事情沒有什麼好遺憾的，我想。或許正是因爲當時我選擇下降，才會有上升的機會。我想這樣子也就夠了。我是一個陰沉的人，平時就喜歡翻翻雜書，周末也不會有什麼交際，思想也總是混亂消極的很；然而 L 君是一個完全不一樣的人，很積極、主動，在同學間也很受歡迎。我想，這樣也就夠了。他是一個很有意思的人，我覺得，這個機會給他比握在手裡更好一點。當然，這也是瞎想，可能不論我是不是做了那個決定，他都會上升一級。但是並沒有什麼遺憾的，我有着一個朋友，突然自己覺得非常難受的時候可以傾訴，可以站在那裡一言不發的聽着自己的抱怨，或者聽我平時的漫無邊際的空話，我覺得已經很好了。這樣看來，我稍稍遠一點，他會有機會結交更多的人、認識更多的朋友、看見更多的世界。後來我甚至有點慶幸發生了這樣子的事情，雖然我並沒有覺得自己發揮了什麼作用。但是看見他後來過得很好，我也就釋懷了。</p><p>　　再後來，高一下分文理，於是又有了一次調整班級的機會。當時我的成績出奇的好，於是沒什麼疑問的可以到 L 君的班級。我的班主任希望我過去，他覺得我可能在那邊可能會有更好地發揮。我後來還是放棄了，呆在了原來的班級，我覺得這樣就可以了。後來又陸陸續續發生了不少有意思的事情，但是整個故事差不多交代清楚了。至於我中間的心情變化，是很難用形容詞之類的描述的。如果希望更真切地知道我當時的想法的話，或許可以在這些句子的構造，以及敘事的節奏里略知一二吧。所以我的懊惱就是這樣，無來由的生出又消失，最後甚至這樣子很完滿。所以所謂這種感情，我怕我是真難得體會一次了。我自以爲這一個問題我是回答了。</p><p>　　然後我試一下回答第二個吧。這個答案就相對隨意了，因爲我的答案自身就是隨意的。這裡重述一下前提是不考慮生計問題，也就是也足量但不保證豐裕的資金，我是這樣理解的。如果讓我選的話，如果假設我有那麼一點點文學或者音樂的才能的話，我想做一個流浪歌手在各地走走。就是到處走走，先把中國走一遍，走累了就在就近的城市歇一歇，看看當地的博物館、非遺什麼的，就一間小旅館裡面寫寫歌，作作詩，最好的話是有個能力寫一個長篇小說。然後思考一些無關緊要的瑣碎問題，學習我感興趣的科目和知識。如果在一個地方呆的厭煩了，就繼續走。中國走完了就沿着中東的方向往西走，去一趟埃及，然後往上走去歐洲。把歐洲差不多都走一圈，走累的就找個民俗呆着，繼續寫詩寫小說，學習以及遊覽。北歐這些地方我要多呆一會，看看北極光什麼的。然後繼續到處走。</p><p>　　如果能活得久一些，就走完了全球還能勉強回到中國，我差不多也就累了，就去雲南貴州四川交界的那個瀘沽湖裡呆着看日出日落，寫寫旅行記錄以及回憶錄，把自己所見所聞都寫下來。偶爾去其他城市拜會拜會老朋友。然後等待那個時刻的到來就可以了。</p><p>　　這樣看來這個答案是夠自私了，我沒有提到自己的父母、妻兒家庭、朋友和社會事業什麼的。我想平時回家看看，在家裡帶一些時日就可以了。家庭的話我並不想考慮，這並不是我理想生活的一部分，我是個浪蕩的人，並不想連累其他的人過上這種漂泊的生活，並且我是一個習慣自由的人——看起來很是一個沒責任心的人說的話了。以及朋友，或許我有提到，既然是旅行，到一個地方就拜訪當地的朋友。當然並不會又很多。社會事業？這是一個很難的問題了。它本就與漂泊的方式格格不入。如果存在那麼個清閒一點的工作，比如一年都某個高校里呆個三四個月講講課，然後其他時候就自由地到處走走、學習自己想學的東西，這樣最好不過了，不過難得有這樣的機會吧。如果以什麼責任心或者別的來指責我，我也是會心虛的。因爲在這種生活里，責任心沒有什麼容身之地，我也覺得苦惱。</p><p>　　這樣，我覺得我的第二個問題也回答了，雖然覺得可能自己回答的不是你想聽的內容？但是我盡力表達了自己的意思。倘若爲這個選擇遺憾的話，我也覺得遺憾，但人生就是一個稍縱即逝的東西。有形的事物終將凋亡。</p><p>　　然後我來回答一下第一個問題吧。獵人、農夫、鐵匠、木匠、神職人員、外科醫生、天體物理學家、小說家、橋樑工程師、幼兒園老師。這個是沒有採用先後的，如果要排個先後的話，估計是農夫和獵人占首，神職人員和天體物理學家，然後是幼兒園教師和小說家，其餘的話看着辦吧。總之既然有十個席位，那誰先誰後就不重要了。至於原因，相當主觀了。不過既然是個問題，也許可以對人的性格分個類吧？或者判斷一個人的決策能力？我還是大致說一下自己的原因吧：農夫和獵人，滿足或是需要，並且這兩個的新環境生存能力很強，適合開荒；然後是神職人員使留下的人保有生存的希望，科學家儘量留存人類世界遺留的智慧；幼兒園老師和小說家擔當教育的職責。其餘的就是保證可以有屋子住，可以有好的工具使用，可以排除簡單的病痛。這樣就足夠了。至於其他沒有上榜的人，原因不一一贅述了。至此我認爲這三個問題算是解決掉了。至於你是否滿意，我就並不清楚了，我儘量保持真誠就可以了。</p><p>　　然後猜想着你的上一封信是有書籍推薦之類的東西。我試着也推薦一些吧，可惜最近讀的書是真不多，而且很多還不令人感到滿意。可能之後都會這樣了，畢竟也越來越忙了。這裡我還是推薦一點吧。《荒原狼》，雖然感覺你很可能讀過，我還是列在了這裡，對它有一種特殊的感情。也許是代入感？如果沒有讀過的話，請試一下吧，應當是不會失望的。音樂的話，我並不是太敢使用這種形式推薦出去。說實話，我平時慣於聽的音樂都不太開朗，陰鬱的小調占了大部分。歡騰的曲子也莫過於貝九了。所以我試着在這裡不推薦古典樂，先推薦一個《歸鄉》吧。本來是火影的一個配樂，高梨康治譜曲，不太好描述，可能聽了就知道了？本來不是個看動漫的人，但是火影是個例外。很難說明原因，都看了多少遍了。總覺得有一些特殊的情愫吧。雖然我沒聽什麼歌，還是推薦一點點吧？David Bowie 的<em>Five Years</em>， Ashram 的 For My Sun 以及 Tamino 的 Habibi。這樣子，你估計就知道我平時聽音樂的風格了吧？</p><p>　　然後，說起這個，現在也可以反問你我這裡回答的第一個（懊惱）和第二個問題（沒有生存壓力）啦。我也有那麼一些興趣吧。至於第三個，你肯定正經地想過了，所以我得換一個。所以，既然我這裡講了一些關於我的朋友的事，請你也稍微說一說你的朋友吧？如果可以的話？</p><p>　　最後的遺憾是不知道你的上一封信里寫了一些什麼。我是挺想知道的，這樣子我的回信里也可以有一些評述。可惜遺失掉了。現在希望的是這一封就不要遺失吧？最後願篤志，找到自己的那本書。這次，就這樣吧。</p><p>　　順頌清安</p><p>　　廙水</p><p>作於 2019 年 3 月 3 日。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 書信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>給三弟的信</title>
      <link href="/2019/02/26/essay/letter/%E7%BB%99%E4%B8%89%E5%BC%9F%E7%9A%84%E5%8E%BB%E4%BF%A1/"/>
      <url>/2019/02/26/essay/letter/%E7%BB%99%E4%B8%89%E5%BC%9F%E7%9A%84%E5%8E%BB%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Sorry, password needed.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="9686521bfcbb50088ec282db9d4cb3d71b26843b365c997bf6b449ff2c5dd190">8144f56efd693c6b52f918ba14052d30e187e09e1796f5d24845830e100d850e813284e1e4f27fb7a17b520000639e3fe11260150f738dafa19c2a484a6093b37cb2e03c1826502862a66bed0f8b3f8c49d5e2f86b9b0cddb25ea358b848b5ad4df97aed595cc703b1b26db84ad561fd6013d587f975a7437844a6b3ed3d784f3c434c51b15031f7e1e5c26d8592d9452583f942a2927354ca805f30ca9f364fc6a0b8bd7118c02302471b51b3d527f623d67b8c32f5b5aed541dcefa36082e1b5ff2bd97770da695839dc0b122fa11503829790d752a69afe306c172192013ff7d42a6658b996b05ffdca27375a89eb7bff2147121c3c70af040adc69e6404e76ba1e4d147205406f9a76389fbfd1cddec5d6f5c74415fa92cfbe653e99594eb480798a30dcfd3a59fddcbf9030fc673defdccca892801f19594afb1c9133fc28dfabc21117a01d4567c61d6afab44a3d54cb527fd46a0bef4a2bc63cf52f132697efed57bcbc297c9196d77bdb3c393aef39a95002a4a93026179eeecd0dbc87bafd1ae58491f8b2a8e38290f93b065951c9a6a97ca3912eadfe72f3e299d25f8e28e6fc5b4bd9842a44ecfb934d0b6c17fd0c335d9c7708e98930249f16964f9a68993a7ec50f9ffa8872eeb70e4d98a922b27c301dacfc95c8440bd9d43a987100d9469c7a2ed3e537043c336568177b8a4d69e0a804d57fe3e1454b91baa9f9b93ceba5934598b4b653a7f5f5e9cb621cb9e5780cfd48ed5eff2a14571025e12df3fcf787a9ee2336fe640ed9d6c5e4334fbd1ad8881310c8b8232f363fca88f64f1d737bd3b6fa49ecce018a5179494d9f34712e0e5a6aa8c1fdfc2d035c352c36972b6e3363b78e1d64ccb32ef22ae83edfe8efc219ab31e2e492a5f993e4236cd02b23647b59f7edea765456a7e7cc4ca01ec41dd070bc57deae85eb3a257f69fbbc8eb25ea9613256d7081e8ff206ce3c87142b9670f003873005f1973b775caae69f5b8483247733997d995d7313aef007fad92c6cac6c67881632fb649a06dc623d410884a7d7a2a893dc5cc29b7e127bcb09a784718a99571c2174af9ec56b88c2420f34d286554f073c2100d88784627d078ebc83e5123eb248165347da36617b53c4bc848c043461a0bbc1f65a4d04ae7fe67b7fa652ccfa324690dff67a45224a2350d3b8ddc1a716e229953202b486e0252ae039a359f3b3613daea6df736aa4daac6dd5bad506280f5cbfc3d58f48aff8e741e5707de8418763a0d9a9cb40181e9e72207523e709cda6e9aca01d64f1660bd46616093e1cf2e2570a26f7c4ca139983974857aeb71e5e8aceb756d5e1b094824c901ba9e098809a53c10f421b7fcddf86bae4257caca1e9d977ecabec5868009baa5279a580e7b688212dd73e7156cd606ac99840e2ca942326fbf5ccc558e7c291411ae5d4c6e4ac9c6d6ca6df07f00cf5302fadf86b4eb4da626685c819bb740144e31bb2486b21851d58b5460783b63635d32191867d9a8abd03a030fd4b221b597319e3e69a79e557753814e19d9f6b9309e36fc9f8408f77942e845c748a69f2b027fda676e234e695d94e33fac66f72d2e2d5beabdc94ecea51961ea19cc81ea93d846437cd4fdf770faa01098c0f2df53441df85ab65b3918cfd0b56ae6cd0cc471fecfc696fe0351d77e92715790b847dbc4ff024025c9054a17282d45678baeabd3b9e0af8dff70fc98ad1d9c6ffa1191bd3845d1423861b7da7953973bfcaa0ba406855d28872ebfcb1c62cdba290ef9ae74df5e0e359a3401bcd348086090055082eb1a0d06e2e1a0ea6c20c199c5d2c467f670cec5b1f3f6c821e41103f8c6f50d0918c43434b2c3022c5a4a6ffe1210cb9391b67334b20b581423b4f61f5b74a654955def7d9c1994a448d636b6f8585cc61f446b1cb676c32e5fc488e005191c4d00035fb0492d9bd7b599b587d3cba3d7fc17e99136bb96f59a1562403516f31ceff54d6e314b8d92619fa6fd39473de62960167347d18858b181a96505a20163fa53f59ba6ed3f4b2bf47f29f0d5cda04e0a3fe77580f8b5b3af60afba59c5ac876f065d627b6020ca7dbfe2f5a6e4ae652f9d7317f72d464cfa6b282e6dfa6f93def17bee2f1b2c176595f8a2ae2e83418ffd0280c1f304b47f8acdf54d8a705edf99b905574014c8493311f51e69bd3985a897407ff1f0c9b6f9a366adcaeb78794a0a7cd00af24f976e297452ee76b76eccfda79dd0817eb74d539fcc12bd4b9d60cd21590cab420c5a630b2642a13e4a65612bfeb4123cb5f1992670872caf23e8e2592f16090f3a15b8f30dfc67179937eb63dac9b42af6685f49162854c7a33f14e2ffab874c8aec6e64bc976bf8d1299ce33f0ecb531de7a9433517a8faa1ee089467e7deab758bc0685c8149e99f0603e64e8def0cb10c158df11b9e1ec73919f282a99bfdc55f31dcabb0b274dd2aba71e277069358f8d6c0dd93cb2383e6c9260c5d399e10d6acbc6159e8d72eacd4ba0c3a130afa5921d4f134f341c2774a6df97f39da2e488b0e9cbf6f2466e2b6ea8af77bbfb1991c0c9d611504e2f74f2522068577ffa4b04cb06cdffb75f76ec202b60c11929c0617c4c3070d6bafaf6927493d3e4048573c95676c09503dd10037a0f1e49166197a38e5a51329b120c7d14352f64c47be75ef9f3c438b20a823d228e1ee9a502018c2629e9ebaa3708eb4e75d12bcce041c694c48f27ad1f5d832f49a9d1283784cfe5ea662f08d8c014ac430f4d490bd5f12c93e44924bccb70b3ab8ffb1bce30addf45d285ecc0273048563ea6b9cb844c90aea65e412fc93f46d60d74336067edc31171cb7226850e8a2c175d1348e2bbd6a30dd522041105b9b8f80e7b333e01b081cd85957a3b7ccc2499d1c7e23e370085e99a52aa95c687f2a2c6be96a5af3e12f7f100e85c9433e9186bedac4558df957dc6195362393dfe893f4e6832b211f90c55ee8174a0ab21754d18fe8251459ddb6db7079ddcd55f01fa82e04fe45c50a9326e277d3557805606d34cfbfc31eeb25876ec843824ce012abfe33fb9473868a4f31a4bff6d0bff2cb5d2beb31f3d0b4de6b68203dd94cc7f2ae46adf13fa06c2bfbc3eb83638072a20f2d1b260952c8bfee37b0c0cfcb1dd52ce575557d6ea4f871acbb3c6edcf4c4e7c7aa7c1f0e6dd923bd0963db61fbdfc6466e883a2e70f4d8341aca3b3765839b22f5657b4be5e55dd97466af12848e4a6e86b4c71e026b0a7c3c883150b6227fbc15015e000fdf770ce0d4395a0a0d1b4879fe646ed504cd5652053f0d34ac3717ff3dc8de9ed64882a51bbe03bba59543c1adf841b85186022aa96567634adbfc52b6bde2d8211249b14fa6b002f020f2ad11ad7ff81697cdc42c3d15d320e4906ca59aff0a8ab15f1acd9e2bfdce5cfff5964e17bdaff49de604573539372a933d931c1397f8023c3a131e66eb4c71e5cd64d4cdf014e508c6ace86b67afe3f2309144220b9818a84c1988af32cd5ca8f7ce6e724ed160d38232d9cb14352e4db5d16bb7099bda71fcb4696e95e7242985aaddef6cbad0b10d47de360447f4239ef12e54f1af0e4f590a4157ea30f955dcbb0593ec1cecffc952ef9311a37dc2a90d0cb0ded6fb910c99ca9e8712294ad534cf67d3d9d5fcb0dc5b234e06d33522bbf97f3f4fca04892a5378f5907de62de0d9d73ed06a2055ea2e68aea18a2f26e69658953b300504e3cae44d2e9e595580c2829368c6c047e6c38b9df367583be7232d9c3092e57ce837b7316081cce296c53507332111ee3c60886732c2c225e47cde6d0497d2417a2987488b083a63985076881b487265391a10df797bd022f1ada4087138b17ce384ddf98dd9fc7866a2bdd757ea9e033ecf7b038fc744ec26a0b66037793b3d5ec29b25017f41f6535c8c98fa1bbab7211581d93549de0997208db0046895acad55ec10712531a6da32024615832981246a99935e6e37106b818c37691e6466b75990f67d75e8db3cd7ed046b743213f700e6cb249ae13eed15aae2a2206eeb5fa9688d5db9abdfa68c85d33993793c283ef65e0c75aa14d9a933045bcea7449f922deae7865c0f600fcd474adf8e692648a6af134c4644c797b07489c71f598aacd59affe3ee21a655384b66cf222d9a1d1b72c21e75009cb24e9b41cb79e13864c8dc0684d0e0c6b28ac1ba7fe8eb9ba0fc2590cddc0a5dfbcfe1c63ccbdc09f2cfcbde4e0356e797adb845f09879e4ea2e631f235a5fe9705e426134fe4617a6caa44c42361e65afed29383edea7ea9e96dd7c35129c2ce0f9051cc8b772b5fc2c7543b589f6f82771096a867a1845ae149af3a5a87d2c49253289223dbe50b9967207645f20b579ccb903fcf614839a148854afea6a1c03d3b9eccabdcadd35f5a7fe0ee3d52ff2a12d849462c8d6f0da839cea4a4d9d5f1d9a68f1bfa2f2b3c5009bc4023b1b60b790007948b077fa5068ef10a1f3caf6b1b97b76d73dd9c3e4a203173da1a139b7b07c59afc19ba522ede34524d85f4abe1a58de532ca5009a21b04482cb806632fc623e760bad2c0e03270494df7136ecce036b42d5e86627026c096ebf977c9e4787797f3a115b492b2d1b8d9fa7182b8bbad88c721751ff8be37e5799dc1fed69a96329e9de825f609d84fb11d5d5124e68fb444a977d8838b44c41991392b06bf3a671ff4924b01390e3bec3536ade76a50b016353b866b77579fb77801cecef9cc26b84e523aef6bb4fef1165dc74fe9e921a4133f2cc13828f594e38bfaf5f52dd3a5cac1b43a79d626a884b17d1c87ec6c9306cbe849c3a313790fee099ee582d25946559f65973d989866e92d6572696d2dfd7ef87b0f93a29245a9ea5c3a75fd461a6bf97a358fb7fcd05d0c1a61ab471a1867514b55ac4e5c8025596888f02397c5bf4b2114ff104db9ad55dd11593d0be0bc05f42103871e1a2a87b4669f81458a538df71c5d8185c69925a0c117d1e940737db0d8e8b1819542febc635adcb48a622b71569ead44a7b50bb7a3f51e26f1170a8c7d46414dc973156adac4b306330edfad8502527cb952e545c1bb497f982f9cb53fce878fe28b8eaaeb6c647f76f853dfacd9dd5104750b0ae8b37edc1dad03740b6c30a833b73d9dab97315e965a5f90cd79cff277e6b87470d31653be9d0d266c48ebace86061e2d967055c66f17503854d760c37e8724a5f4e064932be1bceaa271832bb2ce6f5489c3215050c388feff970097df1afd05a331865708851f2993104a61ab3f37def67f3fc8037e946ba81b9c4140936df27c80b0c9ebf5429ff45b756863da7307872216227d19cd9fab8c5aca50978c0688f66010a3044cae17352e109807544477babf4f546da94ad0b317de2cbec6fded3328000e8ea13d3c3b5ea434e13f8ae5930f040ad2e2afc8025ebcc2aacfb401c4e93e5a210d462305a21f599f9fc9b008f3d67849e594b956cad2eb14ac61dee1c5d7e9aac6a7b68d17f57810eb3aa758c554e30b15e8266414e54dfeb907e35f58771ffeb044a5ec2533c4b21206d956de4b3a47e7f49a5f83b9dbd2e66ceb24b9b1a09a5d4b35e813ebb11bc339d0d0170066d16fe8b901e2151c725fc4f5c60413ea28373c4242eb3e60bd446870e988497a51624868b84c776eff8bd1b49ebdc6294dd9be870594e1b68a38537c41411f0ed245ec4eb4b885bd9df75b0b25144fb4b70f7f7dbce52e0a71f24e7ef24d95bda01a0597703ff216c49caa77159b88308d3c14ca3c09554b3803143025a451164fec371159277427d59c12f515940a616bcb5f688ba6695f2d1e50899bbd770207e900aae5fe7b463faaca140fa89173717356ca2fae9e7c192c8c3532754e926a8bbbd53f1f89a3d07e8889879e3b2b03cc01957a931142c48135953feff45de1310ea079c3a5a049d76566678c1f030a2f5322b1453cc1b3008ff9ff6a93f0b6ea12aa4fe3604596c05996b6289d4e20bcb2ed2b4a00abac91dd33086b00a6a4d493bffd3d663dc1b3142a9e987aaba9a14806aed7a79763e5f085fd0c41ac5a1ca594c551b0afedac26db64cb4d1c05bd7f1a4cb0ad09b87c6bb9ccab6195f12a3e27eb1a792d909b21a6512f61f25191f80aadc6f277409e8939aac1579e43ca49bfc17bb161fcee5fc2cd5c0241bc88312e2199daf573549ae495b3d863fb5a9a5692c52737946a4a0016ea6e5f1e01bbb8d1a8ba1ac0a0be05ded68e81145aad7815a19e961a3f41f1ba97e00043130b09682273cbc241f08ae90aca21cdb87477eb4ecab6064d64f79c7483c988de971a82bb2dd7e5bb6a8a2a6f8d8df645cfa1a7a0049eab85317d5571515b61a4a09dbac1c9cab38350fc2991485246eb6838c210563b79cf99fc66413bebf5e961f9a5b7536009c4b33a757ba3782f9593f5a3b3ecd0c6ec964619341c47c9e6f3293a834fba7a4bf7711ed7827f0127aa5131895a152407644a7d0f5818b11f140a935b27151c13b9bae939570466f3600d1074597ccdac24fae779d98a94edbf7bf51a90d77931ec01605bee1aaf1d4aad3536fa848681f71e01ddaaeb843b7e164f1b1f9aeb3c84596be4d64c326db8007e2e7058fd0c070ce4508ae21ae974c0d8d36f3296991741453121415d3f02527c5ccf2ae51ee2fe1bb98d7ad2badec09a861d8428b99b89f6c952e56f50682049236e561223bcdc319ed02b0f725ee0ada2212c13dc5ae3716dc460567d6c168c6002b3474c0c35ae0995057bc3a9d529ff91409134fa77bae63838af240974580aa4ae52e7a99aaf679728e9f15749c54eeb0e704d8ae09c4ba8203c49d5cb9052c388facfa92ad4dfa7a62e7ee6ff246179c8bad4946e130d76368e2bf4d32f7c29e9e6079e4ad7be0f5fec2c7c658c41ca98ef70f5616fccbbd51e7e34da9b9e1fc410c4f7833c09779a6156492309fa7fa986c40ef07c6aae2498aa2b9ebe45efadd34bc4c785ad91a420d10786100c8a36a26bb39431ea061735d8a131765b528430508769480b63899ae7e3f4e323dc76ee2867a9cbbea7b1153bdd6b6228995460d1ea12dc05b190d1ac3fe5ba404b47528f15437088fd0706735f43747e9c2b794d078a7b7a46c1aacadcb738b77d7593544bf740e721af75556e229786ad40251365e9ce868746f063048df287efe739f78377b702b48e6b5442a83dc181f8d488c901f9418e81f98b1420300e91c0a6482302601e2f899bd1cd2df6bc7e6fcd394cc611518efdeead479ec4a78faf1e776988c2a1bee0d556be50f9df0f958ae5ea9c59fe1fa4bbb8c8442e3b82d6ca00454c7ed604c2db50510d6e4741f70e769c70e018df2e0ff8a867eaecd2376512c3a66c345e2fa92c19a15c6c6da696967161548fe26993cee0c0d184d4d235a275b7ff2df4ed821f2e6aa01663b4f2421d988ca500d70b11f1f8662a5438d82294a11a3a15a00828af8f6547c600b233b14517fc3e9c94bfb598473d56e436fa6f4b71827e35041e38dfeabe35596677b4e2a563266c57db35b5c9b502549beec916d84558c7de73df873cf2197d6c327707b094a7b8f8f871198cdbcdc2706ce6fcf1287c3f8006d53833f0892603d584b7ae7d60e8104ce9a7aaf6a0fc2c4e0032aa32a348c778bfbd1d0575339311bf52f2c34a292decc3c4a663512a74dcef3e9e14b334001a4f8b6f499c493cfe5c83c56e87816e53bc1ae805e3ff208d82a5e81349c96b1af6875a20abc0b36eb50f877d27792fe01d899be6a7e3330f74e8909f7e91ebc5b600e3f05b6619360433be56bab3a3c254a46dc43b3eef14939ebe5a5050962e28b69def9e8329cc119d016ff776cbc1d6cbccd2a016512553af304afeedcd3e9d7224621dc5a6c71b417c12d5ba57d8dc6d6984c84d16ffd084bdc5e498c8ffa087071ed9fffce2c5930c40bbd9c40309576886604862f21ce316b74cc7fed97ff2a2b51f379900eafc7828782989e08cddd49a01109959a6d42358fb0d0f0e1262c35125351917e52cbb6e4addfc05e4fa730e2bc9df61a8a864f0f46ad5c173dcc367aa15efdb27011f81e9f1c613778c8f0dfb6470fd9a1b97de006578fa5e96d1f5722c61caf3f5e4510c4a2aa1a5abda74cdc3e385d23894c55e061c08772d5d88d766b88484b43047e380b6d8a96020aee8ae65546687d7710b8b7335ef29196b1898e7b3df877f4057b7989355e81b9aaccb772cedcf6de1ee6f6a2ab7199450d94702b33d30578c2cb4599b8cc40224f3d042a064483a32179c8eb529b48c56eb2dcabe0a70fe6614d47a64e7cb13f2350c58b73636ef74056df2f62c131b55e2cd7786eef6aedb3f6eeabf4518fab2e389903b37c797ef0048cd518baa5203563ef05c3172c634289a9e5fbd2fbc992cf100b6fab15929bd9f39b9017e733ec57b18460a60dcab9eb2ffa291d6942a644baa257481fe100c7ab2b2238c0ce9db4d792cc4e1a69c6b1ceaad1e95b33ecbe0785c6f1191204aeca2c192da883e99a1d286e26634b9cadad48ef131089ae5e3ec0721ec5f50bda573c56ba2a8968d4a665b1fdb5d423fb30716a8f12132c641c7d39bed6df083a752117f540756b176c53d9e890fdd46ebb3cbaddb19871ae29b50dec349f2e1169abd7508687c82e301b73d82dde4a8ca53d44c5bcd0cf1b4bc9235d765fc2526e61a71dfb4458bcd7be88003d4a48e2140f43f56c3035a3844b332522ac88ea036dee6f4638116a32387a322482ff84b7494aa4cc7e56ddbdf23438dca212e63d6dbb40536ba954d0d66d25eee930d88ee6532faaf4d17be9e627a7aa220c71abaec717d79e6b9c53d20f8c5548989ef65006abb96622e0e43cce5efa2463c7ae3130b70c372b56ff5f58e7e20b349d8fa8c332f18b281f4f0e5801142c2fdde321abec6553b4a4a43c7685f6a7ac5d5d9dcaf086c760d4c36cbf155bb0238597b1797feb15c2ebc6b5d42f44af22582ccad6e76719a5cfbdd487e484c104852ed83581e7312300f460b95abfe4bc6335ff5353d2223bdd564f178fb405293e6d481e74aea0a7b9f366feade443ac4d2376ae98293fd832d924537954d0f3dc45eef8a81a599ff5a4cc41fd63d3a7d7d8fa1973249e049715fae55d98dfe8a0fd32771ecf0306e4099425018b7c77c3cbe03b0a016f4e3d3da6cf97a6d643c0f6d56034fd70a7fb5e2b88f7194813409971ef37563816dc3cb8f607ca0fd7919949628ae18d3205ad1508eb3e027cf89abd814d0f3d51acb34418e5cb3de35d2f1beb52f3b51f3c9991f9c26e68e4c9548c8395977430dd8cc319746550267bfd219ffaf2a5b5e046b093d70f9f6a4d930a66ba2308be9879063fbf82330a4a18e1308a3818c290ff9fc0a059faad363472cf15aad0bbb45160b8603381797ef31ef0246f07e1904b541289714a9d205362680627c4cf38547bc93a59c4d3e96d1e0770d4fe37878fd0c624960db82e068dd5c1706d8abba480035184ae42caee5efdcd5da1482328984ba0a06d5d20275922fba0cc05eed22523169f1b64ac82cd567a22c48c4fd775d9604f377f090d73140c75fc2681afe9c81d5f94df2ccd2806b368a5ccb1f3314e85fc45d2479e07a09b2c48192c26db42450a2921a16e982955edf07608d571d7f97e8391a2c4a4d99c337ea7baab9c80765ce818b807678eeb19795c843c2cd6cb9c0034ea758bd880a4b58b4056a9a1bfbbda13e8b4a3fb6e30b34725af192c575f62416df32e6447cf1efa17295cb7dcc39a5d3706aa1a15010e5d1018f28bb5088e4eefeb50f6c9672b825a909cf5e692c9e0c0ad3c0dfa616394312552be9d6265609da96b32a742b8d82e748b849d8d574b0678d02f76074253affd917423b735856c08f9ae1c090f967ad4edce07a6db8f850f39637d4f13d8334fbcb9ad44ce47f06c14a57160d50d13ce1ca39e995be094420d6e29299b447cc093bce9939d8d536a21b3c5ec6391d19e59ec18f7f8925bcfe647cd25af6a1c0d9235c3b104fe60b0284df9d9381fa80564500a103c0a4667689f1cc6e37bab359048e6b381bd8ab7e90e13c21af88c1722e5e065144e991c18a17c8566464e14f245ee51b45237ec1b8f3ec4e9c49ba76524c42d10ea6b49fbc2ed19be9a665a2533fd1311c2f336808956d522e58e8cd48d715caa73ee80941354002eba246e046eafacd6f887ec4e1274b000bbadcf57d29835e7cc02c1546fb73a712ca7ec53d7b16a6f337c49fff7ff913959e573a98689c49a4eab4e636d2fa5dae521a3b8cb164de242adb7671dfac8e6341543a756f79a93a693c306132f57b0558fa73e55ef86a04b05eace3d21b2c60debeefb169d2cc3974f5fae84f6483fbcb8ae1fb9bd760f2efd1e9c931d47a5aa39c228eda0e50a36cea73e02d290e48d2c20c86a4a9f969f795bf64005df9889c308a7aab80ec2b45b728938263815261df8d21ecfecf1338d7b861f477c22d45ac1e3d4d655f2fe331d351e801ca44209cf6e0c01473d9045b357cfae1d12b12cc51a64de3310eafcbcd3ab17848c9edf09256276988cc4c1f7ab466f9ac0f9bf4ae4b78ff7e8fa235d031b64ad786b8a7ace2907c3d65eca2f8abb79a5795c2e67a0c6d995db7dbdefad337a9b4768981128bf5dddd30a54f0fb5e198aa590719004c372b72ea312b203630319adce12d6fc86fbca31821d7fb004039c5ec1b03fdf7459d66617d90d194f45328fd0148ed5bbdf9acc3ef666c6b9dd66805ccb0639d9f76b95d74649f6655fe7caf3428772a1bc5dacf14b918a3bdb9850d95b869e1f2620af0d96684734f422c4b11d77fae3df8b9d1493bca2b5462852a0c99809accb61abdaa6d5f8bd6768b974f10914f14a0728529424e5e363a9ce49075c5133c5232e1e06fb47bfd24032bae4187751777349accbd91565407520b2b6e1224f65fc6a59dc54f78d6d5407ab42a039d60442f58b259d65ccd68780280b7fa1b97cb78119626acdda7ae608de492522fc1db85c0bab349de0719718384fc5a7ab40f5dd97d1da112e68eb5d94856423f9a23bcae17055520b3dd319f230926ffe00638e53d87d3dcea2215afd8622e9948466fff97eeae408d335de75dc0a4c3423cc3a9100a9d8022a7f7dcc50833923291581f96a914379c416afd9b3874db928c0a5ba7f24feaf41e3f944d217be2ff1ef92dec4d014a056c5f2ce6894248ac5edd2cefe0a2c81d13ec4d5cd8da2471c4c64d158f726ccae556f33e4a5400b28f9f68a489283f523debb28b3ce5ca1addb5816389ea4ef22c0e0f69be6bbb29ac334d2a2964341d7f06c17a029baf41d351a9353264d708f6d3a223d95cebcf611e17c20327f836942e091e395d55774d35ad3e03df812ac72b9b26a2d842d5bffea816971924568f249a475a95fa9115ce8effba6d350401d2eb18fc3649a366ffad014d5a9a9d3a889682184f926fd7f69a7bf1e025f3650988155bb9933d5103431defc8d44ed4815b5aff510178e897191cc98ba8de8ae6feea8ce412d385891b15d3476e5cfc3b3b540975dc55dce57f411972fe891ce8809700b8c941504cead363e2121457a66a50752e440844f5e25bcc13c0c817ee1cdfdc0485dd378b7f9d472c460ed8a89fbb1c1978eb7d1a0b8a51ec54281831e99b161efb537c9cd4796cf537bd0338ef17959071ff41a750e2fe602dc4629702cc58b4d61b3fb73783887ec14755016720d440a9224f5504a6bd0231d8f1bb0ff7956df936b083d6e6bf8576fb0eec9d68ecb4f09efba1aa456412052b9df5566206df0313f97bc0adb635b5c3fbbb45b2cebdcc494ed930dca57e633d0fb21e09607907094ae848b1bc5595a6f9d8f7d17297737401d5c12d7790f66a122c9cf7f87e0de2b32696add3af6d534f6768fcea1c4678feda321f43be735613c7c82b27f66b18cec971fdd6b4823b4d9a6e86b3471c98120b28c03c8046f014530c10513db76c7b618f6fd21a0676bf95a6035c01a33a825dfcc763a80094fd0a8515749aff9b282862bd0e27cf987fc1b3e14ab9dfd446fc8756576d4a312966b91f533b41724320f6fbd5cf528efd1522e62eb791c8076c2bf70cc5c245fc1f1a5416cb6178f0bcdcf2a1270bf60b72b5f07e3fbfbce1fdda2c1eecfc4f306d790c5e93a7abb8d7fa40bb7930f82369697a58048b1ccef950d6dad0093648494fa818e699dcfc816bfa824e1f2a06433da12177c60bc8dfb574dcc90789a6bf986e281c9b6af5dd693b3246b58961d7094609d1ba4fa62cd1e8962020b1d89ecce31f1cc8d24d8314bf1110a95376da0c904c84c422109f8a691cbd8b138de08c59187633e0ef74182e699943bf27e9720cc752d82bdd85454030efe706a5c0a225a77576bde20cec5667772152f0e34af7cafe88eb6da3a9ebdd762e40a3755da554c0261fd396ec337843ae7df6401375bcb391dc0aa64eda8f2f8438e091b1ae5a77f4788ee226a03e9c3b536345353810079ed0f1558ec43f0a7eb4b7d0ce8517ced67328527a94f88c0260cd4ef23bc315ff6eb493ed7e892c924a7c3f4db6c376e3b7af72b0078e48e9539d82880232884a3d5395b58bc2c29138a31e8fa9a2675db2e6bf04d620977397f38dd957381a4a1ffd9da12fd2743388d51b82e0fdd31091c9eb428dd49e641d3a880b13acbf81a4f99c1499e3002e4869d635b9b9a003b8b2afdeb922317be58769c7be71feb588e1fce5c3646694541abe59906dfcb84f639b95e27aa3b901c98d07990dacc6bbd975955b32f2918b90d4bfec7d75dd1ecd115fae1dcf55bcdb60ccf719167d1e83d736342e689b885d44a035391094cc95e1565ba8c8309c22492f006c09376bf5878da0e358ca85fdd8afdd892abde808a1c163e3ec1ff8b6b2d6bc0417f337c98fa365c5adfd96785afb9022657d9bd4fd18b0f7d75bec77dd7540be318f82d19248313c8783d660937cbbcee78c7f9711f52d96a7ce69dc4b38bf8c26ed738967e68acfb4c53340c3211e1e7e257caa80f59e0692f3b7d6cd86283c4669e0dda910aa8f7bf103e4aa8654994c064be757aab0d3670936f589e538050fdae27838e2f719259eff176bf38ab055fa501aac304d4d9226f0385de71881a4d2d857f5b7881a8be1a9e8ad5c95876fbf9f2c0322a425bb89db074b728cd06ba0548bd33f97a3de14ed3b8cbd02e4522571f794d17544939d2dbfd02c9c76750fe6c012bce4bc54b0d3df48d3ab3d2c4bcc6f97bc14cd1d0c42ff8999b0c0372f952d26083dc058eaed8a35341b21b0e13f76a5194e0364248501eb107c4fdca10e6385a6a39a0d28627a178270071745c12972d45989e4a5f6f70e2bb9464274657310ff0e2efff074a9daa0437cd741f5529f48f90c689700d073d6b8be183d37225ceed0ae2bc9300ec34bc22a190a2d2efccfc53f90fb248482f70473eb5516ef8731194ce1e080f61a8f168ed5ab6a6bba1c9259eefd5247ae213ce799647e0bd1805b65e88aa7dad54dc2cd4a44e0c491b4495ccf86b3b3ce997d500009da2a6c922d43bec3ce9e7ffc3f5bba43a8a67ee35489e2f109e5c3c11e72a1f575d2457835fe360437fcd4a06507e077659cb05374582a30b866b288084cadf187ce8f3fd884378503536851f113033a4a5265ae274dc6dd098b1f2ed18c46be7121900bd5dde8849a545f876350f041848bea21c7423f72b1fe36bd152fe19cba39c72bd605f4784facc244ec585250a5191e6dfc57c63de8ac6ac466dd0f0d03bfa44865dcb79d8fc768e8db521261cab9ddb58d7008de9299780ef1e4471d34b98171058d3a5e973b82f5345bce2032695411e209d121104e1e7b9ce997c63d859b32fc6156a2fb3b22b5793368c017e2935f34bfa5ad19ef299e4e9af80007dedbfdeb0c9fe1d5964f7f79b6786190daacc6382815ab55128be5e23d61ca4bd2ce02a2846ab80d0fbc1a60771a902945cfa8802110da3258f8c54ab0af56a0200191fd693e80dc7fd3821935eef6926aa80a070bc35cde9cdb45a9b3cf280e8669dbdb86a4b80913a18a4e39f6eedd4fe6b05c050029f7d3d2c1ca86111549cdc5f79648086495b03b33bc182a532cd9e7f0156d1daeb39c34ec3f1c09a5badb398423766eb96f79db2fc8eef158593174a260e292481cdea232729d00e113fa54bdd45758724627acf1fadfd629649c75617c889ae9893f6befc706b5bfbdf65e7e67b3ad6258325d35bcab0c0860d289f9faafbc277ae005fe496f5ec4548a3efa2232f20ed3f54bbaafb40e898025c2fb01ea5d06725f68f755a7577624f4d70c7abcacb6592e6964fe3a7d291c60efe861fdb42740adf4bc82c45be6b5d47eed95fc759f48f6fb6339e91a4e8bcafc10f3aaaf76e2532efe746a0bc2c9dda8b5110d02f5e9bfdb396218a99aec7f778579fa5a00956456b9bb75ff3663a80facaf3b8d50136dda405f24d3cd2d521641322a46833ed76428a56003d97602265a531b1cc62c37ff635db083c16547a153535d89dff62790c8c5a05be3b9401787bc632f59941b3e66c2a88637b0b84dc18cd236c80579f57f8ed93f4e46ce3865332fe7136a3f067926bc2da06c70d272c8af9abcd071552f9eb360da5a792b20f1c0322b87d2655f0bc0b228c0255e103b8f56993bc91d795b0ba46e24a0fce19798ec1d3890e18ec045d8f707e5d3b7c8b9846841869bf25f2f33fb1db9f828b8d201af5a841625a08ad976186488bbcb7688579cef089ce1c4a5155067744592d517948f10e352767faebae4bd283ad6e585a3348ea778a86fb8dd081c09f25d08582ef7242815325548ff4a97ce0509527a1d57820b15dd16a855d41a4ab032bcf7c0b2e7c32199ebc17fdd186620d094bb7aaeac226b926a9693c17f23edbcbad1144d567432451db4b91ac95a4d0dcb7d4b4d0dfc83f60cbcb8c2a93384db826e4e06c07d152</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 書信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>落日記</title>
      <link href="/2019/02/17/essay/%E8%90%BD%E6%97%A5%E8%AE%B0/"/>
      <url>/2019/02/17/essay/%E8%90%BD%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-NnAxSqLP" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="17685905" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>應邀寫的一篇稀里糊塗的日記，權當是好玩吧。寫作的時間已經不可追溯了，大概是在大一下開學的時候。粗粗地記錄了一下報道的事情。</p><a id="more"></a><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>&#160; &#160; &#160; &#160;太陽本來升的高高的，但是上海根本看不見。地上帶有一些雨的印子。「明天是要下雨。」WU 君看着地上約 10 厘米的蚯蚓這麼說。他們熱乎的談着籃球，什麼三分啦，全明星啦。「這個投籃大賽是真的沒意思」。F 君及 H 君聊得很是投機。我剛剛想的那一段是什麼曲子裡的來着？第幾樂章？「有人可以從中線投到籃筐的嗎？」「在空中連續投三個欄是什麼意思」。表述不對。過了正大體育館的門，然後是 WU 君寢室的門，然後是 C 君寢室的岔口。每周必有的羅森晚宴。哈，和 WU 君及 C 君都談過的 2 的根號二次方的故事。「去年的特別好看……」，誰？然而名字我已經記不到了。然後是 H 君的寢室門口。「你們拐一下吧，能多聊一會。」「那能從中場投到籃框是真的厲害。」H 君已經離開了討論。「是，NBA 的運動員和我們不是一個等級的。」「你系統是多少級的。」出寢室的時候 F 君如此問。　</p><p>　　「哎？你這麼早到啦？」「還好吧。」出去吃早餐的時候剛剛碰見 F 君。「W 先生仍未出現……」然後去把教材買了。昨天溜達的太久，從這裡到光華樓，再回來。於是我忘了。一定記着，不然教材會沒有的。然而知識的門緊閉着是在早餐之後被發覺的。昨天我疑心食堂換了師傅，我該和 C 君說一下，畢竟是有趣的事。C 君還沒到，C 君報到怎麼辦？不，等我先檢驗一下。於是和昨天的內容一樣。蛋餅同昨日一般軟，肉包卻已是很久以前的味道。也許師傅換了一半，也許改良了一下，也許時日已長。其實應當買生煎的，好久沒吃過了。生煎那裡沒有豆漿，不，不要排兩次隊。Lament, lethal…vital?不，不對。Nomadic, romantic。到我了。昨天師傅說點包子請指明種類。「肉包。」L 君提到的日記的事情，我應該用什麼東西記一下？不然就忘完了嘛。餡泛黑色，醬油依然多，是上學期的 genre。看着豆漿蓋里的泡泡。我也許拿了一批豆漿的最後一杯，豆漿也許是最少的。我昨天應當把第十章看完，然而還有一本書。對，我的書該還了。先還了再借出來。嗯！是恰空，我收藏過沒有：沒有，演奏者：不明。那上面寫着巴赫。但是《韋洛克》不需要了。等會記着去買教材。對，是要記下來，我昨天什麼沒買齊來着。手機掏出來。洗髮露……我沒和 F 君說我昨天借用了一下，但是應該幹了。和燕麥片。走吧，看看教材。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>&#160; &#160; &#160; &#160;今天應當是沒有太陽了，「你報道去嗎？」「不是的，買教材，你去不去買教材？」「你等我一會。」「一會是多久？」「十分鐘。」「好。」手上有個扳手，剛剛做什麼去了來着？不會借個扳手這麼久的。那回去吧。合着節奏的敲擊聲的聲音，爲什麼阿爾蒂夫尼的回禮是放屁顯得費解。「扳手比錘子好用。」「不會吧？」「他還可以把彎的釘子扳正。」「好吧。」他的牀板現在看起來結實了。等等，我要還書。讓我先把書放進包里。我缺哪幾本書？模電是紫色的。「你們什麼班的？」「找模電。」我正找不到來着。那裡，果然紫的。還有一本 C++的書。外面沒有了，裡面有幾本，絕版了。絕版了爲什麼還當教材，有老師喜歡。果然有兩本，紅色的。我想起了《C++ primer》。一共 100.8.「好，支付寶在哪裡？」哦，看見了，兩毛錢。支付在哪裡？哦，看見了，另一個碼。「有紅包可以領」老闆說着，「72」。爲什麼便宜一點？對，他模電的輔導書沒拿。幫他拿一本，多少錢來着？50.不是五折。「支付寶到賬一佰……」。　　</p><p>　　「元宵節快樂哈，回去就給你打錢，[笑臉]。」「你這個寒假都聽了些什麼？」「有一首恰空特別好，維塔利的。」「喔喔，我知道，我聽了一個寒假的平均律。」我看着手裡的手機屏幕亮了又滅，F 君應該是開始睡午覺了，我該不該提醒一下？不了，Z 君挺高興的樣子。我們愉快地談起賦格，我突然想起剛看完的第十章。「我給你看一個有趣的東西。」我搜索着《尤利西斯的注釋》，並不在書架上，在書包里。啊，我忘記還書了，算了，明天去。我把書拎出來給 Z 君看，Z 君興味盎然。於是平均率的聲音從 Z 君的手機里傳出來。於是 Strauss.R 的曲子從我的手機里傳出來。於是莫鋼的聲音從 Z 君的手機里傳出來。於是勛伯格月光下的比埃羅從我的手機里傳出來。於是薩蒂某我不知道的曲子從 Z 君的手機里傳出來。於是薩拉薩蒂的流浪者之歌從我的手機里傳出來。「揉弦和顫音有什麼區別？是手用的不一樣嗎？」我不知道，我可以查查。「幫我把琴拿過來吧，我正好在練揉弦。」我兩天多沒練琴了。上學期甚至更長。「那我先回去了。」「好」。F 君呼吸的聲音湧進之後的沉默。我把琴放了回去。　　</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>&#160; &#160; &#160; &#160;「你去報道了嗎？08:07」「沒，在超市買東西，要幫忙帶東西嗎」「帶兩瓶礦泉水吧」「那你馬上回來再去報道？」「是」「報道不是還早嗎」「OK 那我等你一塊吧」「嗯」。「GPA Tool 爲什麼已經下不了了 18:33」WU 君。等會，等會再回復，直接發給他。我的日記才開頭。「[分享]各 DBG 簡評 18:19」LY 君。等會，等會再回復他，他怕不是掉進了這個坑。「您的快遞已簽收。」　　</p><p>　　他好像開始研究多人遊戲的打法了。我真的想看會書，去報到以前的那一章的最後幾道題沒有做出來。「我這個月要吃土了。」「我已經把我的女朋友拉進坑了。」不行，三缺一。「我現在正在給我初中的同學安利。」我這個月要吃土了……　　</p><p>　　「我系統是 7.0.0 的，三星系統升級一向比較保守，你應該是 8.0.0 的。」「我看下。」藍廠的 apex，真的可怕。「你知不知道知乎被下架了？」拿進來外賣的 F 君如此問。「不知道。」「據說是討論任期的事情。」「真是可怕……」耳機重新戴上。是莫扎特的小步舞曲？不是，是三重奏。「你知不知道 MWC2018 大會上 vivo 的 APEX？845，真正全面屏，連前置攝像頭都沒有，甚至有 HIFI 芯片……」於是我們走到了食堂。其實我想吃全家的。出門時我如是想，但畢竟時間還長。走到了難以抉擇的三岔路口。「中午吃什麼？」「我隨便。」於是我邁上了右轉的道路。「二樓吧。」於是我收斂了我的腿，邁上了上升的階梯。陽光普照炒飯，我一直想吃來着。「陽光普照炒飯。」8 元。「我以爲是黃金蛋炒飯…你看過《中華小當家》沒有？」「你看過《神廚小福貴》沒有。」於是邁上童年之路。路上有着遊戲王的事，預言的事，反轉的事，大反派的事。然後…「你看過《死神》？」「對啊，六年級開始看的，爛尾時傷心好久。」於是邁上討論《死神》的小徑，童年裡的討論者開始向寢室方向進發。　　</p><p>　　洗髮露。於是開始向着學校外不遠的超市移動。但是我的儲值卡昨天就用完了。酸奶沒有我要的口味，只能提着原味回寢室。我還是去學校里的超市吧，也許便宜一點。不，我已經走了一段距離了。騎車嗎？不，那種東西會滑出來，而且車是溼的。燕麥片只有那種很大包的，那只能拿一瓶洗髮露了。然後我的手機響了。　　</p><p>　　爲何變成奧斯卡金曲些了。不行，我休息一下。　　</p><p>　　好了，現在是肖斯塔科維奇了。　　</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>&#160; &#160; &#160; &#160;爲什麼這個表情老是打不開，昨天是這樣，前天是這樣，這樣都好久了。我是挺想給對面發一個滑稽的，不知道爲什麼這麼突然喜歡上這個老遊戲。啊？這個肖斯塔裡面有人在唱歌？這麼如癡如醉地買了這麼多擴充包。網上說是 dpi 的問題，也有說是隱藏底欄的問題，我都試試吧。於是手機進入了反覆調整重啓的狀態。太陽從來沒出現過，但是天就開始黑了，該吃飯了。我的手機屏幕一會亮一會黑，不行，這個底欄太大了。重啓。GALAXY S8。嗯，這個合適了，那個菜我沒見過。「今天有湯圓。」對，我剛剛看見了。對，今天是元宵節。「我這兒元宵十五上物理課」一個不辨男女的頭像。L 君。不要急啊，正在寫啊。「湯圓在那邊。」「不，就吃飯。」我想試試那個新菜。像是土豆。「我要那個土豆。」果然是甜的，也確實是土豆。裡面的肉有股快餐店的味道？食堂或許真的來了新的師傅。那邊有個同學的頭髮挺長的，眼睛都看不見了。我以前也這樣，我以後也這樣。再過幾個月？　　</p><p>　　門口碰見了阿姨在澆水。「阿姨好。」「哎，你好，有你的快遞。」澆的什麼？蒜？「阿姨這是蒜嗎？」「是，蒜髮芽了就…你吃湯圓沒有？」「沒，我們那邊不吃湯圓的。」我現在是在幹什麼來着。阿姨整理着一些快遞的包裹。嗯，我是來領快遞，我都忘了的。「你把那個表填了。」爲什麼要填這麼多，原來不是只簽字的麼。也許還在放假的階段。我抱着我的箱子繼續向上攀登。</p><p>　　「是蓋個章就可以走了嗎？」H 君問輔導員先生。「是呀，蓋個章，簽個字就能走了。」「早知道我讓個同學幫我辦了，我能多睡幾天懶覺。那延遲報道怎麼辦？」輔導員旁邊站的是哪位？是他的女朋友？他女朋友長什麼樣的，我記不得了。上學期指導形勢與政治來着。不，我不知道，不知道就不要亂說。那我們可以回去了。「話說我們組上學期討論要聚餐的，趁沒開學聚聚啊。」「晚上約了高中同學。」大家都忙啊，然而熱鬧是他們的，我……「你了解筆記本電腦嗎？」「不，不清楚，在攢錢買，估計大二換。」我突然感到有人拍我，「嗨，新年快樂！」是 H 君。「嗨，好久不見。」「上海真是冷，來了就蓋個章，早知道多睡幾天。」「早來兩天也挺……」「學校也真是的，如果晚開學兩天，我媽絕對會多留我兩天的，我等會問一下怎麼延遲報道。」上海和成都溫度沒什麼差別。哪裡都一樣。我想起了哈爾濱的三弟。願安好吧。養生，現在也有 0 攝氏度了，沒這麼冷了。　　</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>&#160; &#160; &#160; &#160;這教材居然是哈工大的，果然……那那本程序語言呢？看起來特別厲害。原來是斯坦福的老教材。上學期那個教材是真的不像話，這本也許會比較有趣，網上評價還蠻好的。「去吃飯嗎？」「我把牀收好就去。」於是我開始計算偏導數。翻到昨天那一處。「x 與 y 的地位是平等的。」我記得我折了一下。對，是這裡了。　　</p><p>　　「我找到了，不知道你有沒有興趣，我這裡剛好有《死神》的一個遊戲，PSP 移植的，剛好我還有模擬器，你要我考給你。」我應當繼續看我 Python 的課，第五節看了一半了。「好，你給我嘛。」我饒有興趣地看他玩了一小會，我的手機提醒來了。對，是看那個課的時間了。「你先玩着，我去看看書。」等等。微信。我們班有了個新同學？難道是今天……？不，不重要。耳機帶上沒多久，敲鍵盤的聲音聽不見了。對，他還在自己的座位上，但是應該是沒玩了。一節課仍沒看完，有敲門的聲音。W 君到啦？不，裡面探出 Z 君的頭。「你燙頭髮了。」Z 君與 F 君攀談起來。過了一會，他進了我的寢室。「你在幹什麼？你剪頭髮啦？」午飯那個同學頭髮確實挺長的。我把包挪出來給 Z 君一個位子。書包里有什麼？</p><p>　　我不知道。這麼多問題自問自答有什麼好的。「匯了 2000 元哈，元宵節快樂[微笑]。」我不知道，元宵節應該是個團圓的日子吧。我在昨天看見了月亮，成都是不可能看見月亮的。但是上海的月亮異常的清晰，它是那麼的圓，那麼的白，像繞成環的抽紙，像漂白的太陽在污水裡燃燒。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bonjour</title>
      <link href="/2019/01/01/essay/Bonjour/"/>
      <url>/2019/01/01/essay/Bonjour/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-xjiVeffm" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="465469873" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>這是 Joseph 的博客。也許你在其他地方幾乎聽不見他的聲音。但是這裡可能會留存一些，我是說可能。當然，很感謝你可以找到這個地方。</p><a id="more"></a><p>但是有幾個麻煩的問題需要解決。</p><h2 id="Joseph爲什麼寫博客？"><a href="#Joseph爲什麼寫博客？" class="headerlink" title="Joseph爲什麼寫博客？"></a>Joseph爲什麼寫博客？</h2><p>正如前面提到的，也許在大多數情況下，這個博客的主人都會保持沉默。或許有一些特殊的理由，但他自己也不知道。或許是他希望可以和別人分享一些小小的東西，當這些東西在心裡產生了巨大的重量，以致於他需要排泄出來。</p><p>或者他只是簡單地希望一小部分人——很小的一部分人知道這個鬼鬼祟祟的人在想一些什麼，或者干一些什麼。當然，這樣解釋並不是很合理，大部分人閱讀信息的目的也許並不是爲了了解其他人，而是爲了更好地理解自己。所以下一個問題是：</p><h2 id="Joseph的博客寫給誰？"><a href="#Joseph的博客寫給誰？" class="headerlink" title="Joseph的博客寫給誰？"></a>Joseph的博客寫給誰？</h2><p>這個問題同樣是難以回答的。因爲大部分人應該都意識不到這個網址的存在，Joseph 自己也不知道這個衝動將要維持多久。同時他不知道可能會有興趣看這些雜七雜八的人在哪裡。但是無論是誰，一定是 Joseph 的朋友們吧，不論他們曾否蒙面。</p><p>但是很大意義上，這個博客是 Joseph 寫給自己的。現代人缺乏一種自我溝通的方式，也變得健忘。也許他只是打算用這種方式讓一些片段的思維可以保留的更遠一點而已，讓以後的自己可以知道他原來在這個星期天的下午在思考一些什麼樣的東西，讀了一些什麼樣的書，給出了什麼樣的評價，學習了一些什麼樣的技術。如此就可以了。</p><p>當然，我歡迎我的其他朋友。很高興我們可以在這裡碰面，並且一些人或許願意多停留一會，多來幾次聽這個稀里糊塗的人的絮絮叨叨。我很感謝你們。但是你們可以在這裡找到一些什麼呢？</p><h2 id="Joseph在這裡寫一些什麼？"><a href="#Joseph在這裡寫一些什麼？" class="headerlink" title="Joseph在這裡寫一些什麼？"></a>Joseph在這裡寫一些什麼？</h2><p>他原本的初衷是想做一些永久的，私人的筆記。然而這個野心迅速就擴大了。也許這裡將變成一個半公開的思維的儲存地。會有很多混亂的言語進入其中。但很有可能的，這裡面是一些關於文字、音樂、思考、科技的東西，但是除此之外可能會夾雜一些隨意的筆記，那種散漫的，毫無目的的簡短文字。我知道你懂我的意思。當然，初衷：一些學習的筆記。</p><h2 id="如何聯繫Joseph？如果你想聊幾句？"><a href="#如何聯繫Joseph？如果你想聊幾句？" class="headerlink" title="如何聯繫Joseph？如果你想聊幾句？"></a>如何聯繫Joseph？如果你想聊幾句？</h2><p>嗯，他並不想讓他的讀者們在文章下面拉拉雜雜的討論自己拉拉雜雜的文字，所以？郵件聯繫他吧。他也許會很快回覆你，也許不會。這個幾率可能和那一天出太陽沒有相關。總之他一定會回復的。如果有一些有意思的話題，他希望更深入的探討，他也許會寫一封公開信，當然在徵得同意之後。</p><p>總之就是如此了，我很感謝你們的到來。讓我覺得這裡有那麼一點點的人情味。再次感謝。祝好。</p><h2 id="P-S-如果你是第一次來到這裡"><a href="#P-S-如果你是第一次來到這裡" class="headerlink" title="P.S. 如果你是第一次來到這裡"></a>P.S. 如果你是第一次來到這裡</h2><p><strong>關於字體</strong></p><p>本來 Joseph 打算將 Blog 的字體統一爲自己常常使用瀏覽器時設定的字體，但似乎對於字體的客制化沒有非常好的方案。使用將字體掛在網路上的方法，每一次刷新需要從網站上拉取字體文件導致訪問體驗驟降。這在 Joseph 看來是不能忍受的延遲（這關乎美感），於是最後還是砍掉了使用特殊的字體。</p><p>現在的字體設定將會使用查看網頁的設備自己的字體庫，如果在設備中恰巧擁有同樣的字體，它會以正確的方式呈現。如果你們有興趣的話，可以主動在自己的設備上安裝相同的字體。這是通往這個字體 [源樣明體] 的<a href="https://github.com/ButTaiwan/genyo-font" target="_blank" rel="noopener">Link</a>。你們可以通過點擊這個<a href="https://josep-h.gitee.io/images/GenYoMinTW-Medium.ttf">Link</a>進行主動下載安裝。（這個流程在 Windows 系統下非常容易。）以下是這個字體的效果：</p><center><img src="/images/font_example.jpg" width="80%" height="80%" /></center>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
