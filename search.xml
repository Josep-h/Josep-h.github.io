<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>插件安利</title>
      <link href="/2020/11/20/essay/%E5%AE%89%E5%88%A9/%E6%8F%92%E4%BB%B6%E5%AE%89%E5%88%A9/"/>
      <url>/2020/11/20/essay/%E5%AE%89%E5%88%A9/%E6%8F%92%E4%BB%B6%E5%AE%89%E5%88%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>這裡是一些安利的Chrome插件（新開了「安利」的Tag），從原來的網站頁獨立出來。就是一些古怪的插件而已。</p><a id="more"></a>  <p>由於我使用的瀏覽器 Vivaldi 提供了太多的功能，這些功能部分與一些非常優秀的插件衝突。但出於個人習慣，不對這類優秀插件進行記錄，但歡迎告知。</p><ol><li><a href="https://chrome.google.com/webstore/detail/embark-new-tab-page/aeajehgeohhgjbhhbicilpenjfcbfnpg" target="_blank" rel="noopener">Embark</a>：一個 Tab 插件，新 Tab 爲數字時鐘，背景爲一些風景照。</li><li><a href="https://chrome.google.com/webstore/detail/mainichi/dfekdjmdikicceaiokcmmchenpilglhn" target="_blank" rel="noopener">Mainichi</a>：一個 Tab 插件，新 Tab 爲一個小色塊，裡面是不同的圖片，及其對應的日語平假名、日文漢字及讀音。</li><li><a href="https://chrome.google.com/webstore/detail/幾枝/hfohpokminpknagcgncibpacohagppjn" target="_blank" rel="noopener">幾枝</a>：一個 Tab 插件，新 Tab 爲橫置或豎置的兩句古詩（標註作者和標題），以及一些不算艷麗的波浪做底。</li><li><a href="https://chrome.google.com/webstore/detail/new-tab-startup-quotes/bljnhgkajocmhlflgefahihojeajhjji" target="_blank" rel="noopener">New Tab Startup Quotes</a>：一個 Tab 插件，新 Tab 爲一句企業家的名言、雞湯，背景爲白色。</li><li><a href="https://chrome.google.com/webstore/detail/imagus/immpkjjlgappgfkkfieppnmlhakdmaab" target="_blank" rel="noopener">Imagus</a>：方便快速地查看 Web 中的圖片。</li><li><a href="https://chrome.google.com/webstore/detail/kami-extension-pdf-and-do/ecnphlgnajanjnkcmbpancdjoidceilk" target="_blank" rel="noopener">Kami</a>：閱讀並批註 PDF，可以和 Google Drive 同步。作爲 PDF 閱讀器，功能強大。</li><li><a href="https://chrome.google.com/webstore/detail/minimal-scrollbar/ekopmclclddpoipchmcbhifohhbmjafd" target="_blank" rel="noopener">Minimal Scrollbar</a>：縮小瀏覽器默認的粗大的滾動條。</li><li><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">Proxy SwitchyOmega</a>：管理使用的網絡代理方案。</li><li><a href="https://chrome.google.com/webstore/detail/沙拉查詞-聚合詞典劃詞翻譯/cdonnmffkdaoajfknoeeecmchibpmkmg" target="_blank" rel="noopener">沙拉查詞</a>：網頁上快速查詢英文詞彙，很方便。</li><li><a href="https://chrome.google.com/webstore/detail/爲什麼你們就是不能加個空格呢？/paphcfdffjnbcgkokihcdjliihicmbpd" target="_blank" rel="noopener">爲什麼你們就是不能加個空格呢？</a>：自動給中英文加上空格。注意：這個功能和部分文字框存在衝突（例如 Overleaf。）</li><li><a href="https://chrome.google.com/webstore/detail/nutab/hbflaeaeaoabekejplknlenmohgoaodj" target="_blank" rel="noopener">nuTab</a>：一個 Tab 插件，插件爲一個空白的 Markdown 界面，可以隨時修改。並且可以添加喜歡的網站到該界面方便隨時訪問。（非常適合建立待辦的方法。）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安利 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stopping by Woods on a Snowy Evening</title>
      <link href="/2020/11/17/essay/poems/Stopping%20by%20Woods%20on%20a%20Snowy%20Evening/"/>
      <url>/2020/11/17/essay/poems/Stopping%20by%20Woods%20on%20a%20Snowy%20Evening/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-mooVRFqW" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1060914" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>如<em>Out of the Rolling Ocean the Crowd</em>中所言，這裡是接受委託翻譯的原詩，以及個人的拙劣的翻譯。</p><a id="more"></a>  <h2 id="原詩"><a href="#原詩" class="headerlink" title="原詩"></a>原詩</h2><h3 id="Stopping-by-Woods-on-a-Snowy-Evening"><a href="#Stopping-by-Woods-on-a-Snowy-Evening" class="headerlink" title="Stopping by Woods on a Snowy Evening"></a>Stopping by Woods on a Snowy Evening</h3><p>by Robert Frost</p><blockquote><p>Whose woods these are I think I know.<br>His house is in the village though;<br>He will not see me stopping here<br>To watch his woods fill up with snow.</p><p>My little horse must think it queer<br>To stop without a farmhouse near<br>Between the woods and frozen lake<br>The darkest evening of the year.</p><p>He gives his harness bells a shake<br>To ask if there is some mistake.<br>The only other sound’s the sweep<br>Of easy wind and downy flake.</p><p>The woods are lovely, dark and deep,<br>But I have promises to keep,<br>And miles to go before I sleep,<br>And miles to go before I sleep.</p></blockquote><h2 id="翻譯"><a href="#翻譯" class="headerlink" title="翻譯"></a>翻譯</h2><h3 id="駐足林間雪夜"><a href="#駐足林間雪夜" class="headerlink" title="駐足林間雪夜"></a>駐足林間雪夜</h3><p>我想我認識這個林子的主人，<br>他的屋子就在不遠處的村里；<br>他不知道有人在這裡駐足，<br>爲看着他的林子灌上冬雪。</p><p>我的小馬駒必覺得古怪，<br>爲他所停之地，附近沒有農家<br>在林子與結冰的小湖間，<br>在這年最幽暗的傍晚里。</p><p>他晃起他刺耳的鈴鐺<br>問我是否搞錯了什麼。<br>這之外只有細簌聲響，<br>是習風吹拂雪花滑落。</p><p>這個可愛、幽暗而深邃的林子呵，<br>但我還有需要遵守的諾言，<br>在安睡前還有數里路得走呵，<br>在安睡前還有數里路得走。</p><h2 id="遇到的值得推薦的翻譯"><a href="#遇到的值得推薦的翻譯" class="headerlink" title="遇到的值得推薦的翻譯"></a>遇到的值得推薦的翻譯</h2><h3 id="雪夜林駐"><a href="#雪夜林駐" class="headerlink" title="雪夜林駐"></a>雪夜林駐</h3><p>林主我應識，屋舍村中棲。<br>不見我駐馬，獨看雪滿枝。<br>小馬當踟躕，何故停荒隅？<br>今歲最黑夜，幽林間冰湖。<br>擺頸響鈴語，問訊何差池。<br>萬籟皆寂寂，雪軟風依依。<br>佳林何幽深，有約不能遲。<br>前路幾多遠，方到入夢時。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>不太想談對於這首詩歌的理解。倒是想說說翻譯的過程。翻譯這首的難點或許在於原詩的那種微妙的意境，是一層輕薄的紗，一捅就破。讀到後面，仿佛有一種」小橋流水人家「的味道。但又不那麼有力，而是親切地、溫和地滿進來，是哀而不傷的味道。</p><p>這個翻譯的事情挺好玩的。本來只是友人讓我幫忙想想。於是思考翻譯的途中，自己爲了整理思路翻譯了一個版本。既然翻譯出來了，不妨拿來做一做盲評，於是揀選了一些已有的翻譯給大家評價。這個評價的結果姑且不言，整個過程實在是充滿了樂趣。討論的人羣壯大起來，傳來傳去，突然有一種雅集的味道。想想以後或許還能夠組織一點點這樣的趣味活動，解解乏。</p><p>以及我考慮之後聽從了大家的意見，把第二節後兩句最開始的第一個」且「字去掉了。此外由於自己水平不夠，於是完全放棄了對於原詩韻律的呈現，不得不說是一個相當大的缺陷。歡迎讀者也嘗試一下咯。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 詩歌？ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Out of the Rolling Ocean the Crowd</title>
      <link href="/2020/11/17/essay/poems/From%20the%20rolling%20ocean/"/>
      <url>/2020/11/17/essay/poems/From%20the%20rolling%20ocean/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一位友人突然由於翻譯課找到我，邀請我一起翻譯佛洛斯特的詩歌<em>Stopping By Woods on a Snowy Evening</em>，想起了早些時候翻譯的這一首惠特曼的詩。所以放一個原文在這裡當作一個記錄，翻譯稿已經不太找的到了。歡迎有興趣的讀者自行嘗試翻譯。</p><a id="more"></a>  <blockquote><p>Out of the Rolling Ocean the Crowd<br><strong>Walt Whitman</strong><br>Out of the rolling ocean, the crowd, came a drop gently to me,<br>Whispering I love you, before long I die,<br>I have travel’d a long way, merely to look on you to touch you,<br>For I could not die till I once look’d on you,<br>For I fear’d I might afterward lose you.</p><p>Now we have met, we have look’d, we are safe,<br>Return in peace to the ocean my love,<br>I too am part of that ocean, my love, we are not so much separated,<br>Behold the great rondure, the cohesion of all, how perfect!<br>But as for me, for you, the irresistible sea is to separate us,<br>As for an hour carrying us diverse, yet cannot carry us diverse forever;<br>Be not impatient—a little space—know you I salute the air, the ocean and the land,<br>Every day at sundown for your dear sake my love.</p></blockquote><p>這首詩原文很清晰，但恐怕翻譯起來難度不小。就以最後一句爲例，實在是很難搞定這種英文表達帶來的奇妙感受。Anyway，我先嘗試完成佛洛斯特的那首小詩吧。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 詩歌？ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被打斷的馬七</title>
      <link href="/2020/11/16/essay/music/%E8%A2%AB%E6%89%93%E6%96%AD%E7%9A%84%E9%A9%AC%E4%B8%83/"/>
      <url>/2020/11/16/essay/music/%E8%A2%AB%E6%89%93%E6%96%AD%E7%9A%84%E9%A9%AC%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>上海音樂學院歌劇院建成沒有多久，第一次進這個廳。但體驗實在一言難盡。</p><blockquote><p>地點：上音歌劇院<br>時間：2020年11月8日<br>指揮：張亮<br>樂團：上海愛樂交響樂團<br>座位：樂池正前方偏音樂廳後部<br>開始前的食物：港式餐廳</p></blockquote><a id="more"></a>  <p>　　《馬七》本身是一部晦澀的作品，在此之前聽了很多次也不得要領。由於這部作品的冷門，對於這種部作品的討論也很少。令人印象最深刻的果然還是第一樂章最開始的那個標誌性的不和諧音。比較有趣的地方是第一次見識到這麼多配器的同時使用。吉他、曼陀鈴、管鍾、鋼片琴、沙錘、鑼等等。特別是曼陀鈴的聲音，十分獨特有趣。（當時我聽到曼陀鈴的時候想了很久這個樂器是什麼，發現是曼陀鈴之後又在樂池裡找了一陣子。果然我對這個曲目非常不熟悉。）最後的疑惑是，現場的吉他應該是加了擴音器的。但是在馬勒的時代，擴音器也被使用了嗎？如果沒有，後面的觀衆想必聽不見吉它的聲音吧。<br>　　<br>　　但聽完的感悟果然還是我不懂這部作品。不知道它在描繪什麼樣的意境，有什麼樣的故事。雖然其名爲夜曲，在第三樂章依舊十分張揚。我實在沒太懂。樂團現場演繹平平，不過衆多的獨奏沒有明顯翻車還算不錯。</p><p>　　然後是上愛。不知道是不是由於這是新開放的音樂廳，觀衆尚沒有建立起好的禮儀。在第一個樂章結束的時候，竟然傳來了不小的鼓掌聲。甚至有一些沒能及時入場的觀衆在這個時候入場，使第二樂章和第一樂章完全割裂，意境全無。更甚的是，在後面每一個樂章間，觀衆依舊鼓掌，聲音甚至更大了。實在不太能理解。</p><p>　　以及進場的手續問題。爲了進場，經過了檢查健康碼、形成碼、兩次驗票種種繁雜冗餘的步驟，是在給人留下了很糟糕的印象。想上一次聽貝多芬也不是如此場景，實在滑稽。</p><p>　　總而言之，是一場不太妙的演出。也很難給人留下深刻的印象。着實有些失望。最後回寢室的路上。聽見一起去現場的樂迷朋友說，上交的某場演出，有一次因爲觀衆在樂章間鼓掌，指揮轉過身用指揮棒指着那個鼓掌的區域良久。上交的觀衆確實是不鼓掌的，在我印象里。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Joseph&#39;s S8</title>
      <link href="/2020/10/22/essay/Joseph&#39;s%20S8/"/>
      <url>/2020/10/22/essay/Joseph&#39;s%20S8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-usMhLsJS" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="472141225" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>　　今日他的使命至此終結。把他的自動開機，鬧鈴取消後，關機放在一邊，頓時五味雜陳。從此之後，Joseph 的藍牙配對菜單少了這樣一個朋友。多圖預警。</p><a id="more"></a> <p>　　他的前任是黑莓 Z10，另一個手機巨頭的絕唱。在 2017 年，年初，三星上半年期間 Galaxy s8 發布。那個時代的安卓機統一爲魅族初創的三合一 Home 鍵，蘋果仍停留在粗笨的 iPhone 6 時代的風格。高考結束後不久，這樣一個手機出現在了我的手中。我還記得很清楚，當時坐在地鐵上，我小心翼翼地，把他放在了他的包裝盒裡。父親問我爲什麼不多用用，我不記得我回答了什麼。但那是真正的，滿足的感覺。s8 回應了我的期待。</p><p>　　快四年過去了。這一系列依此發布了 s9，s10，s20 三部。整個手機圈也出現了翻天覆地的變化，國產手機全面崛起，屏下指紋、120 瓦充電、120Hz 高刷，並搶先進入 5G 時代。經歷了薩德事件和 Note7 事件，推出 s8 的三星在 17 年已經在國內市場站在邊緣。如今三星已淪爲了每年年報的 Others 角色，而蘋果僅以自研芯片和 iOS 站穩腳跟。手機的形態也是千變萬化，從三星、小米各自給出一套方案，隨後蘋果發布 iPhone X，將劉海屏推向市場。安卓機淪爲一片劉海和水滴屏的世界，其後挖孔屏和機械結構升降屏也出現在了市場。</p><p>　　非常遺憾。</p><p>　　我的 s8 是當時被稱爲「煙晶灰」的一個顏色，機身通體顏色保持暗銀色，在深沉的光線下會透出紫色。在當時一衆 5.4 寸手機中引入 5.8 寸 18：9 屏幕（當然之前還有突破性的小米 Mix 一代。）鶴立雞羣。流暢的曲面設計和完全對稱的真反面，讓整個手機變成一個深邃的鵝卵石，在平面上幾乎一個可以滾動的水珠。前面板上下邊框寬度完全對稱，左右邊框則被曲面屏隱藏起來，完成了在那一年最爲令人驚艷的作品。我很慶幸當時我做出了正確的選擇，在之後幾年一直至今我從未遺憾。</p><p>　　s8 基本是這段時間陪伴我時間最長的物件。剛拿到手機時會不斷地倒騰各種新奇的功能，開發無數新鮮的玩法。恰好 s8 是一個藏寶系統，即使在我前幾天仍在使用的途中我也能發現新鮮的功能。後面慢慢熱情消卻了，手機更多變成了一個工具而非一個玩具。收發信息、掃碼付款變成了他的常態工作。但是每一次，當我把他放在桌子上的時候，新消息進入了我的手機，他那圓潤的邊框閃爍起一陣流光溢彩，我便能再一次欣賞他的風姿。</p><p>　　兩個月前，我去掉了他的殼子。起因是我希望給後背清清灰，但就是這樣的一個瞬間，我拿起他的時候，仿佛發現了一個新的東西，一種新的體驗。是令人感動的手感和難以置信的輕便，從此他便以這樣的姿態繼續存在在我的生活中。三年多過去了，我還是偶爾會抱怨他突然卡起來，偶爾又掉電迅速。但畢竟已經有些年紀了，我便不爲難他。</p><p>　　「手機」這樣的工具，由於時時刻刻呆在自己身邊，沾染了自己的氣味，變得人性。從圖標到壁紙，系統組件的顏色，各式工具的選擇和搭配，都是手機用戶性格的烙印。每次到晚上十一點時，看見他提醒我去查看明日的日程；到十二點時，他提醒我去休息。儘管我都不太聽他的，但是仍爲他的執拗感到快樂。我今天中午進入食堂的時候在想（那個時候，s8 正放在我的桌子上），他知道自己就要離開我了嗎，他知道自己之後提醒休息的是另一個人了嗎（這部手機之後會交給母親，她或許希望繼續使用，不過這個看她）。我是該爲他知道「我」是我而高興，還是爲他不知道「我」是我而高興呢？</p><p>　　或許之前就是所謂的戀舊吧。我不願意把這個理解爲是我習慣於自己的習慣，而狀況在改變時感受到的不習慣。而是一種更加複雜的東西，或許是一種真摯的喜愛和抱歉的心情。</p><p>　　這麼多年後，我還想得起，當時在三星專賣店，第一次看到它的時候，聽見的那首歌。那一切的場景，都如此生動。啊，哎。很高興遇到你，在那個時候，那個地點。</p><p>　　以下是他陪伴我走過的地方，見證過的風景。</p><center><img src="/images/Things/s8/1.jpg" width="80%" height="80%" />攝於17年9月4日，復旦大學南區，剛剛入校。</center><center><img src="/images/Things/s8/2.jpg" width="80%" height="80%" />攝於17年9月7日，復旦大學南區，住宿區樓下的貓。</center><center><img src="/images/Things/s8/3.jpg" width="80%" height="80%" />攝於17年9月20日，復旦大學本部，社團招新。</center><center><img src="/images/Things/s8/4.jpg" width="80%" height="80%" />攝於17年9月23日，家樂福里的奇怪物種。</center><center><img src="/images/Things/s8/5.jpg" width="80%" height="80%" />攝於17年9月28日，前往張江參加中秋活動，從張江回本部途中。</center><center><img src="/images/Things/s8/7.jpg" width="80%" height="80%" />攝於17年10月01日，遇見我喜歡的專輯。</center><center><img src="/images/Things/s8/9.jpg" width="80%" height="80%" />攝於17年11月11日，去同濟蹭的音樂會。</center><center><img src="/images/Things/s8/10.jpg" width="80%" height="80%" />攝於17年12月11日，正在上大物課的時候往窗外望去。</center><center><img src="/images/Things/s8/11.jpg" width="80%" height="80%" />攝於17年12月12日，爲了給嘉祥的校友加油，在校門前錄像時天氣甚好。</center><center><img src="/images/Things/s8/12.jpg" width="80%" height="80%" />攝於18年1月25日，寒假回家，和三弟重訪三星堆。</center><center><img src="/images/Things/s8/13.jpg" width="80%" height="80%" />攝於18年2月15日，家裡對面的湖，湖旁的櫻花樹開了。</center><center><img src="/images/Things/s8/14.jpg" width="80%" height="80%" />攝於18年3月18日，相輝堂開膛演出。</center><center><img src="/images/Things/s8/15.jpg" width="80%" height="80%" />攝於18年4月27日，去同濟蹭的踢踏舞，坐在第一排正中央。</center><center><img src="/images/Things/s8/16.jpg" width="80%" height="80%" />攝於18年5月4日，復旦旦苑的54套餐，一點也不好吃。</center><center><img src="/images/Things/s8/17.jpg" width="80%" height="80%" />攝於18年7月9日，丹霞地貌，在前往甘肅支教途中。</center><center><img src="/images/Things/s8/18.jpg" width="80%" height="80%" />攝於18年7月18日，調研當地非遺時特意造訪的一個「景點」，其實只有一個小寺廟。</center><center><img src="/images/Things/s8/19.jpg" width="80%" height="80%" />攝於18年8月19日，和同學一起去烏鎮。烏鎮的牆很美。</center><center><img src="/images/Things/s8/20.jpg" width="80%" height="80%" />攝於19年1月17日，期末季結束後去看現代藝術展。</center><center><img src="/images/Things/s8/21.jpg" width="80%" height="80%" />攝於19年5月27日，校慶的那天，食堂里的西瓜。</center><center><img src="/images/Things/s8/22.jpg" width="80%" height="80%" />攝於19年7月5日，去珠三角調研時，一羣人去點都德吃早茶。「菜單上的通通來一份！」</center><center><img src="/images/Things/s8/23.jpg" width="80%" height="80%" />攝於19年7月19日，和Bobby去看《不眠之夜》，我將再去一次。</center><center><img src="/images/Things/s8/24.jpg" width="80%" height="80%" />攝於19年8月1日，抵達新加坡，第一次去魚尾獅。</center><center><img src="/images/Things/s8/25.jpg" width="80%" height="80%" />攝於19年9月8日，第一次聽到管風琴的獨奏。</center><center><img src="/images/Things/s8/26.jpg" width="80%" height="80%" />攝於19年10月10日，新國立Utown的裸眼3D繪畫，應該是一個到處旅遊的畫家畫的。</center><center><img src="/images/Things/s8/27.jpg" width="80%" height="80%" />攝於19年12月4日，將離開新加坡前和Bobby吃的一頓鰻魚飯，芥末很棒。</center><center><img src="/images/Things/s8/28.jpg" width="80%" height="80%" />攝於21年1月7日，返回成都前先前往了哈爾濱。抵達的第一天晚上，民宿小區裡的兔子。這裡一點都不冷。</center><center><img src="/images/Things/s8/29.jpg" width="80%" height="80%" />攝於20年1月8日，前往拜訪聖索菲亞大教堂，可惜它還在裝修內飾。</center><center><img src="/images/Things/s8/30.jpg" width="80%" height="80%" />攝於20年1月10日，和三弟前往滑雪的途中。</center><center><img src="/images/Things/s8/31.jpg" width="80%" height="80%" />攝於20年5月1日，和幾位朋友徒步峨眉山。見到洗象池的時候，剛好兩腿抽筋，跪在了面前。</center><center><img src="/images/Things/s8/32.jpg" width="80%" height="80%" />攝於20年5月2日，峨眉山的日出。</center><center><img src="/images/Things/s8/33.jpg" width="80%" height="80%" />攝於20年9月23日，貝多芬！</center><center><img src="/images/Things/s8/34.jpg" width="80%" height="80%" />攝於20年10月3日，在光華樓附近看到一個眯着眼睛在草地上打滾的貓。</center><p>感謝你，我的 s8。</p>    <div id="aplayer-bqqTotoc" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5052770" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物志銘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>‘Monster’观感（下）</title>
      <link href="/2020/10/20/essay/%E8%A7%82%E6%84%9F/Monster%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2020/10/20/essay/%E8%A7%82%E6%84%9F/Monster%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>请注意：该版本目前为草稿！请谨慎食用。</p></blockquote>    <div id="aplayer-eSefikct" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="461353" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="评价：★★★★★"><a href="#评价：★★★★★" class="headerlink" title="评价：★★★★★"></a>评价：★★★★★</h3><p>　　这里是 Monster 剧评的后半部分。这一部分主要讨论人物塑造和主题问题。由于讨论内容的特殊性，将不可避免地剧透。请未观看过该部作品的读者一定不要进入后续剧情章节，除非各位觉得剧透并不是那么严重的问题。此外，本文作者没有经过任何仔细研究，本文内容请视为完全主观甚至胡说八道的。</p><a id="more"></a>  <h2 id="一个概述"><a href="#一个概述" class="headerlink" title="一个概述"></a>一个概述</h2><p>　　对于本部分的内容，个人并不希望将人物和其对应的主题区分开；而是以某些角色为核心，在阐述这些人物是如何构造的同时，讨论这篇人物对应的主题。这样的结构之所以可以实现，得益于 Monster 主题的多元性和模糊性。在观看的过程中我不得不认为，不同角色承载的主题是截然不同的，然而其整体又构成了一个大的主题（有的人说是“人性”，但个人并不认为是非常好的概括吧，这个概括太偷懒了。）</p><p>　　此外，不得不承认 Monster 涉及的众多主题，包括小人物身上承载的主题，是难以逐一梳理的。类似博德曼律师承载的“对于正义的执念”，迪特身上承载的“在接下来的日子寻找快乐”，以及 511 院长引出的“爱的教育”。这些小单元都有自己的精彩和值得思考的问题。我们将直接对这些问题放弃讨论。而将注意力放在以下二级标题的四个主题和对应的人物上。</p><p>　　在这一部分结束后，我将试图对于整部作品提出一些有趣的问题。由于这部作品充分留白的性质（我当然指的不是剧情上合理的解释这样的问题），一些问题存在一定思考的空间。在此之后，是对整部作品及本人的评价的一个简单总结。</p><p>　　P.S. 在本章节开始前，我试图部分回收上半部分的观点，对于 BGM 的批评。本作的 BGM 在大多数情况下是合理的，但是也不乏出戏的 BGM。上半部分中可能将这一点说得过重了一点，在此声明。</p><h2 id="葛利马、超人苏坦纳、没有悲喜的"><a href="#葛利马、超人苏坦纳、没有悲喜的" class="headerlink" title="葛利马、超人苏坦纳、没有悲喜的"></a>葛利马、超人苏坦纳、没有悲喜的</h2><p>　　葛利马首先出现在第 40 集，名为“Grimmer 的章节”。以葛利马为题的集数分别为第 42 集“The Adventures of the Magnificent Steiner”，及第 71 集“The Magnificent Steiner’s Rage”。期间自 52 集开始，葛利马承担罪责开始逃亡并进入暗线调查卢恩海姆，一直到 68 集重新进入主线。</p><h2 id="约翰、怪物、没有名字的"><a href="#约翰、怪物、没有名字的" class="headerlink" title="约翰、怪物、没有名字的"></a>约翰、怪物、没有名字的</h2><h2 id="天马、医生、无所适从的"><a href="#天马、医生、无所适从的" class="headerlink" title="天马、医生、无所适从的"></a>天马、医生、无所适从的</h2><h2 id="怪物是谁？"><a href="#怪物是谁？" class="headerlink" title="怪物是谁？"></a>怪物是谁？</h2><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> Draft </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 观感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兩隻金烏（下）</title>
      <link href="/2020/10/20/essay/%E4%B8%A4%E5%8F%AA%E9%87%91%E4%B9%8C%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2020/10/20/essay/%E4%B8%A4%E5%8F%AA%E9%87%91%E4%B9%8C%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　金烏每日自陰影處起飛，連續飛翔一日到陰影處停歇，凡飛過之處，皆一片光明燦爛。</p><p>　　　　——《華嵇紀-卷三》</p><a id="more"></a>  <h2 id="古怪的畫家（一）"><a href="#古怪的畫家（一）" class="headerlink" title="古怪的畫家（一）"></a>古怪的畫家（一）</h2><p>　　當他從上級那裡接到任務時，很詫異。</p><p>　　他從來都只是一個抓小偷小販的警察，沒什麼能耐，更對不上人們稱呼的「可敬的人民衛士」。除了可以每天每夜在一個地方蹲崗而無抱怨之外，毫無特色。上一次立功，就是因爲在一個酒店的門前，他連續守了兩個月，每日就吃些簡單幹糧過活。當嫌疑人終於大搖大擺出現在他的面前的時候，他差點沒有力氣抓捕嫌疑人。這都是些不足掛齒的事情，但是這次不一樣。他突然覺得有什麼，可以讓他一下子飛黃騰達的機會；但也同樣，可能意味着再也無法升遷。收到上級給他的資料後，他收拾收拾立刻就出門了。今天晚上……他想着這個事情，習慣性地整理了自己的制服，讓它更筆挺了一些。一點差錯都不能有，一點都不能。</p><p>　　他要拜訪的第一位，9 點整，是住在那個臨海的小片區的著名畫家。聽說這不算個不近人情的人，我還是直接去吧。他這樣想着。咚咚咚，他敲響了這棟別致的小房子的門，並喊着「畫家先生」。</p><p>　　伴隨着一些不清晰的嘟囔和開門聲，一個看起來還沒太睡醒的不算年輕的年輕人出現在了門口，他立刻整頓了一下表情，立得更筆直了一些。幾番寒暄後，他擠進了畫家的門。他開門見山，立刻就擊中了這一次希望訊問的東西。「先生，您知不知道那個叫做『金烏』的盜賊？」對方沒有回答，他突然覺得有些不知所措，他也愣在了那裡。看着對方不知道如何形容的表情，他從包里掏出了一張紙，小心地給對方展示了一下。這是最最重要的證物，是串聯起所有東西的物品。絕對不能弄壞，他這樣想，於是只給對方草草地看了一下，連讓對方碰一碰的機會都沒有。</p><p>　　這是上級交給他的物證，從「金烏」的上一個據點裡找到的。爲什麼說那個是「金烏」的上一個據點，是因爲這個空蕩蕩的房間裡寫着「金烏」標誌性的台詞。除此之外有些生活的痕跡，以及在現場找到的這一張剪報和那張有燙疤的紙片。但是這些東西，對於這個尚且木訥的警察來說，並不意味着什麼，唯一的線索就是眼前這個頭髮亂糟糟的畫家。</p><p>　　見到對方表情仍然毫無變化，但做出了一個「看完了」的示意，他不得不收回了這張紙。然後掏出了那份剪報，但這一次，對方甚至沒有把報紙全部抽出來就塞了回去。看來他想起這個事情了，他想，這是乘勝追擊的時刻。在他正想開口的時候，想不到對方先開口了。「那麼，警察先生造訪寒舍，有何貴幹？」他不得不覺得非常窘迫，好像自己的資質淺薄被對方看出來了，他更加緊張地坐直，擺出大勢的樣子，「沒有什麼，想知道您是否知道這位『金烏』？」這一次我要堵住對方，於是立刻又說了一句，「這張紙是從『金烏』逃逸的藏身處找到的。」</p><p>　　對方愣住了。果然我將住了他一軍，他滿意地想着。看着對方起身，他的內心也更加激動。「不，我想我不認識。」如此突如其然的拒絕，他突然覺得線索都斷掉了，只剩下今晚還有機會。對方又在嘰里咕嚕地說些什麼，但他沒聽確切。只是聽到對方好像在詢問自己的意見什麼的，於是立刻拒絕了對方的請求，說了幾句告辭的話，逃也似地離開了那裡。</p><p>　　這是個古怪的畫家，太糟糕了。我什麼線索也沒有找到，他一邊搖頭，一邊大邁步，一邊揮着雙手的時候想着。不，有個事情，我需要確認一下。他停在了路口，走到最近的電話亭，撥下了畫家家裡的電話。這可真是個有錢人。</p><p>　　無人接聽。</p><p>　　這個畫家去了哪裡。在這個短短的時間，這不對勁。這個，這哪裡有問題。契機……頂着一頭亂蓬蓬頭髮的畫家、沒睡醒的畫家、裝作不知情的畫家，在我離開後的這一刻鐘內，離開了自己的房間——爲什麼這麼做，爲什麼這麼做。只有一個事情起了變化，他從我這裡得知了「金烏」的事，他得知了有人拿到了「金烏」的把柄，這個指向「金烏」的線索。</p><p>　　這個畫家他慌忙地離開了自己的房間，原因只能有兩個：他是「金烏」，他害怕地逃離了自己安穩的小房間；他是「金烏」的同黨。是這樣的，是這樣的。這個木訥的小警察抓住了立大功的機會。抓住這個機會，抓住這個畫家！這一切的想法充斥了他的腦袋，甚至在他還沒聽到「無人接聽」的聲音完全消失的時候，他就已經完成了這樣偉大卓越的思考。抓住一切機會，抓緊一切時間。回頭，去找那個古怪的畫家。</p><p>　　他立刻離開了電話亭，朝着剛才來的路風風火火地行進。我不能太誇張，不能太張揚。這樣打草驚蛇，我要鎮定。於是他選擇了用不正常的速度搖擺着雙腿，裝作若無其事地行進的樣子，而不至於跑起來。很快他來到了畫家的房前。他在門口觀察了一小會，確認房間裡暫時沒有活動的痕跡，靠近了一些，從窗戶外里看。裡面果真沒人。他跑啦，還是他去通風報信啦。</p><p>　　「您在幹什麼呀，先生？」他被嚇了一大跳。他趴在窗戶上，看着房間裡的擺設如癡如醉，完全沒注意到聲音的來源，也完全沒注意到自己像個白天裡的賊。「這戶人，這戶人你看見了嗎？你認識他嗎？住在裡面的那個畫家？啊，你認識他嗎？」他甚至沒看見自己在和誰說話，也沒注意到自己的領子也歪了，就吐出了一連串問題。當他說完，還在喘着粗氣的時候，才注意到地上站這個不太高的，掛着報筒的小報童。這個小報童往門前看了一眼，「我知道他看了今天早上的報紙。」報紙？事情變複雜了，這個畫家先看了報紙然後才離開。「你什麼時候送的報紙？」「十分鐘前。」複雜了，好傢夥，這個報紙。「我要一份報紙！」他幾乎是搶一般的，從報童手裡奪過一份報紙。</p><p>　　在看到報紙的標題的時候，他突然快樂了，他破解了一切的謎題，他終於覺得自己不是個愚昧的人。他知道自己應該去哪裡，去找誰，做些什麼。他將報紙的錢和應該找零的錢一下子扔個報童，把報紙塞進了自己的包，離開了畫家的家。</p><h2 id="屋頂的金烏（五）"><a href="#屋頂的金烏（五）" class="headerlink" title="屋頂的金烏（五）"></a>屋頂的金烏（五）</h2><p>　　我握着手裡的報紙，慢悠悠地往博物館走。今天雖然沒有什麼事情，但其實應該畫一些什麼畫的。畫室里還躺着昨天沒有畫完的一幅寫生畫——我正在描摹我的畫室周圍的動人景色。但顯然這個突然發生的事情更加吸引我的注意，所以我正握着我的報紙走在通往博物館的路上。</p><p>　　很快我走到了一個汽車站台附近，等到了一輛電車坐上去，繼續完成我通往博物館的行程。這個時候顯然不是大家出行的時間，電車裡基本上沒有什麼人。司機躲在那個幕布後面安靜地駕駛着這輛車，讓它看起來仿佛是自己動起來的——它確實是自己動起來的，但是它是怎麼自己動起來的？作爲一個藝術家，我是搞不懂的。但我應該動用我的創造力，去想象，它是怎麼動起來的。既然叫電車，應該就是用「電」這種東西吧。「電」從上面那個管子裡輸到車的內部，這個東西通過「某種方式」驅動了輪胎，帶着我們往前走。但「電」究竟是什麼呢？這我就不懂了。</p><p>　　我看着窗外的景色莫名其妙地流動而不知原因，茫然地進行一些無厘頭的思考的時候，我抵達了目的地附近。這是當地最富盛名的博物館，有着號稱全國最多、最全的藏品集，當然也配備着號稱最先進的防盜措施和足夠的安保人員。這樣宏大的規模，即使不是周末也會有諸多遊客和當地的小學組織的春遊隊伍造訪。它總是和醫院一樣，熙熙攘攘的。</p><p>　　這是一棟簡潔明了的建築，有紅色的素麵牆壁，上面貼着白色的瓷磚；整體形狀基本是一個巨大的立方體。不同面牆上有着不同樣式的浮雕，並且也不是完全的平面，而是有輕微地波濤樣的起伏。對於一般人來說，是非常古怪的樣式；但從我的角度來看，這實在是一個別致的建築，兼具着一種古典美和現代性。我曾經伏在這個建築周圍，連續幾天研究牆壁上的圖案流連忘返。裡面的藏品就更不用說了，作爲一個以傳說爲題材繪畫的畫家，這簡直是不可多得的寶地。</p><p>　　但今天吸引我到這裡來的，是別的東西。我注意到今天博物館和往日的情況有着明顯的差異：博物館四周的安保人員並沒有出現，而停着不少的警車。博物館的門儘管開着卻沒有進進出出的遊客樣貌的人，更別說那些吵鬧的、穿着時髦俏皮的小學生了。警車旁和門前都站着些胖大警察，穿着我方才才端詳過的那種制服，三三兩兩地討論一些什麼。這個時候我才注意到，警車外面還拉着一條警戒線，把整個博物館的大門圍出了一個半圓形，半圓形外是幾個拿着筆和紙，正在刷刷書寫着的人。那些應該是記者了吧。我一邊這樣想着，一邊也確認了今天的特殊情況讓我到不了博物館裡。於是我找到了一家能看見大門附近樣子的咖啡館的座位，隨便要了杯咖啡，從書架上拿出來一本不知道什麼國家的作家寫的翻譯過來的書看了起來。</p><p>　　書的內容很滑稽，也不太有趣，講的是一個漁夫，竟然愚蠢地在休漁期開始前的最後一天，睡過了而沒能出海，被他的妻子連着罵了七天七夜的故事。而且我也總是不能很認真地看這本書，因爲隔壁正坐着一個標緻的年輕人（穿着雖然不算名貴但絕對講究），他拿着笨重的鋼筆在一沓紙上發出沙沙的聲音。當然我沒法打斷他，說「你靜靜」。因爲他看起來在做正事，而我只是個遊手好閒地看滑稽劇的人。</p><p>　　當我擡起頭有意無意地看向他的時候，他也突然擡起了頭看向了我。他的眼睛很精緻，眼角略微下垂，是很適合做速寫的那種。「你是畫家先生吧？」他側了側他的腦袋，「剛才，有一位先生告訴我，一位可敬的畫家先生將會到這裡來，並交給了我一張畫家先生的照片。那上面的人像極了你。」我第一次覺得不妙。</p><h2 id="古怪的畫家（二）"><a href="#古怪的畫家（二）" class="headerlink" title="古怪的畫家（二）"></a>古怪的畫家（二）</h2><p>　　在他的面前，突然出現了這樣一個人：一個嚴肅的男人——或許他可以這樣認爲。這個人穿着警察的制服，看起來有板有眼。警察交給他一張乾淨的紙條（神祕兮兮地），紙條上是乾淨的文字。「記者先生，一會這裡會出現一個穿着隨意的還算青年的人，他是一個畫家。他會是今天『金烏』盜竊案的關係人。」紙條後面貼着一張符合這個描述的小照片。就是這麼一段話。作爲一個岌岌無名的小記者（與夢想相悖），從來不曾有什麼驚天大報道這樣的事情（就業以來）。從來都是去一些小打小鬧的地方，採訪一些瑣事。其實今天，他完全不應該到這裡來。只是出於「記者的嗅覺」，他來到了這裡，然後收到了這樣一張紙條。他感激地看着那個離他遠去的可敬的警察先生，並又一次看着手上的紙條。</p><p>　　他現在正坐在路邊的一個咖啡館，正對着那個「金烏」宣揚將要偷竊的博物館（記者的情報總是比大衆來得靈通）。於是他開始預演，這個神祕的畫家和「金烏」的關係。實際上，他只是在一疊稿紙上寫來寫去，但是完全無法集中注意力。以致於他的筆發出的聲音太大影響了周圍的人這一點，他也沒有察覺。他如此投入地進行着自己漫無邊際的假想（這是職業所需！），甚至沒有注意到旁邊的客人已經換了一個。當他終於覺得自己口渴了，想要去抓住桌邊的咖啡時，他注意到了。旁邊的那個桌子上的顧客變了，變成了一個自己從未見過的男性。穿着隨意，還算青年，出現在這裡，這個早晨，和照片上的人非常像。這個人皺着眉頭，露出一副想笑卻有不想笑，一種惱怒卻又謹慎的神情（完全不坦率的人）。</p><p>　　他受驚似的立刻移回了自己的視線，小心翼翼地裝作繼續寫着稿子（不能打草驚蛇），並時不時地朝那邊看去。那個畫家好像看一本書出了神。那是怎樣一本書，這本書和「金烏」的關係是什麼。他知道，在戰爭時期，人們會使用兩本一樣的書作爲密碼本，然後通過標註頁碼和字的位置來傳遞密碼。密碼本。那本書回是密碼本嗎？（這太離譜了）他立刻收回了自己的目光，開始側起自己的耳朵努力地聽那邊的一聲一響。突然他意識到，對方正在擡頭看着自己，他立刻慌張了起來，擡起了頭，看着對方。「你是畫家先生吧？」他儘可能地做出隨意的樣子，以免這樣嚇到對方。於是他意識到自己需要，更加嚴肅地、完整地告訴對方緣由（保持專業素養）。「剛才，有一位先生告訴我，一位可敬的畫家先生將會到這裡來，並交給了我一張畫家先生的照片。那上面的人像極了你。」（愣頭愣腦）他突然意識到自己不該說這麼多，但說到這裡他已經發現那個畫家地表情發生了巨大的變化。是某種抽搐一樣的表情，仿佛白天看見了什麼怪物一般。</p><p>　　就在這個時候，天空中一陣巨大的轟鳴聲。首先是一個灰色的頭從博物館上方露出來，然後聲音越來越大，形態越來越完整，露出了兩個翅膀。這個巨物的頭遮住了剛從雲里鑽出來的太陽照下的光線，四周閃爍着詭祕的光影。頓時從那個巨物上，他感受到了一種壓迫感，他甚至沒能注意到那個畫家的驚詫表情，和遠處正在博物館附近工作人員的混亂情況。直到這個龐然大物慢慢從視線里消失的時候，這種轟鳴中的奇怪寂靜才慢慢消失，對話才成爲了可能。他這個時候才注意到了對面一臉受到嚴重驚嚇樣的畫家（嗯？）。「不過是飛行器，先生不必如此受驚。」（職業素養）他希望自己能夠將話題拉回剛才的對話。就在這個時候，越過畫家呆楞着的肩膀和頭顱，他看見了後面的博物館門前的樣子。</p><p>　　那裡的警察亂成一片。有一兩個警察拿着黑色的盒子喊來喊去，警察開始四處跑動。有的警察手上拿着黃色警戒線，有的警察手上拿着棒子。他們開始無規律地、沿着各種方向地繞着整棟樓行進，留下剩下的一兩個警察操着黑盒子大喊大叫。旁邊的記者羣體不甘寂寞，在警戒線外瘋狂地閃着自己的閃光燈。那邊發生了什麼事情？儘管他這樣急切地希望知道正在上演的一切，也不能撂下這個重要的畫家（畢竟是關係人）。他迅速拉起了畫家的右手，用自己的右手在桌上拍了一把錢，足以付清兩個人的用餐（先這樣吧），迅速超那個方向跑去。</p><p>　　在他拽着還沒回過神來的畫家跑到那羣混亂的人附近的時候（至於這麼吃驚嗎），他只聽見了這樣的幾句話。「『金烏』比預告的時間早來了數個小時，尚未得得知博物館蒙受損失情況，但『金烏』的標誌性留言已經出現在了博物館的一面內牆上。」這顯然是另一個記者正在一邊瘋狂地做着筆記一邊無心念出來的話。</p><h2 id="屋頂的金烏（六）"><a href="#屋頂的金烏（六）" class="headerlink" title="屋頂的金烏（六）"></a>屋頂的金烏（六）</h2><p>　　在我面對着這個奇怪的記者不知道該說什麼的時候，天上似乎響起了一陣轟鳴。嗯，是飛行器的聲音。我感覺到我的頭上產生了一大片陰影。但是……這是什麼樣的感覺呢：被「某個人物」惡意地玩弄。仿佛這個場景我在什麼時刻經歷過，在數年前，或者數天前；或者是精心策劃好的。這個陰影有某種象徵，讓我突然覺得恐懼。就在同一個時刻，我捕捉到了我身後的一些細碎的聲音，是一些人快跑的聲音。<br>　　<br>　　事情的異變我也從正對着我看的那個眼睛精緻的記者那裡看出來了。他似乎說了什麼，但是我完全沒聽清他在說什麼。他直愣愣地看着我，或者說我的背面，他注意到了什麼我也注意到了的事情。於是他立刻拽起了我的手，就在同時站了起來把我順時針拽了九十度。我聽見了遠去的飛行器的聲音、口哨的聲音、人物跑動的聲音、手掌拍到桌面上的聲音、銅幣落地的聲音、有人高喊「金烏」的聲音。我感到我的眼前的光景在不斷地變化，並且感到自己正在任由那個記者的擺布。在我奪回了自己的意識的時候，我發現我已經站在博物館前的警戒線旁了。</p><p>　　我對那個魯莽的記者完全沒有了興趣，我只注意到了這樣的一個現場。一羣亂成一團的警察，以及一羣亂成一團的記者。我發現我很快理解了這裡發生了什麼。「金烏」如同其預言的一樣，來到了這個博物館，拿走了一樣東西。但是與預告不同的是，他出現在了一個不正確的時間，拿走了一個不值錢的東西，留下了標誌性的那一段話，然後消失了。</p><p>　　很快我的耳朵告訴我，現場找到了一張新的紙條。紙條上是另一個預告，市內的另一個博物館，一周之後的同一個時間，他將再次出現。這就是「金烏」麼。我不禁啞然。這是我被拽到博物館前的十分鐘後，我花了這些時間掌握正在發生的一切，以及將要發生的一切。在這十分鐘之後，我才意識到了這樣一個事情。我的左臂被那個記者緊緊地抓住，我的右手周圍突然出現了一個銀色的鐵環。我很快反應過來這是什麼東西。然後看見了這個鐵環，上面有一根鏈子，這個鏈子連到的另一端，是今早拜訪我的、當時身板鐵直、現在滿臉通紅的民警。</p><p>　　如今那個自己被玩弄的感覺越來越明顯。就在我想着這樣的事情的時候，眼前開始出現白色的飛沫，飛沫越來越稠密、覆蓋了我的所有視線。隨後我能看見的彩色的事物都變成了黑色，我完全進入了黑白雪花相間的世界。</p><h2 id="金烏的自白（一）"><a href="#金烏的自白（一）" class="headerlink" title="金烏的自白（一）"></a>金烏的自白（一）</h2><p>　　今天他去迎接那個著名的畫家。畫家因爲蒙受了錯誤的冤屈，被他親手送進了監察室。後來想起，他覺得自己當時實在是過於魯莽，竟沒有對着整個事情有些許懷疑。正當要按照手續對那個畫家開始審理的時候，畫家的嫌疑立刻被洗清了。因爲」金烏「的又一次到訪。這一次」金烏「再一次比他所預告的時間提前了數個鐘頭，搞得警察再一次顛八倒七。但如同上一次一樣，被盜走的既不是博物館最值錢的東西，也不是最有名的東西——只是一些花里胡哨的小玩意。</p><p>　　這完全一樣的手法立刻讓畫家擺脫了冤屈，但是警署里完全亂成了一團。上司怒不可遏，拎起手邊的東西就砸。他嚇壞了，因爲警察這一次部署不周有一部分自己的責任。好在後面上司沒有怪罪下來。今天他接到上司的命令，去監察室帶出畫家先生，並賠幾句禮，表示警方的歉意。</p><p>　　待他走到監察室外面的時候，仿佛畫家已經聽到了自己的聲音。他聽見裡面傳來斷斷續續的聲音。「那張肖像，是你給的嗎？」。他愣在了原地，肖像是指什麼。「那張肖像，是你給的嗎？」「肖像？」「那……看來不是你給的。果然是這樣，呵呵，哈哈哈。」然後是幾句非常侷促乾癟的笑聲。「來吧，你該帶我出去了」</p><p>　　他打開門，看到了門口站着的畫家。畫家看起來神采奕奕，並露出異常嘲諷的表情。畫家的眉毛高高吊起，並伸出一隻手搭在他的肩膀上。「走吧。」他不知道該說些什麼，他完全沒有理解那個所謂的「肖像」是指什麼，於是他忘記了賠禮道歉，只是木訥地沿着警察署的走廊一直往前。走到警察署的門口，畫家收回了自己的手，又咯咯地笑了兩聲，附耳道，「我是『金烏』，你並沒有錯。」然後轉頭出去了，留下他完全地愣在原地，腦中迴蕩着這個畫家的最後一句話，以及那嘲諷的笑聲。他完全不想追上去，再拷上他的手銬，但卻不知道爲什麼。</p><h2 id="《華嵇紀-後記》（未發表）"><a href="#《華嵇紀-後記》（未發表）" class="headerlink" title="《華嵇紀-後記》（未發表）"></a>《華嵇紀-後記》（未發表）</h2><p>　　……</p><p>　　爲了完成這部書，我花了很長的時間閱讀整理文獻，不知多少春秋，約莫半輩子。</p><p>　　某一個時刻，一個靈感進入了我的腦海：我想杜撰一個假的故事，埋在這本書里。我第一個想到的是太陽的形象，於是構想了太陽的某種使者，起名爲了「金烏」。這樣的形象在這個名字下漸漸具體了起來。我把關於這個生物的描述穿插在了一些別的有名的神話生物中間，草草得對這種生物加以勾勒。沒有人質疑這樣的形象，由於這部書其他的部分過於詳實充盈。幾乎所有研究者都將這部書推崇備至，成爲一種典範。以至於從來沒有研究者找到我來詢問我關於「金烏」的事情。</p><p>　　退休以後，我停止了傳說方面的研究工作，接任了一個小鄉鎮的圖書館管理員，偶爾也養養小花。工作很舒適，這個小鎮子的優美環境也令人心曠神怡，是適合偶爾翻翻書的環境。一切都是恰到好處。</p><p>　　……<br>　　<br>　　這部分後記，已囑託我在鄉鎮裡的子女在我去世之後公布。我不太想承擔諸多學者的對於這個事情的質疑和各種批評，但也有些許遺憾不能看到諸位老學究的氣憤神情——那這部書就這樣了，我能夠確認，本書的其餘部分都是依循已有的文獻和實地採風拿到的信息完成的，仍然具有相當的研究價值，這一點還請諸位放心。</p><p>　　——　燈徽氏</p><h2 id="金烏的自白（二）"><a href="#金烏的自白（二）" class="headerlink" title="金烏的自白（二）"></a>金烏的自白（二）</h2><p>　　</p><hr><p>　　<strong>題外話 3</strong>：這一篇由於種種原因，推進速度慢於預期。可能情況是由於已經產生了較爲完整的構思，反而對細節如何填充完整瞬間索然無味。</p><p>　　<strong>題外話 4</strong>：好像因爲各種各樣的原因擱置了很久。於是再一次提筆續寫發現變得更加困難，看來這個工作不能再拖下去了——恐怕其會變得和冰上行一樣不了了之。</p><h2 id="修訂"><a href="#修訂" class="headerlink" title="修訂"></a>修訂</h2><p>　　暫無</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雜記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>網站安利</title>
      <link href="/2020/10/20/essay/%E5%AE%89%E5%88%A9/%E7%BD%91%E7%AB%99%E5%AE%89%E5%88%A9/"/>
      <url>/2020/10/20/essay/%E5%AE%89%E5%88%A9/%E7%BD%91%E7%AB%99%E5%AE%89%E5%88%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>這裡是一些安利的網站（新開了「安利」的Tag）。基本上是各種奇怪網站的合集，包括一些主流的工具、值得推薦的資源收集。覆蓋面不會很大。</p><a id="more"></a> <h3 id="工具類"><a href="#工具類" class="headerlink" title="工具類"></a>工具類</h3><ol><li><a href="http://mohu.org/info/symbols/symbols.htm" target="_blank" rel="noopener">$ \LaTeX $ 語法快速查詢</a>：一個簡單的網站，用來查突然忘掉的語法。</li><li><a href="https://material.io/resources/color/" target="_blank" rel="noopener">Material Color Tool</a>：支持 Material Design 的組合配色方案。提供一個非常簡單的色盤，用來快速確定自己喜歡的顏色。</li><li><a href="https://feed43.com" target="_blank" rel="noopener">Feed43</a>：用來對網站自建 RSS 的網站。可以手動對一些未提供 RSS 鏈接的網站，通過建立爬取規則生成 RSS 文本，從而在閱讀器中訂閱。</li><li><a href="https://trello.com/" target="_blank" rel="noopener">Trello</a>：老牌看板網站，用來管理團隊項目進展。競品有 Notion 及 GitHub Board。</li><li><a href="https://mubu.com/" target="_blank" rel="noopener">幕布</a>：快速整理寫作的網站。基本思路是利用「層級關係」。</li><li><a href="https://www.remove.bg" target="_blank" rel="noopener">removebg</a>：自動移除背景的網站工具。效果一般，和 PPT 摳圖效果不相上下。支持少量免費的外接 API 用來自動摳圖。</li><li><a href="https://www.photopea.com" target="_blank" rel="noopener">photopea</a>：線上簡易 PS，基本上可以完成大部分圖片操作。</li><li><a href="https://pixlr.com" target="_blank" rel="noopener">PIXLR</a>：線上簡易 PS，比上面那個更加好用。</li><li><a href="https://www.overleaf.com" target="_blank" rel="noopener">Overleaf</a>：線上 LaTeX 寫作，免除手動配置 tex 環境之苦。支持中文，但是中文支持度不夠。</li><li><a href="http://gitd.cc" target="_blank" rel="noopener">GitHub代下載</a>：用來下載 GitHub 的 Release 文件等，不是所有的文件都能下載，但是速度極快。</li><li><a href="https://drive.google.com/" target="_blank" rel="noopener">Google Drive</a>：對於 AI 研究者最大好處，其支持在線上空間運行 python 文件，並提供完全免費的 8GB 的獨立顯卡借用，具有完整的 Torch 等環境用以神經網絡訓練。24 小時重連一次，速度尚可接受。</li><li><a href="https://www.notion.so/" target="_blank" rel="noopener">Notion</a>：筆記類應用的極致，功能簡潔而不簡單，顏值能打，存在大量的模板可供選擇。缺點有二：不支持筆跡，不支持離線。</li><li><a href="https://dida365.com/" target="_blank" rel="noopener">滴答清單</a>：清單類應用最推薦者。支持微信轉發新建任務，支持全平台、免費功能夠用、支持在系統日曆（如微軟 Mail）訂閱。缺點：月視圖收費。</li><li><a href="https://www.innoreader.com/" target="_blank" rel="noopener">Innoreader</a>：RSS 閱讀器，簡潔明了，功能夠強。之前被牆過一段時間，目前又可正常工作了。默認一小時抓取一次。可以和 Feed43 搭配使用。</li><li><a href="https://nipponcolors.com" target="_blank" rel="noopener">日本の伝統色</a>：日本傳統色，UI 和顏色都相當棒的網站。</li><li><a href="https://www.makeamap.cn" target="_blank" rel="noopener">易制地圖</a>：繪製虛擬地圖。</li></ol><h3 id="書籍"><a href="#書籍" class="headerlink" title="書籍"></a>書籍</h3><ol><li><a href="https://zh.d2l.ai" target="_blank" rel="noopener">動手學深度學習</a>：這本書的網絡資源，中文翻譯，支持線上運行代碼，並自帶交流區。</li><li><a href="https://tour.golang.org/welcome/3" target="_blank" rel="noopener">A Tour of Go</a>：Go 語言的線上學習書籍，支持線上運行代碼。風格輕快。（需要梯子。）</li><li><a href="http://www.shakespeares-sonnets.com" target="_blank" rel="noopener">Shakespeare’s Sonnets</a>：莎士比亞十四行詩的線上平台，可以查看所有的十四行詩。</li><li><a href="https://wd.bible/" target="_blank" rel="noopener">微讀聖經</a>：線上聖經閱讀。支持和合本、英王欽定本多版本對照閱讀。</li><li><a href="https://waltwhitman.com" target="_blank" rel="noopener">Walt Whitman</a>：懷特·惠特曼生平及詩集。</li></ol><h3 id="資源"><a href="#資源" class="headerlink" title="資源"></a>資源</h3><ol><li><a href="https://pixabay.com/zh/" target="_blank" rel="noopener">Pixabay</a>：擁有大量優質高清圖片的網站，適合尋找壁紙。主要是照片類別，動物照片尤其多。（頭圖下載自該網站）</li><li><a href="https://wallpapershome.com" target="_blank" rel="noopener">WallpapersHome</a>：擁有大量優質高清圖片的網站，抽象圖片尤其多。有不少從各類操作系統中抽出的系統壁紙。</li><li><a href="http://simpledesktops.com" target="_blank" rel="noopener">Simple Desktops</a>：擁有大量優質高清圖片的網站，多爲抽象簡潔的圖片。主要由純色背景及小圖標組成。</li><li><a href="https://21wallpaper.design" target="_blank" rel="noopener">21 Wallpaper</a>：每數個月由不同設計師設計多組壁紙，提供免費下載的古怪項目。風格差異巨大，目前由於新冠暫停運行，官網上宣稱 21 年重啓該項目。</li><li><a href="http://www.musictool.top" target="_blank" rel="noopener">音樂搜索器</a>：用來在多平台搜索音樂的網站。支持下載網易雲、QQ 等多類流媒體的音樂文件（支持版權限制及僞無損下載）。</li><li><a href="https://cn.imslp.org/wiki/Main_Page" target="_blank" rel="noopener">Imslp</a>：全球最大的樂譜下載網站，古典區必備網站。有多個版本的樂譜，甚至一些手寫稿影印版。</li><li><a href="https://storage.googleapis.com/download.tensorflow.org/data/shakespeare.txt" target="_blank" rel="noopener">莎作全集</a>：莎士比亞畢生作品組成的 txt 文件，可以用來做 NLP 任務。（需要梯子。）</li><li><a href="https://new.shuge.org/view/hong_lou_meng_tu_yong/" target="_blank" rel="noopener">書格</a>：用來搜古籍的地方。網站 UI 很不錯，內容尚待更深入探索。</li><li><a href="https://www.fontsquirrel.com" target="_blank" rel="noopener">Font Squirrel</a>：一個下載免費字體的網站。</li></ol><h3 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h3><ol><li><a href="http://conceptnet.io" target="_blank" rel="noopener">Concept Net</a>：NLP 最大的知識圖譜之一，可以查找沒些詞的同義詞、反義詞、常用詞組等等。該知識圖譜通過計算語言學建立，而非人工標註。</li><li><a href="http://wordnetweb.princeton.edu/perl/webwn" target="_blank" rel="noopener">WordNet</a>：NLP 的重要知識圖譜之一，用來搜索不同詞的各種不同的意象。</li><li><a href="https://demo.allennlp.org/reading-comprehension" target="_blank" rel="noopener">AllenNLP demo</a>：AllenNLP 的一些模型的線上調用，方便查看一些句子的 dependency tree 以及其他。</li><li><a href="https://storage.googleapis.com/chimera-painter/index.html" target="_blank" rel="noopener">Chimera Painter</a>：谷歌使用神經對抗網絡，生成2D或者3D的怪物圖像。（需要梯子。）</li><li><a href="https://deepmoji.mit.edu" target="_blank" rel="noopener">Deep Emoji</a>：一個將文字映射到Emoji的Demo網站。</li><li><a href="https://ai-art.tokyo/en/?ref=appinn" target="_blank" rel="noopener">AI Art</a>：將肖像或者風景藝術化的網站（效果奇佳）。</li><li><a href="https://thispersondoesnotexist.com" target="_blank" rel="noopener">this person does not exist</a>：通過 GAN 網絡生成的世界上不存在的人物的頭像，看起來很逼真。每一次刷新會生成一張新的圖。（擔心隱私泄漏的場合，可以使用上面的圖片代替真人照。）</li></ol><h3 id="奇怪內容"><a href="#奇怪內容" class="headerlink" title="奇怪內容"></a>奇怪內容</h3><ol><li><a href="https://www.casebook.org/intro.html" target="_blank" rel="noopener">CaseBook</a>：一個 Jack the Ripper 相關諮詢的款熱愛好者搭建的網站，內含關於這個事件的相當細節的信息。</li><li><a href="https://lab.magiconch.com/nbnhhsh/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">能不能好好說話？</a>：將現在網絡語言的奇怪縮寫翻譯回正常普通話的網站。對於「xmsl」這些詞彙搞不清楚的，可以在這裡搜一搜，老年人日常學習資源。</li><li><a href="https://nbviewer.jupyter.org" target="_blank" rel="noopener">nbviewer</a>：可以把 GitHub 中的 pdf 文件之類的放進這個網頁，獲得一個新的鏈接。通過該鏈接，可以直接在瀏覽器中打開該 pdf，而避免下載。適合用來放置 CV 等線上資源。</li><li><a href="http://intrologic.stanford.edu/applications/herbrand.html" target="_blank" rel="noopener">Introduction to Logic</a>：奇怪的邏輯學輔助工具。反正我用不來。</li><li><a href="https://www.typingclub.com/" target="_blank" rel="noopener">EdClub</a>：通過遊戲的方式學習正確的打字姿勢。類似闖關遊戲的思路，不斷地學習更正確地使用鍵盤。</li><li><a href="https://femurdesign.com/theremin/" target="_blank" rel="noopener">Theremin</a>：模擬特雷門琴的聲音，在觸屏設備上尤其好玩。此外，可以嘗試不同音階系統的鋼琴。</li><li><a href="https://www.futureme.org" target="_blank" rel="noopener">futureme</a>：給未來的自己寫信。非常簡單。</li><li><a href="https://app.ww.calm.com/" target="_blank" rel="noopener">Calm</a>：白噪聲網站。大部分功能收費，但是簡單的自然環境音仍可以使用。</li><li><a href="http://lotrproject.com/map/#zoom=3&amp;lat=-1684.5&amp;lon=1500&amp;layers=BTTTTTTTT" target="_blank" rel="noopener">Map of Middle Earth</a>：魔戒地圖。</li></ol><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><ol><li>新增三個【奇怪內容】。</li><li>新增【書籍】，【工具類】，【奇怪內容】各一項。將AI相關網站獨立。</li></ol><h2 id="鳴謝"><a href="#鳴謝" class="headerlink" title="鳴謝"></a>鳴謝</h2><ol><li>感謝 Nof 提供【工具類】*1，【資源類】*2，【奇怪內容類】*1。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安利 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题更新Ver 1.0</title>
      <link href="/2020/10/17/tech/Hexo/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0Ver%201.0/"/>
      <url>/2020/10/17/tech/Hexo/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0Ver%201.0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本 Post 用以记录 Ver1.0 涉及的更新内容及其方法：</p><ol><li>增加并修改 Title 图标及颜色。</li><li>新增更新时间及排序方法。</li></ol><p><strong>注意</strong>：该方法对应的文件类型为<code>scss</code>/<code>css</code>/<code>pug</code>/<code>js</code>。可能和以<code>ejs</code>为主的主题存在些微区别，但方法大致相同。</p><a id="more"></a>  <h2 id="增加并修改Title图标及颜色"><a href="#增加并修改Title图标及颜色" class="headerlink" title="增加并修改Title图标及颜色"></a>增加并修改Title图标及颜色</h2><p>首先找到 theme 对应的 style 文件。在本主题中，该文件路径为：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="symbol">\t</span>hemes<span class="symbol">\m</span>aupassant<span class="symbol">\s</span>ource<span class="symbol">\c</span>ss<span class="symbol">\s</span>tyle.scss</span><br></pre></td></tr></table></figure><p>在其中找到 title 对应的部分。这个工作可能不是那么容易，需要先进入<code>index</code>（在我这里是<code>index.pug</code>）文件查看。那么我们同时打开<code>idnex.pug</code>文件。这个文件路径为：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="symbol">\t</span>hemes<span class="symbol">\m</span>aupassant<span class="symbol">\l</span>ayout<span class="symbol">\i</span>ndex.pug</span><br></pre></td></tr></table></figure><p>在其中找到关于 Post 和 Post-title 对应的代码往下找就行了。在我的主题中，这部分文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.post-meta&#x3D;post.date.format(config.date_format)</span><br><span class="line">    if post.categories.length &gt; 0</span><br><span class="line">        span&#x3D; &#39; | &#39;</span><br><span class="line">            span.category</span><br><span class="line">                for category in post.categories.toArray()</span><br><span class="line">                    a(href&#x3D;url_for(category.path))&#x3D; category.name</span><br></pre></td></tr></table></figure><p>从这里得知 style 文件中的应该修改的是在<code>.post-meta</code>这里，对其进行修改、增加风格就可以了。比如对于显示阅读时间的部分，是按如下方式修改的，这只是一个咖啡的图标而已。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.time</span> &#123;</span><br><span class="line">            &amp;<span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">                <span class="attribute">color</span>: <span class="number">#9c786c</span>;</span><br><span class="line">                <span class="attribute">font-family</span>: <span class="string">"FontAwesome"</span>;</span><br><span class="line">                <span class="attribute">content</span>: <span class="string">"\f0f4"</span>;</span><br><span class="line">                <span class="attribute">padding-right</span>: <span class="number">0.3em</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里的修改相当地繁琐，故不一一列举，方法都是一样的。</p><h2 id="增加Update时间及按照该时间排序"><a href="#增加Update时间及按照该时间排序" class="headerlink" title="增加Update时间及按照该时间排序"></a>增加Update时间及按照该时间排序</h2><p><code>updated</code>是 Hexo 默认的关键字，可以如同<code>date</code>关键字一样，转化为符合时间格式的特殊数据结构，因而可以用以比较时间。所以为了增加 update 时间，在每一个文件的 title setting 的部分加上一个<code>updated</code>字样即可。</p><p>但是只是这样做是不可以排序的，使用 Config 文件中的<code>order by:</code>也无法达到希望的效果。所以这里借助 top 插件的代码。找到文件<code>generator.js</code>。该文件位置在：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules\hexo-generator-index-pin-top\<span class="class"><span class="keyword">lib</span>\</span></span><br></pre></td></tr></table></figure><p>将这个文件中用来比较的 date 均改为 updated，即可。</p><p>对于后面风格化的设置，参见上一小节的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo主题更新记录</title>
      <link href="/2020/10/16/tech/Hexo/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0/"/>
      <url>/2020/10/16/tech/Hexo/Hexo%E4%B8%BB%E9%A2%98%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Hexo 主题更新记录。本页面用以记录 Blog 主题的累积更新。</p><a id="more"></a>  <h2 id="Ver-0-0"><a href="#Ver-0-0" class="headerlink" title="Ver 0.0"></a>Ver 0.0</h2><p>从<a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">maupassant</a>主题开始。</p><blockquote><p>Maupassant最初是由Cho大神为Typecho平台设计开发的一套响应式模板，体积只有20KB，在各种尺寸的设备上表现出色。由于其简洁大气的风格受到许多用户喜爱，目前也已经被移植到了多个平台上，例如：</p><p>Typecho：<a href="https://github.com/pagecho/maupassant/" target="_blank" rel="noopener">https://github.com/pagecho/maupassant/</a><br>Octopress：<a href="https://github.com/pagecho/mewpassant/" target="_blank" rel="noopener">https://github.com/pagecho/mewpassant/</a><br>Farbox：<a href="https://github.com/pagecho/Maupassant-farbox/" target="_blank" rel="noopener">https://github.com/pagecho/Maupassant-farbox/</a><br>Wordpress：<a href="https://github.com/iMuFeng/maupassant/" target="_blank" rel="noopener">https://github.com/iMuFeng/maupassant/</a><br>Ghost: <a href="https://github.com/LjxPrime/maupassant/" target="_blank" rel="noopener">https://github.com/LjxPrime/maupassant/</a></p></blockquote><h2 id="Ver-1-0"><a href="#Ver-1-0" class="headerlink" title="Ver 1.0"></a>Ver 1.0</h2><p>更新时间：2020-10-16</p><p>更新内容：</p><ol><li>新增<code>Pinned</code>图标及字符，至 Title 栏。</li><li>新增项：<strong>更新时间</strong>及<strong>更新次数</strong>。文章会根据更新时间排序。<ol><li>在 Index 页，若有更新，则显示更新时间及其更新次数，反之显示创建时间。</li><li>在文章内容页，默认显示所有。</li><li>该功能尚有一定缺陷。即，不能使用默认的 Title setting 中的 date 代替 updated 标签。需要手动建立 updated 项。</li></ol></li><li>调整了 Title 栏图标颜色。</li><li>增大了文章标题大小。</li><li>调整了 Title 和正文、文章与文章之间的距离。</li><li>Index 页面文章间增加横线。</li><li>开启 Categories 计数。</li><li>在顶栏增加 Tags 栏。</li><li>调整 Index 界面显示的文章数目；取消 Archive 界面的分页。</li></ol><h2 id="Ver-1-1"><a href="#Ver-1-1" class="headerlink" title="Ver 1.1"></a>Ver 1.1</h2><p>更新时间：2020-10-20</p><p>更新内容：</p><ol><li>Navigator 的顺序修正，使其支持跳转到依据更新的时间的上一篇或者下一篇。<ol><li>修改方法：找到<code>node_modules/hexo/lib/plugins/generator/post.js</code>，将第四行改为“updated”即可。</li></ol></li></ol><h2 id="Ver-1-2"><a href="#Ver-1-2" class="headerlink" title="Ver 1.2"></a>Ver 1.2</h2><p>更新时间：2020-11-20</p><p>更新内容：</p><ol><li>原【Collection】板块易名为【Bookmark】。</li><li>原【Timeline】的icon修改。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动检测Typo</title>
      <link href="/2020/10/15/tech/Hexo/%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8BTypo/"/>
      <url>/2020/10/15/tech/Hexo/%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8BTypo/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Typo 是一个相当烦人的东西（实际上只是自己懒得多次检查 Typo，有的时候就算发现了也会懒得改。）。所以打算自己找一个可以自动检查 Typo 的脚本。我本来以为这是一个技术上成熟的东西，然而并没有。勉勉强强在 GitHub 里找到了一个对付 Typo 的 Repo：<a href="https://github.com/shibing624/pycorrector" target="_blank" rel="noopener">PyCorrector</a>。这个工具是为了中文设计的，是否能对英文使用暂时存疑。</p><a id="more"></a>  <p>我这里暂时不打算多费口舌讨论它的原理，以及是否有更好的竞品之类的问题。（我相信现在的中文 NLP 水平肯定不止如此。）若希望寻求技术细节，请进入上述的链接。直接进入使用环节。</p><h2 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h2><p>这个工具首先需要通过 Pip 安装下述 Package：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install https:<span class="regexp">//gi</span>thub.com<span class="regexp">/kpu/</span>kenlm<span class="regexp">/archive/m</span>aster.zip</span><br><span class="line">pip install pycorrector</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：上述两个步骤请不要颠倒，否则可能会出现依赖问题。</p><p>这样就完成了安装。这里粘贴该包的使用的 Demo：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pycorrector</span><br><span class="line">corrected_sent, detail = pycorrector.correct(<span class="string">'少先队员因该为老人让坐'</span>)</span><br><span class="line">print(corrected_sent, detail)</span><br></pre></td></tr></table></figure><p>它会返回纠正过的句子以及哪些部分是需要纠正的。但是它这个工具的准确率实在不行，这个纠正句子基本是不能信的。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>但是上面只是获得了环境，为了更好地使用，不得不写了一个新的脚本。由于这个工具的准确率实在不行，而且速度也并不快，所以为了避免每一次对所有文件的搜索，系统维持了一个名为<code>checked.json</code>的文件，里面存有已经检查过的所有文件。如果你希望重新检查该文件，则从该文件中移除对应的名字即可。此外，每一次检查回将错误信息记录在一个名为<code>log.txt</code>的文件中。这两个文件都会储存在 Hexo 最外层的文件夹中。</p><p>每一次运行该程序都会覆盖<code>log.txt</code>，并且将每一次检查过的新文件加入<code>checked.json</code>文件。具体代码附在该链接中：<a href="https://josep-h.gitee.io/code/analysis.py">Link</a>，请自行下载。该文件中的地址可能需要微调。我将其放在 Hexo 根目录的名为<code>update</code>的子文件夹中。</p><p>最后可以将其加入 update 脚本中，这样每一次更新可以获得新的 log 文件查看是否有 Typo。最后再吐槽一句，它的准确率不行(它甚至使用的还是结巴分词……)。如果各位发现了更好的工具，敬请告知。</p><p>最后三点注意：</p><ol><li>第一次由于所有文件都没有检查过，所以会非常缓慢。请耐心等待。</li><li>该脚本刚开始运行时，会导致系统一点小卡顿，这是加载大型语言模型产生的正常情况，不用慌张。</li><li>如果在写作某篇文章时不希望加上自动 Typo 修正的功能，可以在该篇文章最开始的设定中添加一行：<code>typo: false</code>。该功能我写了，但是没有单独测试。若有问题我之后再改吧。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『Monster』觀感（上）</title>
      <link href="/2020/10/12/essay/%E8%A7%82%E6%84%9F/Monster/"/>
      <url>/2020/10/12/essay/%E8%A7%82%E6%84%9F/Monster/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-zdAYfDwc" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="28844056" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="評價：★★★★★"><a href="#評價：★★★★★" class="headerlink" title="評價：★★★★★"></a>評價：★★★★★</h3><p>　　於我而言，這是一部非常獨特的作品。在我有限的觀看過的作品中，本部作品算不上天衣無縫，有很多不可迴避的硬傷（甚至是劇情上的），但並不妨礙這部作品仍在值得推薦的清單中。本來這部作品是打算好好整理之後再完成這篇評價，但是又覺得這部作品中後期帶來的感覺會隨着時間流逝慢慢散掉，所以在此之前抓住這個感覺，先記下來吧。由於內容太長，爲避免過於影響觀感，考慮分爲上下兩篇。上篇是對於 Monster 的批評以及劇情上的討論；下篇會把注意力放在人物和主題刻畫上。</p><p>　　<strong>注意</strong>：本篇內容分爲概述和對劇情討論兩部分。由於提前得知劇情會對觀感又非常大的影響，在概述中我將盡力避免過於直白的劇透；但是請未觀看過該部作品的讀者一定不要進入後續劇情章節，除非各位覺得劇透並不是那麼嚴重的問題。此外，本文作者沒有經過任何仔細研究，本文內容請視爲完全主觀甚至胡說八道的。</p><a id="more"></a><h2 id="總體感受"><a href="#總體感受" class="headerlink" title="總體感受"></a>總體感受</h2><p>　　本部在一個很「黑暗」的氛圍下，用一種使人感到不太愉悅的敘述方式引導主線前進。故事本身並不太新穎，是帶有某種恐怖色彩的偵探抓罪犯的故事，混合着公路片的些許風格。在這個過程中又插入了不少的小插曲，小插曲設計算不上精妙，有些部分甚至有些拖沓和套路。以及和動漫這種呈現形式非常不相稱的惡意和壓抑（相較於大多數作品而言都是。）</p><p>　　最草率的概括可以把故事區分爲三個階段：陰謀的展開；雙方拉鋸；結局。陰謀展開和結局屬於正常的節奏（相較於長篇而言），而在雙方拉鋸則保持着一種詭異的節奏，有一種反覆前功盡棄的挫敗感。這段大概在 30 集左右，加上本部作品各種敘述上的些微問題及特色，基本能勸退大多數觀衆。</p><p>　　但是在這諸多指責之後，我仍然會選擇推薦這部作品。這絕對不是一部用來找樂子消遣的作品；但也不是將立意擺得高大上的作品——至少作品沒有給出一個核心的要旨。作品的態度僅是講一個故事而已，而且我得承認這部作品講故事的方法很高明。</p><p>　　這也絕對不是主流的作品，在中長篇動漫中，主題的選擇更屬於特立獨行的類別。相較於一些熱門的作品來說，能找到的議論這部作品的文段更是少之又少。其中不乏評論認爲，這部屬於「黑深殘」作品或者「故作深沉」。對於這些意見，個人持中立態度。我看見的是一個講故事的野心和這個故事張牙舞爪的鮮明姿態。至於它是否「黑深殘」還是什麼，還是交給諸位讀者評判吧。同樣，也有不少評價說，這是一部講述「人性」的作品。「人性」這種評價實在隔靴搔癢，故本人對這個觀點也持中立態度，還請諸位觀衆自行評判。</p><p><strong>小批評</strong></p><p>　　此外，即使未觀看過該作品，我也希望提前做一個小批評，作爲一個預警，以便更容易接受該作品或者考慮是否直接放棄。該部作品敘事節奏略微拖沓。Monster 的主線劇情展開是順利且乾淨利落的。線索與線索聯繫緊密，基本沒有斷節。甚至大多數時候，是先陳述某人物通過某線索找到了下一個目的地之後才開始補充這些線索的由來。這讓故事整體的節奏自然靈活，有一種壓迫感。</p><p>　　所以我希望指責的拖沓並不是指故事主線的推進，也不是對插曲、倒敘類似部分的指責，而是細節的節奏問題。這部作品擅長放大細節，例如人物的眼神變化、光影的變化等等，不能否認這樣的敘述手段讓更幽暗的環境變得更加瘮人，然而這樣的處理並不總是得體，在某些時候會營造出一種錯誤的觀感，讓劇情內短暫的時間（如十多秒的對峙）被錯誤地渲染，讓一些本來應該緊張的瞬間變得緩慢、鬆弛，緊張感盡失。</p><hr><p><strong>注意</strong>：後部分涉及大量劇透，請未看過該作品的讀者三思後繼續。</p><hr><h2 id="其他指責"><a href="#其他指責" class="headerlink" title="其他指責"></a>其他指責</h2><p>　　上述對這部作品的節奏問題做了一個批評，之後需要先陳述更多的批評。由於後續內容和劇情緊密相關，故移入分割線之後。</p><h3 id="劇情邏輯問題"><a href="#劇情邏輯問題" class="headerlink" title="劇情邏輯問題"></a>劇情邏輯問題</h3><p>　　本部作品劇情存在諸多不合理之處。由於該作品經常使用倒敘的方法——讓一部分事實在故事的後期突然出現，使得一部分不太符合邏輯的內容被習慣性地忽視。這些問題本身是致命的（然而後面我會試圖迴避掉這個嚴重的問題），它們的存在讓故事的推進存在着牽強和不合理之處。最爲不合理的部分集中在約翰和羅伯特上。</p><ul><li>約翰</li></ul><p>　　約翰作爲本作的核心人物，他的個人能力被無限地放大了。其中最費解的是艾斯勒醫院殺人案中，院長三人是如何被約翰殺死的。在這個時刻，約翰處於半昏迷狀態，並完全沒有行動能力，他如何獲得毒藥以及如何預料到院長會吃他的房間的糖果諸多問題都是難以解釋的。</p><p>　　其次是約翰的強大洗腦能力。法蘭茲.撥納帕達的洗腦能力來自於他的心理學知識，以及長期的洗腦教育；而約翰的洗腦能力卻仿佛只需要幾句話就可以完成，甚至讓對方死心塌地。姑且不論那些思想脆弱的殺人犯這樣本來就不安定的因素，劇情中展示了不少次約翰洗腦普通人（或者說生活不那麼順利的人）的過程，總之還是有些費解的，這是些微牽強的設定。</p><p>　　以及約翰的存在感問題。約翰先後換過多次養父母，而這些養父母均在收養約翰不久後被殺害。這一系列事件由於極高的相似性被聯繫在了一起，卻從未有官方人員發現了這個被收養的兒子的事實（即使警官已經發現了這些夫婦都沒有子嗣這個特徵），這並不是合理的現象，只能說是爲劇情服務了。</p><p>　　但約翰相關的劇情邏輯的問題並未那麼嚴重——我們可以將約翰自身視作作品中一個超凡的存在，他的存在是不現實的，而帶有「神」的色彩的。這一系列的不合邏輯，是來自於約翰自身的神性。這和所謂的「主角光環」並不相同。這個作品存在這樣一個預設：「只有怪物才能做到。」於是他做到了。作爲一部動漫作品，我們可以接受出現超自然的誇張的設定，約翰的存在正是如此。</p><ul><li>羅伯特</li></ul><p>　　而另一個難以解釋的角色是羅伯特。羅伯特最大的疑點在於，他如何接近的博德曼律師的。博德曼律師作爲律師界的新星，其合伙人毫無疑問也應該是律師界的大名鼎鼎人物。然而羅伯特在富翁休伯特的案件中被天馬用槍射傷至天馬被捕間約莫一年時間，羅伯特如何獲得這樣的地位並且成爲博德曼律師合伙人的？只能說是另一個費解的問題了。</p><p>　　然而這些不正常的推進，並未影響故事的邏輯主鏈。律師由另一個聽命於約翰的角色頂替也是完全可以的。只能說是作者希望讓故事裡的每個角色有自己的結局吧，就像沒有看到最後的風景的羅伯特那樣。</p><h3 id="不合時宜的BGM"><a href="#不合時宜的BGM" class="headerlink" title="不合時宜的BGM"></a>不合時宜的BGM</h3><p>　　在大多數時候，BGM 都是一部作品的加分項，然而卻不是這部作品的。這部作品的 BGM 並不合適。大多數時候，它的 BGM 都處於若有若無的狀態，這基本符合了 Monster 整體的灰暗畫風。即使完全沒有 BGM，我也不會因此指責。但是很遺憾的，在衆多的 BGM 中混入了一些違和的，過分歡快的音樂。這些音樂出戲到甚至讓我認爲我正在觀看一部別的作品。</p><p>　　這不是指這部作品不能使用歡快的音樂，但在這部作品的任何時刻，都沒有存在純粹的快樂。更多時候仿佛是死亡才能帶來慰藉，而活着的愉悅着的人都遭受着或曾遭受了非人的命運。例如在妮娜和迪特在一起閒逛的時候，這兩個滿身瘡痍的人，互相安慰（並都擔心着天馬）；因爲在這短短的閒暇里獲得了快樂，而使用一個非常歡快的背景音樂，這是非常不合適的。</p><p>　　此外其他的 BGM 並未給我留下非常深刻的印象，比較平庸，或者說這是一部不太需要 BGM 的作品：只要 BGM 不發揮太差，就都可有可無。很遺憾它沒有達到及格線。後面是本部作品中鮮有的兩首配得優秀的作品。</p>    <div id="aplayer-atGPCrSD" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="461404" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div>    <div id="aplayer-tIYEhZgg" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="461406" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="不必要的展開"><a href="#不必要的展開" class="headerlink" title="不必要的展開"></a>不必要的展開</h3><p>　　儘管前面對敘事節奏做了一個批評，但並不是批評的全貌。節奏的失衡不僅僅來自於那種特殊的敘事風格，也在一些展開上有所體現。Monster 塑造了很多生動的人物，或喜或悲的人物有很多，但是是否所有的人物都需要展開？Monster 中出現的人物（尤其是前期）基本上都獲得了自己的一個小歸宿。而這些人物的出現，有的與主線有密切聯繫，而有的只是剛好和「主題」有輕微的呼應。以妮娜的經歷爲例，妮娜打工的咖啡廳老闆羅素先生，身份是一個殺人犯。但問題在於爲什麼需要將妮娜所在的餐廳設計成一個殺人犯，而不是一個普通人？關鍵在於羅素那句「砂糖的味道」。如果這句話沒有出現，那麼這一段背景設定的意義就不存在了。</p><p>　　但相反的，舒克警官出現則是意義不明。作品在舒克警官的登場及遭遇上花費了大功夫，他也很好地起到了一個「工具人」的作用串起了這個案件，但是只是造出了一個和天馬被陷害案相仿的結構，舒克警官自身是沒有立起來的角色，對於故事發展的作用也非常有限。和舒克形象類似的有博德曼律師——博德曼律師大可不這樣費筆墨給出一個背景。</p><p>　　爲了更直觀地表達上述批評的含義，我舉出派特羅夫院長事件作爲對應的例子。私以爲派特羅夫院長和「寶寶」是處理得相當出色的兩次展開，其有血有肉及其登場和退場的方式較舒克和博德曼都是更加自然合理的。　　</p><p>　　當然這個挑剔未免苛刻了點。作爲一個如此宏大的案件，如果牽扯的人物太少反而是一個奇怪的點。（甚至本文出現的衆多巧合，比如葛利馬和羅伯特曾是好友這樣的設定已經有些過於刻意了。）但是這些人物如何登場、如何退場、如何在後續中發揮自己的作用，都是值得費心的事情。私以爲 Monster 並沒有把這一點處理得非常好，使得節奏拖沓問題更加嚴重。</p><hr><p>　　好像前面各種指責，把這部作品批得體無完膚。但並不如此，這部作品具有的特點是那麼獨特，讓我完全可以忽視前面的諸多問題將其納入我的推薦。正如前文所言，其劇情設計、人物設計、敘事手段設計都是獨樹一幟的。我將試圖討論一下這幾個點，之後進入最爲複雜的主題篇章。</p><h2 id="關於劇情"><a href="#關於劇情" class="headerlink" title="關於劇情"></a>關於劇情</h2><h3 id="時間表"><a href="#時間表" class="headerlink" title="時間表"></a>時間表</h3><p>　　以下表格部分根據回憶重現部分劇情，肯定存在錯誤之處。標註黑體爲重要事件。其中，短期支線劇情均省略。</p><div class="table-container"><table><thead><tr><th>標記</th><th>事件概述</th><th>線索</th></tr></thead><tbody><tr><td>暗線</td><td>1950 年代，小鎮屠殺慘劇</td><td></td></tr><tr><td><strong>波納伯塔</strong></td><td>1960 年代，波納伯塔入住紅玫瑰宅邸，舉辦朗讀會</td><td></td></tr><tr><td><strong>511</strong></td><td>1960 年代，511 幼兒之家</td><td></td></tr><tr><td>葛利馬</td><td>1961 年，《超人蘇坦納》在西德開播，持續兩年</td><td></td></tr><tr><td>博德曼</td><td>1968 年，休特芬·博德曼以通敵之罪被捕</td><td></td></tr><tr><td>查培克</td><td>1969，查培克與科拉休會面</td><td></td></tr><tr><td><strong>安娜&amp;休伯特</strong></td><td>1970 年，馬爾戈特·蘭卡與安娜非法越境德國，安娜越境失敗</td><td></td></tr><tr><td>博德曼</td><td>1971、1972 年，博德曼夫婦相繼離世</td><td></td></tr><tr><td><strong>安娜</strong></td><td>1974 年，安娜前往布拉格旅遊，與軍人結婚後爲躲避優育計劃私奔。軍人被捕後殺害</td><td></td></tr><tr><td><strong>安娜&amp;波納伯塔</strong></td><td>1975 年，雙胞胎出生</td><td></td></tr><tr><td><strong>安娜&amp;休伯特</strong></td><td>1976 年，蘭卡寫信給安娜：「三隻青蛙」</td><td></td></tr><tr><td>休伯特</td><td>1977 年，漢斯格魯古·休伯特與蘭卡分別，卡爾出生</td><td></td></tr><tr><td>查培克</td><td>1979 年，米朗·科拉休出逃</td><td></td></tr><tr><td>安娜&amp;休伯特</td><td>1980 年，休伯特前往三隻青蛙，遇到安娜和雙胞胎</td><td></td></tr><tr><td><strong>波納伯塔&amp;妮娜&amp;查培克</strong></td><td>1981 年，雙胞胎之女被查培克和波納帕達帶入紅玫瑰</td><td></td></tr><tr><td><strong>波納伯塔&amp;雙胞胎</strong></td><td>波納帕達策劃紅玫瑰屋慘案。三隻青蛙失火</td><td></td></tr><tr><td><strong>波納伯塔</strong></td><td>波納帕達從捷克到西德</td><td></td></tr><tr><td><strong>約翰&amp;沃爾夫&amp;511</strong></td><td>1984 年，沃爾夫將軍於捷克邊境發現雙胞胎並帶回，並將約翰放入 511</td><td></td></tr><tr><td><strong>511</strong></td><td>1985 年，511 起火案</td><td></td></tr><tr><td><strong>約翰&amp;天馬</strong></td><td>1986 年，李貝特夫婦謀殺案</td><td>故事的起點</td></tr><tr><td><strong>雙胞胎</strong></td><td>雙胞胎居於海德堡佛多拿家，約翰失蹤</td><td>511 之家</td></tr><tr><td>波納伯塔</td><td>1989 年，柏林牆倒塌。波納帕達逃至廬恩海姆，出版《安寧的家》</td><td></td></tr><tr><td>查培克</td><td>彼得·查培克在米朗·科拉休的協助下逃到德國，定居法蘭克福，舉辦朗讀會</td><td></td></tr><tr><td>約翰&amp;休伯特</td><td>1992 年，蘭卡隱退，定居奧芬巴赫</td><td></td></tr><tr><td>約翰&amp;休伯特</td><td>休伯特司機和管家遇害</td><td></td></tr><tr><td>約翰&amp;休伯特</td><td>1993 年，休伯特朋友及競爭對手遇害</td><td></td></tr><tr><td>約翰&amp;休伯特</td><td>1994 年，休伯特會計遇害</td><td></td></tr><tr><td><strong>約翰&amp;天馬</strong></td><td>1995 年，天馬和約翰重遇</td><td>艾娃的目擊</td></tr><tr><td><strong>天馬&amp;約翰&amp;休伯特</strong></td><td>1995 年 5 月，佛多拿夫婦及記者遇害。休伯特園丁遇害</td><td></td></tr><tr><td>休伯特</td><td>1995 年 12 月，蘭卡被殺</td><td></td></tr><tr><td><strong>天馬&amp;查培克</strong></td><td>1996 年 2 月，土耳其街案件</td><td>極右四人（寶寶，查培克現身）</td></tr><tr><td><strong>天馬&amp;約翰&amp;休伯特</strong></td><td>1996 年，慕尼黑，休伯特繼承案</td><td>繪本出現，三隻青蛙，休伯特線結束</td></tr><tr><td>511&amp;天馬</td><td>1996 年，布拉格，511 院長被殺</td><td>511 磁帶，511 線結束</td></tr><tr><td><strong>倫克</strong></td><td>1997 年，布拉格，倫克找到紅玫瑰宅邸</td><td>怪物的情書和安娜的畫像</td></tr><tr><td><strong>天馬</strong></td><td>布拉格，天馬越獄案及艾娃求生案</td><td>休特芬·博德曼之子入場</td></tr><tr><td><strong>查培克&amp;約翰</strong></td><td>艾娃被寶寶和查培克帶至法蘭克福指認約翰</td><td>四人組希特勒計劃</td></tr><tr><td>約翰</td><td>約翰抵達紅玫瑰宅邸，玫瑰宅邸被燒</td><td>46 具白骨</td></tr><tr><td>查培克</td><td>1998 年，法蘭克福連環殺人案，寶寶和查培剋死亡</td><td>查培克線結束</td></tr><tr><td><strong>ALL</strong></td><td>盧恩海姆事件</td><td>波納伯塔線結束</td></tr></tbody></table></div><p>　　以上是結合個人記憶以及參照<a href="https://book.douban.com/review/7459626/" target="_blank" rel="noopener">該鏈接</a>的結果。從一個角度看，上述區分把劇情劃分爲故事開始前和故事開始後兩部分，而整個故事主線是追尋「過去發生了什麼」，或者「怪物是如何誕生的」。所以這個故事是一半在往前推進，另一半在往後推進：一直到故事的結尾，故事的最初推動者才終於現身。所有人的行動是明線，過去發生了什麼是暗線；從另一個角度看，故事的明線是天馬如何追蹤約翰，暗線是約翰如何完成自己的計劃。這條線索是故事的大主線，在這個故事線中，天馬只是故事推動者而非主角；至於天馬線，我們將會將更多注意力放在天馬所承載的主題上，所以劇情部分我們先將其略過不表。</p><p>　　而這條線索核心在於妮娜。妮娜是故事最開始的參與者，妮娜的記憶是走往過去的核心。然而妮娜的記憶被上了幾道鎖：佛多拿，紅玫瑰&amp;查培克，妮娜&amp;波納伯塔。以妮娜爲核心的上述過去的主線順序爲：妮娜被母親放棄，妮娜被波納伯塔抓入紅玫瑰宅邸，波納伯塔放還妮娜，妮娜見到約翰並給約翰講述經歷，妮娜和約翰逃離國境，妮娜被放入 47 號孤兒所，妮娜成爲李貝特養女。其中，被母親放棄的部分，是關於約翰動機的揭示，這是在故事最後的最後才出現的內容；紅玫瑰宅邸由於內心的恐懼不願回憶，在心理醫生多詞幫助下未能成功；和約翰講述經歷的回憶是貫穿全劇的最大的反轉，也是「怪物」誕生的重要契機；逃離國境及其之前的回憶由於李貝特案件而被封鎖。</p><h3 id="幾點補充"><a href="#幾點補充" class="headerlink" title="幾點補充"></a>幾點補充</h3><p><strong>明暗線的連接</strong></p><p>　　關於妮娜的記憶存在一個爭議，主要來自於「妮娜向約翰講述紅玫瑰宅邸」一處。有觀點稱：約翰在接受了妮娜的故事之後，決定自己成爲怪物，將妮娜洗腦忘掉紅玫瑰宅邸事件，然後自我洗腦，讓自己成爲紅玫瑰宅邸事件的親歷者，並代替妮娜成爲怪物。這個觀點個人認爲並不可靠（事實上這裡有諸多的解釋，放在這裡的不是我最開始的解釋，在思考之後認爲目前的解釋更加合理。）</p><blockquote><p>（約翰）內心真正渴望把妹妹的可怕經歷全部承受最後才會以爲那是自己真實的記憶。妮娜也應該是受到了很大的精神創傷所以在講述過程中主客互換，類似希望對面這個傾聽的「自己」才是真正的自己之類的。      ——$S^2$</p></blockquote><p>　　所以約翰在根據自己相信的記憶行動，而這個記憶是屬於妮娜的。這個意義上，正向時間裡，妮娜的明線（尋找自己的記憶）和約翰的暗線是呼應的；約翰在正向時間中的明線是和妮娜過去時間中的暗線呼應的。換句話說，約翰是活在過去的，沒有失去記憶的妮娜。對於這個呼應關係，核心在於「女裝」的約翰。在土耳其街約翰就以女裝的身份出現過，這裡是對這個鏡像的最初提示，和最初的「女裝」約翰對應，一直鏈接到最後章節，母親放棄妮娜，天馬自問<strong>「母親放棄的是誰」</strong>這個問題。請格外留意這個問題，私以爲這是理解約翰線的最爲重要和初始的線索。所以兩組明暗線交織在一起，並借用妮娜回憶的問題不斷反覆，由天馬和倫克發現的物證對應妮娜回憶起的記憶，完整地再現出過去發生的一切。這種敘事結構非常地精巧，讓這種不斷地插敘倒敘的敘事結構也能有序地進展，並且留足了懸念。<br>　<br><strong>OP 與明暗線</strong></p><p>　　說到懸念，不得不提起 Monster 的 OP。這是非常獨特的 OP，甚至一直到中後期之前都無法理解 OP 的含義。OP 中的所有元素，排除掉心驚膽戰、「孤立無援」的天馬，各種元素都是指向的三隻青蛙、紅玫瑰宅邸事件，以及所謂的「最後的風景」。這樣的 OP 是很隱晦的，即使將後面各類事件的關鍵元素湊在一起我們也不能得知含義，這也是敘事結構異曲同工的效果。天馬和倫克發現的物證只能說明當時發生了什麼，例如紅玫瑰宅邸事件的存在性，而不能探尋其動機；而這個動機的部分則存在在妮娜的回憶里。比如那個貫穿始終的斷章取義，「人可以成爲任何東西，但是不能成爲怪物。」相較而言，ED 的信息量不太多，我們就不多琢磨了。</p><p><strong>兩個反轉</strong><br>　　<br>　　以及在紅玫瑰宅邸登場前，出現了一個大 Trick，即 511 幼兒之家。這是一個華麗的障眼法，不僅吸引了觀衆也吸引了天馬的注意力。似乎在 511 幼兒之家故事就到達了一個源頭，然而事後證明這這只是對紅玫瑰宅邸的拙劣模仿。是非常自然且優秀的展開，而 511 幼兒之家的前院長的改過自新也是對應結局的暗示。</p><p>　　關於劇情，最後想要提到的「究竟是誰進入了宅邸」這個大反轉。這個反轉絕對留夠了線索，但是觀衆基本上（或者說我）難以想到。這裡約翰說了一句「夢醒了」，於是立刻毀掉了自己一手建立的黑道銀行，前往盧恩海姆。故事在這裡發生了非常有趣的變化，關於「怪物是誰」的討論也在這裡第一次浮上水面，也是終幕的拉開。</p><p>　　後續關於人物和主題部分，請見本作品劇評（下）</p><h3 id="幾點更新"><a href="#幾點更新" class="headerlink" title="幾點更新"></a>幾點更新</h3><ol><li>爲了方便，將 Anna Liebert 譯爲「妮娜」，而不考慮其本名；約翰同理。Franz Bonaparta 統一譯爲「波納伯塔」，並將該角色的其他名字也用該名字代替。</li><li>附上維基劇集鏈接：<a href="https://en.wikipedia.org/wiki/List_of_Monster_episodes" target="_blank" rel="noopener">List of <em>Monster</em> episodes</a>。</li><li>在思考之後，接受$S^2$對於「關於劇情-幾點補充-明暗線的連接」中妮娜失憶原因的見解，並將原始版本放置在這個位置：關於妮娜的記憶存在一個爭議，主要來自於「妮娜向約翰講述紅玫瑰宅邸」一處。有觀點稱：約翰在接受了妮娜的故事之後，決定自己成爲怪物，將妮娜洗腦忘掉紅玫瑰宅邸事件，然後自我洗腦，讓自己成爲紅玫瑰宅邸事件的親歷者，並代替妮娜成爲怪物。這個觀點個人認爲並不可靠，我更傾向於：妮娜的故事讓約翰自以爲自己是親歷者而變成了怪物（這個觀點的暗示來自於，妮娜講述了幾天幾夜這個故事），妮娜自己出於迴避忘記了紅玫瑰宅邸。但無論如何，妮娜失去了逃離三隻青蛙之前的記憶，而約翰記得哪些事件則是不清楚的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 觀感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo开启RSS</title>
      <link href="/2020/10/11/tech/Hexo/Hexo%E5%BC%80%E5%90%AFRSS/"/>
      <url>/2020/10/11/tech/Hexo/Hexo%E5%BC%80%E5%90%AFRSS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　想了想还是打开 RSS 吧。其实没有什么特别的目的，只是对于一些（我觉得没有）正使用 RSS 的朋友一些方便吧。对于 RSS 感兴趣的，可以点击这个链接：<a href="https://en.wikipedia.org/wiki/RSS" target="_blank" rel="noopener">Link</a>。顺便这里作为一个小小的 Memo，慢慢地记录一些推荐的 RSS 源。</p><a id="more"></a>  <h2 id="关于RSS"><a href="#关于RSS" class="headerlink" title="关于RSS"></a>关于RSS</h2><p>　　这是一个相当有历史感的东西，现在推荐算法之类的东西遍地都是，让这种不太智能、比较僵硬的获取信息的方法显得有点过时（但 Blog 啊什么都是过时的东西了）。但是总有一些信息是希望主动获取的，而这样的信息分布在各种各样的网站，逐个逐个地打开是一件令人烦恼的事情。所以干脆把它们放在一起，这就是 RSS 的初衷。<br>　　然而 RSS 和 Blog 相性并不是很好。Blog 体现着维护这个网站的主人的诸多用心，各种各样的细节都是经过多番考量的结果，是毫无疑问的个人维护的思想的小庄园，通过 RSS 来阅读这些信息未免会失去这片园地的主人希望提供的信息。但无论如何，为了方便还是提供了这样一个链接（因为对于主人来说，打开这个服务并不是困难的事情）。后面也会简单记录一下基于 Hexo 的 Blog 开启 RSS 的方法。<br>　　为了使用 RSS，需要一个 RSS 阅读器和订阅源。<br>　　<strong>关于阅读器</strong>：前段时间，由于某些不太清楚的原因，国内封禁了一批 RSS 阅读器的服务提供者，类似 Feedly 这样的网站，本人原来使用的 Inoreader 并未能幸免。然而最近本人发现 Inoreader 突然恢复了功能，仿佛某个老友突然造访，还是令人高兴。<br>　　<strong>关于订阅源</strong>：订阅源是由各个网站提供的链接，可以用来告诉 RSS 阅读器自己的网站存在了更新。由于 RSS 在国内非常不主流，大多网站也并未提供对应的 RSS 源。搜索有趣的 RSS 源是一件费时间，但是能长时间给人愉悦的工作。本文也希望用该部分内容记录一些优秀的具有 RSS 源的网站。</p><h2 id="RSS源"><a href="#RSS源" class="headerlink" title="RSS源"></a>RSS源</h2><p>本栏欢迎 RSS 用户推荐。</p><ol><li><a href="https://sspai.com/feed" target="_blank" rel="noopener">少数派</a>：挺有趣的科技宅关注点聚集地。</li><li><a href="https://www.theguardian.com/music/classicalmusicandopera/rss" target="_blank" rel="noopener">守护者 - 古典音乐</a>：一些古典音乐的信息。</li><li><a href="http://www.yankodesign.com/feed/" target="_blank" rel="noopener">Yanko Design</a>：设计作品呈现，偶尔能有不错的点子。</li></ol><h2 id="Hexo如何启用RSS"><a href="#Hexo如何启用RSS" class="headerlink" title="Hexo如何启用RSS"></a>Hexo如何启用RSS</h2><p>　　这个工作相当的简单。</p><ul><li>安装 npm 脚本，用以生成富文本 xml 文件。</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-feed</span><br></pre></td></tr></table></figure><ul><li>打开 Hexo 最外层的<code>_config.yml</code>文件，在其中添加下述代码：（请仔细观察，文件中是否已经存在此代码。）</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">    <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="comment">#Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>然后在任何一个位置标记上 RSS 源的链接，类似<code>**/atom.xml</code>这样的链接。例如本站的 RSS 是：<code>https://josep-h.gitee.io/atom.xml</code>。（这个链接可以在每篇文章右边的 Links 的最后一排找到。）</li></ul><p>　　这样就可以通过 RSS 阅读器获取信息了。需要注意的一点是，这样拉取的信息是不完整的，例如文内放置的音乐不会呈现在部分 RSS 阅读器中（这个情况在 Inoreader 中存在。）</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兩隻金烏（上）</title>
      <link href="/2020/10/09/essay/%E4%B8%A4%E5%8F%AA%E9%87%91%E4%B9%8C/"/>
      <url>/2020/10/09/essay/%E4%B8%A4%E5%8F%AA%E9%87%91%E4%B9%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　相傳在盤古開天闢地後不久，天地間仍處在某種混沌，在這漫長的時間中誕生的是一種金色的鳥，它被人們稱爲金烏。</p><p>　　　　——《華嵇紀-卷三》</p><a id="more"></a><h2 id="金烏-（一）"><a href="#金烏-（一）" class="headerlink" title="金烏 （一）"></a>金烏 （一）</h2><p>　　「金烏」是我在鄉下採風的時候，偶然從小鎮裡的一個當鋪的老闆那聽來的事情。他顯然不是很清楚金烏具體是什麼，只是神神叨叨地說這是一種不可靠近的神鳥，通體金色，凡靠近之物均不可逃脫灰飛煙滅的命運。看着他一臉的嚴肅，這毫無疑問勾起了我的好奇心，開始在坊間搜索關於這個「金烏」的故事。我發現這裡的像我這樣的年輕人，大都不太知道這個事情；但老人們或多或少都聽過這個故事。他們對於這個事情的表述沒能更加詳細，只是慢慢得知了所謂「金烏」可能是複數的存在，甚至可能是一個「種族」，如果我們能這樣稱呼。</p><p>　　這樣無謂的搜索持續了約莫兩周的時間，也接近了我採風得到的假期的時間的尾聲。儘管期間一直在這周圍打探「金烏」的故事，但總歸覺得這還是在迷霧裡的一個東西，是一個比傳說更爲難以信任的東西。但我相信所謂傳說皆具有某種源頭，而這個源頭就是我感興趣的東西。抱着最後的期待，我走進了當地的圖書館的古籍區，打算在這裡碰碰運氣。</p><p>　　正當我搜索到一部叫做《華嵇紀》的時候，我突然產生了某種靈感，篤定這本就是我一直在尋找的東西了。我順着他的編號朝着書架上尋去的時候，卻發現這本書不在架上。它被借走了？我很失望地回到檢索處。這些小挫折難以擊敗我這樣折騰的人，於是我開始不依不饒地詢問檢索處的工作人員，連珠炮地詢問着，「這本書現在在哪裡？」，「哪裡有它的副本或者有誰知道這本書情況？」等等的問題。工作人員陷入了某種茫然，慌亂地回答着：「它不在書架上嗎？」，「哦哦，我不清楚它的情況，但我認爲圖書管理員或許知道」。然後我追問道，「那圖書管理員現在在哪呢？」。工作人員便又開始吱吱唔唔了。</p><p>　　儘管工作人員的無用超出了我的想象，但還是給我指出了一個方向，「在那邊有個小梯子，那個梯子一直往上，通向一個小閣樓間。閣樓間裡是我們圖書管理員的辦公室，你去那裡問問。」這是我知道的一切新鮮的信息了。</p><p>　　儘管不懷什麼期待，我還是爬上了這個梯子，見到了一個空空的小房間——裡面空無一人。這是一個非常非常小的房間，四處的裝潢也是嶄新的，仿佛家具是剛剛才被搬放至此，沒有任何沾上的灰塵，這對一個閣樓來說簡直難以置信。這裡擺放的東西也讓我認識到這裡的工作人員很快會回來。於是我暫時離開了圖書館，到了對面的一家麵館，打算隨便吃點什麼。但這裡的人山人海的吃飯場景讓我食慾全無。匆匆吃完，發現現在還沒到圖書館上班的時間，不得不在旁邊的一家小茶館裡面整理這段時間採風的成果。然而由於我過於執着於金烏，自己的工作進展反而是一籌莫展，覺得這次的採風終歸是失敗了。</p><p>　　對自己的工作感到失望之後，我再一次回到了那個閣樓里的小房間。「不，我不知道有這本書。哦，或許說我聽說過，但不詳細了解。」，「不，我不是古籍區的管理員，我是圖書館的管理員。」，「你不該來找我，你應該去三樓的那個總管理部。他們或許會知道。」然後我得知了如何到達圖書館三樓——這實在是非常費勁的一條路。</p><p>　　在我找到他們所指的總管理部的房間時（事實上，我在中間繞了很多很多的路，三樓有非常繁複的辦公室設置，每一次我敲開一扇門，都會有一個鐵板一樣的臉出現告訴我，「對，我們是總管理部，但不我們不負責你希望詢問的內容。不是我們這裡，你應該去檢索處問清楚。」），我第一次感到如釋重負。</p><p>　　「請問，我在找一本叫做《華嵇紀》的古籍，請問你們知道這本書現在在哪裡嗎？檢索處告訴我這本書並沒有被借閱，但……」我試圖組織我的語言。「但它不在這裡對吧？」管理人員看着我。「對，我想……」我注意到他直愣愣地看着我，但還是不得不接下去，「我想知道這本書在哪裡，我想立刻借閱它。對，我想立刻借閱它，我趕時間。」</p><p>　　他看了我好一陣子，好像仔細的考究着我的眼睛和鼻子的位置是否正確一樣最終得到了準確的結果一般，終於開口了。「你的情況我清楚了。你希望立刻借走一本沒有被標註爲借出的書，或者他的副本……」此刻他桌上的電鈴響了，然後他結束了到嘴邊的言論，說了句失陪然後快步離開了辦公室。我窘迫地站在那裡。</p><p>　　大概一刻鐘後，管理人員回到了辦公室，在自己的椅子裡坐下，在文件里一陣翻找之後，「對的，對的。我知道了，我今天早上剛剛收到一份整理的古籍清單。清單顯示你要的那本書，在一樓小梯子通往的閣樓里存放着。不過那本書非常破敗了，你可能看不到它。如果你想看到這本書，你需要找那裡的管理員。」「可是我剛剛從那裡過來」，我小聲抗議。「如果可以」，管理人員看着我，「你能告訴我你找那本書做什麼？我看過那本書，或許還記得什麼。」我感到我露出了一個吃驚的表情。「真的？那太好了，我在找關於『金烏』的事情，請問您知道嗎？」「對，我知道，那個『金烏』。」</p><h2 id="金烏-（二）"><a href="#金烏-（二）" class="headerlink" title="金烏 （二）"></a>金烏 （二）</h2><p>　　「如果我沒記錯的話」，他說了這句話後停了下來，開始在文件堆里翻找着什麼東西，儘管我們都知道他翻找的動作並不會幫助他回答這個問題。「《華嵇紀》裡確實有着關於『金烏』的記錄，但還是不甚詳細。有這麼一句話，『相傳在盤古開天闢地後不久，天地間仍處在某種混沌，在這漫長的時間中誕生的是一種金色的鳥，它被人們稱爲金烏。』我記得很清楚。」</p><p>　　我草草地在筆記本上記下這句話，這基本上是這段時間最爲切實、明確的進步了，但還是，存在於語言這種轉瞬即逝的載體之中，甚至我連自己是否有一部分字沒聽清而理解錯誤都全然不清。就在我這樣思考的時候，聲音在這個房間中的混響也結束了，於是我不得不重複一遍他的話以得到確認。他點了點頭，同時示意自己也不記得更多的細節了。「總之你可以去一樓閣樓拿到那本書，如果一切順利的話，它應該在那裡。」</p><p>　　事情發展至此，我不敢認爲關於「金烏」，我能從這本書里找到更多的細節，於是我點了點頭，對他表示感謝，然後離開了。但我很快意識到，在這個小鎮裡，對金烏感興趣的不止我一個。</p><p>　　在我的上次徒勞的搜索後的兩天的早晨，我所居住的賓館前台告訴我有一位女士曾經給我打過電話，關於「金烏」的事情。我很激動地記下那個電話號碼，向賓館道謝後匆匆忙忙走到外面的電話亭，撥下那個號碼。不一會，我聽到聽筒里傳來一個女性的聲音，「請問您是那天搜索那個『金烏』的先生嗎？」「是的是的，請問女士是？」</p><p>　　我明顯感覺到對方有些許遲疑，但還是立刻答道，「我也是搜索『金烏』的人之一，我在小鎮的圖書館裡和檢索處詢問一本叫做《華嵇紀》的時候，檢索處工作人員告訴我，就在兩天前有位先生也問過這部書的事情，她給了我一個電話，於是我遲疑地打了過來，發現接電話的是賓館的前台……所以……」聽到對方這樣說，我不免失望——這意味着對方知道的信息應該不比我更多。我把我收集到的信息一五一十地告訴了她。「這樣吧，我希望再去一次圖書館。我想自己找到那本古籍看看。」我感到些許無奈，但還是只能回答說，「好，我也打算這樣做來着。不然就明天吧？」然後是一些瑣碎的約定。</p><p>　　第二天，早晨八點半的時候，我在圖書館的門口看見了一位端莊的女性，相當文質彬彬。既然是追蹤「金烏」的人，自然是一個研究傳說或者民俗之類的學者了（除了我這種僅僅出於遊手好閒性質的）。我向她揮了揮手，示意她我就是那個搜索金烏的先生。</p><p>　　「哦，早。」「嗯，早。」套路的見面禮結束後，還是有些許尷尬。「那我們進去吧？」在進去的過程中，我再一次簡單地向她說了一遍自己那天在圖書館裡的糟糕經歷。這一次我有了明確的目的地，那個曾向我背誦過《華嵇紀》內容的管理人員。我直覺地知道這是位某種意義上的「該書籍」的最高管理者。</p><p>　　因爲我已經來過了三層的總管理部，這一次我很快找到了這個地方，見到了上一次的那個管理人員。我示意讓女士先進去說明來意，自己也緊跟着進去了。管理人員的回覆和之前並沒有什麼差異，依然是讓我們去一樓閣樓間找圖書管理員。但我們不依不饒地問了許久，管理人員表示自己在下午會給我們一個回復，關於那本古籍現在在哪裡、是否可借閱這種種問題都會一一告知我們。我們心滿意足地離開了三樓總管理部。</p><p>　　「現在我們去哪裡？去一樓閣樓嗎？說不定能直接看到《華嵇紀》。」我點頭表示同意。不久後我們站在了一樓閣樓間的地板上。這裡的一塵不染等等特點完全如同上次，這一次書籍管理員正坐在我們進門正對的那個辦公桌上。上面的檯燈發出橙黃色的光線，讓整個房間的整潔呈現出了一種奇特的氛圍。「嗯……那個……」站在我身旁的女士打算開口，「我們是來詢問關於《華嵇紀》的事情的。總管理部的人說，這部書現在正在你們這裡，請問我們能看一下嗎？我們只對這本書的一部分感興趣。」「啊，很遺憾！我們並不知道這本書在哪裡，正像我們之前告訴過你們的這樣。這樣的書籍不會經過我們管理員之手，而是直接交給古籍管理員。」「但我們怎麼找到這個古籍管理員？」「這個我也告訴過你們了。」圖書管理員很不悅地看着我們兩個。</p><p>　　很快圖書管理員似乎看出她的態度太強硬，便補上了幾句。大概是說她確實不知道情況，這些書不經由她們之手，我們找到古籍管理員一定能要到這本書云云的話。並且對總管理部管理人員記憶的段落表示不予評論，「我沒看過這本書，它壓根沒到我的手上。」然後又緊接着說，建議我們不要接着找這本書給圖書館帶來麻煩云云的話，又表示那本書沒有什麼價值云云。我們簡單地堆笑應付了一下就離開了。</p><p>　　「我查找了這裡的所有文件，關於那本《華嵇紀》的。」管理人員轉動着他的小轉椅，「記錄這有關它信息的，有且僅有我說的那個關於古籍的清單，除此之外，我找到了一些專家。他們有的肯定地表示我的回憶是精確的，但這本書恐怕已經不容易找到了。它或許作爲重點的保護對象保護起來了。」我們正想追問更多的細節，但管理人員露出某種無可奉告的神情，把我們請出了總管理部。</p><p>　　這個時候我才突然想起，「你是爲什麼需要找到這部書？」這位動人的女士回答道，「我是研究民俗的學者。我在研究中發現在一系列討論宇宙生成的傳說記載中，都提到了一個名爲『金烏』的生物，他們表示，這種生物在傳說中的地位不可動搖。但是在我查找一切關於『金烏』的論證之後，發現他們不可避免地引用了這本名爲《華嵇紀》的古籍。然而我跑遍了大半個都城，都沒找到這部神祕的古籍，我一直追蹤至此，找到了關於它的些許線索終於也在這裡斷掉了。」</p><p>　　她停止了講述看着我，似乎想聽聽我尋找金烏的理由。面對這樣認真的學者，我對自己的畫家身份感到羞愧，也恥於告訴這位博學的女士自己僅僅是處於好奇才這樣大費周折的，於是我尷尬地笑了笑，沒有出聲。</p><h2 id="《華嵇紀-卷三》"><a href="#《華嵇紀-卷三》" class="headerlink" title="《華嵇紀-卷三》"></a>《華嵇紀-卷三》</h2><p>　　相傳在盤古開天闢地後不久，天地間仍處在某種混沌，在這漫長的時間中誕生的是一種金色的鳥，它被人們稱爲金烏。</p><p>　　金烏通體金黃，部分呈現赤紅色，故也名赤金烏。金烏呈現鳥的形態，有寬闊的雙翅，展翅可包攬視線中的全部天空。其全身仿佛被火焰包裹，以致耀眼奪目，人類不可長久直視。觀看過久者眼睛會呈現異變，留下黑癍，之後該人若觀察其餘物體，皆會看見一淡黃色重影，並呈現出金烏的輪廓。</p><p>　　金烏每日自陰影處起飛，連續飛翔一日到陰影處停歇，凡飛過之處，皆一片光明燦爛。傳說，金烏非晨起松枝所掛之露珠不飲，非夜雨後拔起之筍不食。後來，金烏漸漸隱去了蹤跡，聲稱自己看見過金烏的人也明顯變少。爲銘記這種神鳥，世人爲太陽起別名爲金烏。（燈徽氏作。）</p><h2 id="現代的金烏（一）"><a href="#現代的金烏（一）" class="headerlink" title="現代的金烏（一）"></a>現代的金烏（一）</h2><p>　　由於各種尋找的嘗試我都碰了壁，再加上自己的假期也已經在不知不覺中用盡，不得不起了歸意。「這個傳說雖然是從這裡被我發現的，卻不意味着這個傳說只有這裡才有。」我一邊把我這幾日的衣服收進包裹里一邊這樣想。我走到旅館的櫃檯，把這幾日的旅費和伙食費一併結了，突然起意想要給那位女士打一個電話。後來想想還是算了，就借旅館的信紙隨隨便便寫了些告辭的文字，放進了旅館門口的郵筒然後就離開了。</p><p>　　後面回到了自己的寓所，卻總是記掛着那個叫做「金烏」的生物。我嘗試找了不少當地的民俗學家、民族學家，但也只能說是一無所獲。有的民俗學家能說出《華嵇紀》的名字，而其他的則都搖頭表示從未聽聞。經過幾日的折騰，雖然繪製的作品還在緩慢地推進，但心思總不在上面。每次畫上幾筆，便覺得索然無味，想要拿起畫板就砸下去。想着「今天就到這裡吧」，就擲下了筆，接着苦惱「金烏」的事情了。</p><p>　　反覆苦惱了幾日，一日在外出吃飯途中偶然發現散落在地上的報紙。報紙上用那種廉價的紙印着誇張的大號字寫成的誇張的標題。我拾起這個報紙，報紙名爲《日新日報（娛樂版）》。反覆翻了幾次。這個報紙的報社（日新報社）是當地非常有名的一家民營企業，除了專門刊登國際或者全國要聞的核心報紙，還有許多八卦花邊、娛樂活動的周邊報紙。我手上的這份《娛樂版》便是報道娛樂周邊的小報。大標題是某某馬術比賽，哪位哪位和哪匹哪匹又奪冠了。我隨便翻了翻，尋人啓事、招聘崗位、治療腳氣的廣告什麼的，真的是應有盡有。我想了想，帶着報紙回到了畫室，試探性地給報社打了一個電話，問了問刊登小邊角啓事的要求和酬金等等。心裡盤算了一下，便聯繫報社，打算在該報的小角落連續登個一周的廣告。</p><p>　　」先生們好，鄙人系某某畫社畫師，日前打算以本地傳說爲題繪製大型主題作品。但在『金烏』這一主題上缺乏素材。望知情人士將信息材料郵寄給本人，經驗證後將重金回報。「後面是我的地址、聯繫方式種種。帶着這個短訊造訪了報社，將之交給了報社之後，我並不期望能獲得什麼新信息，還是就回到畫室接着開始自己不安穩的創作。</p><p>　　報紙所說的」以本地傳說爲題「這個，其實並不是胡謅的，也的確是我目前正在從事的創作。我本次前去採風也是希望搜集這方面的線索。然而七色鹿、玉蟾蜍此類，比起這神祕的」金烏「都突然間黯然失色，也不怪我看着空白的畫布靈感頓失。看着滿屋子混亂不堪的景象，我才反應過來，我現在還餓着肚子。</p><h2 id="現代的金烏（二）"><a href="#現代的金烏（二）" class="headerlink" title="現代的金烏（二）"></a>現代的金烏（二）</h2><p>　　伸伸懶腰，打算出去溜達一下。我習慣性地走到樓下的收信箱，打開收信箱的蓋子，抖出一大堆信件。裡面多是各地畫展的過時的邀約等等，夾雜着一些通過不正常方式塞進我信箱的糟糕小廣告。我把這些信件摞在一起，在桌上震了震，讓它們看起來規整了一點，便準備扔到最近的垃圾箱裡。</p><p>　　這個時候，一個包裹的有點凸起的信件吸引了我的注意力。這封信件不像那些噴着怪異味道香水的邀請函或者小廣告，只是在信封上寫着收件人的姓名和地址。我把這封信挑了出來揣在了衣兜里，把別的都扔進了垃圾箱，然後開始信步四處溜達。</p><p>　　回到畫室，剛剛坐下準備泡杯熱茶，才想起包里還裝了一封奇怪的來信。我把它從衣兜里掏出來，平展在畫桌上，起身去泡了杯熱茶。</p><p>　　「畫家先生敬啓。」</p><p>　　這恭恭敬敬的樣子，和這種看起來不太精緻的包裝，恐怕是哪裡的窮酸書生吧。我用裁紙刀劃開了信件表面，看見了裡面的東西。是一根不明所以的黑色羽毛和一封有着清秀字體的書信。書信寫得密密麻麻，顯得非常缺少紙張的樣子，但是在這衆多的字跡里，我抓住了這樣一個詞：「金烏」。難道說，這個羽毛……？！我擱下了自己的水杯，迫不及待地抓起這封信，全然不顧這封信究竟是從哪裡來的、爲什麼會寄給我，開始了閱讀。</p><p>　　（事實上，我收到這封信的時候，已經是我在報紙上刊登啓事後的一個多月了。儘管對「金烏」的好奇未減，但是出於養家糊口，我不得不把自己的精力重新集中到自己的傳說主題的畫作上。畫作的進展異常地順利，讓我漸漸忘了我在報紙上登過啓事這門子事——這個事實還是在我讀完這封信件，正意猶未盡的時候突然想起的。）</p><p>　　以下是我收到的信件的原文，我承諾信件的內容沒有經過任何修改，一字一句甚至連一個標點都沒有被擅自動過，除了我隱去了信件寄件人及其朋友的姓名，用張三李四這樣的名字代替了。</p><h2 id="現代的金烏（三）"><a href="#現代的金烏（三）" class="headerlink" title="現代的金烏（三）"></a>現代的金烏（三）</h2><p>畫家先生敬啓，</p><p>　　抱歉貿然給您寄來此信。鄙人深知這已經是您在《日新日報》上刊登徵集信息啓事的三周後了。近日您未繼續在該報紙上刊廣告，鄙人以爲您或已經完成了創作，或因沒有足夠信息而未能繼續創作。（鄙人真誠希望事情正如前者發展。）</p><p>　　正如前文所言，鄙人此番來信，是爲畫家先生提供些許關於「金烏」的信息。您也不需要給什麼回報，如若能助力您作出名畫，鄙人便已心滿意足。</p><p>　　餘下不表，鄙人不止在書中見到的「金烏」一詞，而是自己親眼看過幾次。此事回憶起來，已是三四年前的事情。那時間，鄙人費盡心力準備某書塾的考核，成年累月翻閱經書。然枯燥之至，每過幾日，必得起身，至林木蔥鬱之處放鬆身心。其間某日，艷陽高照，恍惚間，天地昏黑，轟響陣陣；狂風大作，芳草皆俯伏，蓋一大鳥自雲間飛過。鄙人見識短淺，竟一時愣在原地。待大鳥飛過，轟鳴漸消，鄙人方得回神。其勢驚天動地，仿佛書中所述「金烏」，然並非金色，而是通身玄黑。</p><p>　　鄙人深覺驚駭，便連連造訪此地。後又見得幾次大鳥。數次後，鄙人以爲，大鳥於太陽升起後數時後飛起，太陽落下前數時飛回。其與《華嵇紀》中所記相差甚大，其雖聲勢浩大，然無令人頂禮膜拜之氣質，與鄙人所想象神鳥相差甚遠。爾後幾日，鄙人雖仍定期造訪該地，但無緣再見到真身。然而，鄙人對此大鳥乃金烏這一觀點深信不疑。</p><p>　　畫家先生必嗤笑鄙人所見絕非金烏。先生請想，書中所記金烏距今已不知多少時日，其豈能千百年間絲毫不變，從未演進？金烏記述漸少，並非金烏隱其身遁其形，只因其演進變化，肉眼凡胎不能辨識之，而神鳥豈需隱身遁形！且以其遮天蔽日、芳草失色之形態，不做他想。</p><p>　　隨信附有鄙人經過多次探訪在博物館中找到的類似「金烏」羽毛樣式的樣本，但顏色和大小與鄙人所見相差甚遠，僅供您參考。此外在另一個包裹中是鄙人在金烏駛過地點拾到的一小片黑鱗，鄙人猜測此爲金烏的爪上遺落，故也隨信寄送。然黑鱗不能放入此信封，遂將其單獨包裝在另一信封中一同寄送。</p><p>順頌時祺，</p><p>張三</p><h2 id="現代的金烏（四）"><a href="#現代的金烏（四）" class="headerlink" title="現代的金烏（四）"></a>現代的金烏（四）</h2><p>　　我看完這封信不禁啞然失笑——這不是現在時髦的所謂」飛行器「這樣的東西嗎？這終究是個每日讀書讀蠢了的書呆子罷了，出去散步竟然以爲自己見到了什麼不得了的東西。這個所謂金烏羽毛的東西，不就是類似螺旋槳的翼片這樣的東西嗎？實在是有點可笑了。想到這裡，便也覺得自己也是值得笑話的角色。哪裡有金烏這樣的東西呢？居然還在最開始對那根羽毛產生了這樣的無端的猜測。算了吧，讓那」金烏「去吧。我把這個之前備受我期待的信件和那根黑色的羽毛揉在一起，丟到了我的廢紙簍里，想到他提及的」黑鱗「，應該是早早就被我扔到收信箱旁邊的垃圾箱裡了。</p><p>　　抿了口桌上的熱茶，我接着完成我的畫作。<br>　　<br>　　這個事件之後，我對金烏的興趣頓時減了大半；加上工作纏身，又任何搜索金烏的進展都碰了壁，完全沒有任何推進。就算是我這樣遊手好閒的角色，也終於奈何不了這個神祕的傳說，只得作罷。往後我的工作波瀾不驚，金烏也完全從我的生活中淡去。幾個月後我從那個小鎮的圖書館那收到了一封明信片，意思是那邊收進了一批古籍，誠邀熱心讀者前往云云。至於這是怎麼回事我也不知道了。</p><h2 id="屋頂的金烏（一）"><a href="#屋頂的金烏（一）" class="headerlink" title="屋頂的金烏（一）"></a>屋頂的金烏（一）</h2><p>　　像往常一樣，我坐在自己的畫布前。然而我畫室的樣子已經完全不同，我用自己主題展賺到的一點錢，在原來城市的隔壁購置了一個新的畫室：這個畫室臨海，其餘兩面爲山。這裡雖然看起來偏僻，但是去最近的城市還算方便。但由於不在城市裡的緣故，前來拜訪的客人還是少了許多，我也幸得個清閒。爲了這裡的美景，我特意鑿通了一面牆，改造成了大玻璃，這樣能一覽外面的美麗風光，順便也讓畫室看起來寬敞了很多。不知道是因爲周圍環境變化了的緣故還是什麼，一時間靈感如噴泉般湧出，所以我也能全身心地投入在創作中。</p><p>　　在我搬了新家後約莫兩三個月的某日早晨，我還在疊放被子的時候，聽見一陣沉穩有力的敲門聲。這個地方、這個點，不太會有人來的。「畫家先生，」我聽見門外有個渾厚的男聲在喊，「麻煩您開下門。」行吧。「好，這就來。」我把剛要疊好的被子就扔在那，帶上臥室的門，走到了客廳旁的玄關。我打開門，還沒來得及詢問對方是誰就注意到了對方的穿着。</p><p>　　門外站着可能有一米九的壯漢，全身站得筆直，穿着淺藍色的筆挺制服，腰上跨了一個四方形的小包，帶着令人愉悅的笑容。這是民警的制服，雖說談不上熟悉，但還是能一眼認出來。我在那裡愣了一小會，「請進，請進，民警先生。」對方鞠了一小躬表示回應，然後走到了客廳的沙發旁邊。我示意他先坐，然後自己去廚房準備一些紅茶。一會後，我回到客廳。「請問民警先生來鄙人的小畫室做什麼？」我一邊將茶杯遞給他。這位熟練地把杯子接過去，喝了一小口，然後把杯子放了下來，前屈自己的身子看着我，「先生，您知不知道那個叫做『金烏』的盜賊？」</p><h2 id="屋頂的金烏（二）"><a href="#屋頂的金烏（二）" class="headerlink" title="屋頂的金烏（二）"></a>屋頂的金烏（二）</h2><p>　　我迅速回想起了半年前的報紙，當時鋪天蓋地地報道着「金烏」的「光榮事跡」，幾乎這附近的所有博物館都曾被他光顧過，然而每次都能逃脫。我當時也產生了一點小興趣——那已經是我停止調查「金烏」後的一年多了。這個「金烏」之所以被稱爲金烏，是因爲他的每一次偷盜的展品的現場牆壁都會抄錄同一段話，這也就是我曾經記下的《華嵇紀》的那一段對於金烏的表述。儘管莫名奇妙，但這個盜賊還是被民間用「金烏」稱呼。<br>　　<br>　　由於警察一時間的束手無策，加上政府的高額懸賞，當時還掀起了一陣「金烏學「研究的熱潮，希望從這個角度揣摩這個高調的盜賊的意圖。然而線索並沒有比我自己搜尋的時候多出什麼，「金烏學」研究愛好者沒多久就銷聲匿跡了。後面關於」金烏「的報道也日益減少了。我揣摩警察局顧着臉面，把一些」金烏「案件藏了起來，或者塞給了別的連環案件，避免被民衆指責爲無能。我很早就注意到了這個盜賊，並開始了調查。但是如同我搜索那本古籍一般，我完全找不着這個盜賊的線索。這也難怪，若我能找到，警察也就真是吃白飯的了。</p><p>　　回過神來，我注意到了正端詳着我的民警，我這才發現他進屋之後只說了那麼一句話。不過，民警拜訪我做什麼？我一動不動地坐在那裡，觀察着這個民警的動靜；這個民警也一動不動地坐在那裡，觀察我的動靜。茶水慢慢開始不冒出白煙，外面的鳥聲也逐漸停歇了。民警看起來是突然想起了什麼，開始不再繼續對我的觀察，而是翻起了他的小腰包，然後從裡面掏出了裝在塑封袋裡的一張皺巴巴的紙。他用彎曲的食指和拇指夾起這個塑料袋的一角，小心翼翼地把它夾着，移動到了我的面前。</p><p>　　這是有些年頭的一張小紙，大概是 10 裡面長寬左右。它的背面（我認爲是背面，因爲上面什麼也沒寫）一片空白，除了各種經過蹂躪收穫的褶皺以外，還有一個黑色的燙疤。這些褶皺看起來都已經稜角不清，應該是在某一個平整的東西下面壓過了不少的時間才恢復成這樣；黑色的燙疤中間基本已經碳化，周圍輻射出棕色的燒痕。我想警察點點頭，示意我看得差不多了，此時警察非常緩慢地轉過了一個角度。在旋轉的過程中，我們明顯注意到在紙的另一半寫着一行小字以及一串數字一樣的東西。警察將其旋轉了一百八十度後再一次靜止了下來，他的手臂呈現出一種非常僵硬的角度。我指指面前的桌子，示意其完全可以把它放下來，但他搖搖頭，等着我再接着觀察那張來歷不明的紙片。</p><p>　　紙片的另一面，正如我前文所說，是一串文字和另一串數字。那串數字我再熟悉不過，儘管我現在已經搬到了新的工作室，但那串熟悉的數字曾作爲我與外界重要的聯繫而存在。上面那串文字則記錄着我更加熟悉不過的東西。我將我的視線移開那張紙，疑惑地看着對面的民警。他的手臂由於維持着這個誇張的姿勢而微微顫抖，但是他什麼也沒有說，他熱切地看着我，我只好揣起手，更加仔細地看這張紙片。</p><h2 id="屋頂的金烏（三）"><a href="#屋頂的金烏（三）" class="headerlink" title="屋頂的金烏（三）"></a>屋頂的金烏（三）</h2><p>　　紙片上清清楚楚寫着的，是我原來畫室的詳細地址以及電話號碼。字體是用那種相對粗、並且很不適合書寫這種語言的鋼筆寫成的，可以看到有一些字體的結構已經粘在了一起，但這不會影響這張紙條傳遞的訊息。這張紙的這一面無疑也有一塊燙疤，只不過顏色更淺一點，基本上只是一片棕色。除此之外，我在這張紙上找不到任何的信息。</p><p>　　我解開了揣着的右手，四指指向民警並掌心朝上微弓，示意他可以把這張紙收回去了。他看見我的動作，點了點頭。將他的彆扭的手腕迴轉了一百八十度，保持着大臂和小臂的角度，將紙條放回了腰包，並從中掏出了另一個用檔案袋包着的東西。不過這一次，他很輕鬆地把它放在了我的桌子上，然後再一次坐直，恢復了之前端詳我的姿態。</p><p>　　我拿起檔案袋，看着他打算詢問是否可以拆開。這位民警用我剛才示意他收回的動作朝着我，示意我打開。我逆時針轉着檔案袋上的棉線，但裡面是什麼，我心裡已經有數了。這是一個很輕的檔案袋，裡面可能塞着四五張 A2 大小的紙。揭開了檔案袋的封口之後我抽出了裡面的東西——準確說是還沒有完全抽出，我看見了「日新日報」四個字之後就又塞了回去，順時針將棉線纏好，打算再一次將它放在了桌子上。民警伸出手，在半空中就接過了檔案袋，放回了自己的包里，然後回到了筆直的坐姿。</p><p>　　我看着他，等着他說些什麼，但誰也沒有打算說話。我起身拿起桌上的兩個茶杯，去廚房添了一輪熱水坐了回來。在我回來的時候，沙發上的凹陷尚未完全恢復。我把接好的熱水推到他的面前，扶了扶自己的眼鏡，「那麼，警察先生造訪寒舍，有何貴幹？」。我感覺民警立得不能更加板正的身姿又直了一些，臉上沒有什麼表情，「沒有什麼，想知道您是否知道這位『金烏』？」。我正想回復一些可有可無的套話的時候，對方打斷了我，「這張紙是從『金烏』逃逸的藏身處找到的。」</p><h2 id="屋頂的金烏（四）"><a href="#屋頂的金烏（四）" class="headerlink" title="屋頂的金烏（四）"></a>屋頂的金烏（四）</h2><p>　　果然，這種戲劇性的發展居然落到了我這個過着平平無奇的人的身上。我不知道是該慶幸還是該咒罵幾句——因爲我突然覺得，這是一個能夠接觸到「金烏」的好機會。不過！？我突然覺得哪裡不對勁。我突然想起了數月以前，和我一同造訪圖書館的那位氣質不凡的女士。總不會是她的，我這樣想。於是我打消了我差點吸一口的涼氣，端起眼前的熱水。熱水上的白煙尚且縈繞，彰顯着它的溫暖。字體，我怎麼都不覺得那個字體是……噢，不對我糊塗了，那個是《日新日報》的剪報，並沒有什麼字體的存在。不過那燙疤像是落下的煙頭造成的，這個時候哪裡有女士抽什麼煙啊。</p><p>　　這樣我打定了結論，看着那個正等着我回復的、面無表情的民警，「不，我想我不認識。」這個時候我的熱水回到了桌子上。「不過」，我果然還是想說些什麼，「我對這個事情很有興趣，或許是我遺漏了什麼細節。如果可以的話，我可以參與你們的行動嗎？如果能在現場看見什麼……」「不行。」說着民警就站了起來，「今日打擾了，謝謝您的茶水，我這就告辭。」我還沒來得及說更多話，就看見他三步兩步走到了門口，向我彎了彎腰表示感謝，然後推門出去了，留下一個我還雲裡霧裡地坐在原地。</p><p>　　這個時候，鳥叫便又清晰了起來。我完全不清楚剛才發生了什麼，以及那個名爲「金烏」的盜賊爲什麼要留下那份剪報。我的門鈴響了。我本以爲我會在門口看見那個僵硬的民警，但是在我打開門後，什麼也沒有出現。我注意到了躺在我門前的一方小小的報紙。今天的報紙——看來剛才的是報童吧。也對，可敬的民警先生根本就沒有按門鈴什麼的。我拿着報紙回到了剛才的桌子旁，實現不由自主地被報紙的標題吸引了：「金烏」向警察發出挑戰，10 月 19 日，他將造訪本市博物館，「盜取」世界名畫。這巧了，就是今天吧。</p><p>　　想着自己沒什麼事情干，於是開始整理自己的着裝打算出門先去附近的餐廳隨便吃點什麼，先去博物館裡面逛逛，看看這個「金烏」到底是對什麼東西感興趣。於是我隨便弄了些早餐就出門了。在我關上門的時候，我分明聽見了屋裡的電話傳來的鈴聲。既然我已經關了門，如果是編輯部的催稿啊什麼的，那請儘管過來吧！於是我一搖一擺的往博物館的方向去了。然後我在路上發現了一兩隻正模仿着我動作的鴿子，也在那裡一搖一擺的。我扇了扇手上的報紙，把它們嚇跑了。</p><hr><p>　　<strong>題外話 1</strong>：到目前爲止，《兩隻金烏》一篇的長度已經超過預期了（囉哩吧嗦將近萬字了吧？），將這麼個長文章放在一起未免太挑戰自己的筆力和讀者的耐心了，故在此階截斷，將後面的部分放置《兩隻金烏》（下）或者（中）繼續。</p><p>　　<strong>題外話 2</strong>：這一部分創作實在是預料之外的事情，感覺我已經一定程度地偏離了初衷，但是希望在朝一個還行的方向發展。本小說的實質是不會變化的，只是呈現的結構發生了預期之外的發展而已。是件好事。</p><h2 id="修訂"><a href="#修訂" class="headerlink" title="修訂"></a>修訂</h2><ol><li>經讀者建議，將「現代的金烏（一）」中的「覓食」一詞改爲「吃飯」。</li><li>將「現代的金烏（四）」及「屋頂的金烏（四）」中的「博物館」改爲「圖書館」。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 雜記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode模板</title>
      <link href="/2020/10/03/tech/VSC/VSCode%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/10/03/tech/VSC/VSCode%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Snippets 即快速地插入代码片段的方法。可以通过快捷键或者自动补全生效。这里简单地记叙一下在 VsCode 下使用 Snippets 的方法，以防后日遗忘。</p><a id="more"></a><h3 id="如何配置？"><a href="#如何配置？" class="headerlink" title="如何配置？"></a>如何配置？</h3><p>Snippets 对于不同类别的文件可以使用不同的配置文件。例如对于 Markdown 来说，可以通过选择<code>File -&gt; Preferences -&gt; User Snippets</code>路径进入指令栏，输入 Markdown 进入相应的配置文件。当然也可以通过在命令栏输入<code>preferences: snippets</code>进入。<br>简单的配置文件如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">"newblog": &#123;</span><br><span class="line">"prefix": "nb",</span><br><span class="line">"body": [</span><br><span class="line">"---",</span><br><span class="line">"title: $1 ",</span><br><span class="line">"updated: 2020- $2 13:53:09",</span><br><span class="line">update_ct: 0</span><br><span class="line">"date: 2020- $2 13:53:09",</span><br><span class="line">"layout: page",</span><br><span class="line">"toc: true",</span><br><span class="line">"mathjax: true",</span><br><span class="line">"tags: [ $3 ]",</span><br><span class="line">"categories: [ $&#123;4|随笔, 技巧, 学科|&#125; ]",</span><br><span class="line">"---",</span><br><span class="line"><span class="string">"&lt;!--more--&gt; $0 "</span></span><br><span class="line">],</span><br><span class="line">"description": "create a new blog"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里的<code>prefix</code>便是触发 Snippets 的前置。Body 是主体，其中<code>$0</code>表示光标出现的位置。</p><p><strong>特殊之处</strong></p><ul><li>多光标可以通过<code>$1</code>，<code>$2</code>等表示，其表示先后到达的顺序，可以通过 Tab 键到达下一个光标位置完成修改。</li><li>同时也可以设置<code>${1|A, B|}</code>，获得到达具体位置之后的选项。</li><li>此外可以绑定变量、设置多光标等等，这里暂时用不到故忽略。</li></ul><p>除此之外，我偶然发现了一个可以添加当前时间地点的参数设定的方法，将上面的设定改写为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">"newblog": &#123;</span><br><span class="line">"prefix": "nb",</span><br><span class="line">"body": [</span><br><span class="line">"---",</span><br><span class="line">"title: $TM_FILENAME_BASE ",</span><br><span class="line">"updated: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",</span><br><span class="line">update_ct: 0</span><br><span class="line">"date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",</span><br><span class="line">"toc: true",</span><br><span class="line">"mathjax: true",</span><br><span class="line">"tags: [ $1 ]",</span><br><span class="line">"categories: [ $&#123;2|随笔,技巧,学科,学术|&#125; ]",</span><br><span class="line">"---",</span><br><span class="line"><span class="string">"&lt;!--more--&gt; $0 "</span></span><br><span class="line">],</span><br><span class="line">"description": "create a new blog"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这个修改的版本可以自动读出当前该文件的名字（去除尾缀）作为 Blog 的标题，读出当前的时间。基本上可以完全懒人操作了。更多的设定参考链接 <a href="https://www.clloz.com/programming/assorted/2020/09/14/vscode-snippet/" target="_blank" rel="noopener">如何使用Snippets</a></p><p>以本文为例，获得的结果为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">VSCode模板</span> </span><br><span class="line"><span class="attr">updated:</span> <span class="number">2020</span><span class="number">-10</span><span class="number">-03</span> <span class="number">20</span><span class="string">:13:50</span></span><br><span class="line"><span class="attr">update_ct:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="number">-10</span><span class="number">-03</span> <span class="number">20</span><span class="string">:13:50</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[</span> <span class="string">]</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">[]</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Smart-Suggestion"><a href="#Smart-Suggestion" class="headerlink" title="Smart Suggestion"></a>Smart Suggestion</h3><p>不知为何，Markdown 默认是不支持自动调起 VSCode Suggestion 的。解决方法有 2：</p><ol><li>在 Shortcuts 中找到 <code>Trigger Suggestion</code>，通过快捷键手动调起。</li><li>手动地将该设定添加到<code>settings.json</code>中：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"[markdown]": &#123;</span><br><span class="line">    "editor.quickSuggestions": &#123;</span><br><span class="line">      "other": true,</span><br><span class="line">      "comments": false,</span><br><span class="line">      "strings": false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样就没有遗憾了。该方法参见链接 <a href="https://deepns.github.io/tech/enable-quick-suggestions-for-markdown-in-vscode/" target="_blank" rel="noopener">Enable quick suggestions for Markdown in VS Code</a> 。</p><p>更多详情参见：<a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets" target="_blank" rel="noopener">Vscode官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go常用语法</title>
      <link href="/2020/10/03/tech/Go%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/10/03/tech/Go%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>开始正式学习 Go，参考该网站 <a href="https://tour.golang.org/welcome/5" target="_blank" rel="noopener">link</a>。</p><a id="more"></a>  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 C 语言，Go 程序通过调起各种包(Packages)运行，在 Import 中是调起的其他包的路径。除此之外，Go 默认也是从 main 开始运行，所以 main 函数仍然是不可缺少的。</p><p>为引入这些包，需要这样写</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"main"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Export"><a href="#Export" class="headerlink" title="Export"></a>Export</h3><p>在 Go 中，大写字母开头的值是视为 Exported 的，可以为外界调用，反之则不是。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如在下述的程序中，<code>math.pi</code>就是不可调用的，并得到这样的报错：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./prog.go:<span class="number">9</span>:<span class="number">14</span>: cannot <span class="built_in">ref</span>er to unexported name math.pi</span><br><span class="line">./prog.go:<span class="number">9</span>:<span class="number">14</span>: undefined: math.pi</span><br></pre></td></tr></table></figure><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>函数定义基本和 C 语法相同，但仍存在一些差异：例如他的形参数据类型放置在形参名字后面，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，当连续多个形参使用相同的数据类型时，可以省略除了该序列中最后一个外的所有数据类型声明，例如上面的例子可以重写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义多返回值的函数也是可以的，形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，可以在函数头上声明返回的值的 name，从而在 return 语句时不加强调。然而这种方法并未得到提倡，因为在很长的函数中，似乎可读性并不强。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">y = sum - x</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数应当返回（7,10），即（x,y）对应的值。</p><h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>使用 var 语句声明变量。声明的方法如同函数形参，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">fmt.Println(i, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且参数是可以定义在 package level 的，即上例中的 c, python…除了简单的声明变量，还可以初始化，变量的数据类型和初始化的数据相关。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br><span class="line">c, python, java := <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">"no!"</span></span><br></pre></td></tr></table></figure><p>如果未显式地声明，而仅仅是使用 var 定义，则同时定义不同的数据类型是可以接受的。此外可以使用<code>:=</code>代替这种情况。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">int8</span> <span class="keyword">int16</span> <span class="keyword">int32</span> <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> ...</span><br><span class="line"><span class="keyword">byte</span></span><br><span class="line"><span class="keyword">rune</span> (<span class="keyword">int32</span>)</span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span></span><br></pre></td></tr></table></figure><p>这些数据类型没有初始化时，会被赋给 0 值，如<code>int</code>对应 0,<code>srting</code>对应空字符串。</p><p><strong>类型转换</strong></p><p>类型转换使用<code>a = T(b)</code>完成，如下例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure><p>在 Go 中，类型转换是<strong>必须</strong>显式声明的。</p><p><strong>常量</strong></p><p>常量的声明和普通变量相同，但是需要在开头加上一个 const。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br></pre></td></tr></table></figure><p>需要注意的是，常量不可以使用<code>:=</code>定义。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针的形式和 C 相似，都是通过<code>*T</code>表示。定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> *p <span class="keyword">int</span></span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">p = &amp;i</span><br><span class="line">fmt.Println(*p)</span><br></pre></td></tr></table></figure><p>取地址方法及取值方法也和 C 相同。</p><h3 id="Struct-语句"><a href="#Struct-语句" class="headerlink" title="Struct 语句"></a>Struct 语句</h3><p>声明一个新类型方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">v := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">x := v.X</span><br></pre></td></tr></table></figure><p>struct 中的值可以用<code>.</code>获得。也可以通过指针的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v := Vertex(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p := &amp;v</span><br><span class="line">p.X = <span class="number">1e9</span></span><br></pre></td></tr></table></figure><p>理论上需要通过<code>(*p).X</code>访问 X 值，然而 Go 允许，仅仅使用<code>p.X</code>直接对其进行访问。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">"hello"</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure><p>Go 通过这种方式来定义数组。他的访问和赋值都和 C 相同。Array 的长度是固定的，不可以在运行过程中修改的。在上述例子中存在一个类似 C 的初始化方法，在这个初始化中，尽管声明了 6 个整形的空间，但仅仅给了 5 个初始值，则最后的一个元素会被初始化为 0。</p><p><strong>Slide</strong></p><p>与之相关的是一个特殊的数据结构 Slide：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> = primes[<span class="number">1</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>这个的表现和 C 语言是完全一样的，然而和预期不同的是，这个 Slide 并不储存数据，而是仅仅类似于地址和指针一样的东西。对于 Slide 的更改会导致对于其截取的原数组的更改，并且其他包含相同元素的 Slide 也会立刻应用这些更改（因为他们只是取地址）。</p><p>对于 Slide 的元素截取和 Python 一样，可以使用<code>:</code>符号表示截取范围。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:]</span><br></pre></td></tr></table></figure><p>以上四种表达是等价的。Slide 存在 length 和 capacity 两个变量。前者为 Slide 包含的元素数量，后者为 Slide 所指向的 Array，从 Slide 包含的第一个元素开始计算的元素数。这两个值分别可以通过函数<code>len()</code>及<code>cap()</code>获取。</p><p>特殊的是，我们可以 extend Slide 的范围。对于以下的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">s = s[:<span class="number">0</span>]</span><br><span class="line">s = s[:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>其并不是在 Slide s 中重新获得新的 Slide，而是在完成一次 Re-sldie。即<code>s = s[:4]</code>语句是针对最开始的长度为 6 的数组进行的。这仅仅发生在，数组的长度右端超过了 Slide 的长度并小于 Slide 的容量时才会发生，称为 Extend。</p><p><strong>Nil Slide</strong></p><p>空数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">fmt.Println(s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"nil!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Append</strong></p><p>类似 Python 的 list，Go 提供了一个可变长的数组。这个数组在元素超出容量时会自动再分配一个空间，然后返回的地址指向一个新的数组。其使用如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// append works on nil slices.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// The slice grows as needed.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can add more than one element at a time.</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Range</strong></p><p>类似 Python 的，他的 For 循环也可使用 Range 操作。Range 在每一个迭代返回一个计数器和一个对象对应的值。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pow = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> pow &#123;</span><br><span class="line">fmt.Printf(<span class="string">"2**%d = %d\n"</span>, i, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不希望获得对应的值，则可以使用<code>_</code>代替位置。如果只希望使用 index，则只显式地记下一个值即可。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 的 0 值为<code>nil</code>，一个 nil 的 Map 既没有 key 也不能增加新的 key。Map 可以使用 make 函数初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br></pre></td></tr></table></figure><p>其中，string 是键值，Vertex 是 Map 指向的对象。Map 的访问是通过键值访问的，这个设定与 C 及 Python 都一致。下面是一个更完整的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat, Long <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Vertex)</span><br><span class="line">m[<span class="string">"Bell Labs"</span>] = Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m[<span class="string">"Bell Labs"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，Map 还可以如此初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">"Bell Labs"</span>: Vertex&#123;</span><br><span class="line"><span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"Google"</span>: Vertex&#123;</span><br><span class="line"><span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者干脆省略 Vertex 声明，改为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line"><span class="string">"Bell Labs"</span>: &#123;<span class="number">40.68433</span>, <span class="number">-74.39967</span>&#125;,</span><br><span class="line"><span class="string">"Google"</span>: &#123;<span class="number">37.42202</span>, <span class="number">-122.08408</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对 Map 的其他操作</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, key) <span class="comment">// 从字典m中删去Key及其对应的值。</span></span><br><span class="line">elem, ok := m[key] </span><br><span class="line"><span class="comment">// 如果ok == true，则字典m中存在键值key；</span></span><br><span class="line"><span class="comment">// 反之则不存在，并返回0值elem</span></span><br></pre></td></tr></table></figure><h3 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">sum += x</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">pos, neg := adder(), adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(</span><br><span class="line">pos(i),</span><br><span class="line">neg(<span class="number">-2</span>*i),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子里，函数 adder()相当于一个“函数模型”，调用这个模型获得的是一个函数的实体即 pos, neg。而这个 sum 是这个函数模型实体的参数，所以会逐渐累加，其效果如同 C 中的 static 变量。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="For-语句"><a href="#For-语句" class="headerlink" title="For 语句"></a>For 语句</h3><p>Go 仅含有这样一种循环语句。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和 C 的语法非常像。同样的，如果不需要这三要素中的某一部分，可以完全空出来，如同 C 的操作。如上第二个或第三个 For 循环。而在 Go 中，并没有专门的 While 语句，有上述第三种 For 循环代替。</p><p>更直接的，如果希望写出一个死循环，则可以如此写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="If-语句"><a href="#If-语句" class="headerlink" title="If 语句"></a>If 语句</h3><p>和 For 语句一样，成分不需要使用括号包含。但是大括号是需要的，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似 For 语句，If 语句可以在条件前增加一个初始化语句。该初始化语句的内容，在后面大括号范围内有效。例如下面的写法是有效的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%g"</span>, v) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Switch-语句"><a href="#Switch-语句" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><p>Switch 语句和 C 语言相似，然而，Go 的 Switch 语句不会运行后面所有的部分，而仅仅运行满足条件的语句。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">fmt.Println(<span class="string">"OS X."</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"linux"</span>:</span><br><span class="line">fmt.Println(<span class="string">"Linux."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// freebsd, openbsd,</span></span><br><span class="line"><span class="comment">// plan9, windows...</span></span><br><span class="line">fmt.Printf(<span class="string">"%s.\n"</span>, os)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的程序仅会运行其中的一项，而非所有。同时这个初始化语句和 If 语句相同，是可以省略的。与 C 不同的是，这里的 Case 语句不需要是 Const，同时也不需要是整型。同时，Switch 是从上往下执行的，他会在任何一个满足条件的 Case 中停下并不再考察后面的 Case。</p><p>特殊的，我们可以声明一个不带有条件的 Switch 语句。此时，这个 Switch 语句的含义是传递一个 True 值。然而我们在 Case 的声明时，仅需要返回 true 或者 false 即可。换句话说，我们可以将其作为一个 if-then-else 的链使用。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t := time.Now()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good morning!"</span>)</span><br><span class="line"><span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good afternoon."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"Good evening."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Defer-语句"><a href="#Defer-语句" class="headerlink" title="Defer 语句"></a>Defer 语句</h3><p>Defer 语句会暂停现在的所有执行，直到它环境里的其他语句执行结束后才会执行（即一个栈）。并且按照后定义的 Defer 先执行的顺序执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"!!"</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如上式的输出为<code>hello \n !! \n world</code>。</p><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><p>Go 没有类，但是可以在类上定义方法。这类方法的定义和其他函数有些许不同，需要在<code>func</code>关键词到方法名间增加一个 receiver。形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也能为仅仅数据类型构造 Methods，然而它不能为其他 package 里的数据类型如此操作，或者对内建数据类型数次操作。如需要针对内建数据类型，则需要重定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，使用这样的 Receiver，不能对其含有的值进行操作。在我们需要操作其内容的时候，我们需要使用指针的 Receiver，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">v.Scale(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>对于 Methods 来说，使用实体或者指向实体的指针操作实体中的参数都是可以的。</p><h2 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h2><p>Interface 一种特殊的数据类型，它是一系列 Methods 签名的集合。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Abser</span><br><span class="line">f := MyFloat(-math.Sqrt2)</span><br><span class="line">v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat implements Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex implements Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In the following line, v is a Vertex (not *Vertex)</span></span><br><span class="line"><span class="comment">// and does NOT implement Abser.</span></span><br><span class="line"><span class="comment">// a = v</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们说一个 Type 实现了一个 Interface，如果它存在 Interface 中声明的函数的实现。这个实现不需要显式地声明，他们的名称相同即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">M()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">S <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method means type T implements the interface I,</span></span><br><span class="line"><span class="comment">// but we don't need to explicitly declare that it does so.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I = T&#123;<span class="string">"hello"</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述例子中，存在 Interface I，Type T。其中 T 实现了 Methods M，则可以说是 Type T 实现了 Interface I。这样的 Interface 让实现和使用解耦，我们只需要关心 Interface 或者其实现，而不需要两者兼顾。</p><p>从更根本的眼光来看，Interface 是一个元组：<code>(value, type)</code>。它保存一个类型及其对应的值。对 Interface 调用一个 Method，相当于调用其代表的 type 对应的 Method。</p><p><strong>关于 nil 值</strong></p><p>存在这样的情况：Interface 对应的值不存在。但是这种情况的 Interface 并不为空，其保存了对应的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">M</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"&lt;nil&gt;"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(t.S)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i I</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t *T</span><br><span class="line">i = t</span><br><span class="line">i.M()</span><br><span class="line"></span><br><span class="line">i = &amp;T&#123;<span class="string">"hello"</span>&#125;</span><br><span class="line">i.M()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，t 并没有被初始化，所以对应的值是 nil 的（因为它甚至只是一个指针。）。而若去掉代码<code>i = t</code>，则 Interface i 就是一个空 Interface，此时调用<code>M()</code>就会报错。</p><p><strong>关于空 Interface</strong></p><p>对于没有声明 Methods 的 Interface 被称为“Empty Interface”。这样的 Interface 可以指向任何一个数据类型。这样的情况被用在处理不确定数据类型的时候。</p><p><strong>关于 Interface 的 Type</strong></p><p>我们有的时候需要知道 Interface 指向的 Type 是什么，此时我们这样调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t := i.(T)</span><br></pre></td></tr></table></figure><p>如果 Type T 和 Interface i 的值完全相同，则会返回 i 对应的实体。如果类型不同则会报错。为了得知类型的同时不 raise error，我们采用下面的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t, ok := i.(T)</span><br></pre></td></tr></table></figure><p>如果 ok 为真，则意味着两种数据类型相同，并返回值 t；若为 false，则数据类型不同，且会返回 T 的 0 值。在这个设定下，我们可以这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">"Twice %v is %v\n"</span>, v, v*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">"%q is %v bytes long\n"</span>, v, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Printf(<span class="string">"I don't know about type %T!\n"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个语句比较 v 的类型。</p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Error 是一类内建的 Interface。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的函数都会返回一个 error 值，若 error 值等于 nil，则表示成功运行。他可以像上述代码的后半部分那样使用。</p><h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><h3 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a>Goroutines</h3><p>一个 Goroutines 是 Go 驱动的一个线程。以下语句会调起一个新线程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> f(x, y, z)</span><br></pre></td></tr></table></figure><p>f, x, y, z 的检验都是发现在当前的 goroutine 的，而调起的新函数则会运行在一个新的 goroutine 中。不同的 goroutine 运行在一个相同的地址空间中，所以他们的值是共享的。</p><h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>Channels 是一种类型相关的导管。我们可以通过这个东西接受或者发送值，通过运算符：<code>&lt;-</code>。类似下面的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// Send v to channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// Receive from ch, and</span></span><br><span class="line">           <span class="comment">// assign value to v.</span></span><br></pre></td></tr></table></figure><p>Channels 的定义方法和 Map 及 Slide 类似，需要借助 make 函数，定义方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>默认的情况下，这两个操作都会阻塞当前的 Channels。这样可以完成同步，并不需要显式地锁住线程。下面是一个示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Buffered Channels</strong></p><p>Channels 可以存在 Buffer。通过下面的定义方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>以上定义了 100 个 Buffer。Send 命令会 Block 仅有可能为 Buffer 已满；Receive 命令会 Block 仅有可能为 Buffer 为空。这两种情况会导致死锁错误。</p><p><strong>close</strong></p><p>Send 的过程中，可以主动关闭 Channel，即不再发送数据；Receive 可以检验某个 Channel 是否被关闭。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">v, ok := &lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，Close 在这里不是必要的，除非 Receiver 需要明确地知道数据发送已经结束并终结进程。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>失衡的貝多芬</title>
      <link href="/2020/09/23/essay/music/%E5%A4%B1%E8%A1%A1%E7%9A%84%E8%B4%9D%E5%A4%9A%E8%8A%AC/"/>
      <url>/2020/09/23/essay/music/%E5%A4%B1%E8%A1%A1%E7%9A%84%E8%B4%9D%E5%A4%9A%E8%8A%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>回到上海再一次第一次進入東方藝術中心，已是近一年之後。曲目是貝多芬《第二交響曲》及《第五交響曲》。指揮家非常年輕，作爲小澤征爾的弟子，表現值得期待。樂團也是未曾感受過的樂團。</p><blockquote><p>地點：上海東方藝術中心<br>指揮：俞璐<br>樂團：寧波交響樂團<br>座位：樂池正前方偏音樂廳後部<br>開始前的食物：KFC蝦堡套餐</p></blockquote><a id="more"></a>  <h2 id="曲目及演繹"><a href="#曲目及演繹" class="headerlink" title="曲目及演繹"></a>曲目及演繹</h2><h3 id="《第二交響曲》"><a href="#《第二交響曲》" class="headerlink" title="《第二交響曲》"></a>《第二交響曲》</h3>    <div id="aplayer-ckjXbdbi" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="550607355" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p><strong>簡評</strong></p><p>No.2 並不是經常見到的一個表演曲目，一方面它自身不是非常具有特色，另一方面也是它代表着貝多芬第一時期的末端，仍然帶着莫扎特的影子。</p><p>作爲 D 大調的作品，整部作品四個樂章，無一不呈現出明朗積極的特徵。這可能也是本次音樂會被命名爲《命運與希望》（命運自然是指 No.5）的重要原因。但是這部作品呈現出了單調的、一味的積極情緒，使人並不覺得特別審美，而是有一種淡淡的困意（也和本人對這部作品並沒有非常了解有關）。</p><p>整個作品的展開完全在意料之中，抒情的部分也顯得不夠吸引人，唯一能給人留下深刻印象的是第四樂章的第一主題，明亮且有趣，但也僅此而已了。正如前文所言，整部作品透露出濃厚的莫扎特風味，也是貝多芬第一時期的象徵。</p><p>需要注意的一點是，其中第一樂章的一個樂段，在 No.9 再一次忠實地再一次出現，這肯定是貝多芬有意之舉。至於這兩部作品是如何連接在一起的，待考。</p><p><strong>演繹</strong></p><p>這部作品的演繹也中規中矩，沒有特別可以拿出來說道的地方。乾淨利落，毫不拖沓。</p><h3 id="《第五交響曲》"><a href="#《第五交響曲》" class="headerlink" title="《第五交響曲》"></a>《第五交響曲》</h3>    <div id="aplayer-LhoxFlAC" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="459860068" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>第五交響曲又名命運交響曲，由於過於出名，甚至於爛俗，以致在國內幾乎見不到現場的演出，演出次數更是遠遠趕不上不那麼出圈的 No.7 &amp; No.8。這是一個相當悖論的事情。</p><p><strong>簡評</strong></p><p>回到作品本身。作品呈現出明顯的鬥爭性，第一樂章那個著名的動機，似幽靈般圍繞整部作品：隨着作品的推進，這個著名的動機，逐漸從一種激烈的憂鬱，變成激昂的四連音，象徵着某種勝利的轉變。</p><p>但是這個勝利是在第三樂章發生的，第一樂章是完全的失敗。「命運」的強力，將故事的主人公擊倒在地，並以主人公的完全失敗作結。隨後進入了多愁善感的第二樂章。儘管第二樂章伊始保留着某種抒情的特徵，但在後半部分，再一次呈現出了強的鬥爭性，然而在現在占據上風的卻是某種光輝的勝利。但我們並沒有得到結論，在鬥爭中進入了第三樂章。</p><p>第三樂章前幾個小節的靜謐氛圍逐漸被到來的鬥爭逼近;隨着逼近的鬥爭聲愈加明顯，我們發現這是變奏的第一樂章中所謂「命運」的動機，然而此時它不再陰鬱，而是光輝、明朗，具備帝王版的威嚴。這是最後一次鬥爭，在第三樂章結束時已然奠定了局面，最後我們迎來了偉大的第四樂章。</p><p>第四樂章高昂，絕對的積極，不留餘地。第三樂章和第四樂章的緊密鏈接讓這種明亮的印象更加令人深刻——命運毫無喘息機會！大概是這樣的感受。這樣的勝利比 No.2 的積極和 No.9 妥協式的勝利更加積極，是純粹得令人感動的氛圍。罕見的作品。</p><p><strong>演繹</strong></p><p>演繹仍然具有相當的水準。美中不足的是其中的短笛，總是比正常的音高高出一小截，而又由於短笛所在的高頻段異常抓耳，第四樂章短笛的每次進入都嚴重分散了我的注意力。音過高的短笛呈現出一種飄忽不定的聲線，致使發聲也不清晰。</p><p>其次是小號的處理。在第二樂章小號聲音過大——在同時奏響的時刻，小號幾乎蓋住了所有的弦樂組，迫使聽衆丟掉了大部分細節。所幸小號在聲音大的同時沒有破音，令人感動。</p><p>圓號發揮非常出色，音色動人圓潤，實在驚艷。在整場演出中不搶眼，但是以自身的過硬實力將自己的部分發揮到了最好。以及巴松也可圈可點，儘管在高音區發揮略有失常（一方面是巴松本來不擅長高音的原因），其餘部分富有彈性的聲音具有相當的美感。</p><h3 id="安可"><a href="#安可" class="headerlink" title="安可"></a>安可</h3><p>本場演出沒有安可。</p><h2 id="總評"><a href="#總評" class="headerlink" title="總評"></a>總評</h2><p>總而言之是值回票價的演出。俞璐指揮的演繹可圈可點。或許師承小澤征爾的緣故，其具有相當豐富的肢體語言。在指揮的同時，動作幅度劇烈，但是富有美感，有一定觀賞性。No.5 的一部分處理讓整體顯得不太勻稱，在某些時刻有被少部分樂器帶偏的感覺，但基本上維持了高水準的演繹。</p><p>兩部作品我個人還是更喜歡爛俗的 No.5，No.2 由於過於明亮讓我有點吃不消……</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>本次的安可並沒有如同預期一般出現，而是出現了俞璐的一段致辭。俞璐簡單地描述了一下自己對於貝多芬的仰慕之情，並且說了一下疫情下古典樂的現狀。最後吐露了一個宏偉的計劃：在五天之內演出貝多芬的九部交響曲。這應當是中國古典樂從未有過的盛況。</p><p>賴於寧波市政府的贊助及 Bilibili 的支持，這樣的行動才能發起。俞璐特別感謝了 Bilibili 的贊助。對於古典樂愛好者，這肯定是一個非常令人激動的信號：這個小衆的羣體也開始進入羣衆的視野。</p><p>在每次音樂會結束後回寢室的路上，一票樂迷總會各抒己見。再一次感受到自己肖斯塔聽得太少了……</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elementary OS双系统安装</title>
      <link href="/2020/09/22/tech/linux/Linux%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/09/22/tech/linux/Linux%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><center><img src="/images/screenshot/home.png" width="80%" height="80%" /></center><p>这两日心血来潮给副系统装上了 Elementary OS。这一路配置相当地顺利，除了最后的一步。这里记录一下配置的过程及一些细节问题。</p><a id="more"></a>  <h2 id="录制DD盘"><a href="#录制DD盘" class="headerlink" title="录制DD盘"></a>录制DD盘</h2><p>这次安装的是<a href="https://elementary.io" target="_blank" rel="noopener">Elementary OS 5.1</a>，基于 Ubuntu 18.04 的发行版。在原系统下，上官网拿到了 ISO 之后就可以利用<a href="https://rufus.ie" target="_blank" rel="noopener">rufus</a>将 ISO 烧制到 USB 中。这个也是安装双系统的常用软件了。将 ISO 读出后，选择 DD 模式烧制。烧制结束后准备工作结束。</p><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><p>安装系统过程非常流畅。插上烧制好的 USB，重启进入 USB 启动。可能这里会进入 Grub，而不是进入 USB。此时需要进入 Grub 中的 Configuration 将 USB 调整为最高优先级，然后重启。</p><p>重启后会进入 Elementary 的安装引导。这一路没有特别需要注意的。最后需要提及的是关于分区部分。Elementary 自动识别出了之前在我的电脑上存在的 Ubuntu 19.04，于是默认选项是在该分区上使用新的系统对其进行覆盖。如果是新的双系统的话会需要重新选择分区。</p><p>到目前为止都是非常顺畅。（请不要连接 WiFi，之后会有时间更新镜像后再 update。）</p><h2 id="进入系统"><a href="#进入系统" class="headerlink" title="进入系统"></a>进入系统</h2><p>作为 Surface Book，安装双系统（或者说 Linux）系统，不能够开箱即用，有三个问题需要解决：</p><ol><li>Linux 会在后台挂起一个不知何物的进程，这个进程会始终占用 90%左右的 CPU。</li><li>Linux 无法自动地在集成显卡和独立显卡间切换，导致耗电极快。</li><li>由于 Surface 的高分屏，Grub 界面字体非常小（尽管 Elementary 内部的分辨率是完全正常的，包括登录界面。）</li></ol><p>为了方便，请现在这个时刻安装一个 vim 吧，后面会用上的。由于 vim 体积不大，完全可以先把换源的事情放在后面，基础设定要紧。</p><h3 id="更换Kernel"><a href="#更换Kernel" class="headerlink" title="更换Kernel"></a>更换Kernel</h3><p>为解决第一个问题，需要更换 GitHub 上大神完成且预编的<a href="https://github.com/linux-surface/linux-surface" target="_blank" rel="noopener">Linux Kernel</a>。找到 Release，获取其中的三个内核文件并安装。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dpkg</span> -i <span class="regexp">*.deb</span></span><br></pre></td></tr></table></figure><p>这样三个内核文件就安装好了。此时重启，在 Grub 界面中找到 Advanced Configuration 并选择 Surface Kernel 即可。</p><p>这个步骤真的是被坑了很久才摸清楚的处理办法。对于其他的 Linux 来说，这个方法也是完全可以使用的。这个 Kernel 理论上提供了对于触摸屏、物理按键，甚至热插拔的特性，但大神预编的版本并不包含触摸屏功能。（但谁会想在 Linux 下拥有触摸屏呢……）所以预编的版本完全没有问题。</p><p>自此那个恼人的后台在重启后就不会出现了。</p><h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><p>这是选择 Ubuntu based Linux 的主要原因。之前使用 Manjaro 的时候，会发现这个步骤非常困难，但在 Ubuntu 下完全可以接受了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ubuntu-drivers <span class="built_in">auto</span>install</span><br></pre></td></tr></table></figure><p>默认的显卡驱动完全没有问题。上述命令运行结束后，显卡驱动就安装结束。为了完全切换为核显，需要先重启（否则软件内部是一片空白）。重启后，打开这个软件的 GUI 界面就正常了，切换一次设定，将之改为核显驱动，随后重启。双显卡问题就此解决。</p><p>这个也是血泪教训。尽管网路上的冲浪人士宣称 Manjaro 或者 Arch 拥有更加方便的驱动配置，但对于我来说不是这样的。</p><h3 id="Grub修改"><a href="#Grub修改" class="headerlink" title="Grub修改"></a>Grub修改</h3><p>Grub 修改完全可以和 Grub theme 的切换一起来完成了。先在<a href="https://www.gnome-look.org/browse/cat/109/order/latest/" target="_blank" rel="noopener">Gnome的主题站</a>上找到合适的 Grub 主题。我这次选择的是这个：<a href="https://www.gnome-look.org/p/1397139/" target="_blank" rel="noopener">Linux Mind</a>。说实话不好看，但是也懒得接着找了。</p><p>将下载好的主题包解压，把他移动到一个特定的位置。为了方便我们先创建一个新的文件夹：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">mkdir</span> /<span class="keyword">boot</span>/grub/themes</span><br></pre></td></tr></table></figure><p>然后把解压后的文件夹移入这个文件夹。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp 主题包名 <span class="regexp">/boot/g</span>rub<span class="regexp">/themes/</span></span><br></pre></td></tr></table></figure><p>然后修改配置文件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/grub.d/<span class="number">00</span>_header</span><br></pre></td></tr></table></figure><p>在最开始的注视内容之后添加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">GRUB_THEME</span>=<span class="string">"/boot/grub/themes/主题包名/theme.txt"</span></span><br><span class="line"><span class="attr">GRUB_GFXMODE</span>=<span class="string">"3000x2000x32"</span></span><br></pre></td></tr></table></figure><p><code>3000x2999</code>是 Surface 的分辨率。这样修改结束后，主题和分辨率就都调整好了。然后更新 Grub 配置文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo update-grub</span></span><br></pre></td></tr></table></figure><p>更新结束后重启。这一个步骤就完成了。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>但现在距离一个好用的系统还有不少的步骤……比如好用的浏览器，舒适的输入法等等。在这些开始之前需要先更换镜像。</p><h3 id="apt换源"><a href="#apt换源" class="headerlink" title="apt换源"></a>apt换源</h3><p>进入文件：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vim</span> /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure><p>如果担心的话可以先做一个备份。然后用下面的内容替代该文件所有内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#清华源</span><br><span class="line"># 默认注释了源码镜像以提高 apt <span class="keyword">update</span> 速度，如有需要可自行取消注释</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ focal-security main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>保存退出就结束了。然后运行一下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> update</span><br><span class="line">sudo apt-<span class="builtin-name">get</span> upgrade</span><br></pre></td></tr></table></figure><p>镜像工作至此结束。</p><h3 id="更换输入法"><a href="#更换输入法" class="headerlink" title="更换输入法"></a>更换输入法</h3><p>类似 VS Code 或者 Vivaldi 啥的都非常简单，故不赘述。这里说一下输入法的问题。原配的 IBus 在 Ubuntu 下是能用的，但不知为何在 Elementary 下不能正常使用了。正好，那我换成 Fcitx 好咯。</p><p><strong>注意</strong>：这里遇到了目前位置最为严重的 Bug。在执行这个操作以前，我可以进入”语言及区域“中的”键盘设定“处调整快捷键，但在该操作结束以后，该设定不再能被打开，并且在装回 iBus 后仍然处于不能使用状态。</p><p>Anyway，输入还是重要的，所以为了避免冲突，卸载 iBus，然后下载 Fcitx。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> fcitx fcitx-sunpinyin</span><br></pre></td></tr></table></figure><p>为了使用 Fcitx，这俩就够了。后面一个软件提供中文输入支持。</p><p>输入<code>im-config</code>设定 fcitx 为默认输入法，注销系统然后登入。</p><p>此时在 Application 处搜索 Fcitx Configuration（注意，这个需要搜索，它不会出现在目录中。），然后设定 Sunpinyin 的相关设定。此时即使选择了双拼，但输入的时候看起来仍然是全拼。这个 bug 重启之后就解决了。</p><p>然后是一些微调工作，比如将字体设定为 20 等等。</p><h3 id="Grub-customizer"><a href="#Grub-customizer" class="headerlink" title="Grub customizer"></a>Grub customizer</h3><p>尽管我们已经成功地调整了 Grub 的分辨率以及 Theme，但目前 Grub menu 非常地令人难受。为了仅保留我们需要的选项，grub customizer 作为一个 GUI 工具是一个方便的选择。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> add-apt-repository </span>ppa:danielrichter2007/grub-customizer</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install grub-customizer</span><br></pre></td></tr></table></figure><p>后面的事情就比较直接了。</p><h3 id="Fish-shell"><a href="#Fish-shell" class="headerlink" title="Fish shell"></a>Fish shell</h3><p>这个安装过很多次，应当轻车熟路了。</p><p>首先上<a href="http://fishshell.com" target="_blank" rel="noopener">官网</a>添加 ppa。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">add</span>-repository <span class="keyword">pp</span><span class="variable">a:fish</span>-<span class="keyword">shell</span>/release-<span class="number">3</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">$ sudo apt-<span class="built_in">get</span> install fish</span><br></pre></td></tr></table></figure><p>安装结束后将 fish 设为默认：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s <span class="regexp">/usr/</span>bin<span class="regexp">/fish</span></span><br></pre></td></tr></table></figure><p>然后 Shell 默认会调起 fish，之后可以使用 bash 暂时回到默认的 shell。</p><p>最后修改 fish 的 greeting messege：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> -U <span class="comment">fish_greeting</span> <span class="comment">"Bonjour! Joseph..."</span></span><br></pre></td></tr></table></figure><p>Fish 的设置结束。更多设置，使用<code>fish_config</code>查看。</p><p><strong>修改 ls 颜色</strong></p><p>此外，由于 Terminal 默认的<code>ls</code>颜色比较难以接受，所以需要手动修改。而 fish 的方法和主流不太相同，这里做一下记录。</p><p>首先需要获得系统的配色方案，在此基础上修改：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~</span><br><span class="line">dircolors -p &gt; <span class="string">.dircolors</span></span><br></pre></td></tr></table></figure><p>这样配色方案就存放在文件<code>.dircolors</code>中，对这个文件进行修改即可。规则不一一列举，参见文后链接。为了让这个配色方案在 fish 中生效，需要修改 fish 的设定文件。该文件位置在：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.<span class="built_in">config</span>/fish/<span class="built_in">config</span>.fish</span><br></pre></td></tr></table></figure><p>在该文件中添加：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">eval</span> (dircolors ~<span class="regexp">/.dircolors | head -n 1 | sed 's/</span>^LS_COLORS=<span class="regexp">/set -x LS_COLORS /</span>;<span class="regexp">s/;$//</span><span class="string">')</span></span><br></pre></td></tr></table></figure><p>添加结束后重启 terminal 就可以了。</p><h3 id="Autojump"><a href="#Autojump" class="headerlink" title="Autojump"></a>Autojump</h3><p>安装结束 Fish 之后，我们就可以开始配置 Autojump 了，虽然简单，但很有帮助。直接使用 apt 安装 Autojump 是不可以的。需要这样处理：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/wting/autojump.git</span><br><span class="line"><span class="keyword">cd</span> autojump</span><br><span class="line">./install.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p>然后打开文件：<code>~/.config/fish/config.fish</code>，在其中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">    <span class="built_in">set</span> --<span class="built_in">local</span> AUTOJUMP_PATH <span class="variable">$HOME</span>/.autojump/share/autojump/autojump.fish</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -e <span class="variable">$AUTOJUMP_PATH</span></span><br><span class="line">        <span class="built_in">source</span> <span class="variable">$AUTOJUMP_PATH</span></span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后关闭 Shell 再打开，设定就结束了。</p><h3 id="按键重映射"><a href="#按键重映射" class="headerlink" title="按键重映射"></a>按键重映射</h3><p>按键重映射主要是为了让 Win 键代替右 Alt 键，让他发挥一点点小作用。这里需要用到工具 xmodmap。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">xmodmap</span> -e <span class="string">"remove mod1 = Alt_R"</span></span><br><span class="line">xmodmap -e <span class="string">"add mod4 = Alt_R"</span></span><br></pre></td></tr></table></figure><p>其中<code>mod1</code>代指 Alt 键，<code>mod4</code>代指 Super 键。具体的名称可以在后面链接中找到。但是这两个命令是临时的，在系统重启后就会消失。为了避免这个问题，我们需要设定开机自启。开机自启的方法很多，但是众多尝试都失败了。</p><p>这里记录的方法依赖 Gnome 的设定。在 Application 中添加一个用来替换按键的脚本，然后就可以开机后运行了。</p><h2 id="WeChat-amp-QQ"><a href="#WeChat-amp-QQ" class="headerlink" title="WeChat &amp; QQ"></a>WeChat &amp; QQ</h2><p>有的时候这俩软件还是相当必要的。这两个软件都需要 Wine 进行驱动。为了安装这两个软件，我们需要相当繁琐的设定。</p><h3 id="安装Wine"><a href="#安装Wine" class="headerlink" title="安装Wine"></a>安装Wine</h3><p>先添加仓库：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O- http<span class="variable">s:</span>//deepin-wine.i-<span class="keyword">m</span>.dev/setup.<span class="keyword">sh</span> | <span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>然后安装对应的软件，表格如下：</p><div class="table-container"><table><thead><tr><th>应用</th><th>包名</th></tr></thead><tbody><tr><td>TIM</td><td>deepin.com.qq.office</td></tr><tr><td>QQ</td><td>deepin.com.qq.im</td></tr><tr><td>WeChat</td><td>deepin.com.wechat</td></tr></tbody></table></div><p>使用以下语句安装：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">apt-get</span> <span class="selector-tag">install</span> <span class="selector-tag">deepin</span><span class="selector-class">.com</span><span class="selector-class">.wechat</span></span><br></pre></td></tr></table></figure><p>至此，两个软件都可以正常地运行，但存在三个问题：</p><ol><li>字体由于分辨率奇小无比。</li><li>中文无法正常显示（因为我习惯用英文系统）。</li><li>输入框字体不能正常显示（事实证明，这个原因和 2 中原因不一样。）</li></ol><h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p>为了修正分辨率，我们需要 Wine 主体，但我们还没有安装。</p><p>在安装好了 Wine 之后，我们就开始解决乱码问题。打开<code>/opt/deepinwine/tools/run.sh</code>和<code>/opt/deepinwine/tools/run_v2.sh</code>两个文件;将其中的<code>WINE_CMD=&quot;deepin-wine&quot;</code>改为<code>WINE_CMD=&quot;LC_ALL=zh_CN.UTF-8 deepin-wine&quot;</code>。这样就解决了中文乱码。</p><p>事实上，将系统改为中文也能够解决这个问题，但，嗯……还是英文更好看一些。（以及一些翻译不合理以及不完全的位置让人觉得有点难受。）</p><h3 id="输入框问题"><a href="#输入框问题" class="headerlink" title="输入框问题"></a>输入框问题</h3><p>即使解决了上述问题，微信的输入框仍然处于乱码的状态，这是由于缺少字体。为了解决这个问题，我们将 Windows 中的字体移植到 wine 容器中的 Fonts 文件夹中，这样这个问题就解决了。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>以微信为例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">env</span> WINEPREFIX=<span class="string">"<span class="variable">$HOME</span>/.deepinwine/Deepin-WeChat"</span> winecfg</span><br></pre></td></tr></table></figure><p>会打开一个 GUI 界面用以调整屏幕分辨率。该分辨率需要针对不同的软件分别设置。该数值调整为 192 较为合适。</p><p><strong>注意</strong>：这个步骤应当先打开一次软件，待 Wine 容器初始化之后再进行，而不是在安装了软件之后立刻进行，否则不会有任何变化。</p><p>至此微信和 QQ 的安装工作结束。但是目前没有完成系统托盘的修改。目前两个软件的小托盘图标会独立显示出来，这个问题放在以后调整吧。</p><h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>Elementary 是优雅的，令人爱不释手的。在体验了一天的情况下，并没有出现令人难以理解、严重的 bug。其自带的日历、邮箱软件都充满了优雅的味道。整体的动画流畅舒适，快捷键分布自然高效。毫无疑问，这是一个满足了我目前基本需求的系统，我也愿意在短期内尝试将其作为主力使用去感受一下它的魅力。</p><center><img src="/images/screenshot/apps.png" width="100%" height="100%" /></center><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/w84963568/article/details/78884003" target="_blank" rel="noopener">更换Grub主题</a></li><li><a href="https://www.cnblogs.com/Briddle-ch/p/13369274.html" target="_blank" rel="noopener">在Ubuntu 18.04中安装Wine QQ、微信、TIM</a></li><li><a href="https://blog.csdn.net/yhuiqq788/article/details/104211021" target="_blank" rel="noopener">Wine不能正常显示中文</a></li><li><a href="https://stackoverflow.com/questions/13995857/suppress-or-customize-intro-message-in-fish-shell" target="_blank" rel="noopener">fish修改Greeting</a></li><li><a href="https://www.jianshu.com/p/c405db78091c" target="_blank" rel="noopener">Wine分辨率调整</a></li><li><a href="https://codeyarns.github.io/tech/2014-02-27-how-to-install-autojump-for-fish.html" target="_blank" rel="noopener">Autojump安装配置</a></li><li><a href="https://www.cnblogs.com/yinheyi/p/10146900.html" target="_blank" rel="noopener">xmodmap按键重映射</a></li><li><a href="https://blog.csdn.net/u013045749/article/details/53576868" target="_blank" rel="noopener">Ubuntu ls更改配色方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>論告別之聲</title>
      <link href="/2020/09/20/essay/music/%E5%91%8A%E5%88%AB/"/>
      <url>/2020/09/20/essay/music/%E5%91%8A%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-SIAMYcVL" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1418922883" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>　　這裡原來是大三下半學期（即網課期間）完成的通識課《音樂美學與實踐》的期末論文。但是又想到可能以後會對部分音樂做一個評價/體會，所以考慮把這一篇擡過來做一個開頭（因爲裡面確實包含了我對部分作品的真實感受及評價）。個人雖然是一個古典音樂的愛好者，但和門外漢並沒有多少的區別，評價方法也是完全主觀的（甚至不嚴謹的）。至於本篇中頻繁提到的《馬九》有幸聽過現場，奈何時間久遠，現在希望再回憶起細節實在是不太現實的事情。但這也是音樂的特徵之一吧。總之，請將該文當作一篇完全不專業的隨筆觀看。（本篇中提到的作品不會附上鏈接，有興趣者請自行搜索。）</p><a id="more"></a>  <p>【摘要】略</p><h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>　　在文學研究中，形式與內容儘管糾纏不清，但仍能一定程度地區分開二者特點，文學中作家意義的表達更依賴於內容；而在音樂中，「樂音的內容就是樂音的運動形式」 ，其形式和內涵具有先天的一致性，於是將一切的內涵都賦給其形式的音樂藝術實踐成爲可能，例如巴赫所作的《賦格的藝術》。但與之相對的，以舒伯特的《鱒魚》爲代表，也存在大量具有明確主題的音樂實踐。<br>　　如同中國詩歌常常以「告別」作爲主題，音樂也是如此。但是與中國詩歌相差甚遠的是，音樂中的「告別」往往不拘束於一個特定的人，甚至不存在一個告別的具體對象，這與音樂本身高度抽象、形式美的特徵是分離不開的，因而藉助音樂實踐對告別場景的建立也具有模糊性。而這種模糊性也使得我們討論的「告別之聲」具備獨特內涵，自然也擁有討論的價值。根據「告別」的形式與對象的不同，這個主題可以產生多樣且複雜的變化。同時，「告別」這一主題也經常和「死亡省思」，「時代變遷」等等主題存在內在關聯。<br>　　「告別之聲」在這裡特別指：藉助音樂這個特殊體裁表達某種告別情愫的形式。事實上，在音樂研究中存在與之相對應的「告別敘事」（Farewell Story）這個固定的提法，並且已經發展出了獨特的內核和理解，該提法在馬勒作品研究中常見 。不過我們避免這個音樂分析上的固有詞彙，從更直觀的角度進行理解。在本文中，我們將結合對應的音樂實例，討論音樂中埋藏的告別之聲。</p><h3 id="二、告別的形式與內涵"><a href="#二、告別的形式與內涵" class="headerlink" title="二、告別的形式與內涵"></a>二、告別的形式與內涵</h3><h4 id="（一）告別的形式特徵"><a href="#（一）告別的形式特徵" class="headerlink" title="（一）告別的形式特徵"></a>（一）告別的形式特徵</h4><p>　　儘管在之前對於「告別之聲」的指代進行了簡單的表述，但是顯得空泛而抽象，所以我們需要先更具體地確定「告別之聲」指代的是哪一種音樂實踐。正如前文所說，這個主題具備相當的複雜性和抽象性，使我們難以找到一個合適的範例作爲出發點。所以在討論更複雜的「告別」的內涵前，我們先試圖從形式的角度理解「告別之聲」，以這個爲切入點再進入音樂的更深內涵理解。這裡我們將分析三部不同的作品，試圖找到「告別」形式上的規律。</p><h5 id="海頓《升f小調第四十五號交響曲》"><a href="#海頓《升f小調第四十五號交響曲》" class="headerlink" title="海頓《升f小調第四十五號交響曲》"></a>海頓《升f小調第四十五號交響曲》</h5><p>　　這部作品第四樂章具有「典型」的形式上的「告別」意味：其中演奏人員變少、樂器逐漸離場、演奏強度漸弱等等設計，從形式上完成了「告別」意義的表達。這裡的告別對象是觀衆，隨着整個華麗繁複的部分慢慢進入兩把小提琴的演奏時，整部作品結束。這裡的告別相當具象化，指「物理意義上」的告別，即將告別的意義全盤交付給形式，因此也容易被理解。而我們所希望找到的告別則是更抽象、模糊的一種音樂實踐。</p><h5 id="貝多芬《降-E-大調第二十六鋼琴奏鳴曲》"><a href="#貝多芬《降-E-大調第二十六鋼琴奏鳴曲》" class="headerlink" title="貝多芬《降 E 大調第二十六鋼琴奏鳴曲》"></a>貝多芬《降 E 大調第二十六鋼琴奏鳴曲》</h5><p>　　這部作品被貝多芬分樂章地標上了題目，分別爲「告別」、「缺席」、「重逢」，並且貝多芬將之題詞獻給自己的贊助人魯道夫大公 ，是典型的主題音樂。所以我們可以把它當作一個相當不錯的關照對象。遵循音樂速度的線索，我們可以找到一個值得關注的關鍵點：對於一部奏鳴曲而言，第一樂章往往採用快板，而貝多芬反常地使用了從柔板到快板的結構，而其餘兩個樂章則保持了傳統的速度規範：「缺席」樂章維持了較慢的速度，渲染出一種憂鬱悲傷的氛圍；而「重逢」樂章則是速度陡升，呈現出了明顯的明朗愉悅。</p><h5 id="馬勒《第九交響曲》"><a href="#馬勒《第九交響曲》" class="headerlink" title="馬勒《第九交響曲》"></a>馬勒《第九交響曲》</h5><p>　　承接上面的分析，貝多芬的這部鋼琴奏鳴曲還有一個值得注意的部分：在該奏鳴曲中前三個音符作爲動機，被標註爲「Lebewohl」 ，這一動機在馬勒《第九交響曲》中被再次使用，於是我們也可以從形式的角度簡單地分析一下馬勒的這部作品。其前三樂章作爲諧謔曲或者迴旋曲這樣的曲式，都以相當快的速度前進，特別到了第三樂章的前半部分，幾近脫繮的野馬，銅管喧天；卻在第四樂章突然戛然而止，將話語權交給了溫柔的弦樂組，進入了作品的尾聲。交響曲中普遍的處理是以快板甚至急板的第四樂章作結，而馬勒在這裡反常地選擇了柔板，這個選擇是具備特殊意義的，正是與其選用的「告別」動機有所呼應。<br>　　不難從上述的分析中找到規律：一種由快速逐漸緩慢、由強至弱、由歡快至沉鬱的過程，是「告別」存在的可能形式特徵。這給了我們一個線索：樂曲的節奏對於告別具有暗示意味。這樣的規則尺度可以變化，即既能對應於一部作品，也能對應於作品的某一個片段。</p><h4 id="（二）告別的內涵特徵"><a href="#（二）告別的內涵特徵" class="headerlink" title="（二）告別的內涵特徵"></a>（二）告別的內涵特徵</h4><p>　　在上面的討論中，我們似乎找到告別的一種特徵，但事實是我們在援引馬勒《第九交響曲》時實際上並沒有嚴格說明，爲什麼這部交響曲是「告別」的，僅使用「Lebewohl」動機作爲解釋並不是非常有說服力。這便需要我們先簡單討論「告別」具備的內涵，及其在音樂中的表現。<br>　　我們確定「告別」具有幾個要素：告別者，被告別者，告別者的自我表達，某種狀態的改變。此外，我們認爲，告別具有時間上的意義，其建立在回憶與遙望之上的。正如李白《送友人》中兩句「此地一爲別，孤蓬萬里征」，「浮雲遊子意，落日故人情。」兩句，分別對應着遙望和回憶。<br>　　對於音樂，其也應當在傳達「告別之聲」時埋藏着這些信息。我們再一次以貝多芬《降 E 大調第二十六鋼琴奏鳴曲》爲例，上述的結構在這部作品中皆有其呼應的成分。這部作品欲揚先抑，描述了從離別到思念，最後重逢而喜的過程。並且其「重逢」樂章不似「孤蓬萬里征」的遙望，而似溫庭筠在《送人東歸》中的「尊酒慰離顏」那般愉快，同樣構成了「告別」的一個重要要素。<br>　　儘管是從內涵進行的解釋，上述的例證中音樂所傳達的告別由於具有具體告別的場景和對象，所以仍然停留在具象的層面，使用的音樂語言意義也簡明了當。然而在「告別」的內涵這個範疇下，情況可以相當複雜繁瑣，特別是對於不同的告別對象，在這其中涉及到一些有趣的討論，我們將更多例證分解到後面的小節中。但是在上述的過程中，我們已經可以找到一些告別可以被討論的內容，例如死亡與生命、鬥爭與妥協種種。我們後面則將不斷變更考察的對象，試圖更深入地考察「告別之聲」在音樂中傳達的價值與意義。</p><h3 id="三、「告別」與馬勒《第九交響曲》"><a href="#三、「告別」與馬勒《第九交響曲》" class="headerlink" title="三、「告別」與馬勒《第九交響曲》"></a>三、「告別」與馬勒《第九交響曲》</h3><p>　　這時我們再次以馬勒《第九交響曲》爲例，討論「告別之聲」 。在前面分析的內容中，我們已經對這部作品的基本結構進行了解釋。而學者普遍認爲這部作品與「死亡」緊緊關聯，並稱之爲「帶有自嘲的屈從」 。這便自然構成了一個特殊的告別對象——「對於生命和世界的告別」。我們試圖藉助這個例子，對其第一與第四樂章加以分析，討論死亡與告別的內在關聯。</p><h4 id="（一）第一樂章：美麗過往和可怖歸宿的鬥爭"><a href="#（一）第一樂章：美麗過往和可怖歸宿的鬥爭" class="headerlink" title="（一）第一樂章：美麗過往和可怖歸宿的鬥爭"></a>（一）第一樂章：美麗過往和可怖歸宿的鬥爭</h4><p>　　第一樂章體現出告別的時間線索。我們拆解出第一樂章幾個重要的主題或者動機。其一是第一樂章開頭由豎琴撥奏的不規則節奏「心跳動機」；其二是由弦樂組完成的優美旋律，我們稱之爲「回憶」的第一主題；其三是呈現崩壞混亂特點的第二主題。<br>　　第一樂章呈現出一種明顯的鬥爭性：美好場景與死亡威勢的相互交替。第一樂章開頭，隨着第一主題的進入，「心跳動機」透露出的不安感便深深植入了整部作品，然後調起了崩壞的第二主題；隨後藉助兩個主題旋律反覆地構建與崩壞，製造出掙扎的場景，使得整個樂章都充滿着危機，渲染出一種末世感。<br>　　在第一樂章中部存在一個微妙的變化，即第一主題變奏的重現，這個更爲積極的第一主題變奏突然出現，以悠揚婉轉的旋律打破了崩壞的旋律，重新將思索拉回了美好的過去。但這樣的美好終難以久繼，很快便被樂章開頭出現的不安動機再次打斷，重新進入混亂的第二主題。在本樂章最後階段的迴光返照式美好的回憶也未能勝利，終於消失在了完全崩壞的音樂中，第一樂章便在這裡結束。</p><h4 id="（二）第四樂章：失敗的「告別」"><a href="#（二）第四樂章：失敗的「告別」" class="headerlink" title="（二）第四樂章：失敗的「告別」"></a>（二）第四樂章：失敗的「告別」</h4><p>　　第一樂章中第一主題對抗第二主題的失敗，意味着所謂回憶向着宿命屈服，已經沒有任何迴轉的餘地，而「告別」則是非做不可的事情。抹去了第三樂章結束時的歇斯底里，第四樂章終於放棄了一切的鬥爭，衆多聲部互相交織、無盡且穩定地向前進展，展現出鋪天蓋地般可怕的音響效果。我們可以將其看作留戀之物的斷絕，並進入最終的平靜，或稱「毫無苦味的告別」 。<br>　　這樣的音響效果一直維持到第四樂章的結束。在第四樂章的結束時，所有旋律開始分崩離析，陷入瑣碎的囈語。作爲第四樂章結束的降 D 大調主和弦，由於樂曲聲響的效果，呈現出似乎沒能成功回到降 D 大調的慘象，仿佛作品尚未真正講述結束時就宣告了終止。在這場「告別」之中不再設想任何將來之事，沒有所謂天堂或者地獄，只是對於自我了結作出宣告而復歸平靜。這是一個不完整的、失敗的「告別」。第四樂章結尾既沒能回到期望的世界，也沒能「告別」這個世界，而是就這樣悄悄地停止了。<br>　　馬勒的這部作品帶有這樣獨特的色彩：在前三個樂章中不斷對抗命運而失敗，終於放棄鬥爭，進入了第四樂章的告別之時，連告別也沒能完成就戛然而止了。死亡和告別是內在相關的：死亡爲告別者提供了絕佳的告別對象，推動着作曲家對於「告別」這一行爲的實現。然而在這部特殊的作品中，帶者一切不舍的回憶與對生命的執着，「告別之聲」終於在那命運將至的悲感下變成了沉默的遺憾。</p><h3 id="四、「告別」與晚期風格"><a href="#四、「告別」與晚期風格" class="headerlink" title="四、「告別」與晚期風格"></a>四、「告別」與晚期風格</h3><p>　　正像之前對於馬勒作品的分析，「告別」在內涵上與「死亡」主題契合，故也和「晚期風格」內在關聯。晚期風格是指作曲家在臨終前突然出現的與其成熟風格迥異的新風格。在之前的討論中，我們都將音樂中埋藏的「告別之聲」賦給了一部作品。但其本身也可以是一個階段的主題。而由於告別、死亡、晚期風格之間互相存在的關聯性，我們便能將「告別之聲」與晚期風格直接聯繫起來，在作曲家的晚期風格中找到「告別之聲」的影子。這裡我們將主要以貝多芬和舒伯特的晚期作品爲例，對其進行更深入的討論。</p><h4 id="（一）貝多芬的晚期風格"><a href="#（一）貝多芬的晚期風格" class="headerlink" title="（一）貝多芬的晚期風格"></a>（一）貝多芬的晚期風格</h4><p>　　貝多芬早中期的作品如《第三交響曲》和《c 小調第八號鋼琴奏鳴曲》，具有顯然的情感意志流露。這些作品構建出了一個強力、積極的貝多芬形象；而貝多芬的晚期作品則更加富有矛盾性，以其最後五部弦樂四重奏作爲代表，呈現出了客觀、晦澀而具有神祕主義的貝多芬風格，這些作品也被稱爲「無表現」的作品。<br>　　這種風格和其另一部晚期作品《第九交響曲》看似不同，但也存在着統一：《第九交響曲》是絕對主觀、強力的，並刻意地向上，其帶有過分積極宏大的願望，並因此帶有明顯的鬥爭性 以及潛藏的鬥爭失敗的預感。而在其後創作的第十三、第十四號、第十五號弦樂四重奏的第一樂章的開頭則更露骨地在不安定與偉大目標間徘徊。<br>　　《第十五號弦樂四重奏》第三樂章中呈現的無限寧靜與溫暖感受，一定程度地勾勒出《第九交響曲》的鬥爭終於成功的未來；但在其《第十四號弦樂四重奏》中，卻帶着明顯的不穩定情緒。這種矛盾性與馬勒《第九交響曲》的第一和第四樂章對應，建立了鬥爭與妥協的關係，構造出了「告別」的結構，從而建立起了「告別」和晚期風格的內在聯繫。</p><h4 id="（二）舒伯特的晚期風格"><a href="#（二）舒伯特的晚期風格" class="headerlink" title="（二）舒伯特的晚期風格"></a>（二）舒伯特的晚期風格</h4><p>　　與之同時，舒伯特晚期風格也帶有這樣的矛盾性。其創作的《第九交響曲》與貝多芬的《第九交響曲》相似，脫離了《第八交響曲》的沉鬱，終於到達了「偉大」的高度；而在一些其他晚期作品中，例如《C 大調弦樂五重奏》、《降 E 大調彌撒》中構造的形象神祕而消極，而這些形象「成爲他在離開這個世界之前的正式告白」 ，最終形成了我們所討論的「告別之聲」的架構。同時在藝術歌曲《幻影》中，「他將主角替換成幻影時，歌曲的重點也從悲痛絕望的失戀轉移到了無處不在的死亡」 ，明顯地帶着舒伯特本人的死亡省思與複雜心理。其晚期風格藉助死亡省思和矛盾性和「告別」聯繫在了一起。<br>　　這些作品本身構成了「告別」，但不同於先前討論的所有作品，這裡的告別是正在進行的：它不會隨着一部作品的完成而結束，他們懷揣着對於死亡的擔憂往前行進，在衆多的作品間搖擺、碰撞，呈現出一種不停頓的鬥爭性，最後接納真正的死亡才復歸「非塵世的寧靜」 。這樣的「告別」正像是背負着《歡樂頌》那樣的願景帶來的無可調節的矛盾，顯得隆重而莊嚴。</p><h3 id="五、結論"><a href="#五、結論" class="headerlink" title="五、結論"></a>五、結論</h3><p>　　在本文中，我們主要將注意力聚焦於音樂中潛藏的「告別之聲」，分別從形式和內涵的角度，由具象至抽象、由微觀至宏觀地對這個問題進行了討論。我們從「告別」的形式出發，對海頓、貝多芬和馬勒等作曲家的作品分別展開了形式上的討論，並認爲「告別」在其形式上具有由快至慢、由強至弱等等特點。<br>　　從內涵出發，我們則討論了具象的「告別」具有的例如時間線索、狀態變化等等特徵；並依照這條線索，進一步對馬勒《第九交響曲》和貝多芬及舒伯特的晚期風格進行了簡單的探究。我們通過建立起了「告別之聲」與死亡觀、鬥爭與妥協的矛盾性、晚期風格等因素的內在聯繫，指出了「告別之聲」存在的與生命相關聯的重要價值與深刻內涵。</p><p>【參考文獻】<br>[1] 王振蒙，《論舒伯特鋼琴小品 D946 No.2 中的「死亡意象」》，黃河之聲，2019 年 11 期。<br>[2] 張晨，《馬勒&lt;第九交響曲&gt;的「告別」敘事》，中央音樂學院學報，2019 年 03 期。<br>[3] 瞿楓：《幻影」之謎:舒伯特晚期藝術歌曲中的死亡書寫》，中國音樂學，2019 年 02 期。<br>[4] 黃鍵，《馬勒音樂中的死亡內涵初探》，交響（西安音樂學院報），2018 年 04 期。<br>[5] 瞿楓，《舒伯特「晚期風格」研究 ：1827— 1828》，上海音樂學院博士學位論文，2015 年，第 38— 46 頁。<br>[6] 伍維曦，《終結與濫觴——舒伯特晚期風格中的死亡意象》，書城，2015 年 01 期。<br>[7] 鄧軍，《貝多芬&lt;第九交響曲&gt;的「歡樂頌」圖景——探究末樂章「音樂」與「詩」對於作品結構的深層意義》，星海音樂學院學報，2015 年 02 期<br>[8] 愛德華·薩義德，《論晚期風格》，閻嘉譯，生活・讀書・新知三聯書店，2009 年。<br>[9] 西奧多·阿多諾，《貝多芬：阿多諾的音樂哲學》，彭淮棟譯. 聯經出版事業股份有限公司, 2009。<br>[10] 孫國忠，《馬勒交響曲的哲理內涵》，中國音樂學，1989 年 04 期。<br>[11] 漢斯利克，《論音樂的美——音樂美學修改新譯》，楊業治譯，人民音樂出版社，1978 年，第 39 頁。<br>[12] 薛毛毛，《貝多芬晚期風格中的「非英雄」性—以晚期五首鋼琴奏鳴曲爲例》，上海音樂學院碩士畢業論文。<br>[13] Vera Micznik, The Farewell Story of Mahler’s Ninth Symphony, 19th-Century Music (1996) 20 (2).<br>[14] Kolodin, Irving (1975). The Interior Beethoven. New York: Alfred A. Knopf.<br>[15] David B. Greene, Mahler, Consciousness and Temporality (New York: Gordon and Breach Science Publishers, 1984).<br>[16] Constantin Floros, Gustav Mahler: The Symphonies, trans. Vernon and Jutta Wicker, ed. Reinhard G. Pauly (Portland: Amadeus Press, 1993).<br>[17] Donald J. Grout and Claude V. Palisca, A History of Western Music (4th edn. New York, 1998), p760.<br>[18] Gustav Mahler: A Study of His Personality and Work, Paul Stefan, trans. T. E. Clark (New York, 1913), pp. 142-43, and 124-25.<br>[19] Rose Rosengard Subotnik, Adorno’s Diagnosis of Beethoven’s Late Style: Early Symptom of a Fatal Condition, Journal of the American Musicological Society (1976) 29 (2): 242–275.<br>[20] Michael Spitzer, Music as Philosophy: Adorno and Beethoven’s Late Style, Musical Meaning and Interpretation, 2006</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Music </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看Windows电池容量</title>
      <link href="/2020/09/15/tech/%E6%9F%A5%E7%9C%8BWindows%E7%94%B5%E6%B1%A0%E5%AE%B9%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/09/15/tech/%E6%9F%A5%E7%9C%8BWindows%E7%94%B5%E6%B1%A0%E5%AE%B9%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近有同学让我帮忙查一下掉电之类的问题啊，然后我发现我并不知道如何查看电池电量。查了一下发现这个方法可用，记录一下。</p><a id="more"></a>  <p>使用<strong>管理员权限</strong>的 cmd 或者 powershell 输入：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">powercfg</span> /batteryre<span class="keyword">port</span> /output “C:\battery_report.html”</span><br></pre></td></tr></table></figure><p>这个指令会生成一个电池使用情况的 html 文件到<code>C:\battery_report.html</code>。当然这个地址是可以改的，比如改到桌面上。成功后，终端会返回：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Battery life <span class="keyword">report</span> saved <span class="keyword">to</span> <span class="keyword">file</span> path C:\battery_report.html.</span><br></pre></td></tr></table></figure><p>找到这个文件打开即可。里面包含最大电池容量和当前最大可充入电池容量，以及一些其他的电池使用情况信息。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常用语法 —— 数据结构</title>
      <link href="/2020/09/14/tech/Cpp%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/09/14/tech/Cpp%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为太久没用 C++了，导致很多细节的语法已经记不得了。借着这一次刷的少量题回顾一下 C++的语法，以后总会有时候能用上的。</p><a id="more"></a>  <h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">s.find(s1);  <span class="comment">//找到第一个出现的s1</span></span><br><span class="line">s.substr(pos, n);  <span class="comment">//截取从pos开始的n个字符</span></span><br><span class="line">s.substr(pos);     <span class="comment">//截取从pos开始的所有字符</span></span><br><span class="line">s.replace(pos, n , s1); <span class="comment">//将s从pos开始的n个字符替换为s1</span></span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><div class="table-container"><table><thead><tr><th>语法</th><th>含义</th></tr></thead><tbody><tr><td><code>vector&lt;int&gt; v1</code></td><td>默认为空的 vector</td></tr><tr><td><code>vector&lt;int&gt; v1(v2)</code></td><td>默认 v2 副本的 v1</td></tr><tr><td><code>vector&lt;int&gt; v1(n, i)</code></td><td>默认内容为 n 个元素 i</td></tr><tr><td><code>vector&lt;int&gt; v1(n)</code></td><td>默认内容为 n 个默认元素，以 int 为例，应是构建了包含 n 个 0 的 vector</td></tr></tbody></table></div><h3 id="Vector的基本操作"><a href="#Vector的基本操作" class="headerlink" title="Vector的基本操作"></a>Vector的基本操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line">test.push_back(<span class="number">1</span>); <span class="comment">// 插入新元素</span></span><br><span class="line">test.size();        <span class="comment">// 返回长度</span></span><br><span class="line">test.erase(test.begin()+<span class="number">2</span>); <span class="comment">// 删除第3个元素（下标为2的元素）。但这个操作很慢，不建议</span></span><br></pre></td></tr></table></figure><p><strong>Vector 的迭代器访问</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=test.begin();it!=test.end();it++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p><strong>算法</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">reverse(test.begin(), test.end());  <span class="comment">//颠倒</span></span><br><span class="line">sort(test.begin(), test.end()); <span class="comment">//升序排序</span></span><br></pre></td></tr></table></figure></p><p>*<strong>为了降序排序</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(test.begin(),test.end(),Comp);</span><br></pre></td></tr></table></figure></p><p>需要定义一个特殊的比较函数，比较函数的输入为 vector 内含有的元素。对于结构体，可以使用类似的方法定义.</p><p>*<strong>当插入对象是数组时</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> out[<span class="number">3</span>][<span class="number">2</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>,   </span><br><span class="line">             <span class="number">3</span>, <span class="number">4</span>,  </span><br><span class="line">            <span class="number">5</span>, <span class="number">6</span> &#125;;  </span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>*&gt; v1;  </span><br><span class="line">    v1.push_back(out[<span class="number">0</span>]);  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v1[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h2><p>在进入 Map 之前我们需要先搞定 Pair 类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; test;</span><br><span class="line">pair&lt;int, int&gt; test(1, 2);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;test.first&lt;&lt;<span class="built_in">endl</span>&gt;&gt;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;test.second&lt;&lt;<span class="built_in">endl</span>&gt;&gt;;  <span class="comment">//对pair元素的访问</span></span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>类似 python 的字典（不过灵活度大幅度下降。）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map_int;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; map_string;</span><br></pre></td></tr></table></figure><p>其馀的初始化方法和 Vector 雷同，故不赘述。</p><h3 id="Map的基本操作"><a href="#Map的基本操作" class="headerlink" title="Map的基本操作"></a>Map的基本操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; test;</span><br><span class="line">test.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>));  <span class="comment">//插入新元素，使用该方法插入已经存在的键时会报错</span></span><br><span class="line">test[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">//该方法结果和上条效果相同；不存在该键的情况下会新建，反之会覆盖</span></span><br><span class="line">test.size(); <span class="comment">//字典的大小</span></span><br></pre></td></tr></table></figure><p><strong>查找/读值</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l_it=test.find(<span class="number">1</span>); <span class="comment">//查找元素，返回一个迭代器；若迭代器指向map的末尾，则不存在该元素</span></span><br><span class="line"><span class="keyword">if</span>(l_it==test.end())</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"we do not find 112"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;l_it-&gt;second&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//由于返回的对象是一个迭代器，而迭代器指向的是一个Pair类型，故可以通过Pair类型的访问方法访问</span></span><br></pre></td></tr></table></figure></p><p><strong>遍历</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = mp.begin(); it != mp.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p><strong>删除</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp.erase(k);<span class="comment">//删除某一个键</span></span><br><span class="line">mp.erase(it);<span class="comment">//删除迭代器指向对象</span></span><br></pre></td></tr></table></figure></p><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a><strong>unordered_map</strong></h3><p>效果和 map 非常相似，但是一般情况下，使用 unordered_map 更快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="Stack-amp-Queue"><a href="#Stack-amp-Queue" class="headerlink" title="Stack &amp; Queue"></a>Stack &amp; Queue</h2><p><strong>Stack</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.size();</span><br><span class="line">s.empty(); <span class="comment">//判断是否为空</span></span><br><span class="line">s.pop();   <span class="comment">//弹出栈顶元素但不返回</span></span><br><span class="line">s.top();   <span class="comment">//返回栈顶元素</span></span><br><span class="line">s.push();  <span class="comment">// 加入新元素</span></span><br></pre></td></tr></table></figure><p><strong>Queue</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.empty(); <span class="comment">//如果队列为空返回true，否则返回false</span></span><br><span class="line">q.size(); <span class="comment">//返回队列中元素的个数</span></span><br><span class="line">q.pop();  <span class="comment">//删除队列首元素但不返回其值</span></span><br><span class="line">q.front(); <span class="comment">//返回队首元素的值，但不删除该元素</span></span><br><span class="line">q.push(); <span class="comment">//在队尾压入新元素</span></span><br><span class="line">q.back(); <span class="comment">//返回队列尾元素的值，但不删除该元素</span></span><br></pre></td></tr></table></figure><h2 id="Priority-queue"><a href="#Priority-queue" class="headerlink" title="Priority_queue"></a>Priority_queue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq;  <span class="comment">//默认是最大堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq; <span class="comment">//最小堆</span></span><br></pre></td></tr></table></figure><p>其馀操作如同普通的 queue。</p><p><strong>自定义数据结构</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    int x;</span></span><br><span class="line"><span class="class">    tmp1(int a) &#123;x = a;&#125;</span></span><br><span class="line"><span class="class">    bool operator&lt;(const tmp1&amp; a) const</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return x &lt; a.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//方法2</span></span><br><span class="line"><span class="class">struct tmp2 //重写仿函数</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    bool operator() (tmp1 a, tmp1 b) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        return a.x &lt; b.x; //大顶堆</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">int main() </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    tmp1 a(1);</span></span><br><span class="line"><span class="class">    tmp1 b(2);</span></span><br><span class="line"><span class="class">    tmp1 c(3);</span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1&gt; d;</span></span><br><span class="line"><span class="class">    d.push(b);</span></span><br><span class="line"><span class="class">    d.push(c);</span></span><br><span class="line"><span class="class">    d.push(a);</span></span><br><span class="line"><span class="class">    while (!d.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; d.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        d.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;</span></span><br><span class="line"><span class="class">    f.push(c);</span></span><br><span class="line"><span class="class">    f.push(b);</span></span><br><span class="line"><span class="class">    f.push(a);</span></span><br><span class="line"><span class="class">    while (!f.empty()) </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line"><span class="class">        cout &lt;&lt; f.top().x &lt;&lt; '\n';</span></span><br><span class="line"><span class="class">        f.pop();</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p><p>这里主要使用第一种方法吧：在数据结构重载运算符。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>喧譁記</title>
      <link href="/2020/09/07/essay/%E5%96%A7%E5%93%97%E8%AE%B0/"/>
      <url>/2020/09/07/essay/%E5%96%A7%E5%93%97%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-HABcVGNu" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3947466" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>　　一早去等校車回本部，再從本部到江灣校區。去找教務處問保研的事情。這個事情攪成一團實在令人感到難受。吃晚飯的中午，教務處恐怕是沒人的，於是我坐在江灣的圖書館，開始回憶前段時間發生的事情，試圖記下那麼一些遊絲。<br>　　<br><a id="more"></a>  </p><p>　　我果然一點也不喜歡接納新的東西。或者說從一個相對舊的地方往相對新的地方移動。這樣空間上的移動給人一種難以理解的落寞感，這既不是懷念我正準備離開的地方，也不是對於目的地的抗拒。只是一種，潛意識裡的對於「移動」的排斥。</p><h2 id="09-06"><a href="#09-06" class="headerlink" title="09-06"></a>09-06</h2><p>　　走出地鐵站，然後我感覺那種令人不爽的溫度照在了我的額頭上。這是典型的、我所熟悉的上海的陽光的感觸，但是我一點也不喜歡。飛機提前四十分鐘到達了我的目的地，我坐在飛機上是這提前四十分鐘的意義，可惜沒有。在降落的時候，我看着下方的景色，但實話說這和我起飛的時刻看見的風景並不二致。難以想象這段短暫地旅程中，某種轉換就完成了。<br>　　在機場前往包裹提取處的一路上，我感覺我自己的步速開始慢慢地提高，感到了一種所謂「pressure」的東西。在機場囫圇點了個 KFC 的套餐，隨後就開始了返校的道路。這完全沒什麼新鮮事可言，除了睜眼看見的四處都有的人，以及閉眼也能想象到的四處都有的人。<br>　　出地鐵站的一瞬間，我或許在期待我眼前所看見的景色能有哪怕那麼一點點的不同，使我認爲，「移動」不完全是無謂的事情。但映入的一起是反胃的相似性。從地點 A 時間 T0 的離開，到達地點 B 時間 T1，隨後在 T2 離開地點 B，在 T3 回到了 A。我期望 T3 的 A 和 T0 的 A 不再是一個東西了。但如此的相似。這讓我覺得，我的 T0~T3 的時間消失了，從故事的一個結局回到了這個故事的開頭，而且這個故事是如此的單調無聊。<br>　　「新加坡的夏天令人厭煩，因爲它的周而復始是以天爲單位的；而正常的情況是以年爲單位的，這或許能讓人舒服那麼一點。」我想起昨日（9 月 5 日）在自行車上移動的時候說的話。事情沒能得到推進——我產生了這樣的印象。<br>　　「我實在是把我的大學過得太無聊了啊。」<br>　　伴隨着再熟悉不過的一切，我回到了自己的寢室。看着混亂不堪的景象，桌面上積攢的厚厚的灰塵，我連撣撣灰的想法也沒有。這個地方不討我喜歡，從最開始就是。狹小逼仄的空間，周而復始的時間。看着從門外進來的室友 S，我問：「走吧，去新寢室轉轉。」<br>　　新寢室也並沒有什麼特別的。但是最詭祕的是，我回到了大一的住宿的旁邊。於是完成了從 A 到 B 再從 B 回到 A 的又一個實踐。但我不覺得這段時間它消失了，我在這段時間裡失去了很多，卻沒什麼收穫。這段時間它沒有消失，它切實地傷害了我。然而這也確實是一種循環，一種反覆的消耗。新寢室莫名地和高中的寢室相似，但在這種相似性中我感受不到親切。自回到四川以後，和老同學的見面變成了一件時常發生的事情。但我說不清緣由。「既然你不喜歡和人打交道，爲什麼在大學裡主動承擔班委的工作呢？」這是一個朋友問我的。我不知道。矛盾性是有趣的東西，但在這一點上我完全不覺得有趣，倒不如說有一種悲劇的特徵。<br>　　我記得自己原來說過，一個人開始經常地回憶的時候，他就老了。出於某種預感，我才做了這樣一個預言吧。假設前方存在的分岔的路，我究竟是想走上那條前往我不知道方向的道路呢，還是那個回到過去的某個節點的道路呢。或許這兩條路是一條路，只是某種錯覺讓我以爲我有的選罷了。<br>　　晚飯我去了一家我之前就常去的茶餐廳。習慣性地點了菠蘿油。在我咬下第一口的時候，我感覺那種甜度、鹹度、溫度都和我記憶里的一模一樣，既是我所希望嘗到的味道，又是我所不希望嘗到的味道。我是出於什麼目的選擇了這樣一種東西呢，這種在我還沒有嘗試的時候就知道了結局的食物。我大概意識到了「膩煩」這個詞的含義，但又終於覺得自己下次還會再來這個餐廳，再一次點下這個菠蘿油，因爲 pattern 就是這樣，這個人的 pattern 就是這樣。就是類似那種「到了一個新的餐廳一定會點它的招牌菜」這樣瑣碎的特徵，構成了這個人的生活。<br>　　回到了自己的寢室，看着亂成一團的景象，開始大費周折地對其進行整理。不斷地找出各種意料之外的東西，各種瑣碎的日常浮現出來，但終究沒有特別的意義可言，這些時間確實沒有給我留下什麼特別值得回憶的事情，仿佛它不曾存在。</p><h2 id="09-05"><a href="#09-05" class="headerlink" title="09-05"></a>09-05</h2><p>　　難得地把三弟約出來了。雖說這次在成都呆的時間非常長，但其實沒見過幾面，好幾次事情都因爲自己或者他有這樣或者那樣的事情被取消了。但雖說是難得的見面，甚至帶有自己給自己送行意味的見面，也沒有特別的不同。除了破天荒地我去了一趟電影院——電影我是一竅不通的，但不影響我欣然接受了這個安排。這可能是一種介入。<br>　　每次吃飯聽三弟談他在學校里的生活之類的，就由衷地覺得很好：他過着一個不錯的生活啊，不像我這樣子。但這不是某種介入；介入在高三最後寢室告別的時候就結束了。<br>　　於是我說起當時在哈爾濱遇到的那對父子的事情。我總覺得我自己所看見的東西太少了，世界太多隱祕的角落我永遠也碰不到；甚至在我渾然不知的時候，生命就結束了——它總有一天會拋棄我去完成自己的工作。「我想，支教、研究員或者做一個軍官都是非常不同的體驗吧。」我說，「我都想試試，但是人生它只有一次，社會也不會允許我貪心地嘗試別的東西」。我想起在當時高考的時候，聽三弟說他有報考軍校的打算。我想那就是截然不同的、但是聽起來令人興趣盎然的道路。雖說最後還是沒去，但終究貢獻了一個相當不錯的可能性。「我當時聽說要 4 點起來跑操，我就不想去了」。我想，就是因爲這個要 4 點起來跑操它才顯得有趣啊。<br>　　這實在是矛盾的事情。我所厭惡的「移動」，我搞不清楚。我厭惡停在某個地方，卻也厭惡離開這個地方。我清楚有許多的事情，我或許會覺得有趣，我或許會想去探查一番，那絕對不是我所厭惡的。但是我能到那裡去嗎？我感覺到有一個巨大的軌道，或者精緻的台本在我的手中。事情依照某種順序和必然性發生。即使有些時候一些巨大的爆發會脫離這樣的軌道，但最終會被拉回來。這軌道大概是我臆想出來的東西吧；這軌道必將通向一個無趣且嘈雜的世界。<br>　　我們討論電影裡關於時間設定的問題。三弟爲了解釋電影裡的一個現象，給出一種假說：逆時間裡的人對於正常時間有更高的干預能力。正常時間的人會因爲逆時間中人物的行爲得到修正。我說正常時間裡的人奉行着自己的 free will 嗎？他回答說是，因爲這些事實是通過這個人所有的時刻的 free will 的疊加組成的，這一切沒有因果而只是事實。那這是他們 free will 的結果呢，還是這個事實的結果呢？這裡的 free will 或許只是某種意義的事實罷了。對於時空悖論的解釋於我而言最終總會進入一種相當消極的解釋。<br>　　或許只是有些事情因爲在軌道之外，它們才顯地有趣；而爲了讓這些事情保留着他們的趣味，軌道才存在。這不是什麼因果關係，而只是事實。我的心裡存在這樣的軌道的同時，也存在好惡。軌道和好惡構成的瑣碎是這個人的性質。或許有的人的軌道並不存在，有的人的好惡並不存在，但是存在別的東西，比如扳手、比如迷宮、比如門。在衆多的喧譁之中，保存着看見的和看不見的事物；扳動這些扳手，遊蕩在着迷宮或者越過那扇門並不是某種特質，這些事物的存在本身是那個特質。即使，這個人離開了這個軌道，也不意味着軌道出現了錯誤，而是軌道隱含着一個分支，這個分支是最開始就存在的，它是事實的一部分。<br>　　我把我的大學過得太無聊了，終究不是大學的性質，而是我的性質：是因爲主角是我，它才顯地無聊。我所排斥的「移動」恐怕是排斥那移動中的我自己吧……</p><h2 id="09-07"><a href="#09-07" class="headerlink" title="09-07"></a>09-07</h2><p>　　我不知道最後我討論到了這個事情上……是一種很難以解釋的鬱悶造成的。就像上文討論的軌道或者好惡之類的事情，本身就具有主觀性，因爲這些成段成段的討論和廢話並無差別。「這不是理所應當的事情嗎！？」或許是吧。其實這些敘述完完全全脫離了我動筆的初衷，但我還是決定忠實地把這些記錄下來，算是給我在成都滯留的大半年生活畫上一個句號。</p><p>廙水<br>2020-09-07<br>復旦大學江灣校區圖書館</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手記 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿拉伯数字转罗马数字</title>
      <link href="/2020/08/26/tech/%E9%98%BF%E6%8B%89%E4%BC%AF%E8%BD%AC%E7%BD%97%E9%A9%AC/"/>
      <url>/2020/08/26/tech/%E9%98%BF%E6%8B%89%E4%BC%AF%E8%BD%AC%E7%BD%97%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为近日在准备保研的刷题…所以得看各种奇怪的题目。但事实上由于太久没有写算法了，现在还在康复期，先做些简单的东西好了…其实是我觉得这个东西什么时候可能会用上？</p><a id="more"></a>  <h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">    string = <span class="string">""</span></span><br><span class="line">    ones = [<span class="string">"I"</span>, <span class="string">"X"</span>, <span class="string">"C"</span>, <span class="string">"M"</span>]</span><br><span class="line">    fives = [<span class="string">"V"</span>, <span class="string">"L"</span>, <span class="string">"D"</span>]</span><br><span class="line">    ct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num:</span><br><span class="line">        n = num % <span class="number">10</span></span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>:</span><br><span class="line">            s = ones[ct] * n</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">4</span>:</span><br><span class="line">            s = ones[ct] + fives[ct]</span><br><span class="line">        <span class="keyword">elif</span> n &lt;= <span class="number">8</span>:</span><br><span class="line">            s = fives[ct] + ones[ct] * (n - <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">9</span>:</span><br><span class="line">            s = ones[ct] + ones[ct + <span class="number">1</span>]</span><br><span class="line">        string = s + string</span><br><span class="line">        ct += <span class="number">1</span></span><br><span class="line">        num //= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> string</span><br></pre></td></tr></table></figure><h2 id="阿拉伯数字转罗马数字规则"><a href="#阿拉伯数字转罗马数字规则" class="headerlink" title="阿拉伯数字转罗马数字规则"></a>阿拉伯数字转罗马数字规则</h2><div class="table-container"><table><thead><tr><th>符号</th><th>数字</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table></div><p>例如以下的对应：</p><div class="table-container"><table><thead><tr><th>罗马数字</th><th>阿拉伯数字</th></tr></thead><tbody><tr><td>III</td><td>3</td></tr><tr><td>VI</td><td>6</td></tr><tr><td>XVI</td><td>16</td></tr></tbody></table></div><p><strong>特殊规则</strong><br>除了上述简单的累计外，还有一条特殊规则：对于$4\times 10^n$或$9\times 10^n$，应该使用特殊的表达方法：</p><div class="table-container"><table><thead><tr><th>罗马数字</th><th>阿拉伯数字</th></tr></thead><tbody><tr><td>IV</td><td>4</td></tr><tr><td>IX</td><td>9</td></tr><tr><td>XL</td><td>40</td></tr><tr><td>XC</td><td>90</td></tr><tr><td>…</td></tr></tbody></table></div><p>在这个规则下，<code>MCMXCIV</code>代表 1994：M：1000；CM：900；XC：90；IV：4。这意味着对于一个阿拉伯数字，最多需要 4 个符号，但基本上还是遵循十进制的规律，所以毫无竞争力可言。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>野士</title>
      <link href="/2020/08/22/essay/poems/%E9%87%8E%E5%A3%AB/"/>
      <url>/2020/08/22/essay/poems/%E9%87%8E%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>只是翻出了高中時期的周記本，想起最後的兩頁記了些「見不得人」的東西。既然找出來了，也就把它記下來吧。當時晚自習實在看不了教材的時候，相較看小說，果然還是看自己的東西更加有趣。</p><a id="more"></a>  <h2 id="野士"><a href="#野士" class="headerlink" title="野士"></a>野士</h2><p>　　棉芯將燃燒殆盡，<br>　　不，別碰那鏡子。<br>　　別碰那些無趣的嘆息，<br>　　讓它們繼續明亮。</p><p>　　卻棄了你手裡的煙火！<br>　　小心它們燃成了灰，<br>　　灼了你的手。</p><p>　　不，別向無物禱告。<br>　　把它們放在地上，<br>　　等待飄忽的風，<br>　　將它們燃盡。</p><p>　　　　——作於某年 12 月 15 日</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 詩歌？ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『ヒカルの碁』觀感</title>
      <link href="/2020/07/16/essay/%E8%A7%82%E6%84%9F/%E6%A3%8B%E9%AD%82/"/>
      <url>/2020/07/16/essay/%E8%A7%82%E6%84%9F/%E6%A3%8B%E9%AD%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-XUQEvUBP" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="538824" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="評價：★★★★★"><a href="#評價：★★★★★" class="headerlink" title="評價：★★★★★"></a>評價：★★★★★</h3><p>雖然在完成鋼煉 03 的觀感之後就清楚地意識到了自己不具有寫作觀後感的才能，但終於還是落筆來記錄這一部給我直接震撼的作品。</p><a id="more"></a> <p>距離我第一遍看完這部作品可能已經過去 2 個多月了吧。在這之後，我 開始重複看這部作品；把它的漫畫，揪出來補完了北斗杯；把《北斗特別篇》也完成了。但總有一種意猶未盡的感覺……毫無疑問，這部作品是我到目前爲止看過的一部最爲傑出的作品之一。儘管我一直希望爲它寫一些什麼東西，但總覺得那種感情很模糊，難以構成更具象的文字。</p><p>『ヒカルの碁』直譯過來的話應該叫做《光的棋》，另一個譯法爲《棋靈王》。但私以爲，《棋魂》的翻譯還是更加恰當。這部作品顯然不是講述光一個人圍棋道路的作品，更不是以佐爲和光爲核心的作品。佐爲的離開暗示了關於「傳承」的主題。所謂「神の一手」並不是一個具體的存在，是棋士往下奮鬥的道路。但傳承只是這其中衆多主題之一。</p><p>很難想象一部漫畫作品可以把關於圍棋這種行外看熱鬧的嚴肅主題演繹到這樣的程度。我幾乎是在看過了前幾集之後就篤定這是一部優秀的作品，甚至在期末季連續熬夜看完（特別是名人佐爲兩戰，完全沒有喘息的機會），然後二刷三刷。它所傳達的可怕信念和執念，毫無疑問可以讓觀衆爲之動容。</p><p>這個故事基本上是關於對局和人的故事。圍繞着這個核心，將當時日本棋界的人和事慢慢地抖落出來。以筒井、三谷爲代表的以圍棋作爲愛好的普通學生，以棋士作爲衆生奮鬥的和谷、伊角的院生時代，在棋壇風生水起的新生代（可能也比較老了吧）緒方、倉田，以及當時日本的巔峯塔矢名人。</p><p>整個故事基本上是由幾場重要的對局作爲線索拉開的，對於人物的塑造也幾乎是依賴對局完成的。這其中有關乎劇情發展的重要對局，也有配角們閃爍光芒的「魂」的對局。劇情的發展環環相扣，自然而充滿波折。幾個重要的成長階段也自然合理毫不做作。幾次對局將整部的氣氛嚴肅而積極。我可以清晰地感到這部作品中人物的精神透過方框地屏幕向外湧出，閃爍着他們追求的光。</p><p><strong>佐爲 VS 亮</strong></p><p>佐爲和亮一共對局三次。前兩次使亮產生了巨大的恐懼。從此樹立了追趕光的目標。然而在中學圍棋大賽見到真正的光時大失所望，轉而進軍職業世界。</p><p>亮是一個溫柔的人，但是對於超越自己的對圍棋毫無尊敬的光，展現出了一種毫無動搖的決心。即使是遠比自己強大的，也必須去挑戰，這是通往「神の一手」的唯一道路。</p><p>亮由於自己的名人父親，深深知道棋界的艱難，也對其抱着絕對的尊敬和執着。幾乎可以說是全劇中最爲執着的棋手，具有着遠超光前期決意追趕亮的覺悟和決心。</p><p><strong>佐爲 VS 名人</strong></p><p>佐爲和名人也有三次對局。也是劇情重要的三次對局。其中第一句完成了對於光的引導，讓光產生了「他們對這個如此認真，自己也相認真」的想法。這是光從「隨便玩玩」到「認真對待」的重要對局。儘管這局不了了之，但也爲後面的新初段埋下了伏筆。</p><p>第二局新初段賽，佐爲佐爲棋手的執念在這裡爆發。這一戰的分爲塑造將視角交給了名人和觀衆，通過頂尖棋士的評論，將這一戰的「緊張感」渲染到了極致。</p><p>第三局線上圍棋戰，觀衆變爲了世界的業餘棋手。這一次將上一戰未完成的遺憾結束了，也終於開始了佐爲的離別章節。這一章展現的是名人的意志。「這就是名人的棋，絕不退讓，一定會贏。」。結束之後，名人自嘲 「名人我下出這樣一盤棋，也不算壞吧。」名人也有名人的追求。後面名人擺脫成見，隱退棋壇，遊歷四方，不斷地學習和感受圍棋。完成了對於名人角色的收束。</p><p>第三戰光的發現終於讓佐爲意識到了自己存在的意義，即便認識到了自己可能永遠無法碰到神之一手，但還有後輩在不斷地、不斷地朝着那個方向前進。自己作爲傳承者的使命已經完成了，終於放下了自己對於圍棋地熱情，從而不可避免地邁向了消失的結局。</p><p><strong>光 VS 和谷</strong></p><p>在對局中出現對話是常見的手法。和谷和光之一戰，決定了和谷能否就此走向職業棋士。接受老師鼓勵的和谷拼盡全力，發現自己穩操勝券時，腦中迴響的老師的話。這裡算是一個剛剛將要進入棋壇新人的思想吧。樸實且充滿着希望，然而這一戰輸了。</p><p>哎……實在是太多了。光和伊角兩次對局，光和洪秀英的對局，越智和社的對局。這是一羣人展現的對於圍棋這個事業的執着和熱愛。就是這樣單純的故事也能打動很多很多的人了，對這些棋手自然尊敬起來。</p><p>佐爲的離去是在衆多伏筆下必然的事件；如果作者在之後執意讓離開的佐爲回到這世間，儘管滿足了許多的讀者，卻會成爲這部作品的敗筆。將佐爲的意志寄托在光對圍棋的愛中，是最優的解。佐爲的離開和光的成長是密不可分的，道路總是需要一個人走下去的，對於圍棋的愛也不應當是爲了某個人才堅持下去，這是一條自我的、自私的道路。在光與伊角的一局中，那隻突然出現的手和扇子，讓我整個人愣住了。原來這個謎題是這樣的啊……作者實在是……完全在意料之中的解法，但是在長時間的情感烘托之下呈現絕對的殺傷力。光重新帶者佐爲的執念回到了棋壇。應該是佐爲真正滿意的結局吧。</p><p>「傳承」這個主題在北斗杯再一次托出，完成了光回歸棋壇的結局，留下了無窮的可能。這部作品將棋士的精神很好地展現在了所有讀者的面前，即使作爲一個對圍棋一知半解的門外漢，也不得不感到觸動——爲了一個熱愛的事業竟然能夠如是執着地爲之奮鬥，這是如此值得欽佩的事情！卻在現代的世界中越來越少見，實在是令人遺憾。</p><p>我果然是，很不適合寫觀後感……此刻真切地感到自己完全沒有足夠的能力對自己發自內心喜愛的這部作品做出真正恰到好處或者生動的評價。多年以後，我一定會回到這部作品來，看看自己的人生是不是過得就那樣淒涼而單調。或許每個人都藏着一顆棋士的心，奮鬥且掙扎、不停地挑戰、執着地追求更強的棋士的心，在各自熱愛的領域裡將自己的愛和執着傳承下去……</p><p>這是一部可怕的作品。</p>    <div id="aplayer-pYmoOVIZ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="538768" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 觀感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - How to best use Syntax in SRL</title>
      <link href="/2020/07/16/scholar/paper/Syntax_in_SRL/"/>
      <url>/2020/07/16/scholar/paper/Syntax_in_SRL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文讨论如何把句法信息加入 SRL 任务。其中提到了三种方法：使用句法信息作为输入；使用句法信息组成 Multi-task；同时使用上述两种方法，组成 auto-encoder。本文使用 CoNLL’05 和 CoNLL’12 作为训练集进行测试。</p><a id="more"></a>  <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><h3 id="外部信息"><a href="#外部信息" class="headerlink" title="外部信息"></a>外部信息</h3><p>将外部信息加入 NLP 任务的思想在近几年中趋势越发明显。关于这个问题，有三种主流的做法：</p><ol><li>加入 Input：外部信息作为神经网络的额外输入特征。</li><li>作为 Output：神经网络在训练主任务的同时需要对这些信息进行 Multi-task 训练。</li><li>Auto-encoder：同时将外部信息作为神经网络的 Input 和 Output。</li></ol><p>但是这些研究主要停留在了一些浅层信息，例如将 POS 标签和序列标注任务结合。而那些标注句法依赖等等“较长”句法特征信息则没有被仔细研究。这篇文章就是针对这一点进行一个补充。</p><p>在这篇文章中，主要讨论了三个问题：</p><ol><li>应该如何将句法信息加入作为<strong>word-level featrues</strong>？</li><li>如何最好地表达句法信息？</li><li>句法信息表达的选择对于结果有多少影响？</li></ol><h3 id="SRL-System"><a href="#SRL-System" class="headerlink" title="SRL System"></a>SRL System</h3><p>一个语法标注系统能够提取 predicate-argument 结构。在研究早期句法信息一直是 SRL 的重要组成部分，然而当下的 SOTA 模型并没有显式地包含句法信息。这篇文章希望通过实验证明句法信息对于 SRL 系统的重要作用。</p><p>在这篇文章中，作者将外部信息表示为离散特征向量。其中有三类表示：</p><ol><li>Full-C：全成分树表示</li><li>SRL-C：SRL-specific span 表示</li><li>Dep：依赖树表示</li></ol><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>对于不同的整合方式，在语料库 CoNLL’05 和 CoNLL’12 上进行测试获得结果</p><h2 id="句法表示"><a href="#句法表示" class="headerlink" title="句法表示"></a>句法表示</h2><h3 id="Full-C"><a href="#Full-C" class="headerlink" title="Full-C"></a>Full-C</h3><p>参照 Gomez-Rodrıguez and Vilares 提出的方法，将成分分析树进行向量化。为了表示这个提出下列标注：</p><ol><li>$n(w_i)$：指$w_i$和$w_{i+1}$间的共有父节点的数量。</li><li>$l(w_i)$：编号最小的父节点的 non-terminal 标签。如果是 terminal，则为 S。</li><li>$r(w_i)$：$n(w_i) - n(w_{i-1})$</li></ol><p>通过记录所有节点的上述信息，可以完全还原成分分析树。示例如下：</p><center><img src="/images/Research/Full-c.jpg"/></center><h3 id="SRL-C"><a href="#SRL-C" class="headerlink" title="SRL-C"></a>SRL-C</h3><p>只有一小部分的成分分析树中的成分是发挥了作用的。这意味着将整个成分分析树都进行编码可能不是最优解。因此仅保留最有可能有利于标签分类的成分是必要的一个操作。为此，作者使用了剪枝算法，将其中的部分 argument 收集起来，并将无关的部分滤除。对于滤除的结果使用标准 BIO 标记法标记。</p><ol><li>O：单词在任何一个候选成份外</li><li>B：单词是某一个候选成分的第一个单词</li><li>I：单词在某一个候选成分中</li><li>A：单词在一个介词短语中</li><li>V：正在考察的 predicate 的核心动词</li></ol><p>这个标记在上面例图中已经标明。</p><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p>通过依赖树，编码的仍然是成分信息。其具有下列的标签：</p><ol><li>Left/Right：这个但错左右拥有的依赖数。</li><li>Edge：这个单词是管辖这个词（左边/右边/不是）最依赖这个词的词。</li><li>RG（Relative distance to governor）：这个词与其 Governor 间的距离。</li><li>DL（Dependent label）：指向这个词的 denpendent 标签。</li></ol><p>示例如下：</p><center><img src="/images/Research/Dep.jpg"/></center><h2 id="如何使用外部信息？"><a href="#如何使用外部信息？" class="headerlink" title="如何使用外部信息？"></a>如何使用外部信息？</h2><p>加入外部信息的方法如同前文所说，有三：</p><ol><li><strong>Input</strong>：将外部信息和 ELMo 提供的词向量相连。其中依赖树通过将生成的成分树进行变换得到，以保证两种划分方法的一致性。</li><li><strong>Output</strong>：同时预测 SRL 和句法特征，最后使用的损失函数是这两部分的和。</li><li><strong>Anuto-encoder</strong>：将外部信息作为特征输入，并同时作为 multi-task 训练的对象，使得这个方法呈现出 encoder 的特性。</li></ol><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>实验一共进行了 10 组：“3 种使用外部信息的方法”x“3 种将文本句法特征向量化的方法” + 1 个 baseline。实验在 CoNLL’01 和 CoNLL’12 上进行。</p><h3 id="主要结果"><a href="#主要结果" class="headerlink" title="主要结果"></a>主要结果</h3><center><img src="/images/Research/SRL-res.jpg"></center><p>结果表示，句法信息确实是对 SRL 能力有积极提升作用。其中，Full-C 获得了更优于 Dep 的实验结果。作者认为这是由于成分树更加接近于 SRL 的信息。此外 SRL-C 的方法略好于 Full-C 方法，在集外预测时也更具优势。</p><p>并且使用 Multi-task 在这个任务中并没有体现出非常好的效果，而其馀两种方法效果相当。</p><h3 id="与现有系统的对比"><a href="#与现有系统的对比" class="headerlink" title="与现有系统的对比"></a>与现有系统的对比</h3><p>作者将本次实验中表现最为出色的 SRL-C used as Input 作为对比，和现有的各个工作进行对比。这个方法相较于现在已有的模型有略微的提升，但是结果并未明显胜出 ensemble 方法。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP术语集 - Grammar</title>
      <link href="/2020/07/15/scholar/NLP/Grammar/"/>
      <url>/2020/07/15/scholar/NLP/Grammar/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最近开始看 NLP 的论文啊，觉得好多术语都不知道是个什么，就只能一边看一边查咯。</p><a id="more"></a><h3 id="Predicate：谓词"><a href="#Predicate：谓词" class="headerlink" title="Predicate：谓词"></a>Predicate：谓词</h3><p><a href="https://www.grammar-monster.com/glossary/predicate.htm" target="_blank" rel="noopener">Link</a></p><blockquote><p>The predicate is the part of a sentence (or clause) that tells us what the subject does or is. To put it another way, the predicate is everything that is not the subject.</p></blockquote><p>或参照韦氏词典的定义：</p><blockquote><p>the part of a sentence or clause that expresses what is said of the subject and that usually consists of a verb with or without objects, complements, or adverbial modifiers.</p></blockquote><p>简而言之谓词是描述 Subject 做什么或者是什么的一个<strong>成分</strong>，并不一定是一个词。一个谓词的 Core 是一个动词。</p><p><strong>Easy Examples of Predicates</strong></p><ul><li>Adam <em> <strong>lives</strong> in Bangor</em>.</li><li>The telegram <em> <strong>contained</strong> exciting news</em>.</li><li>The girls in our office <em> <strong>are</strong> experienced instructors</em>.</li></ul><p><strong>Real-Life Examples of Predicates</strong></p><ul><li>True friends <em> <strong>appear</strong> less moved than counterfeit</em>. (Greek philosopher Homer)</li><li>Words empty as the wind <em> <strong>are</strong> best left unsaid</em>. (Homer)</li><li>People can <em> <strong>come</strong> up with statistics to prove anything</em>. Forty percent of all people <em> <strong>know</strong> that</em>. (Homer Simpson)</li><li>With $10,000, we would <em> <strong>be</strong> millionaires</em>! We <em> <strong>could buy</strong> all kinds of useful things like … love</em>. (Homer)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>土豆湯製法</title>
      <link href="/2020/07/12/essay/cookbook/%E5%9C%9F%E8%B1%86%E6%B3%A5/"/>
      <url>/2020/07/12/essay/cookbook/%E5%9C%9F%E8%B1%86%E6%B3%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因爲一個人在家，看着家裡有土豆，於是打算就試一次土豆泥。但是土豆泥總感覺味道不如土豆湯，所以打算改做土豆湯，而家裡又沒有用來攪碎蔬果的東西，所以用豆漿機代替。本來戰戰兢兢的，後來發現不僅沒有出問題，而且效果還不錯，而且做法簡單地不可思議。</p><a id="more"></a>  <p><strong>口感</strong></p><ul><li>和西餐廳能吃到的口感相似，不過因爲第一次做多放了水，所以會顯得稀一點。</li><li>顏色呈粉紅色</li></ul><p><strong>材料</strong><br>下述材料是兩人份的。</p><ul><li>正常大小土豆一個</li><li>火腿腸（粗）：1/4 支</li><li>牛奶 250ml</li></ul><p><strong>步驟</strong></p><ul><li>將土豆切丁（很小的類型）</li><li>將火腿腸切丁</li><li>將牛奶導入上述混合物，並加入 50ml 左右的水</li><li>使用豆漿機打碎</li><li>適量放鹽，結束</li></ul><p><strong>實驗失敗經歷</strong></p><ol><li>實驗 001<ul><li>第一次實驗使用了半根火腿腸，發現火腿腸味道太濃，土豆味道不明顯，且湯體成粉紅色，明顯是放多了……</li><li>並且第一次倒入了整碗水，水過多導致土豆湯過稀，應該是使用半碗即可。</li><li>這個事情的後續：豆漿機因此損壞，儘管看起來它好好的。該項目因爲帶來的巨大的經濟損失，將不再被實驗。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 食譜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pip下载Module</title>
      <link href="/2020/07/12/tech/Python/pip%E4%B8%8B%E8%BD%BD/"/>
      <url>/2020/07/12/tech/Python/pip%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Pip 下载东西总是哪里会出一个幺蛾子……即使加上镜像……</p><a id="more"></a>  <p>使用下列指令下载：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip pip install -i https:<span class="string">//pypi.tuna.tsinghua.edu.cn/simple</span> <span class="params">--default-timeout=100</span> <span class="params">--upgrade</span> tensorflow-gpu</span><br></pre></td></tr></table></figure><p>其中<code>--default-timeout</code>项可以避免：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReadTimeoutError: <span class="constructor">HTTPSConnectionPool(<span class="params">host</span>='<span class="params">pypi</span>.<span class="params">tuna</span>.<span class="params">tsinghua</span>.<span class="params">edu</span>.<span class="params">cn</span>', <span class="params">port</span>=443)</span>: Read timed out.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python自动修改格式</title>
      <link href="/2020/07/11/tech/Python/Python%E8%87%AA%E5%8A%A8%E6%8E%92%E7%89%88/"/>
      <url>/2020/07/11/tech/Python/Python%E8%87%AA%E5%8A%A8%E6%8E%92%E7%89%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>偶然发现的一个 Python 自动修改代码风格的工具，感觉挺有用，在此记录使用方法。</p><a id="more"></a>  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先对于安装<code>black</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> black</span><br></pre></td></tr></table></figure><p>注意这个命令需要在 VSC Terminal 所在的虚拟环境中安装。例如如果 Terminal 使用的 conda-base，则该 Module 就应该在 conda-base 里安装。</p><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>打开 VSC 的 Setting(JSON)，将下列代码粘贴在最后方：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"python.formatting.provider"</span>: <span class="string">"black"</span>,</span><br><span class="line"><span class="string">"editor.formatOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="string">"python.formatting.blackArgs"</span>: [</span><br><span class="line">  <span class="string">"--line-length"</span>,</span><br><span class="line">  <span class="string">"120"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在这个设置下，每一次保存会进行一次自动的格式修改。但由于 Python 的特殊性，这个脚本能够改变的主要是行内代码风格，不能对缩进等进行修改。</p><p>参考连接：<a href="https://zhuanlan.zhihu.com/p/73452541" target="_blank" rel="noopener">link</a></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
            <tag> vscode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新老Edge并存方法</title>
      <link href="/2020/07/10/tech/%E6%96%B0%E8%80%81Edge%E5%B9%B6%E5%AD%98/"/>
      <url>/2020/07/10/tech/%E6%96%B0%E8%80%81Edge%E5%B9%B6%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>新版 Edge 尽管支持了 chrome 的插件，但是由于主力 Vivaldi 的能力过强，导致新 Edge 继续吃灰。配合 surface pen，老版 Edge 的 PDF 阅读器作为绝对优势的功能也遗憾被删除。为了能够继续使用老版本的 Edge，在网上搜索一番后，发现这个方法可行，于是记录下来。</p><a id="more"></a>  <h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><p>打开网址：<a href="https://www.microsoft.com/zh-cn/edge/business/download" target="_blank" rel="noopener">link</a>，</p><center><img src="/images/Things/edge.jpg" width="50%" height="50%" />如是选择</center><p>这个下载会获得一个名为<code>MicrosoftEdgePolicyTemplates</code>的压缩文件。将其解压可以得到下述文件：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\-</span> examples</span><br><span class="line"><span class="string">\-</span> html</span><br><span class="line"><span class="string">\-</span> mac</span><br><span class="line"><span class="string">\-</span> windows</span><br><span class="line">    <span class="string">\-</span> admin</span><br><span class="line">    <span class="string">\-</span> admx</span><br><span class="line">        <span class="string">\-</span> zn-CN</span><br><span class="line">        <span class="string">\-</span> en-US</span><br><span class="line">        ...</span><br><span class="line">        msedge.admx</span><br><span class="line">        msedgeupdate.admx</span><br></pre></td></tr></table></figure><p>将上述文件的<code>msedge.admx</code>及<code>msedgeupdate.admx</code>复制到文件夹：<code>C:\Windows\PolicyDefinitions</code>中。同时对应于上述的语言文件夹，将其中相关内容复制到对应的文件夹中。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>上述完成之后可以打开<code>gpedit.msc</code>，进入 windows configureation，依照下列路径进入：<code>Computer configuration -&gt; Administrative Templates -&gt; Microsoft Update</code></p><p>双击 Microsoft Update，点击 side-by-side 选项，将该服务 enable。</p><p>* 注意：这个文件夹只有在完成了上述的修改之后可见。</p><h2 id="重新安装"><a href="#重新安装" class="headerlink" title="重新安装"></a>重新安装</h2><p>回到最开始的网站，保持相同的版本号，下载新的 msi 安装文件安装 edge。这个操作不会将老版本 Edge 放入开始菜单，但是可以通过菜单栏中的<code>open with</code>打开 PDF。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - Towards Robust Semantic Role Labeling</title>
      <link href="/2020/07/09/scholar/paper/Towards%20Robust_Semantic_Role_Labeling/"/>
      <url>/2020/07/09/scholar/paper/Towards%20Robust_Semantic_Role_Labeling/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>ACL 2007</strong></p><p>为暑研工作阅读的第一篇论文。暑研工作的三个基石之一：SRL（Semantic Role Labeling）。现在大部分 SRL system 都基于一个数据集完成的训练。作者认为这样会造成过拟合现象。这篇文章提供了一种在特定数据集上标注后迁移到另一个数据集的方法。本篇文章基于 PropBank（很快我也需要完成这篇文章的阅读了。）这篇文章认为语法上的 parser 和 argument 判断可以很容易的迁移，然而 argument classification 不是。</p><a id="more"></a>  <h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>SRL 是一种用来表征语法结构的方法。党表征一个句子时，一个好的语法标注器应当能够对句子中的每一个谓词，正确地辨别并标注出其语法 label。在近期的工作中，这个工作是通过监督机器学习完成的。尽管这些工作在数据集上都达到了很高的准确率，但是他们极大地与其训练的数据集相关。这篇文章的焦点就是讨论这样的现象。</p><p>实验基于 PropBank corpus（这是一个 WSJ 的标注数据集）完成。</p><h2 id="语义标注（Semantic-Role-Labeling）"><a href="#语义标注（Semantic-Role-Labeling）" class="headerlink" title="语义标注（Semantic Role Labeling）"></a>语义标注（Semantic Role Labeling）</h2><p><strong>成分分析（constituent parsing）</strong><br>成分解析树将一个句子划分为一棵成分树，树上的非叶子节点是划分成的短语，叶子节点是句子中的单词。</p><p>在 NLP 中，分析方法分为：</p><ul><li>词法分析 lexical analysis</li><li>句法分析 syntactic parsing</li><li>语义分析 semantic parsing</li></ul><p>其中语义分析是指将自然语言句子转化为反映这个句子语义的形式化表达。例如：</p><blockquote><p>我吃了一块肉<br>一块肉被我吃了</p></blockquote><p>在语义上都表示为吃(我，肉）的意思，但句子结构却有不同。句子的语义分析是对句子处理技术更高一级的要求，在信息检索、信息抽取、自动文摘等应用广泛。</p><blockquote><p><strong>SRL:</strong> Semantic Role Labeling (SRL) is defined as the task to recognize arguments for a given predicate and assign semantic role labels to them.</p></blockquote><p>SRL 是浅层语义分析技术，以句子为单位处理为“谓词+论元”的结构。</p><h2 id="语义标注和语料库"><a href="#语义标注和语料库" class="headerlink" title="语义标注和语料库"></a>语义标注和语料库</h2><p>这篇文章通过复现 PropBank corpus 中的语义标注方法完成实验。PropBank 是一个包含 300k 单词的语料库，其中对于除了系词（corpula）外的所有动词都标注了谓词 argument 关系。PropBank 使用了 Arg0~Arg5 作为谓词 labels。</p><ul><li>ARG0: Agent, operator</li><li>ARG1: Things operated</li><li>ARG2: EXplicit patient</li><li>ARG3: Explicit argument</li><li>ARG4: Explicit instrument</li></ul><center><img src="/images/Research/semantic-tree.jpg" width="50%" height="50%" />Semantic Tree</center><p>除了这些基本的标志外，还存在 adjuntive argument（ArgMs），以及 ArgM-Loc，Arm=gM-TMP 等等。对于下面的例子，使用 operate 作为候选词获得的标注：</p><blockquote><p>It operates stores mostly in Iowa and Nebraska.</p><p>[$_{ARG0}$It] [$_{谓词}$operates] [$_{ARG1}$ stores][$_{ARGM−LOC}$ mostly in Iowa and Nebraska].</p></blockquote><p>PropBank 假定对于一个谓词的语义单元只存在一个或多个 nodes。尽管对于大部分的 arguments 树只有一个 node，但多个 node 的情况也是存在的。</p><h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h2><p>在 ASSERT 中，SRL 是通过对于一个 syntactic parse 的组分分配一个 role label 实现的。基本上可以被分到三个步骤：</p><ol><li>Argument identification：对于一个给定的谓词，识别句子成分。对于 parse tree 中的任何一个 node，可以被分类为具有语义表示（Not Null Node）或者不具备任何语义内涵。</li><li>Argument classification：假定已知一个谓词的组成已知，这个步骤将 argument label 赋给这些组成。</li><li>Argument identification and classfication：上述两个任务的组合。</li></ol><h2 id="ASSERT（Automatic-Statistical-Semantic-Role-Tagger）"><a href="#ASSERT（Automatic-Statistical-Semantic-Role-Tagger）" class="headerlink" title="ASSERT（Automatic Statistical Semantic Role Tagger）"></a>ASSERT（Automatic Statistical Semantic Role Tagger）</h2><h3 id="模型架构"><a href="#模型架构" class="headerlink" title="模型架构"></a>模型架构</h3><p>ASSERT 对每一个谓词生成一组 SRL（不同于 PropBank，系词是考虑在内的）。模型基本的输入是一个句子以及成分分析树。对于每一个分析树中的成分，ASSERT 提取出一组特征，并使用分类器对这个成分指定标签。该模型使用 SVM 方法及“one vs all”构建 n 个分类器，每一个分类器的结果被综合对标签进行判断。</p><p>上述使用的方法有一个缺陷：每一个 argument 的分类是独立的，而没有考虑其他被赋给相同标签的 argument。这样会忽略部分信息。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>使用的特征如下：</p><ul><li>谓词：确定 arguments 所使用的这一个谓词，同时该谓词的形式及语法信息同样作为特征输入。</li><li>路径：从分析树到当前分类谓词的路径。</li></ul><center><img src="/images/Research/tree-path.jpg" width="50%" height="50%" /></center><ul><li>短语类型：比如 PP，NP 等等成分。</li><li>位置：这个成分出现在谓词前还是谓词后</li><li>状态：这个谓词是主动的还是被动的。</li><li>子类？：这个谓词的子节点，例如在上图中：<code>VP -&gt; VBD - PP - NP</code>。</li><li>谓词 cluster：直观是，对于相似的语法结构的动词应该有相似的对象。例如“eat&amp;devour”。动词被分为 64 类，然后通过这个分类作为特征。</li><li>Head word：这个成分的 head。</li><li>Head word Pos：这个 head word 的 pos。</li><li>成分中的 named entity。</li><li>…… 太多了，不一一列举了。</li></ul><p>在实验过程中，对于 Identification Task 和 Classification Task 的有效特征是不同的。对于 IT，有效的特征是 Path 和 Partial Path，而谓词并不是非常重要。而对于分类，更重要的是 Head word，First/Last word 这些词。</p><p>简单的结论是，结构性的特征（如 Path）对于 IT 有积极作用，而更 lexical 的词或语义上的特征则对于分类更加重要。</p><h2 id="鲁棒性分析"><a href="#鲁棒性分析" class="headerlink" title="鲁棒性分析"></a>鲁棒性分析</h2><p>基本上目前的研究都将注意力放在了带有某种相同风格的文本上，对于这些文本集表现得提高可能更多意味着对于<strong>某类文本</strong>的辨识力/拟合，然而 SRL 等工具应当是普适意味的……为了表现这些模型确实不具有很强的迁移能力，引入下列的数据集。</p><h3 id="The-Brown-Corpus"><a href="#The-Brown-Corpus" class="headerlink" title="The Brown Corpus"></a>The Brown Corpus</h3><p>BC 是美式英语标准语料库，包含 1 百万英文文本，收录 2000 多词越 500 个样本。这个数据集用做语言对照分析。</p><h3 id="跨风格测试"><a href="#跨风格测试" class="headerlink" title="跨风格测试"></a>跨风格测试</h3><p>这一个测试表现模型在一个数据集上训练以后迁移到另一个数据集上是训练得到的结果差异。其选择在 WSJ 模型上先完成训练，然后迁移到 BS 上进行对比。我们掠过结果分析部分。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>获得了在 PropBank 上的 SRL SOTA，并使用这个结果在 Brown 语料库上进行检验。事实证明，在 Brown 上的模型表现大幅度下降，作者认为其中 Identification 步骤对模型能力下降影响不大，分类部分是模型能力下降的主要原因。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用数据结构</title>
      <link href="/2020/07/08/tech/Python/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/07/08/tech/Python/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了准备清华的机考，花了大概半个小时整理了一下 Python 常用的数据结构的技巧（虽然可能存在其他直接的方法……）</p><a id="more"></a>  <h2 id="数列"><a href="#数列" class="headerlink" title="数列"></a>数列</h2><p><strong>栈和队列的实现。</strong></p><p>统一使用 append 压入数字。对于 pop：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a.pop(<span class="number">0</span>)) <span class="comment">#删除第一个元素并返回，用来形成队列</span></span><br><span class="line">print(a.pop()) <span class="comment">#删除最后一个元素并返回，用来形成栈</span></span><br></pre></td></tr></table></figure><p><strong>排序</strong></p><ul><li>普通排序</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = sorted(a, reverse = <span class="literal">True</span>) <span class="comment"># 排序</span></span><br></pre></td></tr></table></figure><ul><li>多个数字排序</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">data = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line">data = sorted(data, key=operator.itemgetter(<span class="number">1</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>其中 operator.itemgetter 可以申明多个数字，是优先级的定义。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><strong>快速创建字典</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = set(range(<span class="number">14</span>))</span><br><span class="line">b = set(range(<span class="number">1</span>, <span class="number">15</span>))</span><br><span class="line">res =  dict(zip(a, b))</span><br></pre></td></tr></table></figure><p>这个方法可以快速组件字典。</p><p><strong>字典的操作</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">res.pop(<span class="number">1</span>, <span class="number">0</span>) <span class="comment"># 右为default值，若没有则返回该值</span></span><br><span class="line">adict = &#123;<span class="string">'a'</span>: <span class="number">12</span>&#125;</span><br><span class="line">res.update(adict)</span><br></pre></td></tr></table></figure><ul><li><code>pop</code>用来删除键，如果要删除的键不存在，则返回申明的第二个参数（这里是 0）。</li><li><code>update</code>用来更新字典，参数是另一个字典。速度比直接创建新字典快不少。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>我发现我几乎没用过 set，可能作为集合每个元素只能出现一次的性质我没太需要用到。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = set(<span class="string">'spam'</span>)</span><br><span class="line">y = set([<span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'b'</span>])</span><br><span class="line"></span><br><span class="line">print(x &amp; y)</span><br><span class="line">print(x | y)</span><br><span class="line">print(x - y)</span><br><span class="line"></span><br><span class="line">y.add(<span class="string">'x'</span>)            </span><br><span class="line">y.update([<span class="number">10</span>,<span class="number">37</span>,<span class="number">42</span>])  </span><br><span class="line">y.remove(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure><p>上述的功能都很直接，故不赘述。特殊的，如果往 set 里面增加重复的元素，则没有任何事事情会发生，所以可以用来快速移除重复元素；但 set 不会维护输入的顺序，所以不建议在使用 set 的情况下做与遍历顺序相关的操作。一般来说，使用<code>if a in B</code>的操作，set 会比 list 更快。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spaCy模型离线安装</title>
      <link href="/2020/07/08/tech/Python/Spacy%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/07/08/tech/Python/Spacy%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了安装 AllenNLP，不得已更新了 Torch。然后发现 SpaCy 的语言包也需要更新。奈何现在不在国内，更新语言包非常难受。网上的方法大多不济，这里简单记录。</p><a id="more"></a>  <h2 id="排雷"><a href="#排雷" class="headerlink" title="排雷"></a>排雷</h2><ul><li>在国内直接使用<code>python -m spacy download en</code>，一般下载到 50%左右就会断开连接。</li><li>下载了离线包之后，在文件夹执行<code>python setup.py install</code>并没有什么用处，模型仍然不能被正确识别。</li><li>使用<code>pip install *.tar.gz</code>，会导致开始下载模型……</li></ul><p>上述方法都是经过反复尝试并且无效的。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在 github 上找到合适的 en 模型下载并解压，得到一个文件夹：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\<span class="selector-tag">-</span> <span class="selector-tag">en_core_web_sm</span></span><br><span class="line">    <span class="selector-tag">en_core_web_sm-2</span><span class="selector-class">.3</span><span class="selector-class">.0</span></span><br><span class="line">    __<span class="selector-tag">init__</span><span class="selector-class">.py</span></span><br><span class="line">    <span class="selector-tag">meta</span><span class="selector-class">.json</span></span><br></pre></td></tr></table></figure><p>将上述文件放入</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\A</span>naconda3<span class="symbol">\L</span>ib<span class="symbol">\s</span>ite-packages<span class="symbol">\e</span>n_core_web_sm</span><br></pre></td></tr></table></figure><p>替换原本文件，然后即可正常使用。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文件管理及自动更新</title>
      <link href="/2020/07/04/tech/Hexo/Hexo%E6%96%87%E4%BB%B6%E5%A4%B9%E7%AE%A1%E7%90%86/"/>
      <url>/2020/07/04/tech/Hexo/Hexo%E6%96%87%E4%BB%B6%E5%A4%B9%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于：</p><ul><li><del>Hexo 文件夹系统（已失效）</del></li><li>Blog 在 Gitee 上自动更新</li></ul><a id="more"></a>  <h2 id="Hexo文件夹系统"><a href="#Hexo文件夹系统" class="headerlink" title="Hexo文件夹系统"></a>Hexo文件夹系统</h2><p><strong>注意，该POST已过时</strong></p><p>在某一个Hexo的版本更新时，其原生地支持了子文件夹的读取，所以本节所表述的方法已不在有必要。</p><p><del>因为最近累积的笔记越来越多了，而 Hexo 原生似乎不支持文件夹操作，故决定建立文件夹系统。它的思路很简单，就是在一个别处的文件夹下完成笔记的记录，在需要更新的时候，使用脚本递归地搜索这些文件夹，将所有的 md 文件全部收集到对应的<code>_posts</code>文件夹下。具体脚本如下：</del></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">ori_path = <span class="string">'../files'</span></span><br><span class="line">dst_path = <span class="string">'../source/_posts/'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file</span><span class="params">(path, name, cat)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(path):</span><br><span class="line">        cat_c = cat.copy()</span><br><span class="line">        cat_c.append(name)</span><br><span class="line">        files = os.listdir(path)</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            get_file(path  + <span class="string">'/'</span> + file, file, cat_c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.md'</span> <span class="keyword">in</span> name:</span><br><span class="line">            route = <span class="string">'-'</span>.join(cat[<span class="number">1</span>:])</span><br><span class="line">            shutil.copyfile(path, dst_path + route + <span class="string">"-"</span> + name)</span><br><span class="line"></span><br><span class="line">get_file(ori_path, <span class="string">''</span>, [])</span><br><span class="line">print(<span class="string">'Done!'</span>)</span><br></pre></td></tr></table></figure><h2 id="自动更新Gitee"><a href="#自动更新Gitee" class="headerlink" title="自动更新Gitee"></a>自动更新Gitee</h2><p>由于 Gitee 每一次更新 Blog 后需要访问 Gitee 手动完成 deploy。这个过程是在令人不爽。所以添加一个脚本用来自动完成这一步。具体依赖 selenium。</p><h3 id="安装selenium"><a href="#安装selenium" class="headerlink" title="安装selenium"></a>安装selenium</h3><p>进入谷歌商店，进入拓展商店下载 selenium。录制结束后导出为 py 文件。注意在这个过程中，需要将部分路径改为<code>xpath</code>。此外可能有 xpath 不能生效的情况，此时需要在该语句前添加 flush()。最后，由于 deploy 需要一些时间，所以需要使用 time 函数手动停止一些时间以完成 deploy。代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBlog</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setup_method</span><span class="params">(self)</span>:</span></span><br><span class="line">    options = webdriver.ChromeOptions()</span><br><span class="line">    self.driver = webdriver.Chrome()</span><br><span class="line">    self.vars = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">teardown_method</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.driver.quit()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wait_for_window</span><span class="params">(self, timeout = <span class="number">2</span>)</span>:</span></span><br><span class="line">    time.sleep(round(timeout / <span class="number">1000</span>))</span><br><span class="line">    wh_now = self.driver.window_handles</span><br><span class="line">    wh_then = self.vars[<span class="string">"window_handles"</span>]</span><br><span class="line">    <span class="keyword">if</span> len(wh_now) &gt; len(wh_then):</span><br><span class="line">      <span class="keyword">return</span> set(wh_now).difference(set(wh_then)).pop()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_blog</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.driver.get(<span class="string">"https://gitee.com/yoursite/pages"</span>)</span><br><span class="line">    self.driver.set_window_size(<span class="number">1514</span>, <span class="number">984</span>)</span><br><span class="line">    self.driver.find_element(By.LINK_TEXT, <span class="string">"Sign in"</span>).click()</span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">"user_login"</span>).click()</span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">"user_login"</span>).send_keys(<span class="string">"email@foobar.com"</span>)</span><br><span class="line">    self.driver.find_element(By.ID, <span class="string">"user_password"</span>).send_keys(<span class="string">"password"</span>)</span><br><span class="line">    self.driver.find_element(By.CSS_SELECTOR, <span class="string">".two:nth-child(3) label"</span>).click()</span><br><span class="line">    self.driver.find_element(By.NAME, <span class="string">"commit"</span>).click()</span><br><span class="line">    self.driver.refresh()</span><br><span class="line">    self.driver.find_element(By.CSS_SELECTOR, <span class="string">".redeploy-button"</span>).click()</span><br><span class="line">    <span class="keyword">assert</span> self.driver.switch_to.alert.text == <span class="string">"Are you sure to redeploy Gitee Pages?"</span></span><br><span class="line">    self.driver.switch_to.alert.accept()</span><br><span class="line">    time.sleep(<span class="number">60</span>)</span><br><span class="line">  </span><br><span class="line">test = TestBlog()</span><br><span class="line">test.setup_method()</span><br><span class="line">test.test_blog()</span><br><span class="line">test.teardown_method()</span><br></pre></td></tr></table></figure><p>完成上述步骤后，结合之前的自动添加空格以及基本的 hexo 操作，我们就可以全自动地完成文件夹整理及 deploy 操作了。如下：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">C:</span><br><span class="line">cd C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\D</span>ocuments<span class="symbol">\J</span>oseph<span class="symbol">\B</span>log<span class="symbol">\u</span>pdate</span><br><span class="line">python update_file.py</span><br><span class="line">cd C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\D</span>ocuments<span class="symbol">\J</span>oseph<span class="symbol">\B</span>log</span><br><span class="line">textlint --fix source/_posts/*.md &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; cd C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\D</span>ocuments<span class="symbol">\J</span>oseph<span class="symbol">\B</span>log<span class="symbol">\u</span>pdate &amp;&amp; python gitee.py</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transformers使用</title>
      <link href="/2020/07/04/tech/Huggingface/"/>
      <url>/2020/07/04/tech/Huggingface/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本地使用 Huggingface 的 transformer 挺麻烦的，可能之后还会碰到。这里做一个记录。</p><a id="more"></a>  <h2 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h2><p>模型如果标注了<code>from_pretrain(&#39;&#39;)</code>之类的，则需要加载模型。而不幸的是，官方下载模型的渠道很慢，需要使用离线下载方法。下述以 BERT 作为例子，下载步骤如下：</p><ol><li>进入链接，找到<a href="https://huggingface.co/models" target="_blank" rel="noopener">模型</a>的位置。</li><li>找到特殊的模型，进入<a href="https://huggingface.co/bert-base-uncased" target="_blank" rel="noopener">界面</a>。</li><li>在模型下方找到<a href="https://huggingface.co/bert-base-uncased#list-files" target="_blank" rel="noopener">List all files in model</a>。</li><li>选择其中的’config.json; pytorch_model.bin; vocab.txt’下载到同一个文件夹。</li></ol><h2 id="模型载入"><a href="#模型载入" class="headerlink" title="模型载入"></a>模型载入</h2><p>在开始载入以前，需要将上述下载文件放置到一个文件夹下。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\<span class="selector-tag">-</span> <span class="selector-tag">bert-uncased</span></span><br><span class="line">    <span class="selector-tag">config</span><span class="selector-class">.json</span></span><br><span class="line">    <span class="selector-tag">pytorch_model</span><span class="selector-class">.bin</span></span><br><span class="line">    <span class="selector-tag">vocab</span><span class="selector-class">.txt</span></span><br><span class="line"><span class="selector-tag">train</span><span class="selector-class">.py</span></span><br></pre></td></tr></table></figure><p>在 <code>train.py</code> 中的代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertTokenizer, BertModel</span><br><span class="line"></span><br><span class="line">path = <span class="string">'D:/LAB/LAB-last/lex-dis/cont-cont/bert-uncased'</span></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(path)</span><br><span class="line">model = BertModel.from_pretrained(path)</span><br></pre></td></tr></table></figure><p>这里模型载入即结束。使用相对路径不知为何不能成功，需要使用全地址。</p><h2 id="模型使用"><a href="#模型使用" class="headerlink" title="模型使用"></a>模型使用</h2><p>tokenizers 和 model 的使用这里暂时搁置。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode连接Python调试</title>
      <link href="/2020/07/04/tech/VSC/vscode%E8%BF%9E%E6%8E%A5python/"/>
      <url>/2020/07/04/tech/VSC/vscode%E8%BF%9E%E6%8E%A5python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>虽然一直用的是 VSC 和 Python 的组合，但是之前都是硬核 print 调试，并且需要从 Anaconda prompt 进入文件夹操作。确实觉得这个方法很难受，于是开始调整 VSC 连接 Python。中途遇到了不少的坑，这里对其进行一个整理。</p><a id="more"></a>  <h2 id="Anaconda环境"><a href="#Anaconda环境" class="headerlink" title="Anaconda环境"></a>Anaconda环境</h2><p>首先需要安装 Anaconda，Anaconda 会默认安装一个带有 conda 命令的 shell，但是在普通的 cmd 和 powershell 里都不能用这个东西。需要在环境变量中添加下述：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\A</span>naconda3</span><br><span class="line"><span class="symbol">\A</span>naconda3<span class="symbol">\S</span>cripts</span><br><span class="line"><span class="symbol">\A</span>naconda3<span class="symbol">\L</span>ibrary<span class="symbol">\b</span>in</span><br></pre></td></tr></table></figure><p>然后重启，这样可以在 cmd 里使用 Ananconda，例如 conda activate base 等命令。然而在 Powershell 里不知为何不能使用。使用<code>conda init</code>方法宣告无效。</p><h2 id="VSC和Python"><a href="#VSC和Python" class="headerlink" title="VSC和Python"></a>VSC和Python</h2><p>VSC 默认的 Terminal 是 Powershell，所以不能正常使用<code>conda</code>命令，所以需要添加 cmd。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"<span class="selector-tag">terminal</span><span class="selector-class">.integrated</span><span class="selector-class">.shell</span><span class="selector-class">.windows</span>": "<span class="selector-tag">C</span>:\\<span class="selector-tag">Windows</span>\\<span class="selector-tag">System32</span>\\<span class="selector-tag">cmd</span><span class="selector-class">.exe</span>",</span><br></pre></td></tr></table></figure><p>这个时候会报找不到 package 的错误，需要在 VSC 中添加 conda 的地址。在 VSC 设置中搜索<code>conda</code>并输入：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\1</span>3808<span class="symbol">\A</span>naconda3<span class="symbol">\S</span>cripts<span class="symbol">\c</span>onda.exe</span><br></pre></td></tr></table></figure><p>同时在设置中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"code-runner.executorMap"</span>: &#123;</span><br><span class="line">  <span class="string">"python"</span>:<span class="string">"<span class="variable">$pythonPath</span> <span class="variable">$fullFileName</span>"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>根据上述的设置，将 Terminal 变为 cmd，然后即可正常 debug。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 英文文本成分分析</title>
      <link href="/2020/07/03/tech/Python/%E8%8B%B1%E6%96%87%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
      <url>/2020/07/03/tech/Python/%E8%8B%B1%E6%96%87%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了确定句子中从句的位置并将其剥离出来，需要找到一个成分分析的 parser，本文是对使用这个 parser 的一个具体的说明。使用的工具来自 ACL 2018：<a href="https://github.com/nikitakit/self-attentive-parser" target="_blank" rel="noopener">Constituency Parsing with a Self-Attentive Encoder</a>。</p><a id="more"></a>  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这个工具可以和 SpaCy 及 NLTK 一同使用。但是在尝试工程中发现和 SpaCy 的联动除了一些问题，会返回不知道如何解决的错误，但是 NLTK 则运行正常。这里记录 NLTK 版本的安装和使用方法。</p><p>首先，这个模型的运行需要先行下载：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line">nltk.download(<span class="string">'punkt'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> benepar</span><br><span class="line">benepar.download(<span class="string">'benepar_en'</span>)</span><br></pre></td></tr></table></figure><p>但是这个下载速度非常地慢。希望离线下载需要访问上述 GitHub 链接，找到对应的<code>benepar_en2.zip</code>包下载。（不知道为何，找不到 benepar_en 包）。将这个压缩包放置在<code>C:/Users/.../AppData/Roaming/nltk_data/models/</code>下。punkt 包也能通过访问 nltk_data 找到对应的压缩包，不过这个包需要放置在上面文件夹旁的<code>tokenizers</code>文件夹下并解压。</p><p>这样就完成了这个模型的安装。如果不存在<code>benepar</code>则可以先 install 一次。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> benepar</span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line">parser = benepar.Parser(<span class="string">"benepar_en"</span>)</span><br></pre></td></tr></table></figure><p>由于我们使用了 nltk 的方法，所以不需要引入 SpaCy 的文件。上面的代码可以获得一个 parser，这个 parser 可以用来完成成分分析。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree = parser.parse(context)</span><br></pre></td></tr></table></figure><p>上述获得的 tree 打印出来效果如下：</p><blockquote><p>Added another executive at a big bank: “We were all a little goosey over the weekend trying to forecast what would happen Monday, but it’s been very quiet.”</p></blockquote><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">SINV</span></span><br><span class="line">  (<span class="name">VP</span> (<span class="name">VBN</span> Added))</span><br><span class="line">  (<span class="name">NP</span></span><br><span class="line">    (<span class="name">NP</span> (<span class="name">DT</span> another) (<span class="name">NN</span> executive))</span><br><span class="line">    (<span class="name">PP</span> (<span class="name">IN</span> at) (<span class="name">NP</span> (<span class="name">DT</span> a) (<span class="name">JJ</span> big) (<span class="name">NN</span> bank))))</span><br><span class="line">  (<span class="name">:</span> :)</span><br><span class="line">  (`` ``)</span><br><span class="line">  (<span class="name">S</span></span><br><span class="line">    (<span class="name">S</span></span><br><span class="line">      (<span class="name">NP</span> (<span class="name">PRP</span> We))</span><br><span class="line">      (<span class="name">VP</span></span><br><span class="line">        (<span class="name">VBD</span> were)</span><br><span class="line">        (<span class="name">DT</span> all)</span><br><span class="line">        (<span class="name">ADJP</span> (<span class="name">DT</span> a) (<span class="name">RB</span> little) (<span class="name">JJ</span> goosey))</span><br><span class="line">        (<span class="name">PP</span> (<span class="name">IN</span> over) (<span class="name">NP</span> (<span class="name">DT</span> the) (<span class="name">NN</span> weekend)))</span><br><span class="line">        (<span class="name">S</span></span><br><span class="line">          (<span class="name">VP</span></span><br><span class="line">            (<span class="name">VBG</span> trying)</span><br><span class="line">            (<span class="name">S</span></span><br><span class="line">              (<span class="name">VP</span></span><br><span class="line">                (<span class="name">TO</span> to)</span><br><span class="line">                (<span class="name">VP</span></span><br><span class="line">                  (<span class="name">VB</span> forecast)</span><br><span class="line">                  (<span class="name">SBAR</span></span><br><span class="line">                    (<span class="name">WHNP</span> (<span class="name">WP</span> what))</span><br><span class="line">                    (<span class="name">S</span></span><br><span class="line">                      (<span class="name">VP</span></span><br><span class="line">                        (<span class="name">MD</span> would)</span><br><span class="line">                        (<span class="name">VP</span></span><br><span class="line">                          (<span class="name">VB</span> happen)</span><br><span class="line">                          (<span class="name">PRN</span></span><br><span class="line">                            (<span class="name">-LRB-</span> -LCB-)</span><br><span class="line">                            (<span class="name">NP</span> (<span class="name">NNP</span> Monday))</span><br><span class="line">                            (<span class="name">-RRB-</span> -RCB-)))))))))))))</span><br><span class="line">    (, ,)</span><br><span class="line">    (<span class="name">CC</span> but)</span><br><span class="line">    (<span class="name">S</span></span><br><span class="line">      (<span class="name">NP</span> (<span class="name">PRP</span> it))</span><br><span class="line">      (<span class="name">VP</span> (<span class="name">VBZ</span> <span class="symbol">'s</span>) (<span class="name">VP</span> (<span class="name">VBN</span> been) (<span class="name">ADJP</span> (<span class="name">RB</span> very) (<span class="name">JJ</span> quiet))))))</span><br><span class="line">  (<span class="name">.</span> .))</span><br></pre></td></tr></table></figure><p>返回的 tree 是<code>nltk.tree</code>的结构，对于每一个 node，其子树或为另一个 node，或者为一个 leaf，一个 leaf 就是一个字符串。可以使用：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> type(node) == str:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>判断对象是一个 node 还是一个 leaf，如果是一个 node，则可以仿照 list 的方式对其进行遍历。此外 tree 结构的每一个 node，对应一个 label，调用的方式为：<code>node.label()</code>，可以获得这个节点的标签，在上面的实例中，”S”就是一个标签，标志着其句子成分。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows上安装LaTeX</title>
      <link href="/2020/07/03/tech/LaTeX/windows%E4%B8%8A%E5%AE%89%E8%A3%85/"/>
      <url>/2020/07/03/tech/LaTeX/windows%E4%B8%8A%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-voQWbbAg" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1455701955" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>这不是第一次安装 latex 了，但每次安装都会遇到一些问题，消耗搜索的时间，这次对其作一个整理。</p><a id="more"></a>  <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先是从 tex live 的官网上下载到最新版的 texlive 并安装。基本上，官网上下到的是一个叫做<code>install-tl-windows.exe</code>的可执行文件。这个文件点开后即可开始下载。下载的时间很长，预计从早上开始下载需要在傍晚才能下载结束。</p><p>不出意外安装结束之后，windows 的“开始”会出现 TexWorks Editor 等等工具。以及 Tex 的路径可以自动加载到系统环境变量中，重启之后即可生效。</p><h2 id="VSCODE"><a href="#VSCODE" class="headerlink" title="VSCODE"></a>VSCODE</h2><p>使用 VSC 可能会比较舒服，但是总有一些小问题。为了在 VSC 中预览 LaTeX，需要下载拓展：LaTeX Workshop。下载结束后 VSC 可以获得高亮 Tex 代码的能力。</p><p>在左侧的工具栏会在选中 Tex 文件时获得新的 LaTeX 标志，其中可以选择编译文件或者在 VSC Tab 中预览文件。</p><p>为了和 VSC 链接，需要打开 VSC 的设置代码，添加下述代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">"latex-workshop.latex.recipes": [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">    <span class="attr">"tools"</span>: [</span><br><span class="line">      <span class="string">"xelatex"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"xelatex -&gt; bibtex -&gt; xelatex*2"</span>,</span><br><span class="line">    <span class="attr">"tools"</span>: [</span><br><span class="line">      <span class="string">"xelatex"</span>,</span><br><span class="line">      <span class="string">"bibtex"</span>,</span><br><span class="line">      <span class="string">"xelatex"</span>,</span><br><span class="line">      <span class="string">"xelatex"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line">"latex-workshop.latex.tools": [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"latexmk"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">      <span class="string">"-synctex=1"</span>,</span><br><span class="line">      <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">      <span class="string">"-file-line-error"</span>,</span><br><span class="line">      <span class="string">"-pdf"</span>,</span><br><span class="line">      <span class="string">"%DOC%"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"xelatex"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">      <span class="string">"-synctex=1"</span>,</span><br><span class="line">      <span class="string">"-interaction=nonstopmode"</span>,</span><br><span class="line">      <span class="string">"-file-line-error"</span>,</span><br><span class="line">      <span class="string">"%DOC%"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"bibtex"</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [</span><br><span class="line">      <span class="string">"%DOCFILE%"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line">"latex-preview.command": "xelatex",</span><br><span class="line">"latex-workshop.latex.autoBuild.run": "never"</span><br></pre></td></tr></table></figure><p>上述的代码会将 recipe 加入 build 选项，通过点击编译文件。但在这个设置中，如果文件出现 error，VSC 将会选择终止执行，在终止执行的情况下，虽然可以获得一个 pdf 文件，但是这份文件的一部分内容是有误的，例如 Content 的添加等等，所以这个版本在写作中途可以用来作为参照但并不适合作为最后微调的方法。</p><p>在这个情况下，可以使用 overleaf 或者在文件所在的文件夹下唤起 cmd，使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">xelatex</span> <span class="selector-tag">main</span><span class="selector-class">.tex</span></span><br></pre></td></tr></table></figure><p>忽视中间的错误可以获得生成的文件，在这个文件中 Content 等信息是正常的。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python英文分句</title>
      <link href="/2020/06/30/tech/Python/%E8%8B%B1%E6%96%87%E5%88%86%E5%8F%A5/"/>
      <url>/2020/06/30/tech/Python/%E8%8B%B1%E6%96%87%E5%88%86%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简记 NLTK 对英文文本进行分句的方法。</p><a id="more"></a>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.tokenize <span class="keyword">import</span> sent_tokenize</span><br><span class="line"></span><br><span class="line">sent_tokenize(<span class="string">'this is an example. simply an example.'</span>)</span><br></pre></td></tr></table></figure><p>上述代码返回的结果是包含了两个分句的 list。结束。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSV读写</title>
      <link href="/2020/06/30/tech/Python/CSV%E8%AF%BB%E5%8F%96/"/>
      <url>/2020/06/30/tech/Python/CSV%E8%AF%BB%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>每一次碰到 CSV 都需要单独搜一次做法，还经常出一些小 bug。这里对最简单的 CSV 读写做一个整理。</p><a id="more"></a> <p>csv 存储的内容如：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'data'</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">'index'</span>: <span class="number">0</span></span><br><span class="line">    &#125;, ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="读CSV"><a href="#读CSV" class="headerlink" title="读CSV"></a>读CSV</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.csv'</span>, <span class="string">'r'</span>, encoding=<span class="string">'unicode_escape'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    reader = csv.DictReader(csvfile)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        print(row[<span class="string">'data'</span>], row[<span class="string">'index'</span>])</span><br></pre></td></tr></table></figure><p>注意 <code>unicode_esxape</code> 是对文件中出现了奇怪字符使用的。如果使用 <code>utf-8</code> 仍不能正常解码的时候可以使用。</p><h2 id="写CSV"><a href="#写CSV" class="headerlink" title="写CSV"></a>写CSV</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">fieldnames = [<span class="string">'data'</span>, <span class="string">'index'</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.csv'</span>, <span class="string">'w'</span>, encoding = <span class="string">'utf-8'</span>, newline = <span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    writer = csv.writer(csvfile)</span><br><span class="line">    writer.writerow(fieldnames)</span><br><span class="line">    writer.writerow([<span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'example.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames)</span><br><span class="line">    writer.writeheader()</span><br><span class="line">    writer.writerow(&#123;<span class="string">'data'</span>: <span class="number">2</span>, <span class="string">'index'</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>即第一次使用<code>writerow</code>时，需要先写入第一排域名，然后后面每一排则是根据域名排序的 list。</li><li>使用字典和 list 是等价的，哪个方便用哪个。</li><li>写入的时候一定不能标记为<code>unicode_escape</code>，否则会乱码。使用<code>utf-8</code>就 ok。</li><li>需要加上<code>newline = &#39;&#39;</code>，否则每一行后面会接一行空行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用系统操作及文件操作</title>
      <link href="/2020/06/27/tech/Python/%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/06/27/tech/Python/%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-PMbeNVxe" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="465149196" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>在预处理文件以及训练模式时经常用到一个文件操作，这里稍加整理。</p><a id="more"></a>  <h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br></pre></td></tr></table></figure><p>OS 操作很常用，用于获取文件夹之类的操作。主要使用<code>os</code>和<code>shutil</code>两个库文件。</p><h3 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os.path.exists(path)</span><br><span class="line">os.path.isdir(path)</span><br><span class="line">os.path.isfile(path)</span><br><span class="line">files = os.listdir(path)</span><br></pre></td></tr></table></figure><p>判断路径是否存在，是一个文件夹还是一个文件。对于一个文件夹可以继续使用 <code>listdir</code> 获得文件内容</p><h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(path)</span>:</span></span><br><span class="line"> </span><br><span class="line">    path=path.strip()</span><br><span class="line">    path=path.rstrip(<span class="string">"\\"</span>)</span><br><span class="line"> </span><br><span class="line">    isExists=os.path.exists(path)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        os.makedirs(path) </span><br><span class="line">        print(<span class="string">'OK!'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Existed!)</span></span><br><span class="line"><span class="string">        return False</span></span><br></pre></td></tr></table></figure><h3 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.remove(path)</span><br><span class="line">os.rmdir(path)        <span class="comment">#仅能删除空文件夹</span></span><br><span class="line">shutil.rmtree(path)   <span class="comment">#递归删除所有内容</span></span><br></pre></td></tr></table></figure><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p>对于文件夹和文件的操作方法是一样的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">os.rename(<span class="string">"test"</span>,<span class="string">"test1"</span>)    </span><br><span class="line">os.rename(<span class="string">"test.txt"</span>,<span class="string">"test1.txt"</span>)</span><br></pre></td></tr></table></figure><h3 id="复制和移动"><a href="#复制和移动" class="headerlink" title="复制和移动"></a>复制和移动</h3><p>需要使用 <code>shutil</code> 的库文件操作。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shutil.copyfile(<span class="string">"foo.txt"</span>,<span class="string">"bar.txt"</span>)  <span class="comment"># file only</span></span><br><span class="line">shutil.copytree(<span class="string">"foo"</span>,<span class="string">"bar"</span>)          <span class="comment"># dir only</span></span><br><span class="line">shutil.copy(<span class="string">"foo"</span>,<span class="string">"bar"</span>)              <span class="comment"># both</span></span><br><span class="line">shutil.move(<span class="string">"foo"</span>,<span class="string">"bar"</span>)</span><br></pre></td></tr></table></figure><ul><li>上述的文件的复制方法，存在覆盖能力。文件夹的复制方法则不允许在目标地址存在相应文件夹。</li><li>如果调用<code>.copy()</code>，输入为一个文件和一个文件夹，则会将文件复制入文件夹中。</li><li><code>.move()</code>细节和<code>.copy()</code>相同</li></ul><h2 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h2><h3 id="基本读写"><a href="#基本读写" class="headerlink" title="基本读写"></a>基本读写</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path, <span class="string">'w'</span>, encoding = <span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'foobar!'</span>)</span><br><span class="line"><span class="keyword">with</span> open(path, <span class="string">'r'</span>, encoding = <span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>模式：</p><div class="table-container"><table><thead><tr><th>参数</th><th>效果</th></tr></thead><tbody><tr><td>w</td><td>写文件</td></tr><tr><td>r</td><td>读文件</td></tr><tr><td>a</td><td>追加文件</td></tr></tbody></table></div><h3 id="特殊：json"><a href="#特殊：json" class="headerlink" title="特殊：json"></a>特殊：json</h3><p>JSON 文件是常用的格式，为了方便存储字典型结构的最优选择。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = json.load(f)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(dataset, f)</span><br></pre></td></tr></table></figure><h3 id="特殊：pickle"><a href="#特殊：pickle" class="headerlink" title="特殊：pickle"></a>特殊：pickle</h3><p>pickle 常用来保存二进制数据结构。基本上是什么都能存。不过对于 PyTorch，还是建议使用 torch 自带的 save 函数，不然 torch 会报 warning。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> pk</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.pk'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pk.dump(data, f)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'dataset.pk'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = pk.load(f)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CV：深度卷积神经网络模型及调参</title>
      <link href="/2020/06/27/scholar/DL_DCNN/"/>
      <url>/2020/06/27/scholar/DL_DCNN/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为连续做了两个使用 CNN 网络的模型训练，所以这里单独开一个记录 CNN 调参的心路历程。</p><a id="more"></a>  <h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>经过众多测试，得到的通用模型如下。基本思想是深的神经网络以及小的卷积核，并且卷积核的 channel 逐渐增加的机制。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperNaiveModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(SuperNaiveModel, self).__init__()</span><br><span class="line">        self.conv0 = nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>, padding=<span class="number">3</span>),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">64</span>, momentum=<span class="number">0.1</span>),            </span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">        )</span><br><span class="line">        self.conv1 = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.Conv2d(<span class="number">128</span>, <span class="number">128</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv2 = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">128</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),            </span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv20 = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),            </span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">256</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.conv3=torch.nn.Sequential(</span><br><span class="line">            torch.nn.Conv2d(<span class="number">256</span>, <span class="number">512</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">512</span>, momentum=<span class="number">0.1</span>),            </span><br><span class="line">            torch.nn.ReLU(),            </span><br><span class="line">            torch.nn.Conv2d(<span class="number">512</span>, <span class="number">512</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>),</span><br><span class="line">            torch.nn.BatchNorm2d(<span class="number">512</span>, momentum=<span class="number">0.1</span>),</span><br><span class="line">            torch.nn.ReLU(),</span><br><span class="line">            torch.nn.MaxPool2d(stride=<span class="number">2</span>, kernel_size=<span class="number">2</span>))</span><br><span class="line">        self.dense = torch.nn.Sequential(</span><br><span class="line">            torch.nn.Linear(<span class="number">512</span> * <span class="number">4</span> * <span class="number">4</span>, <span class="number">20</span>),</span><br><span class="line">            nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = x.reshape(x.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>).float()</span><br><span class="line">        x = self.conv0(x)</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        x = self.conv2(x)</span><br><span class="line">        x = self.conv20(x)</span><br><span class="line">        x = self.conv3(x)</span><br><span class="line">        x = x.view(x.shape[<span class="number">0</span>], <span class="number">512</span> * <span class="number">4</span> * <span class="number">4</span>)</span><br><span class="line">        x = self.dense(x)</span><br><span class="line">        <span class="keyword">return</span> x1</span><br></pre></td></tr></table></figure><h2 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h2><p>由于训练资源不够，所以使用一个 5x5 的卷积核代替了应有的两个 3x3 卷积核链接的效果。根据 VGG，<strong>连续使用两个 3x3</strong>可能效果会好一些。</p><p>Batchnorm 是一个玄学的东西，它的功能并不如预期一样稳定，并且没有必要在没一个网络后都接一个 BN 层。事实上，根据实验，在模型的最开始和最后一层添加 BN 层的效果是明显的。ReLU 层作为非线性化的方法，几乎是必须的。</p><p>此外，过多的全连接层是不利的，每多增一个全连接层会对模型造成一定的影响。预测的原因是由于数据量不够支撑全连接层的泛化性，导致容易过拟合，泛化性差，反而不如一层全连接。所以全连接层越多越好不是绝对的。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> CV </tag>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习的操作们</title>
      <link href="/2020/06/27/scholar/DL_%E8%B0%83%E5%8F%82/"/>
      <url>/2020/06/27/scholar/DL_%E8%B0%83%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>每一次深度模型调参都是让人头疼的东西，总感觉有很多玄学的东西能用，但事实上最后效果都不会太好。这里专门记录一些可能会有影响的调参方法。所以这是一个累积更新的文章。希望之后碰到新的方法和雷区能在这里记下，减少调试时间。</p><a id="more"></a>  <h2 id="有效措施"><a href="#有效措施" class="headerlink" title="有效措施"></a>有效措施</h2><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>数据预处理的效果可能比模型的各种调参来得更加直接有效。对于 NLP 任务可能不那么明显，但是对于 CV 或者 DSP 任务却是立竿见影的。</p><h4 id="数据增广"><a href="#数据增广" class="headerlink" title="数据增广"></a>数据增广</h4><p>计算机视觉中常用的方法。基本是对于图片随机翻转、随机截取、添加高斯模糊、随机遮盖等等措施。其中随机截取和随机翻转是一般都有效的，随机遮盖等则不一定。数据增广可以在模型训练中完成，让模型实时更改数据集内容；也可以在训练前就完成增广；两种方法都用也没有问题。</p><p>对于图片的数据增广方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line">transform = tfs.Compose([</span><br><span class="line">    tfs.Resize((<span class="number">256</span>, <span class="number">256</span>)),  <span class="comment"># 先调整图片大小至256x256</span></span><br><span class="line">    tfs.RandomCrop((<span class="number">224</span>, <span class="number">224</span>)),  <span class="comment"># 再随机裁剪到224x224</span></span><br><span class="line">    tfs.RandomHorizontalFlip(),  <span class="comment"># 随机的图像水平翻转，通俗讲就是图像的左右对调</span></span><br><span class="line">    tfs.RandomRotation(<span class="number">5</span>),</span><br><span class="line">    tfs.ToTensor(),</span><br><span class="line">    tfs.Normalize((<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>), (<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.2225</span>)),  <span class="comment"># 维度和图像的channel相关</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>调用时使用即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = transform(img)</span><br></pre></td></tr></table></figure></p><h4 id="数据标准化-归一化"><a href="#数据标准化-归一化" class="headerlink" title="数据标准化/归一化"></a>数据标准化/归一化</h4><p>即使是非常简单的数据标准化/归一化，就能取得显著的 performance 提高以及训练速度的大幅度提升。对于图像信息，可以使用灰度图均衡化，而对于数字信号或者其他信息，则可以使用 MinMax，标准化众多方法。这个对于模型训练速度的提升可能是数量级上。</p><p>但无论如何，数据标准化几乎应当是数据预处理的必要操作，绝对不能跳过。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直方图均衡化</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img = cv2.equalizeHist(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准化 - 对于一维数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">std</span><span class="params">(data)</span>:</span></span><br><span class="line">    mu = np.mean(data)</span><br><span class="line">    sigma = np.std(data)</span><br><span class="line">    <span class="keyword">return</span> (data - mu) / sigma</span><br></pre></td></tr></table></figure><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><h4 id="损失函数权重"><a href="#损失函数权重" class="headerlink" title="损失函数权重"></a>损失函数权重</h4><p>对于普通的损失函数，对于不同的类加以相同的权进行处理。但是对于类分别不均的训练集/测试集，可以轻微调整模型的损失函数权重，一般权重添加方法是按照训练集的比例强行加权。一般这样就能获得略好的效果。但是还有一定的调整空间。事实上使用这个方法对于一些数据分布不均的方法有非常明显的效果。不过如果实在分布不均的话，可以考虑数据预处理方法解决。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weight = torch.Tensor([<span class="number">1</span>, <span class="number">0.8</span>])</span><br><span class="line">lossfun = nn.CrossEntropyLoss(weight = weight)</span><br></pre></td></tr></table></figure><p>如果使用 cuda 训练，还应该申明<code>.cuda()</code>。</p><h4 id="学习率衰减"><a href="#学习率衰减" class="headerlink" title="学习率衰减"></a>学习率衰减</h4><p>原来习惯性用 Adam 也就没有再关心过学习率的问题，但事实上学习率仍然是有影响的。使用过小的学习率前期的训练时间过长而且容易进入一个不太好的局部最优解，相反使用大的学习率在前期能够势如破竹。（甚至是数量级的提升）但是训练到后期的模型 performan 却需要更小的学习率，所以这里引入学习率衰减的方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjust_learning_rate</span><span class="params">(optimizer, epoch)</span>:</span></span><br><span class="line">    lr = <span class="number">1e-4</span> * (<span class="number">0.4</span> ** (epoch // <span class="number">8</span>))</span><br><span class="line">    <span class="keyword">for</span> param_group <span class="keyword">in</span> optimizer.param_groups:</span><br><span class="line">        param_group[<span class="string">'lr'</span>] = lr</span><br><span class="line">adjust_learning_rate(optimizer, epoch)</span><br></pre></td></tr></table></figure><p>传入的 optimizer 参数就是 PyTorch 的模型。对于 Adam 模型，建议使用 $1e^{-4}$ 作为起始训练速率。</p><h2 id="不稳定措施"><a href="#不稳定措施" class="headerlink" title="不稳定措施"></a>不稳定措施</h2><h3 id="添加模型的全连接层"><a href="#添加模型的全连接层" class="headerlink" title="添加模型的全连接层"></a>添加模型的全连接层</h3><p>添加全连接层会大幅度增加模型的复杂度以及参数量，强制减低模型的训练速度，但而提高模型的过拟合能力。所以增加全连接层方法在数据量不足以支撑的情况下是绝对不推荐的。但是有的时候能发挥一定的作用。</p><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p>Dropout 不是万能的方法。例如对于最后的分类器叠加 Dropout 反而会使模型的表现变得滑稽。Dropout 的添加是需要通过反复实验的。不过建议在模型的一开始不要使用 Dropout，因为模型自身的能力可能就不够，不能够很好地拟合训练数据。而且增加 Dropout 增加了训练时间，对于判断模型的强度也是不利的。在实验的最后发现过拟合严重可以考虑尝试使用 Dropout 方法。</p><h3 id="Multi-task"><a href="#Multi-task" class="headerlink" title="Multi-task"></a>Multi-task</h3><p>这是一个很不确定的东西。Multi-task 的效果随着设计的多任务而变化。事实上，在我使用 Multi-task 的情况下，几乎都没有得到明显的提升，有的时候甚至会拖后腿使模型的能力下降。所以 Multi-task 是需要仔细思考后使用的。</p><h3 id="加载预训数据"><a href="#加载预训数据" class="headerlink" title="加载预训数据"></a>加载预训数据</h3><p>对于 NLP 任务，使用预训参数是必要的，特别是对于 BERT 等模型，即使固定参数，只训练后面的部分也能获得很好的效果。但是对于 CV 任务这个效果却不是一定的。例如在 COVID-19 分类任务中，我使用了 ResNet18 作为一个模型，并加载了 PyTorch 的预训结果，获得了训练速度的显著提升；然而在语谱图分类时，使用预训的结果并没有明显的优势。</p><p>所以模型的训练对象和预训的数据集应该有一定的共同之处时才能够发挥作用。语谱图是完全和 ImageNet 不同的东西，所以不能发挥作用也是在预期之中的。</p><h2 id="基本无效措施"><a href="#基本无效措施" class="headerlink" title="基本无效措施"></a>基本无效措施</h2>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>觀佛記</title>
      <link href="/2020/06/27/essay/tour/%E5%B3%A8%E7%9C%89%E8%A1%8C/"/>
      <url>/2020/06/27/essay/tour/%E5%B3%A8%E7%9C%89%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-jqVLOxkv" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="17685905" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>雖說已經過了快兩個月了，還是想記下那個不那麼特殊的旅途.2020 年勞動節的峨眉山之行。雖說確實沒有太多值得大書特書的細節，但就算當作流水賬一樣地記下來也是不錯的。</p><a id="more"></a>  <p>事實上這個旅程是我從哈爾濱回來以後就一直在考慮的，然而最終因爲疫情的原因沒能在春節附近付諸實踐，實在可惜。然情況總是紛繁複雜，居然到了五一節，我們這些學生還是滯留在自己的窩裡面沒有返校。五一節的幾日長假不得不使人再次萌生了造訪峨眉的想法，於是簡單組織一通後和幾個高中同學一同出發了。</p><p>一早起來，大概九點到了峨眉山腳。當時正逢疫情還在尾聲的時候，每一個關卡都要檢查健康碼之類的東西。不過沒有造成太大的阻礙，我們進山了。在山門口買了個舒適的竹杖。（這確實是救命的東西，不是打猴子，而是作爲另一條腿。）一路上人不算太多，環境也很清幽。走走停停就能看見小亭子之類的東西。風景很難說是絕美，不過與城市的氛圍自然還是迥異。最開始沿着山谷走，能一直看見下面流淌的透明小溪。這種景色總給我一種我曾經來過的感覺，可能是這樣的風景實在是太多了吧。</p><p>一路上碰到一個山大王搶恰巧同行的一個小團隊成員的小挎包。還戀戀不捨地跟了很久，但什麼都沒有搶到。大概是在仙峯寺附近，我的腿開始出現抽筋的症狀，本來是一隻腿，後來不幸另一條腿也開始抽筋。大概像是一條很粗的蟲子在筋肉里穿梭的感覺。雖然感覺到疼但還是得往上走吧，一日登上峨眉算不上那麼容易的事情。中間反覆了幾次，但通過休息和壓腿算是穩定了下來。</p><p>然後仙峯寺之後是令人崩潰的上上下下。每一次站在一個山頭，就看見另一個山頭的小黑頂廟子，意識到那是下一個目的地的同時，得知需要先下山然後再爬到那裡，是真的想罵上幾句髒話，仿佛獲得了前功盡棄的挫敗感。這一路上的風景也相當的一般，沒有想象中的那種壯美，也沒有山大王之流的助興。</p><p>到九嶺岡的時候，整個隊伍已經相當疲憊了。具體什麼時候到那裡的我已經記不確切了，但那個時候着實是懷着是否能在天黑前登上雷洞坪的擔憂。後面我奇蹟般地感覺自己的小腿抽筋消歇了，在鑽天坡一路向上中居然越戰越勇。大家根據情況不同，整個隊伍也逐漸拉長。當時我在第二位，前面和後面的同學都不在了。我看見了洗象池的屋頂的時候，看見了一個寬闊的平台，旁邊的圍欄上立着兩隻互相搔毛的猴子。然後我看見了洗象池幾個字和後面的一列陡峭的階梯。我的兩腿突然傳來一陣劇痛，然後我就地跪了下去。據後面同學說，是聽見了我的慘叫聲。不過總之來到了一個新的節點。</p><p>後面的閻王坡實在震撼人心，長度和陡度都遠超前面的鑽天坡。不久後就走進了夜路，看見道路兩旁藏青色的影子往前進。當到了賓館吃上晚飯的時候已經是 10 點了。那個時候也沒什麼胃口，手機沒電了，可能只是想坐一坐了吧。</p><p>中間的小賣部密集且良心。冰粉實在是天賜美物，中途還買了瓶可樂刺激刺激，但是也懷疑是這個導致體內酸性上升，以致抽筋。小竹棍也是必備之物，後面的路途可能都是靠支着這個小竹棍一點點往上挪的吧。</p><p>好歹，這是第一次完成了一個 41km 的旅途，這是我來沒有想過的東西。我原來想峨眉可能就 20km 吧，我能行。但……總之算是問題不大。第二日起牀去金頂看日出。日出確實是壯麗的。伴隨着衆多舉着相機的人的歡呼聲，像高郵鹹鴨蛋那般的紅色太陽從雲層的那端慢慢露出來，透露出整個鹹鴨蛋黃的金橙顏色，越發地誘人。然後天空呈現出一種絢麗的金色，最後慢慢變成普通閃耀着金光和大菩薩像一樣顏色的太陽了。</p><p>我不太清楚自己是怎麼爬上這個山的。我只記得我在路途的最後一程，我發自內心地想，如果這一路哪怕有一個可以放棄的地方，我可能就結束在那裡了吧。往上走的原因只是既不能停下來，也不能回頭罷了，和意志力什麼的是無甚關聯的東西。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行跡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch方法：DataSet</title>
      <link href="/2020/06/27/tech/PyTorch_DataSet/"/>
      <url>/2020/06/27/tech/PyTorch_DataSet/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>简单记录一下如何使用 PyTorch 的 DataSet 及 DataLoader 功能。</p><a id="more"></a>  <p>DataSet 的使用通过继承 DataSet 类完成，并在此基础上需要构造三个特殊函数。下例为使用 DataSet，通过访问 json 文件获取数据内容，然后在 gititem 函数中获取数据并返回的例子。</p><h2 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataSet</span><span class="params">(torch.utils.data.Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, train_or_valid, transform, path)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        file = open(<span class="string">'data/dataset.json'</span>, <span class="string">'r'</span>)</span><br><span class="line">        data = json.load(file)</span><br><span class="line">        self.datalist = data[train_or_valid]</span><br><span class="line">        self.path = path</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        name = self.datalist[index][<span class="number">0</span>]</span><br><span class="line">        img = Image.open(self.path + name)</span><br><span class="line">        label = self.datalist[index][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"img"</span>: img, <span class="string">"label"</span>: label&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.datalist)</span><br></pre></td></tr></table></figure><p>上述返还的是一个数据字典。</p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>依旧使用上述的例子。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trainset = DataSet(<span class="string">'train'</span>, transform_train, normal_path)</span><br></pre></td></tr></table></figure><h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>DataLoader 是 PyTorch 用来调取 DataSet 的一个类，其声明和使用如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"></span><br><span class="line">trainloader = data.DataLoader(trainset, batch_size = batch_sz, shuffle = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>第一个参数是上述生成的 DataSet，后面如同表述。</p><p>但往往上述的结构由于数据不规整不能满足要求，需要自己定义 Batch 函数。如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">padding</span><span class="params">(data)</span>:</span></span><br><span class="line">    src_len = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> data:</span><br><span class="line">        src_len.append(p[<span class="string">'wav'</span>].shape[<span class="number">1</span>])</span><br><span class="line">    src_pad = torch.zeros(len(data), data[<span class="number">0</span>][<span class="string">'wav'</span>].shape[<span class="number">0</span>], max(src_len))</span><br><span class="line">    tgt = torch.zeros(len(data))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        p = data[i]</span><br><span class="line">        end = src_len[i]</span><br><span class="line">        src_pad[i, :, -end:] = p[<span class="string">'wav'</span>]</span><br><span class="line">        tgt[i] = p[<span class="string">'label'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'wav'</span>: src_pad, <span class="string">'label'</span>: tgt&#125;</span><br><span class="line"></span><br><span class="line">validloader = data.DataLoader(validset, batch_size = batch_sz, shuffle = <span class="literal">False</span>, collate_fn = padding)</span><br></pre></td></tr></table></figure><p>返回的也是字典，并会使用 padding 函数。</p><h2 id="调用-1"><a href="#调用-1" class="headerlink" title="调用"></a>调用</h2><p>上面完成了预先代码的构建，最后是调用的步骤：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx, samples <span class="keyword">in</span> enumerate(trainloader):</span><br><span class="line">    wavs, labels = samples[<span class="string">'wav'</span>], samples[<span class="string">'label'</span>]</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>返回的 samples 就是前面 padding 的结果，可以对此进行修改，例如保留原有的长度信息等等。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch常用训练框架</title>
      <link href="/2020/06/27/tech/PyTorch_%E5%B8%B8%E7%94%A8%E8%AE%AD%E7%BB%83%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/06/27/tech/PyTorch_%E5%B8%B8%E7%94%A8%E8%AE%AD%E7%BB%83%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>现在模型建的比较多了，因此也形成了一套成熟的流程，这里简单的记述一下常用的模型构建的方法，为了后续改进。</p><a id="more"></a>  <h2 id="文件夹架构"><a href="#文件夹架构" class="headerlink" title="文件夹架构"></a>文件夹架构</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\-</span> model</span><br><span class="line">    dataset.py</span><br><span class="line"><span class="string">\-</span> data</span><br><span class="line">    <span class="string">\-</span> images</span><br><span class="line">    <span class="string">\-</span> ori_data</span><br><span class="line"><span class="string">\-</span> preprocess</span><br><span class="line"><span class="string">\-</span> utils</span><br><span class="line">train.py</span><br><span class="line">config.py</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><p><code>config.py</code> 保存 train 以及预处理中的超参，但是不建议使用该文件保存模型的超参（除非整个调整结束）。  <code>utils.py</code> 保留操作函数，用来辅助预处理以及数据分析等等功能。<code>data</code>中存储原始数据以及处理后的数据，部分时候有中间生成数据。<code>images</code>保存为了报告生成的图片。</p><p>生成上述结构代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mkdir</span><span class="params">(paths)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> paths:</span><br><span class="line">    folder = os.path.exists(path) </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> folder:</span><br><span class="line">    os.makedirs(path)   </span><br><span class="line"></span><br><span class="line">mkdir([<span class="string">'model'</span>, <span class="string">'data'</span>, <span class="string">'preprocess'</span>, <span class="string">'utils'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'train.py'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'config.py'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'README.md'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h2><p>常用的 import 库文件。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> pk</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><h3 id="自己的模型"><a href="#自己的模型" class="headerlink" title="自己的模型"></a>自己的模型</h3><p>常用的 Model 架构：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NaiveModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(NaiveModel, self).__init__()</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="预训的模型"><a href="#预训的模型" class="headerlink" title="预训的模型"></a>预训的模型</h3><p>使用一些预训的模型使用。有两种魔改方法，其一是替代原模型中的部分层，另一部分是取出模型的某些部分和自己的其他网络组合。</p><p><strong>替换层方法</strong></p><p>以 vgg16 的替换方法为例。其中可以通过<code>model.features._modules[]</code>拿到对应的层，其中输入为 <code>print(model)</code>产生的输出。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VGG</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(VGGTorch, self).__init__()</span><br><span class="line">        model = torchvision.models.vgg16(pretrained = <span class="literal">False</span>)</span><br><span class="line">        init = torch.load(<span class="string">'data/vgg16-397923af.pth'</span>)</span><br><span class="line">        model.load_state_dict(init)</span><br><span class="line">        conv2d = nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=<span class="number">5</span>, stride=(<span class="number">2</span>, <span class="number">2</span>), padding=(<span class="number">3</span>, <span class="number">3</span>), bias=<span class="literal">False</span>)</span><br><span class="line">        model.features._modules[<span class="string">'0'</span>] = conv2d</span><br><span class="line">        model.classifier = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">25088</span>, <span class="number">20</span>),</span><br><span class="line">            nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">        self.model = model </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = x.reshape(x.shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">128</span>, <span class="number">128</span>).float()</span><br><span class="line">        x = self.model(x)</span><br><span class="line">        <span class="keyword">return</span> x, x</span><br></pre></td></tr></table></figure><p>上面可以通过<code>pretrain = True</code>拿到预训参数，但是下载很慢，可以复制链接自行离线下载然后通过上述方法导入。</p><p><strong>重新组合方法</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面是使用resnet18作为下采样层的UNet模型，通过将ResNet的层取出获得最终模型。其中还使用了预训参数。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Unet</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n_class)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.base_model = torchvision.models.resnet18(pretrained = <span class="literal">True</span>)</span><br><span class="line">        self.base_layers = list(self.base_model.children())</span><br><span class="line">        self.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, kernel_size=(<span class="number">7</span>, <span class="number">7</span>), stride=(<span class="number">2</span>, <span class="number">2</span>), padding=(<span class="number">3</span>, <span class="number">3</span>), bias=<span class="literal">False</span>),</span><br><span class="line">            self.base_layers[<span class="number">1</span>],</span><br><span class="line">            self.base_layers[<span class="number">2</span>])</span><br><span class="line">        self.layer2 = nn.Sequential(*self.base_layers[<span class="number">3</span>:<span class="number">5</span>])</span><br><span class="line">        self.layer3 = self.base_layers[<span class="number">5</span>]</span><br><span class="line">        self.layer4 = self.base_layers[<span class="number">6</span>]</span><br><span class="line">        self.layer5 = self.base_layers[<span class="number">7</span>]</span><br><span class="line">        self.decode4 = Decoder(<span class="number">512</span>, <span class="number">256</span>+<span class="number">256</span>, <span class="number">256</span>)</span><br><span class="line">        self.decode3 = Decoder(<span class="number">256</span>, <span class="number">256</span>+<span class="number">128</span>, <span class="number">256</span>)</span><br><span class="line">        self.decode2 = Decoder(<span class="number">256</span>, <span class="number">128</span>+<span class="number">64</span>, <span class="number">128</span>)</span><br><span class="line">        self.decode1 = Decoder(<span class="number">128</span>, <span class="number">64</span>+<span class="number">64</span>, <span class="number">64</span>)</span><br><span class="line">        self.decode0 = nn.Sequential(</span><br><span class="line">            nn.Upsample(scale_factor=<span class="number">2</span>, mode=<span class="string">'bilinear'</span>, align_corners=<span class="literal">True</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">32</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>, bias=<span class="literal">False</span>)</span><br><span class="line">            )</span><br><span class="line">        self.conv_last = nn.Conv2d(<span class="number">64</span>, n_class, <span class="number">1</span>)</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(n_class * <span class="number">224</span> * <span class="number">224</span>, <span class="number">1024</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dropout(<span class="number">0.4</span>),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">2</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h2 id="Train"><a href="#Train" class="headerlink" title="Train"></a>Train</h2><p>下面是简化的框架。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> pk</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> model.dataset <span class="keyword">import</span> DataSet</span><br><span class="line"><span class="keyword">from</span> torch.utils <span class="keyword">import</span> data</span><br><span class="line"><span class="keyword">from</span> model.naive_model <span class="keyword">import</span> NaiveModel</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(args)</span>:</span></span><br><span class="line">    cuda = torch.cuda.is_available()</span><br><span class="line">    <span class="keyword">if</span> cuda:</span><br><span class="line">        print(<span class="string">"CUDA is prepared"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dataset</span></span><br><span class="line">    trainset = DataSet(<span class="string">'train'</span>, transform_train, normal_path)</span><br><span class="line">    validset = DataSet(<span class="string">'valid'</span>, transform_valid, normal_path)</span><br><span class="line">    trainloader = data.DataLoader(trainset, batch_size = batch_sz, shuffle = <span class="literal">True</span>)</span><br><span class="line">    validloader = data.DataLoader(validset, batch_size = batch_sz, shuffle = <span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># model</span></span><br><span class="line">    model = NaiveModel(batch_sz, <span class="number">224</span>)</span><br><span class="line">    <span class="keyword">if</span> cuda:</span><br><span class="line">        model = model.cuda()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># lossfunc and optim</span></span><br><span class="line">    lossfun = nn.CrossEntropyLoss()</span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters())</span><br><span class="line">    </span><br><span class="line">    accs = []</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">        <span class="comment"># valid</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            preds, labels = [], []</span><br><span class="line">            <span class="keyword">for</span> idx, samples <span class="keyword">in</span> enumerate(validloader):</span><br><span class="line">                img, label = samples[<span class="string">'img'</span>], samples[<span class="string">'label'</span>]        </span><br><span class="line">                <span class="keyword">if</span> cuda:</span><br><span class="line">                    img = img.cuda()</span><br><span class="line">                pred = model.eval(img, labels)</span><br><span class="line">                preds.append(pred)</span><br><span class="line">                labels.append(label)</span><br><span class="line">            torch.save(model.state_dict(), model_path)</span><br><span class="line">            labels = np.concatenate(labels, axis = <span class="number">0</span>).astype(int)</span><br><span class="line">            preds = np.concatenate(preds, axis = <span class="number">0</span>)</span><br><span class="line">            report = classification_report(labels, preds)</span><br><span class="line">            print(report)</span><br><span class="line">            acc = precision_score(labels, preds, average = <span class="string">'micro'</span>)</span><br><span class="line">            print(<span class="string">"Precision: &#123;&#125;"</span>.format(acc))</span><br><span class="line">            accs.append(acc)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># train</span></span><br><span class="line">        <span class="keyword">for</span> idx, samples <span class="keyword">in</span> enumerate(trainloader):</span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            imgs, labels = samples[<span class="string">'img'</span>], samples[<span class="string">'label'</span>]</span><br><span class="line">            <span class="keyword">if</span> cuda:</span><br><span class="line">                labels = labels.cuda()</span><br><span class="line">                imgs = imgs.cuda()</span><br><span class="line">            </span><br><span class="line">            pred = model(imgs)</span><br><span class="line">            loss = lossfun(pred, labels.long())</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            print(<span class="string">'loss: &#123;&#125;'</span>.format(loss), end = <span class="string">'\r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'--pretrain'</span>, type=str, default=<span class="string">'yes'</span>,</span><br><span class="line">                        help=<span class="string">'if pre-train'</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--finetune'</span>, type=str, default=<span class="string">'yes'</span>,</span><br><span class="line">                        help=<span class="string">'if finetune'</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    </span><br><span class="line">    train(args)</span><br></pre></td></tr></table></figure><h2 id="模型保存及预加载"><a href="#模型保存及预加载" class="headerlink" title="模型保存及预加载"></a>模型保存及预加载</h2><p><strong>保存</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">torch.save(<span class="keyword">model</span>.state_dict(), PATH)</span><br><span class="line"> </span><br><span class="line"># example</span><br><span class="line">torch.save(<span class="keyword">model</span>.state_dict(),<span class="string">'model.pth'</span>)</span><br></pre></td></tr></table></figure><p><strong>加载</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">model.load<span class="constructor">_state_dict(<span class="params">torch</span>.<span class="params">load</span>(PATH)</span>)</span><br><span class="line"></span><br><span class="line"># example</span><br><span class="line">model.load<span class="constructor">_state_dict(<span class="params">torch</span>.<span class="params">load</span>('<span class="params">model</span>.<span class="params">pth</span>')</span>)</span><br></pre></td></tr></table></figure><p>这样就是整个模型的最基础框架搭建。但事实上一个任务真正困难的是在数据预处理策略和最后的调参上，这些就放在别的地方补充了吧。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> PyTorch </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python绘图集</title>
      <link href="/2020/06/26/tech/Python/%E7%BB%98%E5%9B%BE/"/>
      <url>/2020/06/26/tech/Python/%E7%BB%98%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>每一次写程序为了可视化都避不开 Python 的 matplotlib，干脆整理一下这个东西。以防后面每次需要反复查一样的东西。</p><a id="more"></a>  <h2 id="绘图基础"><a href="#绘图基础" class="headerlink" title="绘图基础"></a>绘图基础</h2><p><strong>导入步骤</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p><strong>基本操作</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br><span class="line">plt.clr()             <span class="comment">#清空</span></span><br><span class="line">plt.savefig()         <span class="comment">#保存</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">**绘制**：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">plt.plot(x, y, label = <span class="string">'name'</span>, color = <span class="string">'blue'</span>, linestyle = <span class="string">'--'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Time'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Acc'</span>)</span><br><span class="line">plt.legend(loc = <span class="string">'upper left'</span>)</span><br></pre></td></tr></table></figure><p>关于上面的位置，有下表：</p><div class="table-container"><table><thead><tr><th>值</th><th>位置</th></tr></thead><tbody><tr><td>upper right</td><td>右上</td></tr><tr><td>lower left</td><td>左下</td></tr><tr><td>center</td><td>center</td></tr></tbody></table></div><p>排列组合……</p><h2 id="特殊图"><a href="#特殊图" class="headerlink" title="特殊图"></a>特殊图</h2><p><strong>混淆矩阵绘制</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_confusion_matrix</span><span class="params">(cm, savename, title=<span class="string">'Confusion Matrix'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>), dpi=<span class="number">100</span>)</span><br><span class="line">    np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在混淆矩阵中每格的概率值</span></span><br><span class="line">    ind_array = np.arange(len(classes))</span><br><span class="line">    x, y = np.meshgrid(ind_array, ind_array)</span><br><span class="line">    <span class="keyword">for</span> x_val, y_val <span class="keyword">in</span> zip(x.flatten(), y.flatten()):</span><br><span class="line">        c = cm[y_val][x_val]</span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">0.001</span>:</span><br><span class="line">            plt.text(x_val, y_val, <span class="string">"%0.0f"</span> % (c,), color=<span class="string">'red'</span>, fontsize=<span class="number">15</span>, va=<span class="string">'center'</span>, ha=<span class="string">'center'</span>)</span><br><span class="line">    </span><br><span class="line">    plt.imshow(cm, interpolation=<span class="string">'nearest'</span>, cmap=plt.cm.binary)</span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    xlocations = np.array(range(len(classes)))</span><br><span class="line">    plt.xticks(xlocations, classes, rotation=<span class="number">90</span>)</span><br><span class="line">    plt.yticks(xlocations, classes)</span><br><span class="line">    plt.ylabel(<span class="string">'Actual label'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'Predict label'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># offset the tick</span></span><br><span class="line">    tick_marks = np.array(range(len(classes))) + <span class="number">0.5</span></span><br><span class="line">    plt.gca().set_xticks(tick_marks, minor=<span class="literal">True</span>)</span><br><span class="line">    plt.gca().set_yticks(tick_marks, minor=<span class="literal">True</span>)</span><br><span class="line">    plt.gca().xaxis.set_ticks_position(<span class="string">'none'</span>)</span><br><span class="line">    plt.gca().yaxis.set_ticks_position(<span class="string">'none'</span>)</span><br><span class="line">    plt.grid(<span class="literal">True</span>, which=<span class="string">'minor'</span>, linestyle=<span class="string">'-'</span>)</span><br><span class="line">    plt.gcf().subplots_adjust(bottom=<span class="number">0.15</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># show confusion matrix</span></span><br><span class="line">    plt.savefig(savename, format=<span class="string">'png'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><strong>子图</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.plot(x1, y1)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.plot(x2, y2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><strong>热力图</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(matrix)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python图像处理</title>
      <link href="/2020/06/26/tech/Python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2020/06/26/tech/Python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这个是对于 COVID-19 分类任务结束的一个回顾。第一次完成这个图像相关的任务，基本上是一头雾水。在这一次过程中遇到了很多处理的方法，在这里列出来，方便后面使用。</p><a id="more"></a>  <h2 id="读取以及格式转换"><a href="#读取以及格式转换" class="headerlink" title="读取以及格式转换"></a>读取以及格式转换</h2><p>图像处理一般使用 OpenCV 及 PIL.Image 两个库。</p><p><strong>导入</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure><p><strong>图像的读取与保存</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"pic.jpg"</span>， flags)</span><br><span class="line">cv2.imwrite(filename, img)</span><br><span class="line"></span><br><span class="line">img = Image.open(filename)</span><br><span class="line">img.save(filename)</span><br></pre></td></tr></table></figure><p>关于 flags：</p><ul><li>cv2.IMREAD_COLOR:读取一副彩色图片，图片的透明度会被忽略，默认为该值，实际取值为 1；</li><li>cv2.IMREAD_GRAYSCALE:以灰度模式读取一张图片，实际取值为 0</li><li>cv2.IMREAD_UNCHANGED:加载一副彩色图像，透明度不会被忽略。</li></ul><p>以及文件名需要声明为 <code>.jpg / .png</code> 类似的格式才行。</p><p><strong>与 Numpy 互换</strong></p><p>事实上，cv2 导出的数据就是 np.array，例如对于彩色图像是(x, x, 3)的矩阵。而 Image 读出的是 Image 数据，需要转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = Image.fromarray(data)   <span class="comment"># 从array到Image</span></span><br><span class="line">data = np.array(img)          <span class="comment"># 从Image到array</span></span><br></pre></td></tr></table></figure><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>裁剪</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = img.crop((x0, y0, x1, y1))</span><br></pre></td></tr></table></figure><p>传入的是一个数组，标明左上角 <code>x0, y0</code> 及右下角 <code>x1, y1</code>。而由于 cv2 本质上是 np.array，所以可以使用 array 的操作完成。</p><p><strong>Resize</strong></p><p>Resize 是一个相当常用的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = img.resize((<span class="number">256</span>, <span class="number">256</span>), Image.ANTIALIAS)</span><br><span class="line">img = cv2.resize(img, (<span class="number">256</span>, <span class="number">256</span>), interpolation = cv2.INTER_AREA)</span><br></pre></td></tr></table></figure><p>后面是可选项。</p><h2 id="深度学习相关"><a href="#深度学习相关" class="headerlink" title="深度学习相关"></a>深度学习相关</h2><p><strong>直方图均衡化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <span class="comment"># 先转化为灰度图</span></span><br><span class="line">img = cv2.equalizeHist(img)                  <span class="comment"># 然后均衡化</span></span><br></pre></td></tr></table></figure><p><strong>随机变形</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> tfs</span><br><span class="line">transform = tfs.Compose([</span><br><span class="line">    tfs.Resize((<span class="number">256</span>, <span class="number">256</span>)),  <span class="comment"># 先调整图片大小至256x256</span></span><br><span class="line">    tfs.RandomCrop((<span class="number">224</span>, <span class="number">224</span>)),  <span class="comment"># 再随机裁剪到224x224</span></span><br><span class="line">    tfs.RandomHorizontalFlip(),  <span class="comment"># 随机的图像水平翻转，通俗讲就是图像的左右对调</span></span><br><span class="line">    tfs.RandomRotation(<span class="number">5</span>),</span><br><span class="line">    tfs.ToTensor(),</span><br><span class="line">    tfs.Normalize((<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>), (<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.2225</span>)),  <span class="comment"># 维度和图像的channel相关</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>调用时使用即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = transform(img)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> CV </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - Classification of COVID-19 in chest X-ray images using DeTraC deep convolutional neural network</title>
      <link href="/2020/06/04/scholar/paper/Classification%20of%20COVID_19/"/>
      <url>/2020/06/04/scholar/paper/Classification%20of%20COVID_19/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文为课程项目：“COVID-19 的分类和鉴别”做出的准备工作。由于做的工作类型相似，所以做一篇阅读笔记便于参考。</p><a id="more"></a>  <h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>现有的众多方法：</p><ul><li>SVM</li><li>Backpropagation Network</li><li>CNN，作为医学领域最为出众的模型</li><li>Transfer learning。这个方法简单迅速<ul><li>精调（fine-tune）：三类精调：只训练分类层；训练所有参数；训练直到大提升</li></ul></li></ul><p>类分解用来加强低方差的分类器，使在分类边界上更灵活。经常这个方法被用在预处理中提高模型的表现。在医学分析中，类分解经常被用来提高类似随机森林等的分类表现。</p><p>这篇文章使用基于类分解的 CNN 网络，并使用迁移学习方法。对于原数据集中的类，先将其分解为几个完全视为独立的子类，然后对这些子类进行分类，最后组合在一起获得预测结果。</p><h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h2><ul><li>使用基于 CNN 的感知网络检测 COVID-19。</li><li>使用 ResNet 预训的网络分类 CT 图像。</li><li>ImageNet 预训的网络分类 X-ray 抽取特征，然后放入 SVM 中进行分类。</li><li>基于 Transfer Learning 的分类方法，分类 CXR 图像。分为四类：正常、细菌感染、non-COVID、non-COVID 且感染。</li></ul><p>作者认为前面的成果没有讨论数据集的不规则性。这篇文章就讲关注数据的不规则性。</p><h2 id="3-DeTraC-模型"><a href="#3-DeTraC-模型" class="headerlink" title="3. $DeTraC$ 模型"></a>3. $DeTraC$ 模型</h2><p>这个部分讨论整个训练方法的细节。</p><p><strong>3.1 Overview</strong></p><p>整个模型分为三个部分：</p><ul><li>训练从$DeTraC$抽离出的预训的 CNN 模型分离出深层信息，然后使用类分解</li><li>使用复杂优化器进行训练</li><li>使用类组合器去精确分类</li></ul><center><img src="/images/Research/detrac.jpg"/></center><p>类分解器将每一个类分为 k 个子类，并进行单独训练。然后通过类组合器恢复。</p><p><strong>3.2 深度特征挖掘</strong><br>使用 ImageNet 预训的 CNN 模型，通过浅层精调，这样构建特征空间。然后使用 PCA 将高维度信息转换为低维度信息，这对于产生等价类非常有用，并且可以降低空间存储要求，提升效率。</p><p><strong>3.3 类分解器</strong><br>特征空间设为 2D 矩阵$A$，$L$是类别，$m$是特征数量，$k$是类数量，$n$是图片数量。为了完成类分解，使用 k-means 做聚类，将类别划分为等价子类。所有的原标签按照新分出的类别，按照欧几里得距离计算最近的类别然后重新分配标签。这样新获得的数据集称为 $B$。</p><p><strong>3.4 Transfer Learning</strong><br>本论文使用通过 ResNet 预训练的模型，并具有优秀的表现。<strong>作者选择仅变动 low-level 的层数而固定住 high-level 层</strong>。</p><p>参数设定：</p><div class="table-container"><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>学习率</td><td>除最后一层外设定为 0.0001，最后一层设定为 0.01</td></tr><tr><td>批大小</td><td>64</td></tr><tr><td>Epoch</td><td>256</td></tr><tr><td>Weight Decay</td><td>0.01</td></tr><tr><td>Momentum value</td><td>0.9</td></tr></tbody></table></div><p>因为数据很少，使用 SGD 存在不稳定性，所以使用批训练。损失函数为 cross-entropy。</p><p><strong>3.5 Evaluation 与重组</strong><br>在重组阶段，被赋予的新标签会恢复原来的标签，用来衡量模型的性能。这里使用的量为 Accuracy，Specificity, Sensitivity。各自的定义是：（$TN$ 为 <em>true negative</em>。其馀的标记就足够明显了。）</p><script type="math/tex; mode=display">   \begin{aligned}       ACC &= \frac{TP+TN}{n} \\       SN  &= \frac{TP}{TP+FN} \\       SP  &= \frac{TN}{TN+FP}   \end{aligned}</script><p>事实上使用的是多类别的判别方法。</p><h2 id="4-实验部分"><a href="#4-实验部分" class="headerlink" title="4. 实验部分"></a>4. 实验部分</h2><p><strong>4.1 使用的数据集</strong></p><ul><li>数据集包含两个部分：Normal CXRs （80 个正常样本）</li><li>Chest X-ray images，脑筋 105 个 COVID-19 样本和 11 个 SARS 样本。</li></ul><p>经过了数据增强。使用的上下左右翻转等等策略。最后获得了总计 1764 个样本。</p><p><strong>4.2 基于深度学习的类分解</strong><br>使用经过浅层训练的 AlexNet 预训网络，用以抽离原本三个类的特征。然后设定 $k=2$，使用 k-means，对类进行划分，将一个类别进一步划分为 2 个子类。最后得到 norm1, norm2, COVID191,COVID192, SARS1, SARS2 六类。</p><p><strong>4.3 结果</strong></p><ul><li>Acc：95.12%</li><li>SN：97.91%</li><li>SP：91.87%</li></ul><p>使用 70%的数据进行训练，30%的数据进行 Eval。</p><h2 id="5-讨论"><a href="#5-讨论" class="headerlink" title="5. 讨论"></a>5. 讨论</h2><p>训练 CNN 有两种策略。可以使用 end-to-end 的方法，需要大量的标注数据；或者使用迁移学习，仅需要有限的数据就能够完成任务。</p><h2 id="6-读后"><a href="#6-读后" class="headerlink" title="6. 读后"></a>6. 读后</h2><p>感觉是很平庸的一篇文章，将各种预训的结果拼在一起回避数据量过少的问题。唯一可以注意的地方是采用的 decomposition 方法，但这个方法也不是初创的。总体而言像是一个缝合怪。不过就研究方法和使用的数据集构造值得学习。</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> Paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSP：MFCC计算</title>
      <link href="/2020/05/23/course/DSP/MFCC/"/>
      <url>/2020/05/23/course/DSP/MFCC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-JeOleVyj" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5173080" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>MCFF（Mel Frequency Cepstrum Coefficient）的计算过程、背景以及相应的<code>python</code>代码。</p><a id="more"></a>  <p><strong>MFCC</strong>：考虑了人的听觉系统特性，将线性频谱映射到基于听觉感知特性的 Mel 频谱上，然后再计算倒谱。声道的 shape 表现为短时间功率谱的包络线（envelope of the short time power spectrum），MFCCs 的工作则是如何准确地表征这种 envelope。</p><h2 id="1-人听觉系统的特性"><a href="#1-人听觉系统的特性" class="headerlink" title="1. 人听觉系统的特性"></a>1. <strong>人听觉系统的特性</strong></h2><p>人听到的声音高低和声音频率不成线性关系，而是成对数关系。</p><script type="math/tex; mode=display">B(f)=2595log_{10}(1+\frac{f}{700})</script><p><strong>屏蔽效应：</strong>人不能听到所有的声音，只有两个频率分量相差一定的<strong>带宽</strong>时，人耳才能区分。否则只有听到一个音调。这个带宽称为<strong>临界带宽</strong>：</p><script type="math/tex; mode=display">BW_c=25+75[1+1.4(\frac{f_c}{1000})^2]^{0.69}</script><ul><li>其中$f_c$为中心频率。</li><li>当$f_c$在 1kHz 以下时，临界带宽基本恒定为 100Hz。</li><li>当$f_c$在 1kHz 以上时，临界带宽呈指数增加。</li></ul><p>模拟上述的听觉特性，可以进行构造模仿人耳的感知特性。</p><ul><li>Mel 频率尺度：对数关系</li><li>Mel 滤波器组：屏蔽效应<ul><li>每一个滤波器的中心频率在 mel 频率域中呈等间隔分布</li><li>每一个滤波器的带宽在其临界带宽范围内</li></ul></li></ul><h2 id="2-MFCC的计算步骤"><a href="#2-MFCC的计算步骤" class="headerlink" title="2. MFCC的计算步骤"></a>2. MFCC的计算步骤</h2><ol><li>输入语音信号 — 语音波谱</li><li>预加重、分帧、加窗 — 分为不同帧的语音波谱</li><li>用 FFT 计算信号频谱 — 不同帧对应的频谱</li><li>计算频谱的绝对值/平方 — 不同帧对应的能量谱</li><li>使用 Mel 滤波器组 — 获得更符合人类听觉的 Mel 谱特征</li><li>取对数 — 为了倒谱做准备</li><li>DCT — 将乘积通过对数转化为加法。</li><li>Delta MFCC</li><li>输出语音特征</li></ol><h3 id="2-1-预加重、分帧、加窗"><a href="#2-1-预加重、分帧、加窗" class="headerlink" title="2.1 预加重、分帧、加窗"></a>2.1 预加重、分帧、加窗</h3><p><strong>2.1.1 预加重</strong></p><script type="math/tex; mode=display">H(Z)=1-\mu z^{-1}</script><p>即通过一个高通滤波器。在时域中写为：</p><script type="math/tex; mode=display">s_m=s_m-\mu s_{m-1}</script><p>预加重的目的是使频谱变得平坦。同时，也是为了消除发生过程中声带和嘴唇的效应，来补偿语音信号受到发音系统所抑制的高频部分，也为了突出高频的共振峰。$\mu$的取值一般为 0.9~1 之间。</p><p><strong>2.1.2 分帧</strong><br>一个窗为一帧。通常情况下 N=256，时间为 20ms~30ms。对于 8kHz 的信号来说，若帧长度为 256 个采样点，则对应的时间为$256 / 8000\times 1000 = 32ms$。</p><p><strong>2.1.3 加窗</strong><br>对每一帧使用汉明窗。通常，$a$取值为 0.46.</p><script type="math/tex; mode=display">w(n)=1-a[1+cos(\frac{2\pi n}{N-1})]</script><h3 id="2-2-FFT"><a href="#2-2-FFT" class="headerlink" title="2.2 FFT"></a>2.2 FFT</h3><p>对每一帧进行 FFT，变换到频率域中。</p><h3 id="2-3-Mel滤波器组"><a href="#2-3-Mel滤波器组" class="headerlink" title="2.3 Mel滤波器组"></a>2.3 Mel滤波器组</h3><p>人的听力像是一组滤波器（见第一节讨论的<strong>屏蔽效应</strong>），听见的声音在频谱上是不连续的;并且在低频上分布更密集（同样参见第一节中人听到的声音特性）。将能量谱通过一组 Mel 尺度的三角形滤波器组，定义一个有 $M$ 个滤波器的滤波器组。</p><center><img src="/images/Single/Mel组.jpg" width="50%" height="50%" /></center><ul><li>中心频率$f_c(l)$在 Mel 频率域中是等间隔分布</li><li>每一个滤波器的中心频率为：<script type="math/tex; mode=display">f(m)=(\frac{N}{F_s})B^{-1}(B(f_l)+m\frac{B(f_h)-B(f_l)}{M+1})</script>其中：$N$为窗口宽度，$F_s$为采样频率，$M$为滤波器数量，通常取 22~26。通过上式可以获得 M 个带通滤波器$H_m(k)$<script type="math/tex; mode=display">H_m(k)=\begin{cases}0 & \text{ k < f(m-1) }\\\frac{k-f(m-1)}{f(m)-f(m-1)} & \text{ f(m-1) < k < f(m) }\\\frac{f(m+1)-k}{f(m+1)-f(m)} & \text{ f(m) < k < f(m+1) }\\0 & \text{ otherwise }\end{cases}</script></li></ul><center><img src="/images/Single/DSP-滤波器组.jpg" width="50%" height="50%"/></center><p>对频谱进行平滑化，并消除谐波的作用，突显原先语音的共振峰。因此一段语音的音调或音高，是不会呈现在 MFCC 参数内，换句话说，以 MFCC 为特征的语音辨识系统，并<strong>不会受到输入语音的音调不同的影响</strong>。此外，还可以降低运算量。</p><p>计算每个滤波器组输出的对数能量。其中$M$为滤波器个数，$N$为窗口大小。</p><script type="math/tex; mode=display">S(m)=ln[\sum_{k=1}^N|X(k)|^2H_m(k)]</script><!-- **MFCC**$$log|S(e^{jw})|=\sum_{m=-\infty}^{\infty}c_me^{-jwn}$$$$S(w)=lim_{N\to\infty}\frac{1}{N}|X(e^{jw})|^2=lim_{N\to\infty}\frac{1}{N}|\sum_{n=0}^{N-1}x(n)e^{-jwn}|^2$$ --><h3 id="2-4-离散馀弦变换（DCT）"><a href="#2-4-离散馀弦变换（DCT）" class="headerlink" title="2.4 离散馀弦变换（DCT）"></a>2.4 离散馀弦变换（DCT）</h3><p>对滤波器组输出$S(m)$，DCT 得到 Mel 频率的倒谱系数$c(n)$。</p><p>DCT 正变换：</p><script type="math/tex; mode=display">   \begin{aligned}       F(0) &= \frac{1}{\sqrt{N}}\sum_{x=0}^{N-1}f(x),~~~u=0 \\       F(u) &= \sqrt{\frac{2}{N}}\sum_{x=0}^{N-1}f(x)cos[\frac{\pi}{2N}(2x+1)u], ~~~u=1,2,3...,N-1   \end{aligned}</script><p>DCT 反变换：</p><script type="math/tex; mode=display">f(x)=\frac{1}{\sqrt(N)}F(0)+\sqrt{\frac{2}{N}}\sum_{u=0}^{N-1}F(u)cos[\frac{\pi}{2N}(2x+1)u], ~~~x=1,2,3,...,N-1</script><p>将$S(m)$作为上式中的$f(x)$，$m$作为$x$得到下式：</p><script type="math/tex; mode=display">c(n)=\sum_{m=1}^MS(m)cos[\frac{\pi n(m-0.5)}{M}], ~~~n=0,1,...,L</script><p>这里的$L$是 MFCC 系数的阶数，通常取 12~16。</p><h3 id="2-5-Delta-MFCC"><a href="#2-5-Delta-MFCC" class="headerlink" title="2.5 Delta MFCC"></a>2.5 Delta MFCC</h3><p>到此为止，MFCC 只是获得了当前帧的语音特征。而相邻帧之间是连续的，可以通过相邻帧之间的变化更好地表达语音的特征。</p><center><img src="/images/Single/DMFCC.jpg"/></center><h2 id="3-MFCC常用参数集"><a href="#3-MFCC常用参数集" class="headerlink" title="3. MFCC常用参数集"></a>3. MFCC常用参数集</h2><div class="table-container"><table><thead><tr><th>参数</th><th>取值</th></tr></thead><tbody><tr><td>$\mu$（预加重参数）</td><td>0.9~1</td></tr><tr><td>$N$（窗口大小）</td><td>256/512</td></tr><tr><td>采样率</td><td>8kHz/16kHz</td></tr><tr><td>帧长</td><td>20ms~30ms</td></tr><tr><td>$M$（Mel 滤波器组数量）</td><td>22~26</td></tr><tr><td>$L$（MFCC 阶数）</td><td>12~16</td></tr><tr><td>$a$（汉明窗系数）</td><td>0.46</td></tr></tbody></table></div><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h2><ol><li>这篇文章将原理解释得挺不错：<a href="https://blog.csdn.net/zouxy09/article/details/9156785/" target="_blank" rel="noopener">梅尔频率倒谱系数（MFCC）</a></li><li>这篇将流程解释得更清楚：<a href="https://blog.csdn.net/class_brick/article/details/82743741" target="_blank" rel="noopener">语音特征 MFCC 提取过程详解</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读 - Departures from Tree Structures in Discourse - Shared Arguments in PDTB</title>
      <link href="/2020/05/22/scholar/paper/Departure_from_tree_structures_in_discourse/"/>
      <url>/2020/05/22/scholar/paper/Departure_from_tree_structures_in_discourse/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>为了更好地搞清楚自己究竟读过哪些论文，于是决定为读过的论文写一些笔记。这是第一篇笔记，关于 PDTB 中树结构的构建问题。</p><a id="more"></a>  <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>这篇文章关于 Discourse Structure，是指任何超过句子结构以上的结构。尽管在大多数时候，DS 都可以被放在一个树地结构下，但是存在这样一个结构：两棵树会存在交集的情况，即存在一个“daughter”被两个 root 管辖。这篇文章将关注点放在“the shared discourse structure is a <em>syntactically subordinate clause</em> introduced by a <em>subordinating conjunction</em>”。</p><p>关于上述定义：</p><ul><li>syntactically subordinate clause：是指语法上的从句结构</li><li>subordinating conjunction<ul><li>从属连词，a connecting word or phrase that introduces a <strong>dependent clause</strong> and joins it to a <strong>main clause or independent clause</strong>.</li><li>常常被用来加上时间、让步、对比、因果等等条件</li><li>从属连词必须放在 dependent clause 的开头</li><li>例子：because, before, when; even though, as long as, except that</li></ul></li></ul><p>这篇文章考虑的是，从属句可能会作为另一个 DS 的一个 Argument，并暗示了 Syntactic subordication 及 DS 的关联。这篇文章的主张是：尽管在大多数时候，SS 和 DS 是对应的，但是有一些例外的存在。这里讨论这些例外，以及它们的意义。</p><h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h2><blockquote><p>a subordinating conjunction is a grammaticization of the rhetorical organization of discourse</p></blockquote><p>一般认为 Sc（subordinating clause）和其他 non-salient discourse 一样，对主题的连续性无关。这些成分被认为是句子的背景，但是他们本身并不能使主题更进一步。依据这种思路给出了做 Summarizer 的思路：移除所有的 non-salient 部分即可以完成概括。而有人指出，Sc 只是作为一个造成 discourse saliency 的原因。<br>这篇文章会通过经验上的方法，去检验句法和篇章之间的关系。</p><h2 id="3-方法及发现"><a href="#3-方法及发现" class="headerlink" title="3. 方法及发现"></a>3. 方法及发现</h2><p>考虑这样一个句型：”X although Y”，其中 X, Y 是 although 的两个 arguments，Y 是从句，假设标注者并不知道这个句子的关系的情况下，遇到了另外一个句子，这时候我们关心的是，Y 是否被选出作为另一个 DS 的一个 argument。</p><blockquote><p>The London index finished 2.4% under its close of 2233.9 the previous Friday, <strong>although</strong> it recouped some of the sharp losses staged early last week on the back of Wall Street’s fall. London was weak throughout Friday’s trading, <strong>however</strong>, on what dealers attributed to generally thin interest…(1505)</p></blockquote><p>在这个例子中，although 是第一个 ds 的一个 argument，同时也是第二个句子的一个 argument。为了方便我们称呼由 however 引导的这个 ds 为 external relation。在 PDTB 中，这样的 subordinating conjunctions 还有 after, although, as, because, …共计 12 个最为常见。在所有的情况中，以全句作为 er 的比例是最高的；其次是使用 matrix clause；最其次是使用 sc 作为 argument。而使用 coordinating conjunctions 作为对比则可以发现，其后两类的比例是几乎一样的。</p><blockquote><p>it does seem to be the case that there is a correspondence between syntactic<br>coordination and subordination on the one hand, and symmetric or asymmetric salience of discourse arguments on the other</p></blockquote><p>几乎可以认为，sc 的 saliency 低于 matrix clause。因此，认为语法和 ds 相关的观点是可以成立的。</p><h2 id="4-讨论"><a href="#4-讨论" class="headerlink" title="4. 讨论"></a>4. 讨论</h2><p>几个例子：</p><blockquote><p>They won’t buy <strong>if</strong> the quality is not there. <strong>Or</strong> if they feel the wine is overpriced. (0071)</p></blockquote><p>这个例子特殊在，尽管”the quality is not there“是一个 sc，并被 Or 判定为 er，但是可以发现整个句子是以 if 作为基础的，这样的例子可以使用树状结构加以概括。这和前文出现的例子不一样，前文的例子是一些并列的关系。于是可能在没有出现明显的嵌入的情况下，我们认为把 discourse 放入某些树结构中没有太多价值。</p><script type="math/tex; mode=display">{X~~IF~~(Y~~OR~~Z)}~~~--5i</script><p>上述式子可以概括原句。我们给一个新的例子：</p><script type="math/tex; mode=display">{X~~ALTHOUGH~~(Y}~~HOWEVER~~Z)~~~--5ii</script><p>我们认为 Y 延续了这个 DS，而再上面那个例子没有。(5i)这样是符合预期的，因为我们不希望一个 sc 去作为句子的主要成分并 continue 一个 DS。而(5ii)则更有意思。所以在什么情况下，一个 sc 会变成推动句子发展的 salient clause？下面是文章的作者们做的一些观察（文章作者声称自己并不仅仅是做观察，并会将系统的分析留到将来数据集更完善的时候（感觉这是我的锅了））。<br>首先，有两种固定的模式：</p><ul><li>这个 sc 总是后置的。例如”The dilligent boy passed the exam because <strong>he studied hard</strong>“，前置或者居中的 sc 是不行的。</li><li>er 总是限定在 - 对比、因果这样的关系中，而例如并列这样的关系则没有。</li></ul><p>以及一些大概率的模式：</p><ul><li><strong>Anaphoric matrix clause</strong>：这个 matrix clause 在原文中有一个很明显的前指。</li><li><strong>Reduced matrix clause</strong>：通过代词等短句很简单地指向了前文。</li></ul><blockquote><p>it may be <strong>because</strong> these shows need all the protection they can get. (<strong>Implicit-CAUSE</strong>) European programs usually target only their own local audience, and often only a small portion of that. (2361)，对应第二种模式</p></blockquote><p>在上述的情况中，主句总是在前文中有一个前置。可以认为是前置提供的信息削弱了后面主句的 saliency，使得 sc 上位。即，如果主句更多的是在照应前文的观点，则使得其从句更加自由，便可以作为承接下文的句子。</p><ul><li><strong>sc 被一个”coordinating-type“的 subordinating conjunction 引导</strong>：特别的，这里指两个词：<em>although</em>和<em>because</em>。这两种词引导的句子经常被用作 external argument，在发现的 349 例中，有 189 例归于上述两个中的一个。</li></ul><p>所以是否在 DS 中使用树结构，还是说在 DS 下使用树结构只是从语法分析上遗留下来的策略？</p>]]></content>
      
      
      <categories>
          
          <category> 学术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Paper </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动给中英混合文本加上空格</title>
      <link href="/2020/05/22/tech/Hexo/%E6%8A%80%E5%B7%A7_%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%A9%BA%E6%A0%BC/"/>
      <url>/2020/05/22/tech/Hexo/%E6%8A%80%E5%B7%A7_%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>使用 textlint 给文本中英文交界的地方加上空格。对 Markdown 文件或者 txt 文件都会挺有用。</p><a id="more"></a>  <p><strong>安装</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> textlint <span class="comment">--global</span></span><br><span class="line">npm <span class="keyword">install</span> textlint-rule-ja-<span class="keyword">space</span>-<span class="keyword">between</span>-half-<span class="keyword">and</span>-<span class="keyword">full</span>-width <span class="comment">--global</span></span><br><span class="line">textlint <span class="comment">--init</span></span><br></pre></td></tr></table></figure><br>这里使用<code>--save</code>似乎是不行的，无法被程序找到<code>textlint</code></p><p>修改生成的<code>.textlint</code>文件为（似乎不修改也没事）<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"filters"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"rules"</span>: &#123;</span><br><span class="line">        <span class="attr">"ja-space-between-half-and-full-width"</span>: &#123;</span><br><span class="line">            <span class="attr">"space"</span>: <span class="string">"always"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加空格：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">textlint</span> -- fix <span class="regexp">*.md</span></span><br></pre></td></tr></table></figure></p><p>注意，使用这个语法即使写错了也不会报错的。对于 Blog 文件，可以考虑在生成脚本文件最前面，添加一行<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textlint --fix <span class="keyword">source</span><span class="regexp">/_posts/</span>*.md</span><br></pre></td></tr></table></figure><br>这样每一次生成 Blog 的时候就能自动纠错了。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脚本工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章：互连网络</title>
      <link href="/2020/05/21/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap7_%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/05/21/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap7_%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>互联函数</li><li>互联网络的参数与性能指标</li><li>静态互连网络</li><li>动态互连网络<a id="more"></a>  </li></ul><p><strong>互连网络</strong>是一种由开关元件按照一定的拓扑结构和控制方式构成的网络，用来实现计算机系统中节点之间的相互连接。</p><ul><li><strong>节点</strong>：处理器、存储模块或其他设备。</li><li>在拓扑上，互连网络为输入节点到输出节点之间的一组互连或映射。 </li><li>SIMD 计算机和 MIMD 计算机的关键组成部分。 </li><li><strong>3 大要素</strong>：互连结构，开关元件，控制方式。 </li></ul><h2 id="7-1-互连函数"><a href="#7-1-互连函数" class="headerlink" title="7.1 互连函数"></a>7.1 互连函数</h2><h3 id="7-1-1-互连函数"><a href="#7-1-1-互连函数" class="headerlink" title="7.1.1 互连函数"></a>7.1.1 互连函数</h3><p><strong>互连函数</strong>：通过数学表达式建立输入端号与输出端号的连接关系。即在互连函数 f 的作用下，输入端 x 连接到输出端$f(x)$。</p><ul><li>互连函数反映了网络输入数组和输出数组之间对应的置换关系或排列关系。</li><li>互连函数 f(x)有时可以采用循环表示<ul><li>${x_0, x_1, … x_{j-1}}~\to~f(x_0)=x_0, f(x_1)=x_2, …, f(x_{j-1})=x_0$</li><li>$j$称为循环的长度。</li><li>互连函数表示为$f(x_{n-1}x_{n-2}…x_1x_0)$</li><li>$x=x_{n-1}x_{n-2}…x_1x_0$，其中$n=log_2N$。</li></ul></li></ul><h3 id="7-1-2-几种基本的互连函数"><a href="#7-1-2-几种基本的互连函数" class="headerlink" title="7.1.2 几种基本的互连函数"></a>7.1.2 几种基本的互连函数</h3><p><strong>恒等函数</strong>：$I(x_{n-1}x_{n-2}…x_1x_0)=x_{n-1}x_{n-2}…x_1x_0$<br><strong>交换函数</strong>：实现二进制地址编码中第 k 位互反的输入端与输出端之间的连接。</p><ul><li>主要用于构造立方体互连网络和各种超立方体互连网络。</li><li>该函数有 n 种</li><li><strong>立方体互连函数</strong>：当$N=8$，即$n=3$时。</li></ul><script type="math/tex; mode=display">   \begin{aligned}       Cube_0 &= x_2x_1\bar{x_0} \\       Cube_1 &= x_2\bar{x_1}x_0 \\       Cube_2 &= \bar{x_2}x_1x_0   \end{aligned}</script><center><img src="/images/Single/cube.jpg" width="50%" height="50%" />N=8的立方体交换函数</center><p><strong>均匀洗牌函数</strong></p><ul><li>将输入端分成数目相等的两半，前一半和后一半按类似均匀混洗扑克牌的方式交叉地连接到输出端（输出端相当于混洗的结果）。也称为<strong>混洗函数</strong>。直观的来说是将原地址乘 2 取模。</li><li>$ \sigma(x_{n-1}x_{n-2}…x_1x_0)=x_{n-2}x_{n-3}…x_1x_0x_{n-1} $</li><li><strong>第 k 个子函数$\sigma_(k)$</strong>：把 s 作用于输入端的二进制编号的低 k 位。将低 k 位左移一位。</li><li><strong>第 k 个超函数$\sigma^(k)$</strong>：把 s 作用于输入端的二进制编号的高 k 位。将高 k 位左移一位。</li><li>$\sigma^{(n)}=\sigma_{(n)}=\sigma$</li><li>$\sigma^{(1)}=\sigma_{(1)}=f$</li><li>若存在函数使$f(x)\times g(x)=I(x)$则称为$g(x)$是$f(x)$的逆函数。</li><li>逆均匀洗牌函数</li></ul><center><img src="/images/Single/均匀洗牌.jpg" width="50%" height="50%" ></center><p><strong>碟式函数</strong></p><ul><li>把输入端的二进制编号的最高位与最低位互换位置，便得到了输出端的编号。</li><li>$\beta(x_{n-1}x_{n-2}…x_1x_0)=x_0x_{n-2}…x_1x_{n-1}$</li><li><strong>第 k 个子函数$\beta_{(k)}$</strong>：将输入端第 k 位（编号 k-1）与编号 0 交换。</li><li><strong>第 k 个超函数$\beta^{(k)}$</strong>：将输入端第 n-k 位与编号 n-1 交换。</li><li>$\beta^{(n)}=\beta_{(n)}=\beta$</li><li>$\beta^{(1)}=\beta_{(1)}=f$</li></ul><center><img src="/images/Single/蝶式函数.jpg" width="50%" height="50%" /></center><p><strong>移数函数</strong></p><ul><li>将各输入端都错开一定的位置（模 N）后连到输出端。</li><li>$\alpha(x)=(x\pm k)~mod~N$</li></ul><p><strong>PM2I 函数</strong></p><ul><li>一种移数函数，将各输入端都错开一定的位置（模 N）后连到输出端。</li><li>$PM2_{+i}=(x+2^imod)N$</li><li>$PM2_{-i}=(x-2^imod)N$</li><li>该函数互联网络具有 2n 个不同的互连函数。</li></ul><center><img src="/images/Single/PM2.jpg" width="50%" height="50%" /></center><h2 id="7-2-互连网络的结构参数与性能指标"><a href="#7-2-互连网络的结构参数与性能指标" class="headerlink" title="7.2 互连网络的结构参数与性能指标"></a>7.2 互连网络的结构参数与性能指标</h2><h3 id="7-2-1-互连网络的结构参数"><a href="#7-2-1-互连网络的结构参数" class="headerlink" title="7.2.1 互连网络的结构参数"></a>7.2.1 互连网络的结构参数</h3><ul><li>网络通常是用有向边或无向边连接有限个节点的图来表示。</li><li>互连网络的主要特性参数有：<ul><li><strong>网络规模 N</strong>：节点个数，连接的部件数量</li><li><strong>节点度 d</strong>：与节点连接的边数（通道数）</li><li><strong>节点距离</strong>：从一个节点出发到另一个节点终止所需要跨越的边数的最小值</li><li><strong>网络直径 D</strong>：距离的最大值</li><li><strong>等分宽度 b</strong>：把 N 个节点切成节点数相同的两半需要的切除边数的最小值<ul><li>线等分宽度：$B=b\times w$</li><li>w 为通道宽度</li><li>反映了网络最大流量</li></ul></li></ul></li></ul><h3 id="7-2-2-性能指标"><a href="#7-2-2-性能指标" class="headerlink" title="7.2.2 性能指标"></a>7.2.2 性能指标</h3><p><strong>通信时延</strong>：指从源节点到目的节点传送一条消息所需的总时间，它由以下 4 部分构成：</p><ul><li><strong>软件开销</strong>：在源节点和目的节点用于收发消息的软件所需的执行时间。<ul><li>取决于节点处理消息的软件内核</li></ul></li><li><strong>通道时延</strong>：通过通道传送消息所花的时间。<ul><li>通信时延 = 消息长度 / 通信带宽</li><li>有瓶颈的通道带宽决定</li></ul></li><li><strong>选路时延</strong>：消息在传送路径上所需的一系列选路决策所需的时间开销。<ul><li>与路径的节点数相关</li></ul></li><li><strong>竞争时延</strong>：多个消息同时在网络中传送时，会发生争用网络资源的冲突。为避免或解决争用冲突所需的时间就是竞争时延。</li></ul><p><strong>网络时延</strong></p><ul><li>通道时延与选路时延的和</li><li>由网络硬件特征决定，与程序星为和传输状态无关</li></ul><p><strong>端口宽带</strong></p><ul><li>对于互连网络中的任意一个端口来说，其端口带宽是指单位时间内从该端口传送到他端口的最大信息量。</li><li>在对称网络中，端口带宽与端口位置无关。网络的端口带宽与各端口的端口带宽同。</li><li>非对称网络的端口带宽则是指所有端口带宽的最小值。</li></ul><p><strong>聚集带宽</strong>：网络从一半节点到另一半节点，单位时间内能够传送的最大信息量。<br><strong>等分带宽</strong>：与等分宽度对应的切平面中，所有边合起来单位时间所能传送的最大信息量。</p><h2 id="7-3-静态互联网络"><a href="#7-3-静态互联网络" class="headerlink" title="7.3 静态互联网络"></a>7.3 静态互联网络</h2><p>互连网络通常可以分为两大类：</p><ul><li>静态互连网络：各节点之间有固定的连接通路、且在运行中不能改变的网络。</li><li>动态互连网络：由交换开关构成、可按运行程序的要求动态地改变连接状态的网络。</li></ul><p><strong>线性阵列</strong></p><ul><li>一种一维的线性网络，其中 N 个节点用 N-1 个链路连成一行。</li><li>端节点的度：1</li><li>其馀节点的度：2</li><li>直径：N－1</li><li>等分宽度 b=1</li></ul><p><strong>环和带弦环</strong></p><ul><li>环<ul><li>用一条附加链路将线性阵列的两个端点连接起来而构成。可以单向工作，也可以双向工作。</li><li>对称性</li><li>节点的度：2</li><li>双向环的直径：N/2</li><li>单向环的直径：N </li><li>环的等分宽度 b=2 </li></ul></li><li>带弦环<ul><li>增加的链路越多，节点度就越高，网络直径就越小</li></ul></li><li>全连接网络</li></ul><center><img src="/images/Single/带弦环.jpg" width="50%" height="50%" /></center><p><strong>循环移数网络</strong></p><ul><li>通过在环上每个节点到所有与其距离为 2 的整数幂的节点之间都增加一条附加链而构成。</li><li>即如果$|j-i|=2^r$，则 j 与 i 连接。<ul><li>节点度：2n-1</li><li>直径：n/2</li><li>网络规模：$N=2^n$</li></ul></li></ul><center><img src="/images/Single/循环.jpg" width="50%" height="50%" /></center><p><strong>树形和星形</strong></p><center><img src="/images/Single/树形.jpg" width="50%" height="50%" /></center><ul><li>树形可靠性较差，具有较高的节点度</li></ul><p><strong>胖树形</strong></p><p><strong>网格形和环网形</strong></p><ul><li>网格形<ul><li>对于$n\times n$的网格<ul><li>内部节点的度 d=4</li><li>边节点的度 d=3</li><li>角节点的度 d=2</li><li>网络直径 D=2（n-1）</li><li>等分宽度 b=n</li></ul></li><li>一个由$N=n^k$个节点构成的 k 维网格形网络（每维 n 个节点）的内部节点度 d=2k，网络直径 D=k(n-1) </li></ul></li><li>Illiac 网络<ul><li>把 2 维网格形网络的每一列的两个端节点连接起来，再把每一行的尾节点与下一行的头节点连接起来，并把最后一行的尾节点与第一行的头节点连接起来。</li><li>对于$n\times n$的网格<ul><li>所有节点的度 d=4</li><li>网络直径 D=n-1</li><li>Illiac 网络的直径只有纯网格形网络直径的一半。 </li><li>等分宽度：2n</li></ul></li></ul></li><li>环网形<ul><li>把 2 维网格形网络的每一行的两个端节点连接起来，把每一列的两个端节点也连接起来。 </li><li>将环形和网格形组合在一起，并能向高维扩展。 </li><li>一个 n×n 的环网形网 <ul><li>节点度：4</li><li>网络直径：2×(n/2)</li><li>等分宽度 b=2n </li></ul></li></ul></li></ul><center><img src="/images/Single/网格形.jpg " width="50%" height="50%" /></center><p><strong>超立方体</strong></p><ul><li>一个二元 n-立方体由$N=2^n$个节点组成，它们分布在 n 维上，每维有两个节点。</li><li>为实现一个 n-立方体，只要把两个（n－1）立方体中相对应的节点用链路连接起来即可。共需要 2n-1 条链路。</li><li>n-立方体中节点的度都是 n，直径也是 n，等分宽度为 b=N/2 。 </li></ul><p><strong>带环立方体（3-CCC）</strong></p><ul><li>把 3-立方体的每个节点换成一个由 3 个节点构成的环而形成的。</li><li>带环 k-立方体（简称 k-CCC）<ul><li>k-立方体的变形，它是通过用 k 个节点构成的环取代 k-立方体中的每个节点而形成的。</li><li>网络规模为 N=k×2k</li><li>网络直径为 D=2k-1+k/2</li><li>比 k-立方体的直径大一倍</li><li>等分宽度为 b=N/（2k）</li></ul></li></ul><center><img src="/images/Single/带环立方体.jpg" width="50%" height="50%" /></center><h2 id="7-4-动态互连网络"><a href="#7-4-动态互连网络" class="headerlink" title="7.4 动态互连网络"></a>7.4 动态互连网络</h2><h3 id="7-4-1-总线网络"><a href="#7-4-1-总线网络" class="headerlink" title="7.4.1 总线网络"></a>7.4.1 总线网络</h3><p>由一组导线和插座构成，经常被用来实现计算机系统中处理机模块、存储模块和外围设备等之间的互连。</p><ul><li>每一次总线只能用于一个源（主部件）到一个或多个目的（从部件）之间的数据传送。</li><li>多个功能模块之间争用总线或时分总线</li><li>特点：结构简单、成本低、带宽窄</li></ul><p><strong>一种由总线连接的多处理机系统</strong></p><center><img src="/images/Single/总线系统.jpg" width="50%" height="50%" /></center><ul><li>系统总线在处理机、I/O 子系统、主存储器以及辅助存储设备（磁盘、磁带机等）之间提供了一条公用通路。</li><li>系统总线通常设置在印刷电路板底板上。处理器板、存储器板和设备接口板都通过插座或电缆插入底板。</li></ul><p><strong>带宽窄的解决</strong></p><ul><li>多总线是设置多条总线，有两种做法：<ul><li>为不同的功能设置专门的总线</li><li>重复设置相同功能的总线</li></ul></li><li>多层次的总线是按层次的架构设置速度不同的总线，使得不同速度的模块有比较适合的总线连接。 </li></ul><h3 id="7-4-2-交叉开关网络"><a href="#7-4-2-交叉开关网络" class="headerlink" title="7.4.2 交叉开关网络"></a>7.4.2 交叉开关网络</h3><p><strong>单极开关网络</strong></p><ul><li>交叉点开关能在对偶（源、目的）之间形成动态连接，同时实现多个对偶之间的无阻塞连接。</li><li>带宽和互连特性最好。 </li><li>一个 n×n 的交叉开关网络，可以无阻塞地实现$n!$种置换。 </li><li>对一个 n×n 的交叉开关网络来说，需要 n2 套交叉点开关以及大量的连线。当 n 很大时，交叉开关网络所需要的硬件数量非常巨大。</li></ul><p><strong>C.mmp 多处理机的互连结构</strong></p><ul><li>用 16×16 的交叉开关网络把 16 台 PDP-11 处理机与 16 个存储模块连在一起</li><li>最多可同时实现 16 台处理机对 16 个不同存储模块的并行访问<ul><li>每个存储模块一次只能满足一台处理机的请求</li><li>当多个请求要同时访问同一存储模块时，交叉开关就必须分解所发生的冲突，每一列只能接通一个交叉点开关。</li><li>为了支持并行（或交叉）存储器访问，可以在同一行中接通几个交叉点开关。 </li></ul></li></ul><center><img src="/images/Single/mmp.jpg" width="50%" height="50%" /></center><h3 id="7-4-3-多级互联网络"><a href="#7-4-3-多级互联网络" class="headerlink" title="7.4.3 多级互联网络"></a>7.4.3 多级互联网络</h3><p><strong>多级互连网络的构成</strong></p><ul><li>MIMD 和 SIMD 都采用多级互联网络 MIN（Multistage Interconnection Network）</li><li>一种通用的多级互连网络 <ul><li>由 a×b 开关模块和级间连接构成的通用多级互连网络结构</li><li>每一级都用了多个 a×b 开关<ul><li>a 个输入和 b 个输出</li><li>在理论上，a 和 b 不一定相等，然而实际上 a 和 b 经常选为 2 的整数幂，即 a＝b＝2k，k≥1。 </li></ul></li><li>相邻各级开关之间都有固定的级间连接</li></ul></li></ul><center><img src="/images/Single/多级互连.jpg" width="50%" height="50%" /></center><ul><li>最简单的开关模块：2x2 开关</li></ul><center><img src="/images/Single/22开关.jpg" width="50%" height="50%" /></center><ul><li>各种多级互连网络的区别在于所用开关模块、控制方式和级间互连模式的不同。<ul><li>控制方式：对各个开关模块进行控制的方式。<ul><li>级控制：每一级的所有开关只用一个控制信号控制，只能同时处于同一种状态。</li><li>单元控制：每一个开关都有一个独立的控制信号，可各自处于不同的状态。</li><li>部分级控制：第 i 级的所有开关分别用 i＋1 个信号控制，0≤i≤n－1，n 为级数。</li></ul></li><li>常用的级间互连模式：均匀洗牌、蝶式、多路洗牌、纵横交叉、立方体连接等</li></ul></li></ul><p><strong>多级立方网络</strong></p><ul><li>多级立方体网络包括 STARAN 网络和间接二进制 n 方体网络等。<ul><li>两者仅在控制方式上不同，在其他方面都是一样的。</li><li>都采用二功能（直送和交换）的 2×2 开关。</li><li>当第 i 级（0≤i≤n-1）交换开关处于交换状态时，实现的是 Cubei 互连函数。 </li></ul></li><li>一个 N 输入的多级立方体网络有 log2N 级，每级用 N/2 个 2×2 开关模块，共需要 log2N×N/2 个开关。</li></ul><center><img src="/images/Single/多级立方网络.jpg" width="50%" height="50%" />一个8个入端的多级立方体网络</center><ul><li>STARAN 网络采用级控制和部分级控制。<ul><li>采用级控制时，所实现的是交换功能；</li><li>采用部分级控制时，则能实现移数功能。</li></ul></li><li>间接二进制 n 方体网络则采用单元控制。<ul><li>具有更大的灵活性。</li></ul></li></ul><p><strong>Omega 网络</strong></p><center><img src="/images/Single/Omega网络.jpg" width="50%" height="50%" />一个8×8的Omega网络</center><ul><li>一个 N 输入的 Omega 网络<ul><li>有$log_2N$级，每级用 N/2 个 2×2 开关模块，共需要$Nlog_2N/2$个开关。</li></ul></li><li>每个开关模块均采用单元控制方式。</li><li>不同的开关状态组合可实现各种置换、广播或从输入到输出的其他连接。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧克力奶茶</title>
      <link href="/2020/05/20/essay/cookbook/%E5%B7%A7%E5%85%8B%E5%8A%9B%E5%A5%B6%E8%8C%B6/"/>
      <url>/2020/05/20/essay/cookbook/%E5%B7%A7%E5%85%8B%E5%8A%9B%E5%A5%B6%E8%8C%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本文簡單記敘一下巧克力奶茶的做法，爲提高下一次水準做準備。</p><a id="more"></a>  <p><strong>口感</strong></p><ul><li>呈現巧克力牛奶般的顏色</li><li>口感粗糲，不算非常順滑，略苦</li><li>可能會因爲巧克力過多而蓋過茶味，這個還需要探索</li><li>黑巧克力可能並不合適，和奶茶自身的味道些許衝突，沒有展現各自的優勢</li></ul><p><strong>材料</strong></p><ul><li>純牛奶一盒：250ml</li><li>紅茶葉若干：大概小半把，煮沸後占 1/4 個碗</li><li>冰糖：15 顆以上</li><li>黑巧克力：20g。如果放整條那茶味會被蓋過去</li></ul><p><strong>步驟</strong></p><ul><li>冷水煮沸，冷水量不能太多，兩碗以內。</li><li>放入茶葉，小火熬製一段時間，會聞到「番茄味」，水會變成棕紅色。</li><li>倒入牛奶、冰糖、巧克力，小火熬製。煮沸後靜置一段時間</li><li>可以按照相同的辦法，但是不放巧克力就變成普通的奶茶</li></ul><p><strong>實驗失敗經歷</strong></p><ol><li>實驗 001<ul><li>使用了 40g 黑巧克力</li><li>三碗水，水似乎放多了</li><li>使用冷水煮紅茶，效果不理想</li><li>結果：巧克力味道過重，幾乎蓋過了茶味，呈現巧克力牛奶的味道</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 食譜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『鋼の錬金術師』03版觀感</title>
      <link href="/2020/05/19/essay/%E8%A7%82%E6%84%9F/%E9%92%A2%E4%B9%8B%E7%82%BC%E9%87%91%E6%9C%AF%E5%B8%8803/"/>
      <url>/2020/05/19/essay/%E8%A7%82%E6%84%9F/%E9%92%A2%E4%B9%8B%E7%82%BC%E9%87%91%E6%9C%AF%E5%B8%8803/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-JaCnDcqt" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="636907" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="評價：★★★★☆"><a href="#評價：★★★★☆" class="headerlink" title="評價：★★★★☆"></a>評價：★★★★☆</h3><a id="more"></a><p>　　在相對高壓的接近期末季的時候，看完了鋼之鍊金術師 03 版，就簡單地記一下觀感吧。（這真的似乎是我很不擅長的方式，不過不妨一試）<br>　　整體而論，03 版敘述了一個更小的故事，但是述說了更真實的故事；09 版敘述了一個巨大的陰謀，但是結局顯得過於樂觀。僅就故事節奏、完整性種種考慮，個人認爲 09 版優於 03 版。許多人認爲 03 版較 09 版更爲深刻，這一點本人暫無法苟同，但不可否認 03 版本的嚴肅壓抑氛圍對於這樣一個故事時是更得體的，09 版顯得太歡樂。</p><blockquote><p>人は何かの犠牲なしに、何も得ることはできない。何かを得るためには、同等の代価が必要となる。<br>人沒有的犧牲的話就什麼也得不到，爲了得到某些東西，就必須付出同等的代價。</p></blockquote><p>　　在觀看 03 版之前先看的 09 版，毫無疑問的是 03 版的氛圍比 09 版沉重了很多。03 版很大的問題是在後期脫離原作基礎的情況下，事件發生的邏輯鏈開始頻繁斷裂，人物在場景間的移動和出現往往突兀得不講道理。此外許多人物的謝幕方式也顯得莫名其妙，例如被 Sloth 被 Wrath 坑掉，大總統被兒子坑掉。毫無疑問此二人這樣的結局是<strong>相當具有意味</strong>的，也是我很欣賞的部分，但是非常生硬地讓之前的伏筆串在一起打出結局，效果終於是不太理想。</p><p>　　不過除開上述描述的嚴重缺陷，03 版做得相當出色的一點是對於「等價交換」原則的討論，這是一個逆否命題。整部作品中，有至少兩點是被討論到了的。第一點是：付出了代價是否就能獲得同等的回報。第二點是：這個原則本身是否就是可信的？</p><blockquote><p>痛みを伴わない教訓には意義がない、人は何かの犠牲無しには何も得ることには出來ないのだから。しかし、その痛みに耐え乘り越えた時、人は何物にも負けない強韌な心を手に入れる、そう鋼のような心を……<br>不伴隨着痛楚的教訓就沒有意義，因爲人若無犧牲，就不會有收穫。然而，當戰勝這痛楚時，人就將獲得不屈服於任何事物的堅強之心，是的，鋼鐵般的堅強之心。 ——09版</p></blockquote><p>　　在 09 版中，「等價交換」這一原則是不容置疑的，整部作品也沒有違背這一點。在故事的最後，兄弟二人耗費了多年的時間，換來了一顆堅毅的心，這是對於等價交換的總結。但是在 03 版中，對於等價交換的詮釋構成了問題的核心。等價交換原則是被兩兄弟堅信的一點，也是二人被但丁嘲笑的一點。這是一個很現實的問題，正像在劇裡面提到的「人生而不平等」問題在當今社會是顯然的，一個人可能付出百倍的努力獲得的回報只是另外一部分人付出一倍努力的結果，我們稱之爲天分或者運氣。這個問題在 03 版並沒有得到解答，是一個「失敗」的結束，對於所有人來說都是。努力復活母親的兄弟最後只能親手再殺一次人造人；企圖恢復手臂的愛德華，不僅沒有成功，反而永遠與弟弟分離；希望奪取大總統之位的大佐最後被流放。這是一個對於幾乎所有人都是「失敗」的結尾，然而世界還是依舊地運轉。</p><p>　　不過在這樣的悲哀之中，主人公還是抓到了渺小的希望：有一些獲取的東西，是不需要付出代價的，這是被稱爲「愛」的東西。這是一個樸素的答案，卻照亮了整部陰暗的作品。03 版的故事是關於「愛」的故事，它隱藏了行動的動機，卻強調了行動造成的不可挽回的後果，省略了「愛」帶來的溫暖或者企圖讓它們看起來理所應當。但事實上這才是真正的動力，讓所有人行動並堅強的唯一的理由。（聽起來挺怪的，但這一部對於這一點的詮釋挺棒的。）</p><p>　　03 版的部分人物處理得比 09 更爲富有內涵。斯卡自不必說，從一個復仇者最後變成一個殉道者，整個過程 03 版較 09 版來得更爲自然而有人性。03 版設定下的人造人的記憶也是令人造人出彩的點，Rust 在這個版本裡如若新生，找到了自己最後的價值。但是大總統較 09 而言差了很大一截，人物顯得略有扁平化，09 版的大總統有血有肉，是一個塑造地成功太多的角色。有一點最後想說一下，許多人在劇情後期指責阿爾聖母心壞事，愛德華行事拖沓；但事實上，人善良而弱小，這不是罪，而是<strong>現實</strong>。</p><p>　　PS：03 整部覺得最爲最爲令人感動的細節：在修斯准將殉職的那一集，黑色底的報幕。節制而真誠。</p><center><img src="/images/Things/鋼煉.jpg"/>鋼之鍊金術師03劇場版</center>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 觀感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章:IO系统</title>
      <link href="/2020/05/15/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap6_IO/"/>
      <url>/2020/05/15/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap6_IO/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ol><li>I/O 性能</li><li>I/O 可靠性</li><li>廉价磁盘冗馀阵列 RAID</li><li>总线</li><li>通道处理机</li><li>I/O 与操作系统</li></ol><a id="more"></a><h2 id="6-1-I-O系统性能与CPU性能"><a href="#6-1-I-O系统性能与CPU性能" class="headerlink" title="6.1 I/O系统性能与CPU性能"></a>6.1 I/O系统性能与CPU性能</h2><ol><li>IO 系统包括 IO 设备与 IO 设备和处理机的连接</li><li>IO 系统是计算机的一个重要组成部分</li><li>IO 系统可分为存储 IO 系统及通信 IO 系统</li><li>系统响应时间：从用户输入命令开始，到得到结果需要的时间。由 IO 系统响应时间和 CPU 处理时间组成</li><li>评价 IO 系统的参数：连接特性/IO 系统容量</li></ol><h2 id="6-2-I-O系统的可靠性、可用性、可信性"><a href="#6-2-I-O系统的可靠性、可用性、可信性" class="headerlink" title="6.2 I/O系统的可靠性、可用性、可信性"></a>6.2 I/O系统的可靠性、可用性、可信性</h2><p><strong>系统可靠性</strong>：系统从某个初始参考点开始一直连续提供服务的能力，用<strong>平均无故障时间 MTTF</strong>来衡量。</p><ul><li>MTTF：Mean Time To Failure</li><li>MTTF 的倒数是系统的<strong>失效率</strong>。</li><li>MTTR：平均修复时间<br>计算系统可靠性的方法：将不同部件的失效率相加求倒。</li></ul><p>提高系统部件可靠性的方法：</p><ul><li>有效构建方法：消除故障隐患</li><li>纠错方法：即使出现故障也能正常工作</li></ul><p><strong>系统的可用性：</strong>系统正常工作的时间在连续两次正常服务间隔时间中所占的比例。</p><script type="math/tex; mode=display">可用性=\frac{MTTF}{MTTF+MTTR}</script><p>平均失效间隔时间 MTBF：MTTF+MTTR</p><p><strong>可信性：</strong>服务的质量。多大程度上可以合理地认为服务是可靠的。这是不可以度量的。</p><h2 id="6-3-磁盘冗馀阵列RAID"><a href="#6-3-磁盘冗馀阵列RAID" class="headerlink" title="6.3 磁盘冗馀阵列RAID"></a>6.3 磁盘冗馀阵列RAID</h2><p><strong>磁盘阵列 DA（Disk Array）</strong>：使用多个磁盘（包括驱动器）的组合来代替一个大容量的磁盘。</p><ul><li>多个磁盘并行工作。</li><li>以条带为单位把数据均匀地分布到多个磁盘上。（交叉存放）</li><li>条带存放可以使多个数据读/写请求<strong>并行</strong>地被处理，从而提高总的 I/O 性能。<ul><li>多个独立请求可以由多个盘并行地处理：减少了 IO 请求的排队时间</li><li>如果一个请求访问了多个块，就可以多个盘一起处理：提高了单个请求的数据传输率</li></ul></li><li>增加磁盘数量会导致磁盘阵列的可靠性下降</li><li>磁盘阵列组成<ul><li>细粒度：<strong>优点：</strong>所有 I/O 请求都能够获得很高的数据传输率；<strong>缺点：</strong>在任何时间，都只有一个逻辑上的 I/O 在处理当中，而且所有的磁盘都会因为为每个请求进行定位而浪费时间。</li><li>粗粒度：多个较小规模的请求可以同时得到处理。对于较大规模的请求又能获得较高的传输率。</li></ul></li><li>设置冗馀需要解决的问题：<ul><li>如何计算冗馀信息：奇偶校验码</li><li>如何将信息分布：将信息存放在几个盘中；将数据均匀分在所有盘中</li></ul></li></ul><h3 id="6-3-1-RAID0"><a href="#6-3-1-RAID0" class="headerlink" title="6.3.1 RAID0"></a>6.3.1 RAID0</h3><center><img src="/images/Single/RAID0.jpg" width="50%" height="50%" />RAID0</center><ol><li>非冗馀阵列</li><li>将数据切分为条带，交叉地进行存放</li></ol><h3 id="6-3-2-RAID1"><a href="#6-3-2-RAID1" class="headerlink" title="6.3.2 RAID1"></a>6.3.2 RAID1</h3><center><img src="/images/Single/RAID1.jpg" width="50%" height="50%" />RAID1</center><ol><li>双备份磁盘：将数据写入镜像磁盘</li><li>特点：<ol><li>能实现快速读取</li><li>写性能由最差的磁盘决定</li><li>可靠性高</li><li>昂贵</li></ol></li></ol><h3 id="6-3-3-RAID2"><a href="#6-3-3-RAID2" class="headerlink" title="6.3.3 RAID2"></a>6.3.3 RAID2</h3><center><img src="/images/Single/RAID2.jpg" width="50%" height="50%" />RAID2</center><ol><li>存储式磁盘阵列，使用汉明码</li><li>特点<ol><li>每个数据盘存放所有数据字的一位（位交叉存放）</li><li>各个数据盘上的相应位计算汉明校验码，编码位被存放在多个校验（ECC）磁盘的对应位上。</li><li>冗馀盘是用来存放汉明码的，其个数为 log2m 级。m：数据盘的个数（也就是数据字的位数）</li><li>并未被广泛应用，目前还没有商业化产品。</li></ol></li></ol><h3 id="6-3-4-RAID3"><a href="#6-3-4-RAID3" class="headerlink" title="6.3.4 RAID3"></a>6.3.4 RAID3</h3><center><img src="/images/Single/RAID3.jpg" width="50%" height="50%" />RAID3</center><ol><li>位交叉奇偶阵列</li><li>特点<ol><li>采用奇偶校验</li><li>写数据时需要写入校验盘</li><li>读数据时可以通过校验盘恢复数据</li><li>采用的带宽比较小</li><li>校验空间开销小</li></ol></li></ol><h3 id="6-3-5-RAID4"><a href="#6-3-5-RAID4" class="headerlink" title="6.3.5 RAID4"></a>6.3.5 RAID4</h3><center><img src="/images/Single/RAID4.jpg" width="50%" height="50%" />RAID4</center><ol><li>块交叉奇偶校验</li><li>采用比较大的条带，可以同时处理多个小规模访问请求</li><li>特点<ol><li>访问只需要访问数据所在的磁盘</li><li>只有在故障时才会读取校验码并进行重建</li><li>对于上图的设定，写数据需要两次磁盘读和两次磁盘写</li></ol></li></ol><h3 id="6-3-6-RAID5"><a href="#6-3-6-RAID5" class="headerlink" title="6.3.6 RAID5"></a>6.3.6 RAID5</h3><center><img src="/images/Single/RAID5.jpg" width="50%" height="50%" />RAID5</center><ol><li>块交叉分布奇偶校验磁盘阵列</li><li>无需冗馀盘，将奇偶校验分布在所有盘上</li></ol><h3 id="6-3-7-其他RAID"><a href="#6-3-7-其他RAID" class="headerlink" title="6.3.7 其他RAID"></a>6.3.7 其他RAID</h3><ol><li>RAID6：P+Q 双校验磁盘阵列：使用两个校验位，检验空间开销是 RAID5 的两倍；可以容忍两个磁盘出错</li><li>RAID10：先进行镜像再进行条带存放</li><li>RAID01：先进行条带存放再进行镜像</li></ol><h2 id="6-4-总线"><a href="#6-4-总线" class="headerlink" title="6.4 总线"></a>6.4 总线</h2><p>优点：成本低、多样性<br>缺点：不同外设分时共享，限制了 I/O 的吞吐率</p><h3 id="6-4-1-总线的设计"><a href="#6-4-1-总线的设计" class="headerlink" title="6.4.1 总线的设计"></a>6.4.1 总线的设计</h3><ol><li>难点<ol><li>总线上信息传输收到物理因素限制：总线的长度、设备的数目、信号的强度</li><li>I/O 既要快又要高吞吐</li></ol></li><li><p>分离事务总线</p><ol><li>又称流水总线、悬挂总线</li><li>多个主设备时，可以通过打包技术提高总带宽：将事务分为请求和应答。再请求和应答之间，总线可以供给其他 I/O 使用</li><li>分离事务总线有较高的带宽，但是数据传输延迟更大<center><img src="/images/Single/总线.jpg" width="50%" height="50%" />分离事务总线</center></li></ol></li><li><p>同步总线：包含一个供总线上所有设备使用的时钟，并且这些设备是基于该时钟按照一个固定的协议来发送地址和数据的。 </p></li><li>异步总线：没有统一的参考时钟，每个设备都有各自的定时方法。采用握手协议 。</li></ol><h3 id="6-4-2-与CPU的连接"><a href="#6-4-2-与CPU的连接" class="headerlink" title="6.4.2 与CPU的连接"></a>6.4.2 与CPU的连接</h3><ol><li>I/O 总线的连接有两种方法：连接到存储器上；连接到 Cache 上</li><li>I/O 总线连接到存储器总线上</li><li>CPU 对 I/O 设备的编址<ol><li>存储器映射 I/O，将存储器地址分给 I/O 设备，使用 load 和 store 进行读写。将一部分存储空间空出用于设备控制</li><li>为 I/O 设备设置单独的 I/O 指令用于访问设备</li></ol></li></ol><h2 id="6-5-通道处理机"><a href="#6-5-通道处理机" class="headerlink" title="6.5 通道处理机"></a>6.5 通道处理机</h2><p><strong>通道处理机（简称通道）</strong>：专门负责整个计算机系统的输入/输出工作。通道处理机只能执行有限的一组输入/输出指令。</p><h3 id="6-5-1-通道的作用"><a href="#6-5-1-通道的作用" class="headerlink" title="6.5.1 通道的作用"></a>6.5.1 通道的作用</h3><ol><li>程序控制、中断和 DMA 方式管理外围设备会引起两个问题：<ol><li>所有外设的输入/输出工作均由 CPU 承担，CPU 的计算工作经常被打断而去处理输入/输出的事务，不能充分发挥 CPU 的计算能力。 </li><li>大型计算机系统的外设虽然很多，但同时工作的机会不是很多。 </li></ol></li><li>一个典型的由 CPU、通道、设备控制器、外设构成的 4 级层次结构的输入/输出系统。</li><li>通道的功能 <ol><li>接收 CPU 发来的 I/O 指令，并根据指令要求选择指定的外设与通道相连接。</li><li>执行通道程序：从主存中逐条取出通道指令，对通道指令进行译码，并根据需要向被选中的设备控制器发出各种操作命令。</li><li>给出外设中要进行读/写操作的数据所在的地址。如磁盘存储器的柱面号、磁头号、扇区号等。 </li><li>给出主存缓冲区的首地址：该缓冲区存放从外设输入的数据或者将要输出到外设中去的数据。</li><li>控制外设与主存缓冲区之间的数据传送的长度：对传送的数据个数进行计数，并判断数据传送是否结束。</li><li>指定传送工作结束时要进行的操作。例如：将外设的中断请求及通道的中断请求送往 CPU 等。</li><li>检查外设的工作状态是否正常，并将该状态信息送往主存指定单元保存。</li><li>在数据传输过程中完成必要的格式变换。例如：把字拆分为字节，或者把字节装配成字等。</li></ol></li><li>通道的主要硬件<ol><li>寄存器：数据缓冲寄存器，主存地址计数器，传输字节数计数器，通道命令字寄存器，通道状态字寄存器</li><li>控制逻辑：分时控制，地址分配，数据传送、装配和拆分等</li></ol></li></ol><h3 id="6-5-2-工作过程"><a href="#6-5-2-工作过程" class="headerlink" title="6.5.2 工作过程"></a>6.5.2 工作过程</h3><ol><li>通道完成一次数据输入/输出的工作过程<ol><li>在用户程序中使用访管指令进入管理程序，由管理程序生成一个通道程序，并启动通道。<ol><li>用户在目标程序中设置一条广义指令，通过调用操作系统的管理程序来实现。</li><li>管理程序根据广义指令提供的参数来编制通道程序。 </li><li>启动输入/输出设备指令是一条主要的输入/输出指令，属于特权指令。</li></ol></li><li>通道处理机执行通道程序，完成指定的数据输入/输出工作。通道处理机执行通道程序与 CPU 执行用户程序是并行的。 </li><li>通道程序结束后向 CPU 发中断请求。</li></ol></li><li>时间关系</li></ol><center><img src="/images/Single/通道时间.jpg " width="50%" height="50%" />通道时间示意</center><h3 id="6-5-3-种类"><a href="#6-5-3-种类" class="headerlink" title="6.5.3 种类"></a>6.5.3 种类</h3><ol><li>字节多路通道<ol><li>为多台低速或中速的外设服务。</li><li>以字节交叉的方式分时轮流地为它们服务。</li><li>字节多路通道可以包含多个子通道，每个子通道连接一台设备控制器。 </li></ol></li><li>选择通道<ol><li>为多台高速外围设备服务。 </li><li>在一段时间内只为一台高速外设独占使用。</li><li>选择通道的硬件：寄存器/格式交换部件/通道控制部件</li></ol></li><li>数组多路通道<ol><li>适用于高速设备。</li><li>每次选择一个高速设备后传送一个数据块，轮流为多台外围设备服务。</li></ol></li></ol><h3 id="6-5-4-重要：流量分析"><a href="#6-5-4-重要：流量分析" class="headerlink" title="6.5.4 重要：流量分析"></a>6.5.4 <strong>重要</strong>：流量分析</h3><ol><li>通道流量：一个通道在数据传送期间，单位时间内能够传送的数据量。所用单位一般为 Bps。  <ul><li>又称为通道吞吐率、通道数据传输率等。</li><li>通道最大流量：一个通道在满负荷工作状态下的流量 。</li><li>参数的定义 <ul><li>$T_S$：设备选择时间。从通道响应设备发出的数据传送请求开始，到通道实际为这台设备传送数据所需要的时间。</li><li>$T_D$：传送一个字节所用的时间。</li><li>p：在一个通道上连接的设备台数，且这些设备同时都在工作。</li><li>n：每台设备传送的字节数，这里假设每台设备传送的字节数都相同。</li><li>k：数组多路通道传输的一个数据块中包含的字节数。在一般情况下，k &lt; n。对于磁盘、磁带等磁表面存储器，通常 k = 512。</li><li>T：通道完成全部数据传送工作所需要的时间。</li></ul></li></ul></li><li>字节多路通道：<ol><li>传送过程：通道每连接一台个外设，只传送一个字节，然后又与另一台设备连接，并传送一个字节。</li><li>为 p 个设备传送 n 个数据需要时间：<script type="math/tex; mode=display">T_{BYTE}=(T_S+T_D)\times p \times n</script></li><li>最大流量：<script type="math/tex; mode=display">f_{max}=\frac{pn}{(T_S+T_D)pn}=\frac{1}{T_S+T_D}</script></li><li>实际流量：连接在这个通道上所有设备的数据传输率之和</li></ol></li><li>选择通道<ol><li>在一段时间内只能单独为一台高速外设服务，当这台设备的数据传送工作全部完成后，通道才能为另一台设备服务。 </li><li>为 p 个设备传送 n 个数据需要时间：<script type="math/tex; mode=display">T_{SELECT}=(\frac{T_S}{n}+T_D)pn</script></li><li>最大流量：<script type="math/tex; mode=display">f_{max}=\frac{1}{\frac{T_S}{n}+T_D}</script></li></ol></li><li>数组多路通道<ol><li>为 p 个设备传送 n 个数据需要时间：<script type="math/tex; mode=display">T_{SELECT}=(\frac{T_S}{k}+T_D)pn</script></li><li>最大流量：<script type="math/tex; mode=display">f_{max}=\frac{1}{\frac{T_S}{k}+T_D}</script></li><li>选择通道和数组多路通道的实际流量就是连接在这个通道上的所有设备中数据流量最大的那一个 。</li><li>各种通道的实际流量应该不大于通道的最大流量</li></ol></li></ol><h2 id="6-6-I-O与操作系统"><a href="#6-6-I-O与操作系统" class="headerlink" title="6.6 I/O与操作系统"></a>6.6 I/O与操作系统</h2><ul><li>在用硬件实现的 I/O 技术中，哪些会实际被采用，是由操作系统来决定的。 </li><li>I/O 操作主要是在外设和存储器之间进行，所以操作系统必须保证这些 I/O 操作的安全性。</li></ul><h3 id="6-6-1-DMA与虚拟存储器"><a href="#6-6-1-DMA与虚拟存储器" class="headerlink" title="6.6.1 DMA与虚拟存储器"></a>6.6.1 DMA与虚拟存储器</h3><p><strong>DMA 是使用虚拟地址还是物理地址？</strong></p><ol><li>使用物理地址进行 DMA 传输，存在以下两个问题：<ul><li>对于超过一页的数据缓冲区，由于缓冲区使用的页面在物理存储器中不一定是连续的，所以传输可能会发生问题。 </li><li>如果 DMA 正在存储器和缓冲区之间传输数据时，操作系统从存储器中移出（或重定位）一些页面，那么，DMA 将会在存储器中错误的物理页面上进行数据传输。 </li></ul></li><li>解决这些问题的方法 <ul><li>使操作系统在 I/O 的传输过程中确保 DMA 设备所访问的页面都位于物理存储器中，这些页面被称为是钉在了主存中。</li><li>“虚拟 DMA”技术：允许 DMA 设备直接使用虚拟地址，并在 DMA 期间由硬件将虚拟地址转换为物理地址。在采用虚拟 DMA 的情况下，如果进程在内存中被移动，操作系统应该能够及时地修改相应的 DMA 地址表。 </li></ul></li></ol><h3 id="6-6-2-I-O和Cache数据一致性"><a href="#6-6-2-I-O和Cache数据一致性" class="headerlink" title="6.6.2 I/O和Cache数据一致性"></a>6.6.2 I/O和Cache数据一致性</h3><ol><li>Cache 会造成两个副本</li><li>把 I/O 连接到存储器上会出现以下情况：<ul><li>CPU 修改了 Cache 的内容后，由于存储器的内容跟不上 Cache 内容的变化，I/O 系统进行输出操作时所看到的数据是旧值。（写直达 Cache 没有这样的问题）</li><li>I/O 系统进行输入操作后，存储器的内容发生了变化，但 CPU 在 Cache 中所看到的内容依然是旧值。 </li></ul></li><li>把 I/O 直接连接到 Cache 上：<ul><li>不会产生由 I/O 导致的数据不一致的问题。 </li><li>所有 I/O 设备和 CPU 都能在 Cache 中看到最新的数据。</li><li>I/O 会跟 CPU 竞争访问 Cache，在进行 I/O 时，会造成 CPU 的停顿。 </li><li>I/O 还可能会破坏 Cache 中 CPU 访问的内容，因为 I/O 操作可能导致一些新数据被加入 Cache，而这些新数据可能在近期内并不会被 CPU 访问。  </li></ul></li><li>解决内容一致性问题的方法（不管 Cache 是采用写直达法还是写回法）<ul><li>软件的方法：设法保证 I/O 缓冲器中的所有各块都不在 Cache 中。<ul><li>把 I/O 缓冲器的页面设置为不可进入 Cache 的，在进行输入操作时，操作系统总是把输入的数据放到该页面上。</li><li>在进行输入操作之前，操作系统先把 Cache 中与 I/O 缓冲器相关的数据“赶出”Cache，即把相应的数据块设置为“无效”状态。   </li></ul></li><li>硬件的方法<ul><li>在进行输入操作时，检查相应的 I/O 地址（I/O 缓冲器中的单元）是否在 Cache 中（即是否有数据副本）。</li><li>如果发现 I/O 地址在 Cache 中有匹配的项，就把相应的 Cache 块设置为“无效”。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>番茄炒蛋</title>
      <link href="/2020/05/12/essay/cookbook/%E7%95%AA%E8%8C%84%E7%82%92%E8%9B%8B/"/>
      <url>/2020/05/12/essay/cookbook/%E7%95%AA%E8%8C%84%E7%82%92%E8%9B%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>雖然這是道家常菜吧，但也不經常做。偶爾有一次效果不錯，所以記一下。<br><a id="more"></a><br><strong>口感</strong></p><ul><li>甜味爲主的風格</li><li>顏色可以算是鮮艷，絕對不用蔥子，導致色調只有紅色和黃色。</li></ul><p><strong>材料</strong></p><ul><li>一個雞蛋</li><li>一個番茄</li><li>少量姜</li></ul><p><strong>步驟</strong></p><ul><li>打蛋放鹽，放置一段時間</li><li>番茄滾刀切成大塊，撒上白砂糖放置一段時間，儘量將白砂糖塗抹均勻</li><li>放油炒熱，多放些油避免粘鍋</li><li>倒入雞蛋，儘量攤開</li><li>迅速倒入番茄，炒</li><li>用鏟子把番茄切開，小火炒，讓番茄逐漸變軟</li><li>待到顏色看起來像樣子了就能起鍋</li></ul><p><strong>實驗失敗經歷</strong></p><ul><li>按照上述方式，成功完成一次，可喜可賀</li></ul>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 食譜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语音频谱处理</title>
      <link href="/2020/05/10/course/DSP/%E8%AF%AD%E9%9F%B3%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90/"/>
      <url>/2020/05/10/course/DSP/%E8%AF%AD%E9%9F%B3%E9%A2%91%E8%B0%B1%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul><li>叠加原理</li><li>卷积同态系统</li><li>复倒谱和倒谱</li><li>复倒谱的计算</li><li>语音信号的倒谱分析</li><li>计算 MFCC 系数<a id="more"></a>  </li></ul><h2 id="1-广义叠加原理"><a href="#1-广义叠加原理" class="headerlink" title="1. 广义叠加原理"></a>1. 广义叠加原理</h2><p>对于线性系统，使用卷积或者乘法代替线性系统的叠加原理，即：</p><script type="math/tex; mode=display">H[x(n)]=H[x_1(n)*x_2(n)]=H[x_1(n)*x_2(n)]=y_1(n)*y_2(n)=y(n)</script><h2 id="2-卷积同态系统"><a href="#2-卷积同态系统" class="headerlink" title="2. 卷积同态系统"></a>2. 卷积同态系统</h2><p>卷积同态系统由三部分组成：</p><ul><li>特征系统：$D_*[]$</li><li>线性系统：$L[]$</li><li>逆特征系统：$D_*^{-1}[]$</li></ul><p><strong>$D_*[]$</strong><br>输入是若干信号的卷积，输出为若干信号的加法组合。有以下的特性</p><script type="math/tex; mode=display">D_*[x(n)]=D_*[x_1(n)*x_2(n)]=D_*[x_1(n)]+D_*[x_2(n)]=\hat{x}_1(n)+\hat{x}_2(n)=\hat{x}(n)</script><p><strong>$L[]$</strong><br>服从叠加原理：</p><script type="math/tex; mode=display">L[\hat{x}(n)]=L[\hat{x}_1(n)+\hat{x}_2(n)]=L[\hat{x}_1(n)]+L[\hat{x}_2(n)]=\hat{y}_1(n)+\hat{y}_2(n)=\hat{y}(n)</script><p><strong>$D_*^{-1}[]$</strong><br>变换回卷积组合：</p><script type="math/tex; mode=display">D_*^{-1}[\hat{y}(n)]=y(n)</script><p>卷积同态的实现方法。利用 Z 变换，可以将卷积组合变为乘法，利用对数特性，将乘法组合变为加法，用此构成同态系统的特征系统$D_*[]$。其逆同态则是将取对数转化为指数运算。</p><center><img src="/images/Single/逆卷积.jpg" width="50%" height="50%" /></center><p><strong>同态系统的用途</strong></p><ul><li>将二个信号通过卷积（或乘积）合成的信号分开，是一种非线性处理方法。</li><li>对语音信号来说，同态处理的目的是将激励和声道分开，然后再分别进行研究<ul><li>对激励进行研究，可以确定语音片段是清音、浊音及浊音的基音频率等特征</li><li>对声道进行研究，可以确定声道特性及共振峰等特征</li></ul></li></ul><h2 id="3-复倒谱和倒谱"><a href="#3-复倒谱和倒谱" class="headerlink" title="3. 复倒谱和倒谱"></a>3. 复倒谱和倒谱</h2><p>设信号$x(n)$的 Z 变换为$X(z)$，其对数为$\hat{X}(z)=lnX(z)=ln[z[x(n)]]$。<br>那么$\hat{X}(z)$的逆变换为$\hat{x}(n)=z^{-1}[\hat{X}(z)]=z^{-1}[lnz[x(n)]]$</p><p><strong>复对数的多值性问题</strong><br>在复倒谱分析中，Z 变换得到的是复数，所以取对数涉及复对数运算，存在相位多值性问题，称为<strong>相位卷绕</strong>。</p><blockquote><p>例如：对于a为正实数，b为负实数，$ln(ab)=ln(a|b|e^{jk\pi})=ln(a)+ln(|b|)+jk\pi$。</p></blockquote><p>在计算复倒谱时，应保证复对数函数的单值性，满足广义叠加原理，且要选定<strong>收敛域</strong>以保证逆 z 变换的唯一性。</p><p><strong>注意</strong><br>在计算倒谱的情况下，信号经过同态处理的正、逆特征系统后，不能还原自身！因为此时只有幅值信息，丢掉了相位信息。对语音信号分析来说，因为人的听觉系统对频谱幅值敏感，对相位不敏感，所以倒谱分析可以用于语音信号。</p><p>如果对$X(e^{jw})$的绝对值取对数，得</p><script type="math/tex; mode=display">\hat{X}(e^{jw})=ln|X(e^{jw})|</script><p>求出的倒谱频称为<strong>实倒谱</strong>，即</p><script type="math/tex; mode=display">c(n)=\frac{1}{2\pi}\int^{\pi}_{-\pi}ln|X(e^{jw})|e^{jwn}</script><h2 id="4-复倒谱的计算方法"><a href="#4-复倒谱的计算方法" class="headerlink" title="4 复倒谱的计算方法"></a>4 复倒谱的计算方法</h2><p>设信号为$x(n)=x_1(n)*x_2(n)$，<br>则其傅里叶变换：</p><script type="math/tex; mode=display">X(e^{jw})=lnX_1(e^{jw})+lnX_2(e^{jw})</script><p>其幅度为：</p><script type="math/tex; mode=display">ln|X(e^{jw})| =ln|X_1(e^{jw})|+ln|X_2(e^{jw})|</script><p>相位：</p><script type="math/tex; mode=display">\phi(w)=\phi_1(w)+\phi_2(w)</script><p>这被称为相位缠绕。</p><h3 id="4-1-微分法"><a href="#4-1-微分法" class="headerlink" title="4.1 微分法"></a>4.1 微分法</h3><p>信号$X(n)$和倒频谱$\hat{x}(n)$的计算方法：</p><script type="math/tex; mode=display">j\frac{d}{dw}X(e^{jw})=\sum nx(n)e^{-jwn}</script><script type="math/tex; mode=display">j\frac{d}{dw}\hat{X}(e^{jw})=\sum n\hat{x}(n)e^{-jwn}</script><script type="math/tex; mode=display">\hat{X}(e^{jw})=lnX(e^{jw})</script><p>有：</p><script type="math/tex; mode=display">    \begin{aligned}        j\frac{d}{dw}\hat{X}(e^{jw})        &= j\frac{d}{dw}[lnX(e^{jw})]\\        &= \frac{j\frac{d}{dw}[X(e^{jw})]}{X(e^{jw})}\\        &=\sum n\hat{x}(n)e^{-jwn}    \end{aligned}</script><center><img src="/images/Single/int.jpg" width="50%" height="50%" /></center><p>这样就避开了复对数运算。但<strong>缺点</strong>是，$nx(n)$的高频分量较$X(n)$更多，按照原采样频率进行分析回导致频率混叠问题。</p><h3 id="4-2-最小相位信号法"><a href="#4-2-最小相位信号法" class="headerlink" title="4.2 最小相位信号法"></a>4.2 最小相位信号法</h3><p>被处理的信号$x(n)$是<strong>最小相位信号</strong>：Z 变换的全部几点和零点都位于 Z 平面单位元内部的信号，本质上是指具有<strong>最小相位延迟的序列信号</strong>。在实际应用中，许多信号是最小相位信号，或可以看作是最小相位信号。语音信号的模型就是极点都在 z 平面单位圆内的全极点模型，或者极零点都在 z 平面单位圆内的极零点模型。</p><p>设$x(n)$为最小相位信号，则$\hat{x}(n)$为因果稳定序列。</p><script type="math/tex; mode=display">\hat{x}(n)=\hat{x}_e(n)+\hat{x}_o(n)</script><script type="math/tex; mode=display">\hat{x}_e(n)=\frac{1}{2}[\hat{x}(n)+\hat{x}(-n)]</script><p>则有：</p><script type="math/tex; mode=display">\Phi[\hat{x}_e(n)]=\frac{1}{2}[\hat{X}(e^{jw})+\hat{X}(e^{-jw})]=\hat{X}_R(e^{jw})</script><p>该式不包含相位信息。</p><p><strong>注</strong>：原序列的实偶对称序列的傅里叶变换等于原序列的傅里叶变换的实部。</p><script type="math/tex; mode=display">    \begin{aligned}        \hat{X}(e^(jw))        &= \hat{X}_R(e^{jw})+j\hat{X}_I(e^{jw})\\        &= ln|X(e^{jw})|+j{arg[X(e^{jw})]+2k\pi}\\    \end{aligned}</script><p>则$ln|X(e^{jw})| =\Phi[\hat{x}_e(n)]$。<br>又由于：$\hat{x}_e(n)=\frac{1}{2}[\hat{x}(n)+\hat{x}(-n)]$且$\hat{x}(n)$是一个因果序列，可得</p><script type="math/tex; mode=display">    \hat{x}(n)=\left\{    \begin{aligned}    0,~~~n<0 \\    \hat{x}_e(n),~~~n=0\\    2\hat{x}_e(n), ~~~n>0    \end{aligned}    \right.</script><center><img src="/images/min.jpg" width="50%" height="50%" />最小相位法求复倒谱原理</center><h2 id="5-语音信号的倒谱分析"><a href="#5-语音信号的倒谱分析" class="headerlink" title="5. 语音信号的倒谱分析"></a>5. 语音信号的倒谱分析</h2><p>根据语音信号产生的线性模型，语音信号由激励信号与声道冲激响应<strong>卷积</strong>产生的，<strong>解卷积</strong>就是将卷积分量分开，可采用同态解卷积的方法。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语音信号 -&gt; 同态解卷积分析 -&gt; 分离出激励信号和声道冲激信号相应</span><br></pre></td></tr></table></figure></p><ul><li>对声门激励信号进行分析，以判断浊音、清音以及浊音的基音频率</li><li>对声道冲激响应进行分析，以判断声道特性及共振峰</li></ul><p><strong>5.1 声门激励信号的倒谱</strong><br>声门激励信号（浊音）：$e(n)=\sum_{r=0}^M\alpha_r\delta(n-rN_P)$<br>对其进行Z变换得：</p><script type="math/tex; mode=display">E(z)=\alpha_0\Pi_{r=1}^M[1-\beta_r(z^{N_P})^{-1}]</script><p>* <strong>此处的$\beta 可以通过\alpha 求得$</strong></p><script type="math/tex; mode=display">\hat{E}(z)=ln[E(z)]=ln\alpha_0-\sum_{r=1}^M[-\sum_{k=1}^{\infty}\frac{\beta_r^k}{k}(z^{N_P})^{-k}]</script><p>求 z 反变换获得倒谱：</p><script type="math/tex; mode=display">\hat{e}(n)=loga_0\delta(n)+\sum_{k=1}^{\infty}\beta'_k\delta(n-kN_P)</script><p>一个周期冲激的有限长度序列，其倒谱也是<strong>周期冲激序列</strong>，且周期长度是$N_P$不变，只是信号长度成为无限长，振幅随 k 增加而衰减。当声门激励为浊音时，其倒谱只在$kN_P$诸点上不等于 0，其它均为零，那么第一个非零点和原点的距离就是<strong>基音周期</strong>。</p><p><strong>5.2 声道冲激响应的倒谱</strong><br>用极零点模型描述声道响应，其 Z 变换如下：</p><script type="math/tex; mode=display">X(z)=Az^{-r}\frac{\Pi^{M_i}_{k=1}(1-a_kz^{-1})\Pi_{k=1}^{M_o}(1-b_kz)}{\Pi^{N_i}_{k=1}(1-c_kz^{-1})\Pi_{k=1}^{N_o}(1-d_kz)}</script><p>a, c为单位圆内零极点；反之为单位圆外零极点。$z^{-r}$：序列相对于时间原点的延迟。<br>单位圆内的零极点形成复倒谱的右边；单位圆外的零极点形成复倒谱的左边；在原点的值取决于增益。复倒谱通常是双边的，且是比例因子为1/n的衰减指数之和。<br>$\hat{X}(z)$的复对数为：</p><script type="math/tex; mode=display">\hat{X}(z)=ln(A)+ln(z^{-r})+\sum_{k=1}^{M_i}ln(1-a_kz^{-1})+\sum_{k=1}^{M_o}ln(1-b_kz^{-1})\\-\sum_{k=1}^{N_i}ln(1-c_kz^{-1})-\sum_{k=1}^{N_o}ln(1-d_kz^{-1})</script><p>我们希望上式逆 Z 变换是稳定序列，即绝对可求和，即使<strong>ROC</strong>包括单位圆。$\hat{X}(z)$的 RoC：</p><center><img src="/images/Single/Roc.jpg" width="50%" height="50%" />Roc</center><p>其复倒谱：</p><script type="math/tex; mode=display">    \hat{x}(n)=\left\{    \begin{aligned}    ln[A],~~~n=0 \\    \sum_{k=1}^{N_i}\frac{c_k^n}{n}-\sum_{k=1}^{M_i}\frac{a_k^n}{n},~~~n>0\\    \sum_{k=1}^{M_o}\frac{b_k^{-n}}{n}-\sum_{k=1}^{N_o}\frac{d_k^{-n}}{n}, ~~~n<0    \end{aligned}    \right.</script><h2 id="6-基于听觉特征的MEL频率倒谱系数"><a href="#6-基于听觉特征的MEL频率倒谱系数" class="headerlink" title="6. 基于听觉特征的MEL频率倒谱系数"></a>6. 基于听觉特征的MEL频率倒谱系数</h2><p>一种常用的语音特征：<strong>MFCC</strong> （mel frequency cepstrum coefficient）</p><p>人耳能在嘈杂的环境中分辨各种声音 -&gt; 耳蜗起到重要作用 -&gt;耳蜗相当于滤波器组 -&gt;作用：在对数频率尺度上进行滤波 -&gt;对低频信号敏感。基于上述原理，得到类似与耳蜗的滤波器组：Mel 频率滤波器组。Mel 频率：$f_{mel}=2595\times log(1+f/700)$</p><p><strong>MFCC 计算</strong>:</p><ul><li>分帧 -&gt; 预加重 -&gt; 加汉明窗 -&gt; 短时傅里叶变换 -&gt; 得到频谱；</li><li>求频谱平方，即能量谱，用 M 个 Mel 带通滤波器进行滤波；</li><li>对每个滤波器的输出取对数，得到相应频带的对数功率谱，并进行反离散馀弦变换，得到 L 个 MFCC 系数，一般 L 取 12 ~ 16 个左右。MFCC 系数为：<script type="math/tex; mode=display">C_n=\sum_{k=1}^Mlogx'(k)cos[\pi(l-0.5)n/M],~~~n=1, 2, ..., L</script></li><li>将直接得到的 MFCC 特征作为静态特征，再做一阶和二阶差分，得到相应的动态特征。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致我的第一幅眼鏡</title>
      <link href="/2020/05/08/essay/%E7%9C%BC%E9%95%9C_%E7%89%A9%E5%BF%97%E9%93%AD/"/>
      <url>/2020/05/08/essay/%E7%9C%BC%E9%95%9C_%E7%89%A9%E5%BF%97%E9%93%AD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-wQbwDwox" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="401804976" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>雖然勉強還能繼續使用這副眼鏡，但他已經在修補之後一個月不到的時間之後又裂開了。他可能累了吧。我想這麼多年過去了，他的使命差不多可以在這裡結束了？<br><a id="more"></a>  </p><center><img src="/images/Things/glasses.jpg" width="50%" height="50%" />我的眼鏡</center><p>這幅眼鏡是我的第一幅眼鏡，外觀相當樸素，從初中開始一直到現在大三的時候，中間從未換過。儘管中途因爲升度數換過幾次鏡片，但鏡架總沒有換過。也不是只有這一副眼鏡，但平時大多數時候帶的都是這一副，備用的眼鏡總覺得這裡那裡不舒服。本來是全黑的一副眼鏡，卻因爲戴的時間長，眼鏡腿什麼的已經差不多磨成透明的了。尤其是中梁那裡，可能是個人習慣性推鏡架吧，那裡變得尤其的光滑而透明。之前有同學表示過難以置信：這居然原來是黑色的部分。現在他的鏡框折了，鏡片總希望從裡面逃出來。我想他差不多能休息了吧，遇上這麼一個主人。</p><p>想起最早的時候，我總是把他放在眼鏡盒裡，直到上課前才拿出來，用眼鏡布反覆擦拭幾遍，然後小心地戴上，一到下課便立刻取下來又放回原來的盒子裡。但是後面慢慢度數高了，便也只能一直戴着，慢慢地擦拭得也少了，眼鏡盒也不翼而飛……後面我知道不應該用眼鏡布擦，於是用水沖洗。直到最近我端詳它的表面的時候，已經發現了不少細密的紋路覆蓋在眼鏡片上。我想這對視力可能不太好吧？</p><p>這副眼鏡陪我看過了很多的東西——可能我所知道的一切事務中的一半，我的眼鏡也知道吧…真的是很長的一段時間…幾乎現在是我身邊陪伴我的時間最長的東西，特別是對於一個熄燈後才摘下眼鏡，一睜眼就帶上眼鏡的人來說。</p><p>感謝你替我看見的世界。請休息了吧！</p><p>—— 致我的第一幅眼鏡</p><p>廙水</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 物志銘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX在Hexo中的渲染</title>
      <link href="/2020/05/03/tech/LaTeX/%E5%9C%A8Hexo%E4%B8%8B%E7%9A%84%E6%B8%B2%E6%9F%93/"/>
      <url>/2020/05/03/tech/LaTeX/%E5%9C%A8Hexo%E4%B8%8B%E7%9A%84%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>该段落处理$\LaTeX$无法顺利在 Hexo 中渲染的问题。以下为上一次尝试且成功的步骤。<br><a id="more"></a>  </p><p>Hexo 默认的渲染引擎为 hexo-renderer-marked，这里将其更换为 hexo-renderer-kramed，该引擎在前者的基础上修复了一些 bug，具体操作：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">uninstall</span> hexo-renderer-marked <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-kramed <span class="comment">--save</span></span><br></pre></td></tr></table></figure></p><p>修改 marked.js。具体修改方式，用编辑器打开 marked.js（在./node_modules/kramed/lib/rules/inline.js 中）<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([<span class="string">\\`*&#123;&#125;\[\</span>](<span class="link"></span>)# +\-.!_&gt;])/, //替换掉</span><br><span class="line">escape: /^\\([<span class="string">`*\[\</span>](<span class="link"></span>)# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure></p><p>同时<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">em: /^<span class="symbol">\b</span>_((?:[^_]|__)+?)_<span class="symbol">\b</span>|^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,  //替换掉</span><br><span class="line">em:/^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br></pre></td></tr></table></figure><br>这样应该就能成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX常用语法</title>
      <link href="/2020/05/03/tech/LaTeX/%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/05/03/tech/LaTeX/%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>因为最近一段时间有使用$\LaTeX$写公式的需要，所以专门在这里整理一些常用的公式写法，防止后面反复查询。<br><a id="more"></a>  </p><h3 id="常用符号"><a href="#常用符号" class="headerlink" title="常用符号"></a>常用符号</h3><ul><li><code>\infty</code>: $\infty$</li><li><code>\ge</code>: $\ge$</li><li><code>\le</code>: $\le$</li><li><code>\pm</code>: $\pm$</li><li><code>\int</code>: $\int$</li><li><code>\prod</code>: $\prod$</li><li><code>\arg\mathop{\max}_{\theta}</code>: $\arg\mathop{\max}_{\theta}$</li></ul><h3 id="常用等式"><a href="#常用等式" class="headerlink" title="常用等式"></a>常用等式</h3><p>连等式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">    A &amp;&#x3D; B+C\\</span><br><span class="line">    &amp;&#x3D;C+D\\</span><br><span class="line">    &amp;&#x3D;D+F</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">    \begin{aligned}        A &= B+C\\        &=C+D\\        &=D+F    \end{aligned}</script><hr><p>大括号等式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X_p(w)&#x3D;\left\&#123;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">    \frac&#123;1&#125;&#123;2j&#125;,~~~w&#x3D;\frac&#123;\pi&#125;&#123;2&#125; \\</span><br><span class="line">    -\frac&#123;1&#125;&#123;2j&#125;,~~~w&#x3D;-\frac&#123;\pi&#125;&#123;2&#125; \\</span><br><span class="line">    0, ~~~otherwise</span><br><span class="line">    \end&#123;aligned&#125;</span><br><span class="line">\right.</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">    f(x)=    \begin{cases}        0& \text{x=0}\\        1& \text{x!=0}    \end{cases}</script><p>$$</p>]]></content>
      
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的坡县游历</title>
      <link href="/2020/04/27/essay/tour/%E5%9D%A1%E5%8E%BF%E6%B8%B8/"/>
      <url>/2020/04/27/essay/tour/%E5%9D%A1%E5%8E%BF%E6%B8%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在坡县交流了一学期，这里是提交给学校的坡县经验的副本，先做一个小记。可能以后会突发奇想补充一个更自由一点的记叙，如果我还有那个时间的话。如果有什么当时留下的照片什么的也先留在那个版本里吧。</p><a id="more"></a><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>因为 CSC 的缘故，被禁足在了新加坡本地，所以没有机会去马泰游玩，不过在本地的生活也是很惬意的。</p><h3 id="住"><a href="#住" class="headerlink" title="住"></a>住</h3><p>据说 NOC 的同志因为学校 NUS 宿舍装修种种原因不能住在校内，于是我们大部分人都住在离学校有一些距离的 MDIS，需要早上坐大概半小时的车到 NUS 校区。楼下有一个食阁，但是周末几乎不开，幸好附近步行一刻钟处有一个社区的食阁，周末能去吃。除此之外，其他的东西都还算方便，不过刚到寝室的时候，还是不免一阵吐槽，毕竟大家都是抱着体验单人间的生活入住的 hhh。</p><p>新加坡无尽的夏日还是让人头疼的，虽然可以一直穿凉鞋短袖也很爽。不过长袖几乎是必备的东西，因为室内的空调温度相当的低，比如 Science Lib。</p><p>这里和中国的文化差异并没有想象中的那么大。但这确实是个多元的地方，有各种各样的宗教文化、饮食文化并完全不用顾虑歧视种种问题。</p><h3 id="食"><a href="#食" class="headerlink" title="食"></a>食</h3><p>食物开销是除了住宿以外的大头。新加坡的食物很多样，但算不上太好吃，惊艳者甚少。作为学生，最常接触的是食阁，几乎 NUS 校区每个片区都有一个，里面囊括了各个地方的食物，西餐、杂菜饭、海南鸡米饭、叉烧面、日料是几乎每个食阁都有的东西。不过水准价格皆参差不齐。全校最好的是 UTown 的两家，但是略贵一点。一般在校内一餐消费在 4 刀到 10 刀不等。在校外消费的话，普通食阁 5 刀左右，下馆子得 15 刀起步。</p><p>新加坡当地的食物，可以算是十分奇特。<strong>酿豆腐</strong>，一种白水煮豆腐，里面可以加蔬菜、肉制品煮成一团，一些可以加辣酱和叻沙调味，这个东西的价钱是按“件”算的，比如一块豆腐就是 5 毛。<strong>叻沙</strong>，一种调味料？大概是一种椰汁熬出来的辣酱，完全不能被我所接受，但是似乎有不少同学喜欢？这个东西传出的鱼腥味能散布整个商场。最早一次是在新加坡的 Changi Airport 见到这个东西，被它的味道劝退了。<strong>辣螃蟹</strong>，十分昂贵的一种食物，大多是游客来吃的。不过味道很有趣，值得一试。甜辣甜辣的，类似国内一些菜品。此外还有肉骨茶等一些食物，没有尝试就不多说了。</p><p>然后是新加坡的中国菜。新加坡或许能偶尔找到挺正宗的中国菜馆，但大抵会让人失望。这边主要是火锅和港式/广式的茶餐厅，仔细找找能找到不错的。这边几乎每个食阁都有叉烧面和杂菜饭。叉烧面稳稳全食阁最价廉主食，一般是面上放几块叉烧；杂菜饭和复旦的食堂相似，为自选菜。火锅有点贵，香天下和海底捞等都有，还有一些本地的火锅。</p><p>此外，日料、马来菜、印度菜、西餐都很多。坡上似乎有不少不错的日料，我在读期间找到了一家网红鳗鱼饭，吃完满满的满足。还有日语课老师安利的回转寿司之类的，好店需要自己多找找。</p><p>本地有吃完饭和饮料的习惯。所以每个食阁都会有饮品店，卖的一般是 Koppi（马来语的咖啡，还有些类别，比如 Kopi O，Kopi Kosong 等等），还有各种鲜榨果汁，薏米水，还有一个叫 Milo 的饮料，味道和高乐高很像，深受当地人欢迎。令人疑惑的是一瓶可乐卖 1.9 刀，但是在 711 打折的时候，也有 1 刀的，并长期处于打折。</p><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>骑车是不可能骑车的。坡县不愧坡县，一路都是上上下下，在校区内更是不能骑车，因为学院大都建在山包包上。共享单车类似摩拜有，但是非常少，几乎不可用。有共享电动车，但是看起来非常危险，我听到过新加坡同学吐槽这东西有多危险。</p><p>主要出行是靠公交车。公交车需要自己按按钮下车，前方到站是不会在车内通报的，需要自己留意。一趟公交车并不便宜，在 1 刀左右，有起步价和同站换乘优惠。坡县内公交车网路非常密集，几乎可以利用公交车到大部分位置。</p><p>坡县地铁还是挺便利的，不过线路密度不如上海，很多时候还是靠公交车方便。地铁价格和公交车相似。</p><p>步行也是相当友好的。新加坡的道路旁一般建有走廊，走在下面不会被太阳晒也不会被雨淋，很舒适。校内连廊四处都是，楼与楼之前几乎不会有雨淋的风险。</p><p>校内通行主要靠小车.校车有专门的 app，如果选课不幸四处都有的话，坐校车就会是家常便饭了。因为每个学院都是分得比较开，所以不同学院的课一般避不了校车。不过很多 Tut 的选项会有不同的位置可选，所以尽量选自己方便的 Tut 上吧。</p><h3 id="浪"><a href="#浪" class="headerlink" title="浪"></a>浪</h3><p>新加坡好玩的地方不算太多，就那几个，一会就能逛完。不过可以趁着两次 Recess Week（期中和期末的一周复习周，学校强制不能在复习周中安排作业）去周围的国家转转。也可以和同去的小伙伴约在东海岸烧烤，同时坡县有诸多可以徒步的地方。此外新加坡的音乐会虽然不太多，但是票价便宜容易买到。就算是只提前一周也能买到低价的 5~8 排的黄金座位。</p><p>此外这里的建筑相当有特色，各种奇形怪状，并带有夸张色块的建筑随处可见。而且植被非常之好，很多楼顶或者楼内都攀爬着绿色植被。就算是在 NUS 里面也是充满了绿色植被，甚至学校中央是一片有野猴子和野鸡出没的小山包，无愧花园城市之名。</p><p>如果是秋季来可以赶上圣淘沙万圣节的鬼屋活动和国庆烟花，都是可以去凑热闹的不错的选择。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="关于选课"><a href="#关于选课" class="headerlink" title="关于选课"></a>关于选课</h3><p>选课上限 5 门。最开始可能自己申请的课都会被踢掉，但是不用担心，后续的申请很宽松，想要的课一般都能拿到。虽然上限只有 5 门课，但是并不轻松。以日语课为例，一周有 2h 的 lecture 和两次各 2h 的 tutorial，以及对应的课程作业，预计一周的工作量接近 8~10h。</p><h3 id="专业课"><a href="#专业课" class="headerlink" title="专业课"></a>专业课</h3><p>专业课分为偏应用的和偏理论的。理论课程会有很多的例子，一般一个公式就会跟着大量的例子去说明（不过很多时候说明挺累赘的，如果懂了就可以自己看着走。）实践课程会有很多 lab 和 pj，不过这些项目描述都很成型，基本没有歧义，按着老师的要求做就能做出不错的东西，当然还可以在此基础上继续发挥。期末考试不算太难，平时认真应该就不会翻车。</p><h3 id="语言课"><a href="#语言课" class="headerlink" title="语言课"></a>语言课</h3><p>NUS 的语言课真的超良心。以日语课为例，课程由一周一个 lecture 和两个 tutorial 组成。Lecture 是老师讲解知识点，tutorial 是由助教老师带领同学互相对话，调整发声和学习句子的使用等等。Tutorial 人数一个班十个人左右，因为不断换着换着 partner，所以氛围超有爱。到课程后半段之后就大家邀请老师一起愉快聚餐 Utown，中间还有两次蹭到了高贵的 Yale 学院的伙食，大家吃饭时聊天的话题也和国内完全不一样。</p><h3 id="自习"><a href="#自习" class="headerlink" title="自习"></a>自习</h3><p>自习一般不愁找不到地方。在 CS 楼附近是 Central Lib，虽然我在的期间在维护，但还是很大了，插座也很多。Lib 里面自带午休室和小躺椅。然后是 Science 附近的 Science Lib。这个 Lib 并不好找，需要专门寻觅一下，在某栋楼的四楼。该 Lib 人不多，异常地冷，插座不多，有的时候会找不到空的插座。其次是 Utown 的各个 Commons，PC Commons 和 Mac Commons 都是好去处，安静，并且有配好的台式机能用。问题是座位很少，周末一般找不到（除非去很早）。所有 Lib 都是周六开放半天，周日不开，平时也关的很早，可能是建议大家不要只是学习吧？并且 Central Lib 和 Commons 都是打印文件便利的地方。因为我在实验室板搬砖，所以也常常在实验室里的小工位干活。</p><h2 id="科研"><a href="#科研" class="headerlink" title="科研"></a>科研</h2><h3 id="进组"><a href="#进组" class="headerlink" title="进组"></a>进组</h3><p>到了 NUS 后不久，还没开学之前，我就听学长的建议开始在 CS 学院里找合适的 Prof，希望加到 Prof 的实验室做一些事情。于是大胆地写了一封邮件附带一个完全没有经历的 CV。万幸的是，我发的第一个 Prof 就回复了我，让我自己在组里找一个自己喜欢的项目加进去。于是找来找去联系了以为中国的学长，几封邮件来往，相谈甚欢，于是就进组啦。整个学期都在和另一位 master 一起做 NLP 的事情。</p><h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><p>尽管很顺利地进组了，但还是有诸多的问题。其一是国外的交流环境和国内很不一样，很多东西都是不断地请教学长菜慢慢摸清楚；其二是组会里面大家讨论的问题用的语速比上 lecture 的 Prof 快了不止一点，真的常常听不懂。</p><p>最大的问题其实是时间平衡和心态调整。泡实验室真的很耗时间，一般我作业做完了的周末或者课少的工作日都是泡在实验室调代码看数据，自己的时间确实很少了。中途没有去太多地方玩，也没能去马泰一圈。甚至到了期中季也只能请到几天的假，我期末季刚结束的那个周末就再次回到岗位了。并且就算是花了这么多时间，也不一定会有成效，经常在实验室泡了一天心态真的挺崩的。我还记得有一次和 master 一起调代码到了凌晨五点，是真的辛苦。不过每一次看到有一点点进步都会是由衷的喜悦。</p><h3 id="体验-amp-收获"><a href="#体验-amp-收获" class="headerlink" title="体验&amp;收获"></a>体验&amp;收获</h3><p>尽管前面说得这么辛苦，但还是觉得实验室值得一去。而且交流期间进组很容易的，一般给老师说一下，他们都不会拒绝。但是做多少事情，大多就是靠自觉。Prof 很亲和，会邀请你在组会上提出问题，偶尔也会问你几个问题。每次组会整个组会一起去附近的食阁聚餐，吃饭完后 Prof 会请客一人一杯饮料。</p><p>也深刻体会到了科研生活的艰辛和不易，也算是完成了一个科研周期吧。总之收获颇丰，代码能力、越读论文的能力、思辨能力都提升了不少。如果不像把这个学期用在四处游山玩水上，泡在实验室会是不错的选择。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做一个简单的总结吧。这是一个交流的好去处。不太大的文化差异、轻松的氛围、各式各样值得体验的新鲜事物、难得的实验室搬砖经历都让我在现在敲打这些文字时怀念这个美丽的城市。要说我唯一希望有所变动的地方，是那里永不结束的夏季。</p><p>廙水</p><p>2020-04-27</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行迹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章:存储系统</title>
      <link href="/2020/04/24/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap5_storage/"/>
      <url>/2020/04/24/course/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/Chap5_storage/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>存储系统的大纲。主要内容是 Cache 的特性及优化。</p><a id="more"></a><h2 id="5-1-存储系统基础"><a href="#5-1-存储系统基础" class="headerlink" title="5.1 存储系统基础"></a>5.1 存储系统基础</h2><ol><li>存储系统的层次结构<ol><li>要求：容量大、速度快、价格低</li><li>但是这三个要求相互矛盾</li><li>解决办法：采用多种存储器技术，构成多级存储层次  <ol><li>利用程序的局部性原理：时间局部性&amp;空间局部性</li></ol></li><li>存储系统要达到的目标：整个存储系统的速度接近于最快的访问速度，而容量和单位价格接近于最大的存储器</li></ol></li><li>性能参数<ol><li>考虑两层存储层次<br>| $M_1$ | $S_1$（容量） | $T_1$（访问时间） | $C_1$（每单位价格） |<br>| ——- | —— | —— | —— |<br>| $M_2$ | $S_2$  | $T_2$  | $C_2$  |</li><li>整个存储系统的容量即为第二级存储器的容量，即$S=S_2$。</li><li>每单位价格$ C=\frac{C_1S_1+C_2S_2}{S_1+S_2} $。</li><li>命中率<ol><li>$ H=\frac{N_1}{N_1+N_2} $</li><li>$ N_1 $：访问$ M_1 $的次数</li></ol></li><li>平均访问时间$ T_A $<ol><li>$ T_A=HT_1+(1-H)(T_1+T_M)=T_1+(1-H)T_M $</li><li>不命中开销：$ T_M=T_2+T_B $。从向$M_2$发送访问请求到把整个数据块调入$M_1$所需的时间。</li><li>传送信息块的时间：$ T_B $。</li></ol></li></ol></li><li>三级存储结构<ol><li>三级存储系统<ol><li>Cache</li><li>主存储器</li><li>磁盘存储器</li></ol></li><li>“Cache-主存”层次和“主存-辅存”层次<ol><li>前一个层次弥补速度不足，由硬件实现</li><li>后一个层次弥补容量的不足，主要由软件实现</li></ol></li></ol></li></ol><h2 id="5-2-Cache基础"><a href="#5-2-Cache基础" class="headerlink" title="5.2 Cache基础"></a>5.2 Cache基础</h2><ol><li>基本构造和原理<ol><li>存储空间分割和地址计算</li><li>Cache 和主存<ol><li>Cache 是按照块进行管理的。其被分割为大小相同的块。</li><li>主存块地址：用于查找该块在 Cache 中的位置。</li><li>块内位移：用于确定数据在该块的位置。</li><li>地址串 = 块地址|块内位移</li></ol></li><li><img src="/images/Chap5-storage/cpuToCache.jpg" alt=""></li></ol></li><li>映像规则<ol><li>全相联<ol><li>空间利用率最高、冲突概率最小、实现最复杂</li></ol></li><li>直接映像：每一块只能放在 Cache 的一个位置<ol><li>空间利用率低、冲突概率高、实现简单</li></ol></li><li>组相联映像：分组<ol><li>低位被称为索引（对应组相联的组数/直接映像的块大小）</li><li>相联度 n</li></ol></li></ol></li><li>查找算法<ol><li>确定 Cache 中有需要的块</li><li>通过查找目录实现<ol><li>目录表：<br><img src="/images/Chap5-storage/menu.jpg" alt=""></li><li>并行查找：<ol><li>相联存储器：根据查到的组内块地址，从 Cache 中读出一个发送给 CPU</li><li>单体多姿存储器+比较器</li></ol></li></ol></li></ol></li><li>容量：$Cache=2^{index}\times 相联度\times 块大小$</li><li>过程<ol><li>写缓冲器：如果在进行写入操作时，写缓冲器不满，则可以把数据及完整地址交给写缓冲器。</li><li>读不命中：向 CPU 发送暂停信号，从下一级存储器调入数据块</li></ol></li><li>替换算法<ol><li>当新调入一块，而 Cache 又已被占满时，替换哪一块？</li><li>主要替换算法：随机法；FIFO；LRU</li><li>LRU 的实现：<ol><li>堆栈法：用一个堆栈来记录组相联 Cache 的同一组中各块被访问的先后次序。<ol><li>这个方法需要为每一个相联组准备一个小堆栈。</li><li>该方法速度低成本高</li></ol></li><li>比较对法<ol><li>让块两两组合，每一个比较对用一个除法器的状态表示所相关的两个块最近一次被访问的远近次序。</li><li>需要的硬件<ol><li>与门，数量等同块数目</li><li>触发器，和两两组合的比较对的数目相同 $=n(n-1) $</li></ol></li><li>当组内块数较多时，可以使用多级状态位技术减少所需的硬件量。</li></ol></li></ol></li><li>写策略<ol><li>写必须再确认命中之后才可以进行</li><li>写操作可能导致 Cache 和主存内容不一致</li><li>两种写策略：写直达法和写回法</li><li>两种策略的比较：写回法地速度快，使用的存储器的带宽较低；写直达法易于实现、一致性好</li><li>写直达法中，CPU 必须停顿，这个称为“CPU 写停顿”。（可以采用写缓冲器进行优化）</li><li>写操作的调块：写时取，先把所写旦苑所在的块调入 Cache；绕写法，直接写入下一级存储而不调块</li></ol></li><li>性能分析<ol><li>不命中率：与硬件速度无关</li><li>平均访存时间：平均访存时间 = 命中时间 + 不命中率 × 不命中开销</li><li>程序执行时间：CPU 时间 = ( CPU 执行时间 + 存储器停顿周期数 ) × 时钟周期时间<ol><li>存储器停顿周期数：“读”的次数 × 读不命中率 × 读不命中开销＋“写”的次数 × 写不命中率 × 写不命中开销</li><li>存储器停顿周期数＝访存次数 × 不命中率 × 不命中开销</li></ol></li><li>$CPI_{execution}$越低，固定周期数的 Cache 的不命中开销的相对影响就越大；在计算 CPI 时，不命中开销的单位是时钟周期数。因此，即使两台计算机的存储层次完全相同，时钟频率较高的 CPU 的不命中开销较大，其 CPI 中存储器停顿这部分也就较大。因此<strong>Cache 对于低 CPI、高时钟频率的 CPU 来说更加重要</strong>。</li></ol></li><li>改进 Cache 的性能<ol><li>平均访存时间 = 命中时间 + 不命中率 × 不命中开销</li><li>从三个方面改进性能：降低不命中率；减少不命中开销；减少 Cache 命中时间</li></ol></li></ol></li></ol><h2 id="5-3-降低Cache不命中率"><a href="#5-3-降低Cache不命中率" class="headerlink" title="5.3 降低Cache不命中率"></a>5.3 降低Cache不命中率</h2><p>提高 Cache 性能的方法是降低不命中率。本节介绍 8 种降低不命中率的方法。需要降低不命中率的方法都会增加命中时间或者不命中开销。因此，使用时需要综合考虑。</p><ol><li>三种类型的不命中<ol><li>强制不命中：第一次访问一个块，其不在 Cache 中。这种不命中称为冷启动不命中或访问不命中。</li><li>容量不命中：执行程序所需要的所有块不能同时调入 Cache，在程序运行时需要被重复调用。</li><li>冲突不命中：太多块映射到同一组，被重新访问的情况。</li><li>相联度越高，冲突不命中就越少；强制不命中和容量不命中与相联度无关；强制性不命中与 Cache 容量大小无关</li></ol></li><li>增加块的大小<ol><li>增加块的大小：增加了空间局部性，减少了强制不命中；同时减少了 Cache 中块的数目，导致冲突不命中上升；会增加不命中开销</li><li>当第二个作用超过第一个作用时，不命中率会上升</li></ol></li><li>增加 Cache 容量：该方法会增加成本，并增加命中时间</li><li>提高相联度<ol><li>8 路相连和全相联一样有效，故超过 8 的方案实际意义不大</li><li>2：1 经验规则：容量为 N 的直接映像 Cache 的不命中率和容量为 N/2 的两路相联的 Cache 的不命中率相似</li></ol></li><li>伪相联 Cache<ol><li>又称为列相联。获得多路相联的低不命中率，又能保持直接映像的命中速度。<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 先按直接相联的方式进行访问，如果命中则返回</span><br><span class="line">   <span class="number">2.</span> 如果不命中，则会检查另一个块上是否匹配</span><br><span class="line">      <span class="number">3.</span> 如果命中，则发生伪命中</span><br><span class="line">      <span class="number">4.</span> 如果不命中，则访问下一级存储器</span><br></pre></td></tr></table></figure></li><li>如果许多时候，命中发生在伪命中，则速度会变慢。一种简单的方法是，发生伪命中时交换两个块的位置。</li><li>这个方法会使 CPU 流水线设计复杂化，因此一般使用在离处理器较远的 Cache 上。</li></ol></li><li>硬件预取<ol><li>指令和数据都可以在处理器提出访问请求之前预取，可以将其放在 Cache 中或者放在访问速度较快的外部缓冲其中。</li><li>指令预取：一般由 Cache 之外的硬件完成。在一次不命中时，取出相邻的两块指令数据。被请求指令返回时放入 Cache，而预取的指令则放入高速缓冲器。下一次 Cache 访问不命中时，则可能可以通过访问高速缓存器获得信息。</li><li>预取建立在空闲带宽上。如果它影响了对于正常不命中的处理，则有可能会降低性能。可以利用编译器减少不必要的预取。</li></ol></li><li>编译器控制的预取<ol><li>它不是通过硬件预取，而是由编译器在程序中降入预取指令来实现的，这些指令在数据被用到之前，就将它们取到寄存器中去。</li><li>分为：寄存器预取；Cache 预取。</li><li>也可分为：故障性预取，如果出现虚地址故障或者违反保护权限，则会异常；非故障性预取，如果出现故障，则会放弃预取变为空操作</li><li>预取不会改变指令和数值之间的逻辑关系。</li><li>编译器预取的目的是要在执行指令和读取数据能重叠进行。循环是预取优化的对象。每一次预取需要消耗一次指令的开销。</li></ol></li><li>编译优化<ol><li>对于软件进行优化降低不命中率。这个方法的特点是不需要对硬件做出改动。</li><li>程序代码和数据重组：<ol><li>将程序中的过程重新排序，减少冲突不命中；将基本块对齐</li><li>如果编译器知道分支指令很可能转移，则可以<ol><li>将转移目标处的基本块和紧跟着该分支指令的基本块进行对调</li><li>把该分支指令换为操作语义相反的分支指令</li></ol></li><li>同时也可以对数据进行变换，例如调整顺序以改善空间局部性</li><li>编译优化技术包括数组合并、内外循环交换。数组合并是将本来相互独立的多个数组合并为一个复合数组；循环融合是把独立的循环融合为单个的循环</li></ol></li><li>内外循环交换：程序中包含的嵌套循环，并不是按照存储器中存储的顺序进行访问，这时需要交换嵌套关系。</li><li>分块：提高时间局部性来减少不命中。在一次循环中既有对行的访问，也有对列的访问</li></ol></li><li>牺牲 Cache：在 Cache 和下一级存储器的数据通路上增设全相联的小 Cache。这个 Cache 存储因为冲突被替换出去的块，当不命中发生时，在访问下一级存储器之前，先检查牺牲 Cache</li></ol><h2 id="5-4-降低Cache不命中开销"><a href="#5-4-降低Cache不命中开销" class="headerlink" title="5.4 降低Cache不命中开销"></a>5.4 降低Cache不命中开销</h2><p>随着技术的发展，Cache 不命中开销随时间不断增加。</p><ol><li>采用两级 Cache<ol><li>本技术不会印象 CPU</li><li>令第一级 Cache 和 CPU 的时钟周期匹配；第二级 Cache 足够大，能够捕捉大部分到达主存的访问</li><li>平均访问时间公式：<br>$平均访存时间 = 命中时间_{L1}+不命中率_{L1} \times 不命中开销_{L1}$<br>$不命中开销_{L1} = 命中时间_{L2}+不命中率_{L2}\times 不命中开销_{L2}$<br>即，访存时间为$平均访存时间 = 命中时间_{L1}+不命中率_{L1}\times(命中时间_{L2}+不命中率_{L2} \times 不命中开销_{L2})$</li><li>$局部不命中率=该级 Cache 的不命中次数/到达该级的访存次数$；$全局不命中率=该级 Cache 不命中次数/CPU 发出的访存次数$</li><li>对于第二级 Cache，其命中次数小于第一级 Cache，所以其重点放在减少不命中次数上，导致了更大的容量、更高的相联度和更大的块大小；第二级 Cache 不会影响 CPU 的时钟频率，因此设计有更大的考虑空间。</li></ol></li><li>读不命中优先<ol><li>对于写直达，每一次访问需要对主存进行写入。为了提高性能，设置一个写缓冲器，但是这个操作会导致储存访问的复杂化，因为所读单元的最新值可能正在写入</li><li>最简单方法是推迟对读不命中的处理，直至写缓冲器清空。而这个增加了读不命中的开销。</li><li>另一种策略是，检查写缓冲器，如果没有冲突则继续访问</li><li>对于写回 Cache 法，也可以利用写缓冲器。读不命中将替换一个修改过的储存块时，将被替换的块临时复制到一个缓冲器中，从存储器调块，再写入存储器</li></ol></li><li>写缓冲合并：对于写缓冲器。在写缓冲器不为空的情况下，需要将这一次写入地址和写缓冲器中地址进行比较，寻找匹配项：如果有地址匹配而对应的位置是空闲的，则将要写入的数据和该项<strong>合并</strong>。</li><li>请求字处理技术<br>本方法不用增加硬件。从存储器向 CPU 调入一块时，往往只有一个字是立刻需要的。请求字处理技术，就是着眼于这个特性，在 CPU 的请求的字到达后，CPU 不需要等待整个块调入，就将 CPU 重启并继续执行。有两种策略：<ol><li>尽早重启动：一旦请求字到达，就立刻发送给 CPU，CPU 重启继续执行</li><li>请求字优先：调块时先传递 CPU 需要的请求字，让 CPU 继续执行。<br>这个方法有效需要块相对大才能生效；以及下一个指令没有访问同一个块。</li></ol></li><li>非阻塞 Cache 技术<br>Cache 在不命中时仍允许 CPU 进行其他的命中访问，能处理部分的访问，减少了实际不命中开销。</li></ol><h2 id="5-5-减少命中时间"><a href="#5-5-减少命中时间" class="headerlink" title="5.5 减少命中时间"></a>5.5 减少命中时间</h2><p>直接印象时钟频率的高低。</p><ol><li>容量小、结构简单的 Cache：硬件越简单，速度越快；应让 Cache 足够小，以便可以和 CPU 放在同一个芯片上。</li><li>虚拟 Cache<br>采用虚拟存储器的计算机中，每一次访存都必须进行虚实转换，将 CPU 发出的虚地址转换为物理地址，这个一般是由存储部件 MMU 完成的。<br><strong>物理 Cache</strong>：使用物理地址访问的传统 Cache。其标识存储器中存储的是物理地址，地址检测使用的也是物理地址。CPU 需要访问时，先给出一个虚拟地址，由 MMU 转换为主存物理地址，再使用这个物理地址访问 Cache。<strong>缺点</strong>：地址转换和访问 Cache 是串行进行的，访问速度很慢。<br><strong>虚拟 Cache</strong>：可以直接用虚拟地址进行访问的 Cache，存储器中存储的是虚拟地址，检测的也是虚拟地址。当 CPU 访问存储器时，虚拟地址同时送给 MMU 和 Cache，Cache 找出相应的指令。如果 Cache 不命中，则需要 MMU 读出物理地址进行访问。虚拟 Cache 的优点是命中时不需要地址转换；并且不命中时也是并行的，速度更快。<br>但<strong>并不是</strong>所有的计算机都是用虚拟 Cache。其在进行切换时，需要清空 Cache，因为新进程的虚拟地址可能和原进程使用的地址相同。解决这个的方法可以是增加一个 PID，用于标识进程。在 PID 被重用的时候，仍然需要清空 Cache。<br>虚拟 Cache 没有流行的另一个原因。操作系统可能对一个物理地址有多种虚拟地址访问，这可能会导致虚拟 Cache 存在两个副本。</li><li>虚拟索引-物理标识方法<br>优点：兼得虚拟 Cache 和物理 Cache 的好处。<br>局限性：直接映像 Cache 的容量不能超过页面的大小。$Cache 容量\le 页大小\times 相联度$<br>直接用虚地址内的页内位移作为访问 Cache 的索引，但标识是物理索引。CPU 在发出访存请求后，在进行虚实转换的同时，可以进行标识的读取。在完成地址转换以后再比较物理地址和标识。其局限性是为了实现大容量 Cache，又能使索引数比较少，可以采用提高相联度的方法。</li><li>Cache 访问流水化：不能减少命中时间，但能增加带宽</li><li>追踪 Cache：存放 CPU 执行的动态指令序列</li></ol><h2 id="5-6-并行主存系统"><a href="#5-6-并行主存系统" class="headerlink" title="5.6 并行主存系统"></a>5.6 并行主存系统</h2><p>主存的性能主要用<strong>延迟</strong>和<strong>带宽</strong>衡量。第二级 Cache 很大，对主存带宽有一定要求。并行主存系统就是<strong>一个访问周期内能并行访问多个存储字的存储器</strong>，其能有效提高存储器的带宽。<br>对于一个单字宽普通存储器，其字长与 CPU 字长相同，每一次只能访问一个存储字。设其访问周期是$T_M$，字长为$W$，其带宽为：</p><script type="math/tex; mode=display">B_M=\frac{W}{T_M}</script><p>在相同器件条件下，为提高主存带宽，可以采用并行存储器结构：单体多字存储器和多体交叉存储器</p><ol><li>单体多字存储器。<ol><li>对于一个单体 m 字存储器，该存储器可以在每个存储周期读出 m 个 CPU 字，将其带宽提升为原来的 m 倍。但是由于程序执行访问的数据具有一定的随机性，所以实际带宽比最大带宽小。</li><li>优点是实现简单，确定是效率不高：<ol><li>如果提出的指令含有分支指令，且分支成功，则有一部分指令是无效的</li><li>当前指令所需要的多个操作数不一定在一个长存储字中</li><li>必须凑齐 m 个数才一起写入存储器。如果只写个别的字，则需要把相应的长存储字取出，放到数据寄存器中，再修改一个字放回存储器</li><li>如果独写数据在一个长存储字内时，读写操作无法在一个存储周期内完成</li></ol></li></ol></li><li>多体交叉存储器<ol><li>多体存储器由多个单体存储器构成，每一个体有自己的地址寄存器等电路。</li><li>设有 m 个体，每个体有 n 个存储单元。对于计算机使用者来说，存储器是按照顺序线性编址的，如何在二维矩阵和线性地址之间建立对应关系，就是多体存储器编址问题。</li><li>有两种编址方法：高位交叉编址和低位交叉编址。低位交叉编址才能解决访问冲突问题。高位交叉编址能方便地扩展常规存储器的容量<ol><li>高位交叉编址<ol><li>对存储单元矩阵按列优先方式进行编址，即先给第 0 列的各单元按从上到下的顺序依次赋予地址，然后按第一列赋予地址。对于同一个体的高$log_2m$位都是相同的，这就是体号。</li><li>对于第 i 行第 j 列，其地址为$A=j\times n+i$</li></ol></li><li>低位交叉编址<ol><li>先给第 0 行编码，然后从左到右赋予地址</li><li>同一个体的低$log_2m$位是相同的，这是体号</li><li>需要分时启动 m 个存储器。如果每个存储体的访问周期是$T_M$，则各个存储体的启动间隔是$t=T_M/m$。</li><li>采用低位交叉访问能大幅度提高存储器的带宽。由于访问冲突，实际加速比小于 m</li><li>$B=\frac{1-(1-\lambda)^m}{\lambda}$，$\lambda$为转移指令成功的概率。当$\lambda=1$时，并行多体交叉的实际带宽同单体单字并没有区别。由于数据的随机性，单纯依靠增大 m 来提高并行的带宽是有限的。对于标量运算，一般取$m\le8$</li></ol></li></ol></li></ol></li><li>避免存储体冲突<ol><li>体冲突：两个访问要求访问同一个存储体。</li><li>解决这个问题的方法是采用许多体去减少体冲突的次数。体冲突问题可以通过硬件解决也可以通过软件解决。</li><li>软件方法：循环优化法/拓展数组大小，使之不是 2 的幂次</li><li>硬件方法：使体数为素数。体内地址为$地址<del>mod</del>存储体中字数$</li></ol></li></ol><h2 id="5-7-虚拟存储器"><a href="#5-7-虚拟存储器" class="headerlink" title="5.7 虚拟存储器"></a>5.7 虚拟存储器</h2><ol><li>基本概念<br><strong>“主存-辅存”进一步发展的结果。</strong>由小主存储器和大的辅助存储器组成，在管理下像一个单一的、可以直接访问的大容量主存存储器。程序员可以使用地址码对整个程序进行编址，不需要考虑实际主存空间的大小。<br>虚拟存储器可以分为<strong>页式</strong>和<strong>段式</strong>。页式存储器把空间划分为<strong>大小相同</strong>的块，称为页面；段式把空间划分为<strong>可变长</strong>的块，称为段。此二者各有优劣。许多计算机采用段页式，每段被分为若干个页面。</li><li>快速地址转换技术<br>页表放在主存中，每一次访存会引起两次访问，第一次是访问页表，以获得数据的物理地址；第二次是访问数据。这个效率是不可用的，一般采用翻译后备（TLB）解决这个问题。<br><strong>TLB</strong>是一个专用高速缓存器，用于存放近期经常使用的页表项。TLB 是页表部分内容的一个副本。只有在 TLB 不命中时才会进入主存页表查询。TLB 中的项由两部分组成：标识和数据。标识放的是虚地址的一部分，而数据部分存放的是物理页帧号、有效位、使用位等。操作系统需要保证 TLB 中没有该页表项的副本。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冰上行</title>
      <link href="/2020/01/11/essay/tour/%E5%86%B0%E4%B8%8A%E8%A1%8C/"/>
      <url>/2020/01/11/essay/tour/%E5%86%B0%E4%B8%8A%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-fvEjoYyy" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1210185" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>　　我原以为冰是某种坚硬而强大的东西，可是在它遇到温暖的时候，却逃掉了。</p><p>　　这是在冰城的第六天了。这一小段时间，放在我在上海的生活，根本不值一提，它会显得平庸单调而乏味；但在这里，却像是从宇宙诞生到终于坍缩那样漫长而混乱。如果现在我试图从任何一个角度去逼近在这几日里的自己所处的某一个瞬间，都会觉得匪夷所思，像是积累了很多年的顽疾在这一刻突然张牙舞爪，像是目睹了一个明知是自己编织的伟大梦境的崩坏。</p><a id="more"></a><p>　　坐在哈工大的一个藏在角落里的咖啡厅，我决定把这几日的事情记下来。我要记下来的或许不是什么重要或者意义深刻的事情，而是仅仅是一些我没有记在随身小日记上的别的事情，甚至只是那些琐碎平白的语言的补充。尽管我这样费力地铺垫这几日中发生事件是如何地危险可怕、或者平凡无趣，但终究它是一场普通的旅程：这段旅程不论对于我还是别的什么人，都是如此。</p><p>　　早上，我居然很早就起来了，比我平时起床的时间早了不知道多久，我不想躺在床上。我想站起来。外面依旧没有下雪，但是雪满满覆盖着每一个屋顶。我抬起我的手机想看些什么，却意识到我拿起的这部手机没有连接网络，连接着网络的那台手机上没有我想看的东西。想起这几日尚未填写的日记，再一阵肚子小痛，便拿着我没有连着网络的那部小手机小心翼翼地进了厕所。</p><p>　　我从房间门出来，看见隔壁正睡得舒适的三弟。他侧向有太阳射着的一面，他的被子皱成一团，很好地盖住了上半身，两只腿却从被子下支了出来，几缕稀疏的头发很乱地叠在头上。我不打算吵醒他——在他醒了之后便要工作了，还是让他多睡会吧。于是悄悄地，我进入了厕所开始补上前几天的日记。</p><p>　　补完日记的我再一次躺在了床上。很安静的空间，很自我的空间。我盯着天花板上的灯发呆，想着这不是我昨天盯着的灯。我再一次瞥了一眼外面那一片拥有着雪顶的屋子，于是我终于决定还是起来了。想起昨天承诺的今天做出回复，于是便掀起电脑开始阅读昨天仅仅是草草读过的一部分文本。这个房间的设计很是成问题，从我所正坐着的的沙发的位置，沿着时钟一点的方向看去便正好能看到主卧的样子，便是三弟安详的睡容。他换了一个姿势，面向了背光的一侧，头枕在弯曲的右手臂弯上，轻微地蜷缩着，继续着他的睡眠。我很高兴刚才没有不小心吵醒他。但我又在沙发上想着如果我移到他的房间，立刻用某种粗鲁的办法就这样把他把吵醒，或许对于我来说会成一种趣味。但终于我还是没有动，请他再睡一些时间吧。任由这几日的折腾，他虽然嘴上不说，我想也总是疲惫的。</p><h2 id="第五日"><a href="#第五日" class="headerlink" title="第五日"></a>第五日</h2><p>　　疲惫这种东西可能是险恶的世界没藏好自己的全部而露出来的不易察觉的尾巴。不论是前进或是后退，或者停在原地，合着各种五颜六色的情绪一同出现的是恐怖的疲惫。这是我在咖啡厅的想法。此刻我已经结束了上午的滑雪而回到了哈工大，坐在哈工大的某个咖啡厅了，等着一群我认为不会再出现在我的世界中的人，三弟现在的室友们。</p><p>　　点了一杯热可可，然后开始百无聊赖地看着 COC 模组，虽然心里想着，这终于是没有机会的，但还是慢慢地用手机那种小得可怜的屏幕查看这种费劲复杂的文本。在我翻来覆去地看了很多遍之后，终于放弃了。我想趴在自己的手臂上，就在这咖啡厅里睡上一个不管什么用的觉，因为我觉得累。但是又同时觉得不好意思，便一只手当作枕头，侧着脸倒在那桌子上，像个醉汉。我想到底是因为我总是让别人看见一个虚假的自己而感到抱歉，还是因为我总是尝试扮演出来的一个积极有为的青年而感到费劲。我在这样的地方呆了很长一段时间，我并不清楚确切地过了多久，感到时间正在以诡异的速度流逝。尽管我早已预料到某些事情已经不会如同计划那样向前展开了，我还是坐在那个地方，等着那个被告知这个结局的时候。</p><p>　　终于，我听到似乎有叫我名字的人。然后三弟走了进来。他问我其他两个人呢，我只能说还没来。尽管我想着他们已经不会再来了。请告诉他们如果不特别想来今天就先算了吧，我也累了。但是我是因为什么事情而感到疲惫的呢。终于下了这个决策，我们就朝着住宿的地方走去了。</p><p>　　现在虽标着零下 20 摄氏度这样吓人的标签，冰城屋外的夜晚却出奇地不那么冷。两个人便这样走在哈工大的校园里，看着四周不断改变着光彩的冰雕。校园里已经没有太多人，四处行动的是各式各样结成伙的三五人或者成双成对的小情侣，大多数人是不会在这样的晚上还到处走的。我想把刚才那段我想的关于疲惫的话说出来，或许我正在想着这么一个打算的时候，我的嘴就已经开始行动了。我可能若有若无地说了几句。三弟可能是误以为我是因为滑雪而感到累，而我或许矢口否认了几句什么滑雪使人累这种事情，滑雪这样的东西是不会这么伤人的。我想他终于还是不理解我到底想说什么吧。可能我自己也不知道自己想说些什么，以及是不是要让立在我身边的三弟知道这样一些荒唐的想法，于是仓促地岔到了别的话题。经过一番费力地挣扎，我终于又回到那疲惫中去了。</p><p>　　虽然维持这样的状态已经足以可以使我感到愉快，但却心底里明白，这样的时光就如同浮游一般，在刚浮上水面的时候，就预示着它的生命快要消失了。我想我的旅程也快要结束了，但是另一场更大的旅程才刚要开始。从一个旅程跳到另一个旅程，就像是下了一趟火车然后赶上另一辆，终于丧失了所有熟识的人，再一次到一个不知所云的目的地去。我和三弟抱怨说，或许我喜欢的旅程正是那种在一个小湖边，住在一个木房子里，什么也不干，就在里面呆着，这样的生活吧。他说，梭罗就是这样的。我想，我没有梭罗那种底气吧，更没有梭罗那样的气节，我只是一个中国众多普通人中的某一个罢了，也是千千万万个为今晚的月亮感到疲惫而受伤的人中的某一个罢了。</p><p>　　今天这月亮就很圆，虽然小，但是仔细看看，可以看到月亮上的灰蓝色的阴影和乳白色的外皮，架在城市高楼顶上那种泛着红光的灯之间。我说，这月亮很圆。是，哈尔滨云很少。三弟这样回答。</p><h2 id="第四日"><a href="#第四日" class="headerlink" title="第四日"></a>第四日</h2><p>　　我早早地出发前去一个叫做关东古巷的地方。到了才发现，这是一个和关东或者和古巷都无甚关系的地方，一个纯粹的商业街，却打着 AAA 级景区的称号，这实在是费劲。我希望在这里吃一顿午饭，却终于没有找到合适的东西。便到了全中国都可能有的地方去寻觅我想要的东西。进了一家东北菜的餐厅，随意地点了两份菜，却发现东北的菜的分量果然是名不虚传，我不小心点了两个人都吃不完的份。此时手机提示我我收到了些什么消息，我简单地扫了一眼，又出奇地立刻回复了几句，就把它撂在了一边了。</p><p>　　然后便出发去今天的另一个目的地，中国木雕馆。我是不知道中国木雕馆分为木雕馆和金丝楠木馆的，于是我稀里糊涂地走进了金丝楠木馆。我刚进展厅，便看见一个青褐色的小柜子。柜子大概有一米五高，分为上下两个部分，上半部分是竖着的一些密致分布着的等距的长方体木条，围满了上半部分的三边，而留出了面向我的这一边。下半部分是两扇对开的木门，也是呈青褐色，这青褐色上浅浅地游离着一些金色的波浪般的纹路。整个柜子呈现出轻微的上窄下宽。</p><p>　　就在我端详着这一个精巧的柜子时，一个年轻的女性便走到我旁边开始做简单地介绍。现在木雕馆很空，除了我这样游手好闲的零零星星的几个游客，便没有别的人了。她开始很热情地和我聊天，介绍各种各样的木料的来历、构造、设计等等，还讲了些什么清代家具和明代家具的不同什么的。为了解释这个柜子的木门设计之巧妙，她特意无视了“请勿触摸”的标志，将木门拉开，然后等它自动合上。这确实是我从未见过的精巧的设计。</p><p>　　我尽可能做出自己很感兴趣的样子，赞赏了明代家具设计的典雅大气，适当地问了不少的问题，却没想到这位更加热情，开始讲述更多的事情。到最后终于不再讲解和木雕相关的事情，而是讲到了自家鱼缸里养的叫银龙的两条鱼。在这样的一个多小时后，她似乎不小心因为什么我不清楚的缘由当我是一个从事艺术相关工作或者事业的人，然后以这个为假定说出了：想必你也是搞这方面相关的（木雕或者绘画，我也不甚清楚她所说的相关为何物）……然而她正要再往下接着说更多的话时，我最后还是忍不住在这里稍稍地打断了一下她道，我是学计算机的。</p><h2 id="第五日-1"><a href="#第五日-1" class="headerlink" title="第五日"></a>第五日</h2><p>　　坐在从亚布力滑雪场往哈尔滨的高铁上。我们退掉了之前计划的下午五点返程的票，改成了车程一个小时的下午两点出发的动车，代价便是从坐票变成了站票。于是四个人站在狭小的动车车门附近过道那里。一路上聊一些稀奇古怪的东西，讲一些稀奇古怪的故事。我不知道自己为什么要讲某些事情，或者对某些听到的事情保持兴趣。我想你是学文科相关的吧，三弟的某一个室友终于还是问了。是，三弟帮腔到。不是，我是学计算机的。幸好只有一个小时，不需要再继续消耗那么多的精力去构想一些有趣的、可以使这里闷热拥挤的空气不至于沉默的事情。就在我以为还有一段时间才会到站的时候，我们到站了。一路上，我没有机会看见窗外的景色，我的视线里的，是三弟的脸，三弟的一个室友的脸，和另一个室友正弯着腰趴在某一个座椅上睡觉的身影。</p><p>　　我暗自想到，他们的关系真的很好，可以肆无忌惮地开一些奇怪的玩笑，什么顽劣的、过分的玩笑都可以。我想起我自己在大学的室友们，就像是不太认识的一些人，连酒肉之交可能都不太称得上。每个人做自己的事情，有自己的奇怪笑点。我不理解他们有时突然在深夜里爆发的大笑是什么意思，就是那种一会咯咯咯一会哈哈哈的大笑，也没有那种精力去一一询问原由，我知道就算我知道了那么一两个答案，也只会陷入更深的不解之中。最初我在来到这个新的寝室的时候，我还会装模做样的询问一两句，后来便算了吧，他们或许对我是不是关心这样的事情感到无所谓，正如同我对关不关心这样的事情也无所谓一样。我不知道他们的大笑的意味，是想激起那些不知道他们为何而笑的人的注意力，或者仅仅是想大笑而已，这两种原因对我而言都是莫名奇妙的。</p><p>　　我也想发自内心地笑的，但是我找不到机会，更找不到原因。我怎么能期望找到那种可以真正令人愉快的事情。我明明清楚，愉快本身本是与不愉快相对的东西。只有在不愉快的存在下，愉快才显得弥足可贵；而比不愉快更不愉快的时候，愉快才真正地呈现了愉快本来的含义。如果随便一个什么人，一日日地都充满了愉快的话，我只能认为他是分不清愉快和不愉快的人了。像是把黑与白混作一滩一样，搞不清楚自己是否真的愉快，生活在一个自认为美妙的灰色的世界里，并称这种灰色为每日的愉快。但这样，当我们终于分辨出愉快和不愉快是什么东西的时候，愉快本身便不会那么愉快了，因为我们总是在愉快之中的时候意识到这样的被称为愉快的场景终将很快地逝去，否则这样的生活会变成某种日常而不再被人所珍视，而愉快会沦至单调无聊这样的意义，从而变成另一种不愉快。</p><p>　　所以我想：愉快本身性质是消极的。处在愉快之中，或者朝向愉快，或者背离愉快的时候，都是令人难受的，这比处在不愉快这样的环境里更让人难受，像是证明了愉快这种东西的无力。或者说或许愉快是在不愉快的大洋中扔进去的一颗石头，它所激起的每一个波澜都在敲打人逐渐麻木迟钝的神经，用这种微不足道的冲击唤起人对于不愉快的每一份回忆。所以可能对我而言，真的笑或者假的笑，都和哭没有多大的区别吧，只是嘴角的弧度不太一样罢了。</p><p>　　于是这一趟列车就是这么个东西，它是到达愉快和远离愉快的一个分界线，是我旅程的中点，也是下一趟旅程的预告。就在这么一种中间的点，神经不由得紧绷着，承受着一种庞大的、飘渺的感受，承受着这种不怀好意的涟漪。</p><h2 id="第四日-1"><a href="#第四日-1" class="headerlink" title="第四日"></a>第四日</h2><p>　　我走进了一家名为果戈里书店的地方，这是冰城这里著名的书店。看着里面充满了俄罗斯风情的装修，五颜六色的玻璃面板，和橙黄色的灯光，相较于外面的银白色，这里显得相当温暖而舒适。经过一个两层的小楼梯，一个规模不大的书店进入了我的眼帘。这个小书店被一个五六阶高的小楼梯划分为了两部分。前面一个较低的平台，里面摆着两排挺矮的书架，以及一两张装饰繁复的椅子。顺着这个平台正前方的楼梯而上，便到了第二块平台，这个平台沿着第一个平台的四周延伸，形成了一个不完整的高起的回廊。回廊两边都是书架，但是就这样一眼看去，就可以清楚这里没有多少书的。再回头看一眼，看见刚来的楼梯其实可以再往上，但是已经打上了 VIP 的标签。看来我所可以涉猎的知识，便在我面前的两块平台之内了。</p><p>　　我不是漫无目的地进入一个书店，我希望在里面找到一本名为《罪与罚》的书，一是我想到自己一直没有机会再把这本书看一遍，自己当时读这一本书的时候便是感到云里雾里的；二是我想到今年三弟的生日因为自己身在新加坡，也还没有送他什么书，我考虑着《罪与罚》是不是一个合适的选择。于是以这一本书为目标，我开始在这不大的更像是咖啡厅的书店里寻找它。我本来想着，这家名为果戈里的书店，应该或多或少有托尔斯泰、果戈里或者陀思妥耶夫斯基的书吧？可是我一本也没有找到，我希望找的《罪与罚》便自然落了空。我想轻微地谴责一下这家名为果戈里书店的书店，这让我觉得如果我要想瞻仰这些书的真容，非要什么拥有 VIP 名号的大人物不可。当然是我无端地谴责，毕竟就算是对于 VIP 这样的大人物而言，也不一定会有这些书的存在。</p><p>　　于是我两手空空地从书店出来，透过路旁的街牌，发现自己在一个名为果戈里大街的地方。然而这里为什么叫果戈里大街呢？这条道上什么也没有特别的，和我见过的每一座城市的样貌一摸一样。我或许想在这里搜寻一些和果戈里相关的东西，或者和东北相关的东西，但我最后却走进了一家日本的拉面店。一进门听到不太标准的日式欢迎光临，就在那一个瞬间，我想到如果我不知道什么样的欢迎光临是标准的，我或许就不会在意什么，也不会因为这一点小小的差异而搅了兴致，正如去那果戈里书店一样。我在果戈里大街上游走着时，想着可能三弟的考试快结束了，还是等着他一起吃晚饭吧，但终于在这样的考虑中四处溜达了一个小时以后放弃了，最终进入了那一家拉面店。拉面馆最先迎接我的，是糊了我一眼镜的雾气。</p><h2 id="第三日"><a href="#第三日" class="headerlink" title="第三日"></a>第三日</h2><p>　　中央大街是真的名不虚传。里面充斥着各种各样的俄罗斯风格的建筑，特别是那些各种深浅的绿色房屋，在耐克、以及 H&amp;M 这些店的标志下显得更为雅致而别具一格。一条熙熙攘攘的大街，在我到的时候，天已经差不多黑下来了。街两旁的行道树上挂着黄色的灯，将两边的房屋连接了起来，在夜幕下显得温馨。但这温馨是假的，寒风轰击着我的全身，让我感到我当时在雪山之中都尚未感受到的寒冷。路两旁放着许许多多的冰雕，这些冰雕自然比哈工大里面放着的显得更加精致复杂，但也终究是会在不久之后就化掉的艺术，而第二次被造出的时候，这些冰雕也就不是这些冰雕了，只是那些存在过的冰雕的复制品。并这些冰雕耐人寻味多的是那些被成为折衷主义或者巴洛克风格的房子。</p><p>　　我频频地掏出手机想要抓住那些印在我眼睛里的那些五彩斑斓的令我赞不绝口的建筑，直到自己的手失去了手的感觉也没有停下来。然后再一次抓住我注意力的是两个食物，一个是烤红肠、另一个是冰棍。虽然这名为马迭尔冰棍的、售价 15 元每根的冰棍我早有耳闻，也知道这是必然会在之后尝试的东西，但是这寒风劝阻了我立在那数十人的后面为一根冰棍排队的冲动。我只是站在那卖冰棍的地方之外，远远地望了一眼，假装自己有所迟疑地停留了一小会，然后继续前进了。</p><p>　　然后是红肠。我想起在这学期在新加坡的日语课上，老师在最后一节课上问寒假的安排时，我说，我要去哈尔滨。同学们说，那个地方的冬天很冷吧。但我说，那里有很多好吃的。他们问有什么呀。我说，一种叫红肠的东西。现在这个东西真正地出现在了我的眼前，10 元每根。但是在我正走近它想要买下一根来实现之前的回答的时候，我再一次莫名其妙地犹豫了。认为这不过是旅游景点常见的套路罢了，像这样的东西，别的地方也是有的，只是以不同的名字，不同的身份，出现在各个摊贩的名录上，并标着各种正宗云云的名号。于是我抬起的手被我放回了温暖的口袋里。就这样在冰城最出名的城市建筑群里呆了一段时间之后，我决定去寻找我的晚饭，以及拜访圣索菲亚大教堂。</p><h2 id="第四日-2"><a href="#第四日-2" class="headerlink" title="第四日"></a>第四日</h2><p>　　我看着呈上来的拉面中飘着的鸣门卷，它飞起的热气又一次糊了我的眼镜。在到了这里之后不知道第几次抱怨眼镜是多么不方便的同时，慢慢的消耗了这一碗拉面。就在这一碗碳水化合物被我全部吃下去的时候，我看见一条新的信息。三弟考完了，他说他好了，开始问吃晚饭的事情。这样的事情也是有的。这样巧合而令人啼笑皆非的事情也是有的。</p><p>　　我想，这个时候，我应该怎么办呢。如果是我的话，如果是我自己考完了的话，我会想招呼上几个酒肉朋友，或者比酒肉朋友稍好那么一些的零星的几个朋友，在一个可能比平时吃饭的地方略微好上那么一点却又不至于让我承受不起的餐厅吃上一顿，作为惯例式的别过。然而这样的惯例并不使人愉快，它既不是愉快的一部分，也不是不愉快的一部分，而是惯性的一部分，无关乎情感，仅仅是一种惯例。自然这样的饭局甚至会显得比愉快的饭局更为自得，就像是平时随便吃的一顿饭一样。虽然它有着某种仪式上的标签，却终究没有某种仪式的感受。</p><p>　　我想，这样的惯例或者仪式对于每个人来说，应该也是必要的吧，对三弟这样社交圈里如鱼得水的典范来说，应该会更为重要吧。于是我给出了这样的提议：请不用管我吧，叫上自己大学还好的朋友一起吃一顿吧，就当是别过了，后面再想抽出时间就很难了。然而最后他还是没有接受这个提议，或许会觉得难为情吧。确实或许会吧，像是将一个木雕馆里那种老房子拆下的板材制成的柜子摆在充满了明亮并带有玻璃现代风格的展示厅里那样不能称为和谐的场面，我也会在不能够搭上话的氛围里被击溃。毕竟历史和正在发生的已经是两码子事了，历史发生的一切都是某种执念留下的幻觉，或真或假，伴随着主观的某些微不足道的想法而变形。于是便觉得他做出这样的决定不可不谓明智吧。</p><p>　　于是我最后也接受了三弟的决断，抱着再吃一顿夜宵的想法前往刚刚得知的约定的地点。就在推开门的那一瞬间，寒风从外面扑进来问候我，但是刚刚拉面店所赋予我的热的感觉还没有消散，我就在这样的寒风中突然想起来刚入肚的拉面，同时觉得温暖。</p><p>　　我需要四十分钟到那里，我这样回复了三弟。</p><h2 id="第六日"><a href="#第六日" class="headerlink" title="第六日"></a>第六日</h2><p>　　在吃完午饭后告别了三弟，便第二次朝着中央大街前进。这一次，我是奔着之前被自己放弃的马迭尔冰棍而前往的。这一次我从中央大街的腰部的某一个支道上进入了主道，随便选了一个方向，然后笃信着我所寻找着的马迭尔冰棍就在前方。当我再一次看向那些我曾经赞不绝口的建筑以及房屋，却总觉得缺了那么些味道，我想是这或许不够寒冷的缘故，也可能是现在还没有进入夜晚的缘故，还是说因为我知道我将离去而遇见了一些别的感受。我说不清楚。这些即使在白日中也点亮着的霓虹灯招牌，间杂在这些富有着历史感的建筑间闪闪发光。我这一次无心再一个接一个地端详那些冰雕了，我只想找到那个驱使我再一次来到这里的马迭尔冰棍。</p><p>　　我这样盲目的往前前进着，但是却发现我已经走到了中央大街的尽头，便终于意识到自己在十字路口选择了一个没有马迭尔冰棍的方向。这让我感到懊恼，于是我转头开始往回走。然后我立刻发现了一个我上一次便看见但是却没有进去仔细观察一番的建筑，中央书店。没有在果戈里书店找到的《罪与罚》，这里应该会有的吧，我这样想着，进入了书店。这个书店和果戈里书店完全不一样，没有果戈里那种高雅温馨的氛围，里面密密麻麻的是走动着人群；也没有像果戈里书店那样坐在地上看书的群众，也没有停在走廊上拍照的人群。这个书店天花板很高，整个宽阔的房间也几乎没有什么装饰，几列一进门就能看见的书架，和左右向上一直延升到了天花板的书柜。这意味着这里有许许多多的书。我想着我计划里的书或许终于有着落了。于是我埋头进去，寻找我想要的书。</p><p>　　不久，我在那里找到了我正在寻找的书。书很厚，封皮很薄，不像是近段时间常见的把经典或者不经典的书都统一用又硬又厚的封皮包起来那样的做法，而只是在书上包了一层简单的封面就放在书架上了。它甚至连腰封都没有。很中我意。封面和封底都是是完完全全的猩红色，从前到后都是大片的猩红色。正面用端正的某种楷体的变体竖着写着黑色的“罪与罚”三个汉字，以及横着写的 crime &amp; punishment 几个英语字母。悬在这一系列字上方的，是一把被手握着的黑色的斧头。在剩下的空处标着陀思妥耶夫斯基和译者曾思艺的大名。很中我意。</p><h2 id="第五日-2"><a href="#第五日-2" class="headerlink" title="第五日"></a>第五日</h2><p>　　闹钟在五点半准时地把我叫了起来，今天得立刻就离开床铺，我拉开了自己房间的门，示意三弟自己已经醒了，然后穿上衣服出了自己的卧室。透过那扇就在我的卧室旁边的门，我知道三弟也已经起来了。他正坐在自己的床上弯着腰发呆，上衣尚还没有穿上，腰上和肚子上的少些赘肉略微地鼓了起来。而被子被推在一旁，形成了一个突起的泡沫。三弟还是像高中那样每每起床之后就要盯着某个怪异的方向，神志不清地发会不明所以的呆，同时也是比高中的时候胖了一些。</p><p>　　想罢这些我就移步去了卫生间洗漱去了。我再一次出来的时候，三弟已经穿好了衣服开始给室友打电话叫他们起床了。待到我们两人都准备妥当的时候，便出了门。预约的师傅搞错了我们上车的地方，不过总算是顺利坐上了车。本以为车上不会有别的乘客，没想到这一次还是受到了冰城出租车乱象的捣乱，车上坐着另一位去哈尔滨火车站的乘客。不巧的是，另外两名并未来得及准备妥当，而那个没在我们预期之内的乘客的火车在我们的火车之前，着急着去赶自己的车。我们并不占理，就只能先舍下两位室友友人，继续乘着这辆车前往火车站。</p><p>　　然而就在我们到达火车站之时，却发现火车的出发时间比我们原以为的早了二十分钟。而三弟的室友们便没了这个赶上这班车的机会，他们可能得买新的票了。</p><p>　　安稳地坐在了火车上之后，就开始处理那两位室友的行程，好在目前尚有别的车可以到达目标。就在三弟处理着这些我非常不擅长对付的事情的时候，我开始观察车厢之外的情况。外面是一大片被枯树弄得支离破碎的雪原，在这些枯树的间隙里，有着几片不大不小的类似田垄的东西。我之所以可以知道那些是田垄，是因为在那洁白的雪地之中留着规则的被犁过的平行的痕迹。在这些田垄之上，极有规律地堆着些要么圆柱形的、要么三角锥形的谷堆。有的阳光会穿过枯树照在雪地上，使雪地看起来被什么东西踩过一样。远处的山，迷迷蒙蒙，说不清楚是被雾罩着还是什么，呈现出一种很深很暗的藏青色，就像是只调了一点水的花青色。时不时我们会路过一些屋顶上堆满着雪的屋子，却没有见到几个在雪地里行走的人，只看得见地上偶尔稀稀疏疏的脚印。就在我观察着这些平日难得见到的北国风光时，三弟那边的事情也处理结束了。</p><h2 id="第一日"><a href="#第一日" class="headerlink" title="第一日"></a>第一日</h2><p>　　在不知原因地三次延误了航班之后，终于在比原计划晚了三个小时的时候，我到达了冰城。在我假想出的寒冷的空气的威逼下，我准备好了手套、围巾以及两层袜子，却发现外面远没有想象的寒冷。赶上了从机场到火车站的大巴之后，便注意到了坐在一旁的一对父子。虽说是注意，但不是我的眼睛看见了他们，而是我的耳朵抓住了他们交谈的声音。儿子坐在了我左边的座位上，而父亲则是站在或者蹲在儿子的旁边。父亲之所以这样是为了和儿子说话这一点我很清楚，但我也不愿起身离开我的座位而给父亲一个方便，因为车已经开始移动了。</p><p>　　从这对父子零零星星的对话中我大概了解到，这个儿子在广州某地读书，年龄大概在十馀岁，声音尚未变得富有男性的特点。这一次是从读书的地点回到哈尔滨旁的某各小城市里过年。父子会在哈尔滨住上一晚上，然后第二天就赶回家。令我感到奇怪的是儿子读书的内容。我只大概听到儿子这一年的课业是背诵《论语》；下一年的课业是背诵《孟子》，再之后是背诵《易经》和《黄帝内经》。</p><p>　　你要记下老师讲的所有的东西，父亲这样说道，它们以后都很有用。爸爸我没有什么学问，我不懂什么《论语》，但是知道这些东西很有用，你把这些东西给爸爸记牢了，永远都不要忘记。儿子支支吾吾地回答，他不觉得有什么用，自己在生病的时候，老师给扎针也没有治好。于是父亲又重复了一遍上面的话。接下来父亲开始挨着挨着询问课业的事情、生活的事情。最后说，爸爸下次再带你回一次家，再下一次你就该自己回来了。你也大了，该自己走了，这个不难。旁边的乘客也帮腔到，对的，这个不难，都是这么过来的。儿子先是小声地回答自己不行，后来才慢慢地问着父亲自己能不能有一支手机，这样就可以自己回来了。后面父亲又反反复复地交待了不少的事情。</p><p>　　我一边有心无心地偷听着这一对父子的对话，一边看向窗外。窗外没有什么景色，在黑夜里面，无非就是在高速道旁往后滑坠的立着的树，这些树都没有叶子，光秃秃的，这些光秃秃的树使人感到平静。你早点休息吧，我这边应该不会有什么问题了，我编辑了这么一条信息发给了三弟，然后再一次把视线转回了窗外。</p><p>　　直到下车的时候，我瞥到了这一对父子。虽然看不清楚他们穿了些什么衣服，但确实地看见他们一起下了车，朝着我不会再遇见他们的方向前进。没事，你再适应适应吧，三弟这样回复到。原来他还没有睡啊。</p><h2 id="第七日"><a href="#第七日" class="headerlink" title="第七日"></a>第七日</h2><p>　　我终于踏上了回去的路途。然而就在这回去的一天的夜里我一点也没有睡着。房间里墙上钟的声音在不停地刻板地踢踢踏踏，时不时也传来冰箱的些许噪声，房间之外的马路上尚有不少的汽车正在道路上行驶着，出租车“有人的”黄色标牌在夜色里拉成一条长线。三弟今晚回到自己的寝室收东西去了，这个二室一厅一卫一厨的屋子里现在就躺了我这么一个人。</p><p>　　我不知自己出于什么样的目的，没有和三弟订下一起返回成都的飞机，而是古怪地晚了那么两个小时。在这一天之前的晚上，三弟劝我还是自己走吧，不用起那么早了，可以多睡一会。我拒绝了这个提议。于是便还是决定一起去机场。然而我正住着的并不是什么繁华的地段，没有特别多的住户，尝试多次以后，我也没能预约到合适的出租。那走去地铁站吧。我想，凡人的偏执乃是危险的东西，而这一个决心是我已经下好了的。于是我就在这样踢踢踏踏的声音里，看着时间从 2020 年 1 月 11 日的 11 点一点一点划到了 2020 年 1 月 12 日的 5 点。我起身去洗漱，零零碎碎地吃一些东西，再检点了一遍有没有忘记了的东西，顺便检查了一下三弟的房间有没有留下什么他忘记的东西。在仔细地确认这些无误以后，我开始坐在客厅的小沙发上发呆。</p><p>　　这样，我在这寒冷的地方的旅途就竟然就要结束了。我终究没有吃马迭尔冰棍或者是红肠，更不要说别的什么的东西。但是我又没有固守没有人的城池这样的想法，或许这就是时候离开了吧。我心里暗想到，三年后的这一个时刻，我可能会再一次坐在现在我所在的房间里，思考一些相似的问题。想到这个，我不免觉得奇怪，原来我还要回到这里来呀，对，三年之后，我会再到这里来，可是那个时候我或者这里的人们都是什么样了呢？</p><p>　　就这样坐在黑暗里，我终于下定了决心出门。把要是小心翼翼地放在了桌子上，再环顾了一下这个不大的空间。一个双开门的冰箱，一个只能坐下两人的小桌子，坐下两人的小沙发，一台大电视，一个小巧的厨房以及浴室，几面墙上都挂着的小画。于是我再这样望了一眼，出门将门关上。</p><p>　　我是在将来真的会回到这里来，还是会到一个别的什么地方去呢？</p><h2 id="第二日"><a href="#第二日" class="headerlink" title="第二日"></a>第二日</h2><p>　　在时隔上一次见面将近一年这样的时刻，我站在哈工大校门的广场那里竖着的巨大的校庆的冰雕的旁边，看见了耳朵被冻得略微泛红的三弟。这个时候正是哈工大的学生从寝室或者图书馆出来寻觅午饭的时候，在滑溜溜的地板上，小心翼翼地走着许多带着羽绒帽子并把手揣在兜里的人。在我左前方立着一个高大的冰雕，冰雕的下面刻着哈工大的校徽，以及 2020 的纪年的数字，在我的右边是一个用冰砌成的国旗的围栏。我向三弟打了一个简单的招呼然后问我们现在去哪里。</p><p>　　很快，我们抵达了哈工大的食堂。哈工大的食堂是一个怪异的物种。从外面看过去完全不像是在营业的样子，作为一个闯入的外来人，我或许有可能永远都不知道在那垂着的重重的帘布一样的黑色空间之后，藏着一个卖粥与饺子的地方。</p><p>　　于是在这里，热气第一次扑向了我的眼镜。三弟提议吃饺子之后，接着问我要多少，我说二两。他露出了怪异的表情，眼睛瞪得很圆以表示难以置信，然后再一次确定了我的答案，端给了我一份二两的饺子。盘子里的饺子大多不太完整，也不太大。这些饺子不像是平时吃到的饺子那样中间鼓起，而更是呈现出一个扁平的状态。说是二两的饺子，估计一下也就是十个左右的数量。这样我就知道为什么三弟奇怪地看着我了，原来二两的饺子是如此分量微小之物。</p><p>　　于是后来我又去补了一杯粥。本来我是想要一杯豆浆的，然而这里中午没有豆浆。我自作主张地给三弟也要了一碗，尽管他之前说过自己不要豆浆了。这粥是不太甜的那种，不是我喜欢的味道。在若有若无地聊着天的时候，我终于决定去加糖。然而加糖这种事情是不可以一步到位的，在折腾了来回几趟之后，我才终于仰起头，将碗里的黑粥一饮而尽。</p><p>　　待到我放下碗，才第一次认真的注视着三弟的面貌。毕竟也是有将近一年没见了，虽然说不清楚具体哪些东西发生了变化，我却感觉到一些不一样的地方。我指的不一样，自然不是指他的头发如何地变换了形式，或是眼睛如何地望向不一样的方向，而是一些别的东西，一些我的视线抓不到却可以感受到的东西。他可能也趁着在这个时候注视着我吧，我想。</p><h2 id="第五日-3"><a href="#第五日-3" class="headerlink" title="第五日"></a>第五日</h2><p>　　走进门，把随身的东西都撂在一边，然后走进自己的房间把围巾和外套都丢在了床上，折回了客厅，然后摊在了沙发上。疲惫的影响力，真的是不容小视。我就这样茫然地架在沙发上，三弟却看起来很精神。我确实是短时间内没有力气再说一些新的话，于是就任由我的身体稀里糊涂地倒在沙发上。然后我开始很仔细地，试图尽力地消耗着剩馀的所有力气那般，盯着头顶的灯。灯是三层蓝色的荷花叶子一样的图案的组合。每一层之间都很好地错落地分部，不至于拥挤。每一朵花瓣都是向外舒展的、完美的、圆滑的弧线。它从那里发出柔和的光，我接触不到它，它离我太远了。三弟坐在一侧开始试图找些有趣的东西来看，我在旁边继续倒着。</p><p>　　我想，这一趟旅程就这样快要结束了吧。就像一顿火锅已经下完了所有的肉一样，后面的期待也如同捞起来的一块块肉一样，终于寡淡了。也并不完全是这样一个事情。在刚才从咖啡馆回到住宿的路上，三弟和我说他在和老板交接任务的时候，知道了明日自己需要加个班，完成一个仪器的调试。我听着三弟这样一段话，心想自己去冰雪大世界以及二访中央大街的计划就这样被取消了一大半。</p><p>　　我看着自己呼出的水汽在空气中凝结成一片飘摇的白雾，在我伸手抓到那段白雾以前，它们就没影了。如果不是哈工大这片路灯的照耀，这片白雾也就不会出现在我的视线里了。一路上依旧没有什么行人，许多店铺也早早地关了门。我想这些店铺就算开着，也不会有很多人去了，这里已经放假了。我就在这样想着的时候，越发觉得身上正承载着的疲惫的真实与复杂。</p><h2 id="第四日-3"><a href="#第四日-3" class="headerlink" title="第四日"></a>第四日</h2><p>　　毕竟是晚高峰，放在哪里，晚上七点应当都是晚高峰。就晚上来看，忽略掉路旁的冰以及行人穿着的厚衣服，这里的晚上和上海的晚上或者成都的晚上都没有特别的差异。路两旁排了一列闪亮着的灯，灯前排了一列匆促行走在人，匆促的人前排了一列公交车站，公交车站前排了一列等车的人，人前面排了一列排队的公交车。就是很朴素的夜晚的景观，放在中国哪座城市里都是的那种晚上的景观。纵使是冰城，也不可能四处都是冰雕，总会有些不那么哈尔滨的时候的。</p><p>　　终于经历了一路走走停停，我到了目的地。就在我快要到达的时候，手机上的新消息告诉我三弟也到了。时间正好。走进约定的烤肉店再转到二楼，就在进门不远的地方，我见到了三弟。之后就是观赏菜谱的时间。虽然我总是不愿意担当起点菜的重任，但总有些事情不能顺心如意。三弟就是这样，每次在我看着菜谱的时候，他总是要让我也点一些什么东西，不论我怎么推脱掉这份差事。于是我只能打开菜谱，逐页地翻着。这确实是相当厚的菜谱，我很久没有看见这么厚的菜谱了。里面的菜也很有意思，比如一个叫大串的东西。就在我计划随意点两串的时候，我被三弟制止了。于是我想起了中午在东北菜馆的尴尬境地，终于还是缩减了点的东西。然后将菜谱让给了三弟。这些事情还是交给他吧。</p><p>　　这家店不知为何，据说今天的人特别的多，也就使我们上菜的速度很慢。一道菜往往等不到下一道的到来便早早地投了地府，我本以为肚子里占着碗拉面和章鱼丸子便不会吃什么东西，但还是老老实实地吃下了一顿饭的分量。不过三弟定然是没有吃饱的。我们又追加了一份什么榴莲烤饼，但它终于没有被端到我们的桌子上。粗心的服务员忘记了我们的加餐，于是我们坐在桌子上聊了很长一段时间的天——上一次并没有来得及聊到这么多的东西，但所谓聊天，也就是些琐碎的话题，没有什么中心，也没有什么重要的话题。我大概描述了一下我在新加坡的生活，三弟大概描述了一下他在哈工大的生活。</p><p>　　与这顿被服务员忘掉榴莲烤饼的美中不足的晚饭不同的是，三弟的生活听起来很幸福。</p><h2 id="第一日-1"><a href="#第一日-1" class="headerlink" title="第一日"></a>第一日</h2><p>　　终于，我离住宿的地方近了。我刚到冰城的时候，这里就下起了雪。我在雪里等着出租车，旅途遇到一群推销着住宿的人。仓促地拦了一辆车，不太顾砍价的，我逃离了这个地方。还好这里离住宿的地点不太远。一路上师傅开始与我交谈，和我聊着哈尔滨的各种事情。他似乎没有看出我是外地人，先是用本地的话和我攀谈起来，发现我没有完全听懂的时候，他便开始试图说一些更类似普通话的语言。他问我是来做什么的，我说我是来看亲人的。这句是我出于自我保护而说的一句谎话，后来想想却的确如此。我若不是来看亲人的，又是来看谁的呢。</p><p>　　我被司机放在了小区的正大门前，按照之前房东的说法，我顺利进了这个小区。小区很是安静，在这个稍微偏一点的地方显得很舒适。四周实在是安静，地面上由于正下着雪，已经满满地铺了一层。树上挂着黄色的灯，也是这里唯一的光源。这里唯一不和谐的是我这个就算在雪里也隆隆作响的箱子的声音。</p><p>　　我的前面是一条洁白的长路，在黄色的光的照耀下也呈现出些许黄色。我忍不住回头看我走来的路，在我来的那一边，它本也应如同我前方的道路一样整洁，现在却烙上了一串凌乱的脚印以及不连贯的纠缠着的两条长线。拖着箱子、破坏着着安静与整齐的我，在这个时候很清楚地知道：我不属于这里，我只是造访这里，拜访一位亲人，然后再从这里离开。</p><p>　　我之所以在这里停住，恐怕不是由于掌管生命的神这样对我说：请停留在这里。私以为，我之所以停留在这里，是因为我决定如此，而不是其它什么花里胡哨的原因。这件事情的发生既不是我的计划，也不是像我的某个人所构造的计划，它根本就称不上什么计划。尽管我在甚至离开上海前往新加坡以前就如此打定了我要来一趟哈尔滨的主意，甚至是在前年的夏天，我就做出了这样的打算。但它仍然算不上是一个计划，这趟旅程毫无理性的成分，既不考虑支出，也不考虑时间。只有“到这里”是重要的，这是计划的一部分；但是计划也没有别的部分了。被问起我为什么来这里，我谎称自己是因为自己想感受一下寒冷，或者是自己是对东正教教堂颇有兴趣。但我清楚地知道这是敷衍别人以及自己的理由，我知道理由就只有一个，而且正是为了达成这个理由，仅有“到这里”才是重要的，也是必要的。</p><p> 　　这里寄寓着我的一部分生命，我必须到这里，将这一块回忆填上。</p><h2 id="第四日-4"><a href="#第四日-4" class="headerlink" title="第四日"></a>第四日</h2><p>……</p><h2 id="第五日-4"><a href="#第五日-4" class="headerlink" title="第五日"></a>第五日</h2><p>　　站在雪板上，我感受到了最大程度的恶意。我没有任何移动的可能，我所能做的就是坐在哪里，或者任着向下的冲动终于把我一直拽下去。我停不下来，也改不了方向。我所驶向的地方既不出于我的意志，也不违抗我的意志，它独立于我的意志。决定我方向的，终究就是我在踏上这个路途上那一瞬间受到的力。除此之外，再无他物。</p><p>　　我总以为，在不断挣扎的时候，我能够通过某些途径改变自己行进的方向，然后到达我所期望到达的地点；但终于发现这是个徒劳。于是我就停在了我意识到了这一点的那里，感到挫败。我想，如果将这个倾斜的雪道变得水平，那么我所面临的另一个困境便变成了：我只能留在原地，而不是像现在那样向下滑去。或许那个时候，维持移动的唯一便是惯性本身，它既不是无形时刻存在的重力法则，也不是我渺小的意愿。这个雪板就会载着我各式各样的胡思乱想，没道理地一直往前，直到这个巨大的船只撞上了什么东西，终于再也不能移动。</p><p>　　就像这样，我要么在雪上仓皇地四处乱撞，要么就倒在雪地里。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>　　这篇罗嗦的，也没记下很多东西的后记是在第五日受到清华某友人的启发后打算写下的。本来是计划完成一份详尽一些的、3w 字左右的文本，但终于在离开了冰城以后完全丧失了继续完成它的氛围和意念，就如同我在离开那个城市时所担心的那样。所以终于大部分内容都停留在了停留在哈工大小咖啡馆的内容，只是后面草草再补了一些东西。</p><p>　　这篇文本也并应该包含太多的深意，甚至有很多相当重要且关健的事件出于各种考虑以及个人的懒惰终于没有添加进来。简单来说，这或许是因为离开了那里而被迫腰斩的一篇小文章。或许是到了后面越发觉得自己的笔之沉重，终于不能再将原本定下此题的勇气重现出来。</p><p>　　更多是对当时一些思绪的整理，就没有更多的东西了，且当作胡乱作文的结果吧。</p><p>2020-1-11，作于冰城哈尔滨</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 行迹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公开信-给YT的第二封回信</title>
      <link href="/2019/11/12/essay/letter/%E5%85%AC%E5%BC%80%E4%BF%A1_%E7%BB%99Yuting%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%B0%81%E5%9B%9E%E4%BF%A1/"/>
      <url>/2019/11/12/essay/letter/%E5%85%AC%E5%BC%80%E4%BF%A1_%E7%BB%99Yuting%E7%9A%84%E7%AC%AC%E4%BA%8C%E5%B0%81%E5%9B%9E%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-EWHHYzVR" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="438562829" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>YT，</p><p>　　想起来这一封信也是，好像好几次打算开始，都没能完成，真的是非常抱歉了。想着上一封回信被我从上海带到广州，又从广州带回上海，再从上海带到新加坡，若不是一个契机，恐怕又要被我从这里带回去了。时间太久，恐怕之间好些事情已经有变化了吧。在这一次的追加之前，是在我 11 月动笔之前遗留的信的内容。这之后的事情，就留在这部分之后吧。</p><p>7-29 日书：</p><p>　　很抱歉已是拖沓了如此之久了。一段时间以来，我常常想起，或许我应该提起笔来写这一封信，如同每日起床时我想起我的琴，但每当太阳落下的时候，这种感觉就丧失殆尽。以至于当我意识到，过了这么久了，我居然都快要离开中国的时候，我还没有真正开始写这么一封信，就感到一阵无奈。倒不是为事情本身无奈，而是为我自己无奈。</p><p>　　这一个学期发生了不算多、但也不算少的事情。除却学业自接近半期开始初露爪牙这些事情，还有出国一条线时显时隐。个人的心境在这长期中，似乎受了些扰动。或许这是无法提笔的根本原因吧。但这些扰动的原因或者影响，我都是说不清楚的。</p><p>　　首先是对上一封信件文风的回应吧。说一个人的文字有些许味道，是很高很高的赞扬了；或许我的信的风格是变化的，是不稳固的，所以我并不知道自己的风格是什么，所以更没有什么有心之举了。或许我的部分语言结构受日本文学翻译那一脉，或者日本文学那一脉影响很深吧。在高一那段时间，可以说是疯狂地看各种书。当时，除了忙社团和班级活动一堆事情，也就只想看书。那段时期看的书，最多的就是日本文学了。并不是说自己对日本文学有多么深厚的喜爱，而是那种温馨与悲凉交错的感觉，让人觉得真实而深刻。</p><p>　　YT 的文风就和我迥乎不同了，有一种细致明媚的感觉。仅就一系列常见的语气词，用法及效果差别都很大。因为拖欠了如此之久的回信，又时不时想着要回，所以这封信我也是看了好几遍了。而每一次的阅读体验都是相对一致的，虽说内容或各种变化，却有一种稳定含蓄的积极情绪。虽说我写了很多信了，但是真正的回信这却是第一份，这封回信还是出乎意料地长。巧的是，就在这不久后，我接到了另一位同学的回信，不过这是另一个诡秘事情了。</p><p>　　听 YT 谈面包，我想到或许自己更喜欢做一个厨师胜过做一个研究者。或许因为下厨只是因为兴趣，而且也不经常，所以可能对美食的制作有一种自然的好感吧。仔细想想，为了一道小菜围着锅炉转一两个小时还是有点累的。所以干脆做个品尝者好了，见识到没见过的食材和做法永远都是令人激动的事情，虽说常常标新立异的菜并不合人胃口。说起面包，我倒是一直认为越丑的面包味道越好，那种形状奇绝，浑身疙瘩的面包估计就是我的最爱了。</p><p>　　回信中 YT 也对后悔有了一个表述，于是我更清楚地意识到，我确实离这种感情太遥远了。于是说起我的好朋友的事，如果以“如果……就好了”这样的评判去评价当时的那一次选择，我是不后悔的。我有一个非常值得怀念的高中生活，我的朋友也和我一起度过了很多事情。但这不是我不后悔的理由，这不后悔并没有什么理由。这些事情只是恰如其分地发生了，然后事情总会继续往下发展的。至于那个或许“有意味”的团建就是如此，我只是在零零落落的瞬间中意识到了道路的分叉。分叉不是被哪一次偶然构建在那里的，而是一直都在那里的。所谓联结，或许不是执着于道路的方向是否一致，而只是一种联结罢了，一个名字或者一种理念。至于为什么会有一些惋惜之类的情绪呢？犹如一块巧克力，咬下这一块的人都会意识到，这一块巧克力的一部分丧失了，一种味道在被获取的时候丧失了另一部分味道。当巧克力的一部分味道被知晓的同时，其他千千万万种味道就丧失了。惋惜或许就是如此吧。</p><p>　　不过说来也巧，YT 居然有极为类似的经历，只是发展方向截然不同。YT 在信里面有很多的推测与猜想，这确实是一件有意思的事情，只是我不太擅长做出这些假设。</p><p>　　还是很羡慕 YT，不论顺或者不顺，生命中都有如此多有意思而重要的人。我听了很多人的故事，其中不乏有如小说般出人意料、走向戏剧化的故事。但最后还是更喜欢恬静美好的故事，YT 的故事就已经很是恬静美好了。我或许向往一个恬静美好的生活吧，但是自己的生活又是恬静得过分，可以算波澜不惊了。安稳着安稳着，又想来些猛烈的东西，然而这样的东西又使人感到恐惧。所以就在这样安稳，而向往着波澜的生活中避免着波澜，继续着安稳。</p><p>　　说到这些事，说来也怪，我碰到的感情事项不算多，但都是以诡秘而单调的模式出现的。想来也是无聊的些许生活琐事，真要谈起怕是枯燥之至，若想要听，我再抽时间谈谈吧。总之就是如此。说到这里，可以大概谈谈之前有提到的“朋友”的事了。对我而言，友情是一个非常广阔的概念，但是却仅仅适用于一小波人。无疑，我对“朋友”是看得很重的。这里当然指的金兰之交以上的朋友；无论在谁的眼里，这样的朋友恐怕屈指可数吧。我也说不清楚一个朋友在我的生活中会扮演怎样的角色，有时我觉得他们是我的一部分，有时我又觉得，他们或许远离我会更好。这倒也并不是一种飘忽不定。对很多东西我都是变化无常，但是朋友却不是。我说不清楚这是一种尊重还是什么，更多来说，与朋友的相处就如呼吸一般正常，如同张开自己的嘴，或者挥动自己的手臂。有如自己思想的延升，感受到了一些自己感受不到的快乐与痛，然后有了一种一同体验的感觉，便是如此。</p><p>　　以上便是之前的内容了，上一次差不多也快到了结束的位置。我再看了一遍，大概小改动了一两处吧，别的便是如旧了。其中的几点，可能现在 YT 会有不一样的感受吧。特别是我给出的“积极”、“明媚”、“恬静美好”这样的描述。不过还是希望生活大部分时间都会如此。那么我先大概讲一下我这边的情况吧。正如我在前一部分描述的如此，尽管某些细节发生了很大的改动，生活还是如同往日一样前进。更离谱的是，由于这里常年夏天的气候，连天气的转变都不明显。每一日的区别便更加地小。</p><p>　　或许你会对这边我做的科研有一点兴趣吧。这边做的工作是自然语言处理的一个小分支工作。研究的是句子间的联系。简而言之的话，语言学家基本认为大部分句子间的联系可以分为四大类：下文是上文的展开或收束、下文与上文形成反差或对比、上文与下文构成因果关系、上下文间具有时序关系。这些关系大概有句子间具有关联词和不具有关联词两类。句子间没有关键词的这一类的判断非常困难，这就是我这边的工作了。本来以为九月份可以结题，因为已经做了一段时间了。后来发现最初的设想不够有效，于是只能转变方法。后面又尝试了一两种新的想法，还是差一点。最后的思路大概在一个半月前提出，然后在一段时间的工作之后认为这个方法有效，但是距离本任务的最佳成绩有非常细微的差距。在这个情况下挣扎了很长时间，知道上一周周末终于有了突破性进展。想起来在这段时间里，好长一段时期就是有空就到实验室看样例分析句子结构，也是很辛苦了。科研这边的情况大概就是这样了。</p><p>　　然后是日语的事情。我也没想到居然自己会修日语这一门课。这确实是一门挺有意思的语言，也学到了不少东西。今天这刚考完口语，看着日语老师在我离开后在房间里面收东西。我想，这门语言在以后会以如何的形式存在在我的生活里。大概就是那一瞬间的事情，我大概意识到我的交流生活就快结束了。然后熟悉的感觉便再一次到来了。就是那种说不太清楚的难受的感觉，像是现在某些东西往往如此的平淡，总因为种种原因而在生活里消失了。在日后回忆起的时候，一种模棱两可的气息就会涌起来。像是怀疑起自己经历过的岁月是自己的还是像自己的某个人的，像是自己暂时保管着这样一份回忆，觉得这个事情居然真的发生过那样，感受到恐惧。这种恐惧或许是我生活中最执拗的情感了。发现自己不小心扯到这里来了。</p><p>　　那接着这个问题谈吧。YT 看起来是最近遇到了一些“琐碎”但是却难以消解的压抑情绪吧？既然现在不是很清楚 YT 指的是什么，那先谈谈我的吧。我之前应该也说过，自己并不是一个十分积极的人。我之前怀疑过自己有没有抑郁，我想用复旦的心理测试那里试一试，但是它的网络频繁崩溃，后来也不了了之了。我想自己如果还有那么几个真心的朋友，情况或许就不会太遭。我现在没有太怀疑这个问题，可能是我已经忘了吧，也可能是我觉得不重要吧。</p><p>　　啊啊…这后面一段我反复改了好多次，但终于没有找到很合适的东西写下来。抱歉…这一部分我可能不太能直接接下去。我想我在说下去会更多地把一个悲观的世界观展现出来，这个话题我这边先就此打住吧。可能每个人有着自己的痛苦与解脱的方式吧。说起上一次推荐的《荒原狼》，尽管很可能是误读，但我觉得最惊异还是那种态度。那种意识到人生无从寻找价值却仍然创造一种价值的态度。这样的表达不是很合理，但我想，大概就是这样了。</p><p>　　那么，我这边的情况就是这样了。很难说是一个积极的回应，不过还是希望 YT 能够把压抑或者难受吐露一些出来。说不定我只是不擅长处理我这边的。再者，不论怎么说，我都慢慢开始意识到这个时代内在的一种无奈。我感到不是说选择怎样变多，或者说生活如何充满物质、人的生活如何的空虚，而是那种使生活延展下去的动力显得越来越模糊。（一种偏激且极为悲观的看法吧）所以容我先胡乱猜测，也许某些东西，我们所有人都需要找到解决得方法。</p><p>　　回到这个话题早开始的起因吧。电影的话我真的不太能推荐出来，毕竟自己看得十分有限。小说的话，如果《荒原狼》现在还没有来得及读的话，我会再推荐一次。可能再推荐的话，我可能会给卡夫卡的《审判》吧，如果从不同于法律的角度考虑，说不定可以发现新的东西。按照之前，我还是附上推荐的音乐。这一次，在这个状态下，我可能推荐的其一是《马勒第九交响曲》。至于原因，我很难说清楚。它的张力在不同人的面前定会有不一样的感触。其二是过于有名的巴赫的《恰空舞曲》（BWV1004-5），理由同上。不过也有可能这两组都听过了吧……</p><p>　　那么，这一次先如此了。再一次为自己的不守时感到抱歉，以及希望使用电邮不会显得过于随意。最后，希望在你回信的时候，你会感到更快乐一些。</p><p>　　廙水</p><p>　　顺颂清安</p><p>作于 2019 年 11 月 12 日。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给LZ回信</title>
      <link href="/2019/06/23/essay/letter/%E7%BB%99Luzhi%E7%9A%84%E5%9B%9E%E4%BF%A1/"/>
      <url>/2019/06/23/essay/letter/%E7%BB%99Luzhi%E7%9A%84%E5%9B%9E%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Sorry, password needed.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="db1d9cb1fc9d9f93591b8e70963e65f5375c795d9be771598b7d2cb5134eb560">06ec672228af806f6ec08d793425ade0bec8dda191b67fafbc7cc886a506766d43c90893053957757ca7b34cda971242fdb387f1ffbe7ee7889944e0f89a9bc93c98cf203492c4ef62da7d8750dc3323577fb91ba42283ed553df858a3ac7745d26fef8b12c8cfe6c2f40c5f4440b554949a470049caa9a1f60731f23bedc5776819a269ab1c4b964612260166b593ce49ade2a187a6b1dd050c738f2cb689428329f7baef41bbaa200f90aab5dfa0fa36b648e4d2bb759eaa33741b705a2085fb432856b900c534ab04720a70aabc2225b840d34506c1b1856f19df0ea39f86d37a7de36e52fa30ac0699c09d7d51ffe1a9dea960bd576a3d0d84104f605ee3ea514e4e69db1aeb343481846ab3c1ecf154be1bca676afb00e72f4b243418c0145a72d04a088a478b3804ec6fba844cb7079b17250b523cf817bc6225e3d26dce3dacd03679e66c59e00b9fa13ef2442df30469ede484efe42b5edf3a11f908031549a6b1e0865d198ce3cd063ea2d3d759f202967412466fe130c5e0d8fb226c53fd017f0e1f24b806c9c5e7a2ed552613933a209be5f36ff67e7abb7ceff67f7990a61d0b6e4a3c4c7dda8dad5dcc6441b16f9593dac17401773e4875824de4ceb5692fe0d2bbf0e76eaa536689888ef1f9948b94663fbcd5df80212c11d0123e958b3cb7c83049ca5ac7019c12cfd06e6141a9a4dcb8efb8889939c62119b8f4961491dd65fdb488da61e991fb3f1073a401e85772b506691efab9a6b4b10b31f8a5be7329d371c7c5bf5d536102256ccfe821a7d5f7834e1234a99f6caf81c9ddcd42930c2195d7bc5c40726b53e41c6fc7298533f691eed4970a479535224528bf3c3d115d1904d2f479d02693ad2a290482358f3209b74900bc5d559b8781e98bd655dfae348fdfff3fd7da8806694a9f007c8de7655d304cb60b3c15582407a577e4f40e36ad5c98aee5f517b66959c14cf5b96a80a9eb0fed5c975bd3f55b8964cf08aee15137422f4b355b2a93051d091c14559f9458dac768645e21f11f664d4e8f95354ccd8d2dce3dc1e3ca442ea2a90e15f2c73ca77ff81b95a24f59fccd1818229c39ebe94ea37928a09c72faa82eb128303a31ca705b31fa1e1fbb33dd848839c6aea98023742a34bdb15542caa20cf9351c7883a3d9e04543dd6a10108b88b877d0019d12dd03082faa323ce9c2ff4e8aa517f5a6be677bf1cd899879b3178cdeebdd61a87f2278b6ba95651b24778c581f73be472896c4f177779e8cd1f29abdab539324cb6e36719ffd990c240ee56a23745e1bd5bf4a65b0e0250e29b5a0f1d3a00823ab035e27bfd77d45130f4581fb34c309460a2d868f5bafec3c562b20d70e3e6eaeed21398a98010ea5d32af65397a46e22679e90fbb3903106462235ee8a49565713c94805be61be8cadec438201cf7f327b20faa18bfae4a852ce8a4caf06acdeeb67c594de14cd8dbf4cfd2ab084e36391138b3f62ccf6dbe72f64a80676ee284460ef1cfac687e27cce87f88228c776c25009e68a1d28af94f296189d56584054feabd129a0823b3c244d209f5022c97699ff90c9184393354352358f5577d32615214f37cbccf594e072feaf3f53d13ed5d9083f3b6d681b90b047732c57af96a86d59d43ada0b022adce4b0b70e8831e9f07f18c9ea0bd8fd828542ac1502ffe51a355eb183356efe6206dbbc6164508b4d5b920fde876b7cb68663bc218396c1fb0b1dbe19315784d002090e6d83ed0e6d45d87d4de43a0bea50e4652c7a26e87f9c0dfcda65c4457a8df8b2f43c1c582c219303942a4aac78b30bfb8e8126ac992289213bd9781fcf02b4312293d9a570584835f24f11c3e93bc787d25853ab097d8b9c47dcfaf8e8490e94679f7d446b51675df22e0eece3b11e7358a5f75de02e3c07eb4f2bf2a47e1d0d61dedf49129f5900bc06ac6c1eb1adcfeea3353402c4b364a68aaa76824c75544b4d05cbc037d09f3c78c1ee97765e03d524ad9d978ec6affc06976e3eeb4c6212b624e005787269102c64d88c5c4adea16c76aa7e43d3a0ae4497e4ce234a42d8673a5c2f316036fe05b25a399963190a8f5a1df69a9fa15f2c3d8dedbafa2d5eea97e34a422dc89dd314f6740f0599a3b5b07a2f25181b04c90671fa77936ec824afefed8aa7e18f911a39209d1f12713e3f13c9692b4a6431552f0eca7570ca8ca86e5ae10ee25364d7e37a404292ec7cad46da2569322ad69326ee2b95a463448c8627efd761d0b9651ff010c8c59e2d1a1e56a4f1e537e1646376d6086901757f2192bee157c2b4b2295ef6d3a80eb0abb589df4e8aab67e708a2045cd6833b58e44a29bea7ba7ce276f19aff6b4e628d2b1cfc803945b9c924ac32ca207b0ad41c6dc43b68226f173c7062620235ef85fc5115986359249482920d45383929ead07a57026377712182c5fab77059a2501cdb6f0737f565101643106eba709a1493e8f62e3b34e96a2120f5dda493dc326136093b8a9e60b0db30a597127290724a7484f3d9cba1d4d6c9208044b05918a6c00fedc665d869dd2a2960249b0547e8ecfcd6eace332443df3c52ee3d4b43f52645545dfb7008e3c7c2789659c66e663f95fdd7654d509438c03740b258f51cb9ce84becec78cd0e9d1e139baca72ac3bac605623087704b76a462e25469511de18e131bbccfda6e6e36f6878aa3e0c3d5272c78bb73db60494af90341867cdf436471973cc56b3b8d0b5697e0e5a1645c75346f578b6a00c3110bae46931adf63c3e59f7919d109d1cf7b336462139757efec0e6ef77a47d0427b588c155eb4894b9519f15dd962fefd8bfc1ec45b5762f94518b195d18c960ea65488493e2ac4a3c688e4c3fe81270fef62ecfe13591dffd4b5e6daa81c17869de93edd89f631e1fcc56f4921891af9bb696ad9ba1acf5728e1c811c5a44f5f291ffca3859a6531ea739efb8a5dd509363dd323a7b6179705c124e0ada322a76e76cb9eee6c8784a4b98c68d0512ac561e40b5abbd40d4a726e54e15ec449ae527d295bfd8dff3b2d6d35221a16ba9ced8c452ddb21f4a5a78549fddd96f93a2d1d142aaad5f20d285401857399dba65f3b007fa7b2a6f2a6daa05ed1b82d1b21c869c35ab5cf0891a016bd324ece83ab9410420caeebd043ee1ef4e649728b408109db9bd54d2231533a64c39872d65335e0197f320a4180c7e302da2572856727b7504f93373caebd8cd3d342d88489ed711cc01cca7519a30d6d32caa205ff335ab32520aea6c1a0b3f1adb4e78e51bb7581edb988026c70f0c313fd76aa72a193b2a3c8d22c4207ab938b0dc3d524c14ab10c75c1429ce0d8fbb19268c2f0f8456f75c17e13318bb1ef8333f88831d66af1616279983c0b697b74ef2e56aceab3bc5993aff9469ba5283be7f8b300f4f25fc200795985b2858b4f1a4383cb9930acdc447b1934164c8cc18d2b4664de1485974b65248154ab061ab72bbbec721313e2bdbc935cb55e02ff7732a48f4b94de53fb51c1d56f2d0ab019170ebf19a5fd07066a97ed6d98bd4f5d7ffff779f71ddef3d3b3263d1c672049c57435974f6e1fba158d8b582af7ed7a9f71c073beacf192cdc8e979d372f77b235491deceda4777fc49766a1d9d1a9688e9939253801d195ba346042ec979f7f1aecbf907946bb98bfaf9747f5aa720edcf0ba8763fd19adca18a92607d65eb4765d6018f1d4442f80f7cbf6761dd11bd3d5c20b0269834e94ca6ad7351f83a55e3f55e49047d5a77313b146eea8f3cd728083cc33a440683d82787d677d1a1f7feb877db775685337aa7c0eea295db506b1b0b576c65a102a8cafcfa6efea1dbcc1646e055d2149689d1517b2e7677d0cdbe328306205ab41e38803dfdb449497bf525ac56e520dac912948953749636f33c30fe1977b1785dd1fd1e947cb95990f1ecbd2f2a01a724a689a06b47a51e1831368fe8c296b21df39bcd1ad8383234d7bb23b721a7856f82547f218bea9839c88c8ac628a1f84f20941f4bbaeeb15416794af364f4acf6d4a0b3f1023842112b00d936ae1725b1b87d1ad1d15595db18d79a92cbfc10faa2bb1d65dd5285162c122d7f96cbe075c066de3e1132241baad7490ac51de8e663205e18f2dc140bbfa9d8aeb7dacfc8070cb534b3144287a5180919012814aa6c53ac887760e8f88b74e24c1fb866eec5d580a9a170a3954688dca6c6f483324adad5b8a1c4184d7dfe90332beea8534571d2cf3ebf575775ddc3ce2481458e65459d106ba9a3d9a5ebb97e2d2843736a865674b03c7f230439e58b6e634e3b5092b83baa3f6a8d079ba63b20285bef9ce00fa3c2241e900d2bd78a12db712017ddf7cc67ee5c92f5748900dfca330368aec699e40ba8d3e6d39bd5b7ca065cec2faeb1edcee7ad6cb49d7f4015ebadf38348e4d17e51b662cf714c8c55f376bb2b8d7e61ba8b7bd470b3d3e3d8ee157b10d778a1adda7ee2ab119020022be15accafc40151923b5035bb5867d366f4f77a751402b543534068a4383ff443626024edabfd955b5abb68cdacca390f66753c07533d1afecbdde18333ed358ea6a02ea74b89ea67812fcf2d99e238d44f8203dc33e7f5d1703e4704d59633bbe4185647649f27d8d88ea0a4d15b29283130bffa535a23b81d1cc276a4dc12cec535ea5f2d03c122ae64100fc1ad2b8cc470bbc220961e199c63dde2960c8c1c334fdbb1b3ee3721471071e9dbca9d584b426a2f05c9750055dbf53f76fa3f6bcf69f3b452841aae1b76485474fb719eb1f2cd5334577a14f750265e222adda0e7aa6825a1e94c50954666063c1d88459d0d29efa5d6104b6304e69c7470aed416b7504996ae75b49d682b1564a7df9b7128d3920a327050955202ae3d2067665bc1be2d5b690430bad7a33d40316605fa62164634e708ec2b29ff73da536f8698174d55bdb7eb12f01c6626eaab3b5a916c63e57e555e736a6953b8f77ed7559a8ed601549b987aea511704ded4e2a99eb9e3979630def072b792cfc5aa45e5a7986a2b7606e890c73e9a812557ec29a9f44302777624fbb7108ab58ae1a1ed5ccf3c377e11e1e9bb1ddcd72ab4b82a4adcd6d4b934a86aa7851dee9152b7e1cf03bacdc151b13064f4edf3d173d8cbb11691e4f68fd6089b786e89112da11345dbc049f5f434f1474bd1c095640ec9f906b03ed55b5fa8dc5e8d24941c079ec2946298b278fc5dfd08f27612503ae86f7ec3909f6f445ee1e7c2d680923d3e9aed6d0e6441fa3456b9a1d33683b2d5befd477f9ecad4d9eebdec7b6d33920d3d7812b39e41e147b18cfc59f3d2ae6b92f7baba1f7ac9bf27065b65c8c350e1954608a71818ea5b5d7f2ee175b200a3803bbd409c8409e356dd91e50d3a24c3f21f3a52d784c67ab681df9fad016c4525f50779626a526989e3efb8d3e6d1553e058455fcfac0d202d3be3e9537550fd659f4ee7c5c7fe4d5d4750ddc406d7247b12ce922eae724fcabd4147fb1b9ea47524173a0228a7cb1234d877103135a4c0e556ba0a5184f5606698cc721c6ec572a883cef6d60d35199991119ff46c8a54406d7c963d48fc87a78dd2c4747eefb2a1de7aae88ff5c02e3f0f09a7f6e5cdd70be68550b8353e71b15c987240a2045d050cab7749202e8c696406ae9f1e3359e2c5bbcefbd52b3979faf46323eca65d789c9826c9277181de590c8cde4f5f1bfc4e040e61aefacb47a66ba70464223180ab25381ba59f14d508eaa0672f164501f0bd7d0942b510332cd8339daaca5490982cfe5504c2007bfd1069ddca4ff25eb088b6f031fd3851714f62ee8929aac7a853903213c061b543893e156e73984abc407c845bfdcd1b11402426a745a1915c1256d42856c37d6cdf20c9bc8ac7c6d7d2225b1e657cf67615cfd4b707339ecea092fe5e7a08d6cc6021c719a85f8d9eb3bb9797eccfe7841f67cb6c204552654c90ac6f9b4e8f5886ceafde59a539ecfbb976c9c897f62dec9cfd3499271a8837c110d338d3ef4fefa80f1db6e9f43c209c3157fe25af90df1a5df80306a32f471b428f6268e5433f00eddad396a29cd29e1cf0fc83ca93e52fbe813ac98f547b79cfadf861ec30266c11c8441a99bbfb412623909511f3f0fcff216d0bf7a3c6ab926ce4266495767754c659c0e3ba2a37d8f1dec87bbf01ad740699958cbfb0324845632559c50bf8ae7cc0a934c0c463534805a68211089fbdff78b398a3e617adc65f07576d41d869c0bab213e0dfc699d2d828a6da8d4c284daf6918d0d7a052a5ca30074c26b2a2c13ee76fed2228f57c7f458aad380152a0573262c35a002d1efaa630544e1451257cc6167dc863a2a143891d6d47fd0</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公开信-给YT的回信</title>
      <link href="/2019/03/03/essay/letter/%E5%85%AC%E5%BC%80%E4%BF%A1_%E7%BB%99Yuting%E7%9A%84%E5%9B%9E%E4%BF%A1/"/>
      <url>/2019/03/03/essay/letter/%E5%85%AC%E5%BC%80%E4%BF%A1_%E7%BB%99Yuting%E7%9A%84%E5%9B%9E%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-CTuxmqSO" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1422978054" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>YT，</p><p>　　至于怎么称呼，居然想了好一阵子。希望这样叫不会显得尴尬？算起来，好久不见了。上一封信遗失了真是遗憾，推荐书和音乐这些只能期待有可能出现的这封信的回信了。剪纸也就没有办法了。事情是因为残缺才富有诗意的嘛，不过这也是我喜欢信这种交流方式的原因。如果是邮递的信，这种意味也就更重了一些吧。那种发出去就可能杳无音讯的东西，真是蛮有意思的，这也是信的命运吧。</p><p>　　其他的事情暂时先撂着，我尝试一下回答那三个问题吧。初次看到三个问题，以为第一个是最难的，但仔细想想是最后那一个，也不存在什么隐私之类的事啦。那我就尝试从这个最难的问题开始解决吧。</p><p>　　之所以说这个问题比较难，是觉得几个形容词两个形容词离我蛮遥远的。我查了一下“懊恼”的定义：“因委屈或愧悔而心里不自在。”给的例句是“即使被别人误解，他也并不懊恼”。遗憾的意思我倒是知道。但是这个最字就很难了。说我是一个沉闷的人倒是可以，但是这两种感情似乎离我很是遥远。怎么说呢，感觉，如果什么事情发生了，我也难得激起这样子的想法。委屈我是很难感到的，似乎也没碰到什么让我委屈的事，或者说我心大吧？至于愧悔，这个事情就更少见了。我很少后悔什么事情。至于后悔就是觉得当初应该做什么而不应该做什么之类云云，可能一瞬间会有这样的想法，但是很快就消失掉了。正如小径分岔的花园，一条道路在某个地方分叉，便构成了一个新的世界。我选择了其中一个，也就这样成为了自身；另一条道路上的怕不是我吧。所以这样子的心态让我不太产生后悔这种情绪；同时我也接受缺陷之类不完满的因素。所以遗憾的心情若要产生便更是困难了。倘若用时下流行的话来说的话，差不多就是“佛系”了吧。但是又很奇怪的，我自以为自己是一个看起来大大落落，但是还算敏感的人，不应该没有这些细微稠密的情感才是。但在仔细的思索之后，我觉得没有什么。</p><p>　　但这样子也未免会让现在的读者感到索然无味。所以说一个可能和这种心情有关系的事情吧，然而我也早就释怀了。即使曾经有过可能类似的感情，现在或也早已不在了。</p><p>　　是初中和高中时候的事。我小学六年级和中学时代都是在一个成都的私立学校里度过的，这个学校在当地挺有名的，也有很高的直升率。所以从小学一直到高中都在这个学校就读并不是什么奇怪的事。于是在这个阶段里我有很多七八年的朋友或者同学，但是在直升的过程中也会存在之前的好友分到同一个学校两个班的情况。虽然叫很多情况来说已经再好不过了，但总是叫人遗憾。于是你或许大概知道我要说什么样的故事了，但是为了避免感到无聊，请先打消自己的猜想吧。</p><p>　　其实上面的背景并没有描述完。这里再补充一些东西。我中学时代在的学校一直都有精品班这种东西，即使小学也是。我当时是小学五年级稀里糊涂地通过笔试（这是另一个诡异的事了）进入这个学校，然后进入了初中部的两个精品班中的一个。时间很快到初三了，这个时候也是决定直升的时候了。然而高中很特殊的是，他的两个精品班是两个等级，分为更优秀的和一般优秀的。既然这样说了，这个故事就更平常不过了。</p><p>　　下面可以开始正是讲这个事情了。当然是说关于我和我的好朋友的事。下面以 L 君代替他的名字吧。我们是从小学六年级开始做同学的，初中也是一个班。怎么说呢。我是那种不太外向的人，平时也喜欢孤零零的做事情（直到现在也是）。加上初中学校实行的是住宿制，然而我是走读的。所以从哪个角度都是和同学关系更疏远一点的那种，于是很容易想见我并没有太多的交心的朋友。L 君是其中的一位。前面的事情就不多说了，总之我一直感到很幸运能有 L 君这样子的朋友。非要说的话，其实已经结拜兄弟了……总之这之前的事情琐琐碎碎，就跳过吧。</p><p>　　虽然我初中很划水（我一直属于很划水的那种），但还是勉强又可以进入更好的精品班的资格。遗憾的是 L 君没有。然后，当时我说服了我的父母，我的班主任和年级组长，选择放弃进入最好的那个班的资格进入后面那个。每一个年级一共有一百来个人直升，这么多年来也没有人这样子干过。我很难说是不是因为 L 君的缘故，但是坦白来说，极大程度是因为这个。对于我这样的人，能找到一个朋友是很难的。所以这一番努力之后，也就能继续和 L 君做同学了。后来高中快要开学了，然后军训、开学。拉拉杂杂一堆。当我走到我的新教室的时候，我的初中同学及高中同学告诉我，因为我选择退出最优班，以及两三个直升的同学违背直升协议去了期中，于是通过最后在直升期间内的先导课的结业考试中的三个优秀同学升入其中。他告诉我那场考试我是考的最好的，但是我自己选择退出了，所以并没有通知我。然后我就知道了，L 君进入了最优班。这个时候，我正好看到了他，确认了这个事情。他大概给我解释了为什么没和我说这个事，然后抱歉地笑了笑。</p><p>　　事情就是这么诡异，可能其他人看来这巧合也过分了点。所以自然而然的这里会产生这个故事中应当会出现的后悔的倾向，也是我讲这个故事的原因。在那很久之后，我都觉得很难受。倒不是因为他去了另一个班，而是我在这一个班。我为他能去哪一个班而感到高兴，他可以有更多优秀的同学、获得学校更多的帮助，是真心的高兴。同时觉得自己如果当时什么也不做就好了，这样还能继续是同学。于是这样，在高一上的时间内，因为不在一个班，寝室也不在一层楼，平时难得见到面，也就上操之类的能打个照面。于是当我在为高一艺术节写班级节目的话剧剧本的时候，不免觉得遗憾。这种心情真是难以描述、更难以消解。这种心情持续了一个学期，他是知道的，但也没有说什么。</p><p>　　然后到下半学期的时候，我们高中有一个类似于团队建设的大型活动，有一个下午是户外活动。那个时候是夏天，最后是那个翻墙的活动。就是一些人作为支柱把另一些人托上高墙然后再上墙之类的。我想你也玩过。当时我们分到了一个组里面，但也没有说什么，就是坐在一起看其他人四处跑啊跳啊。然后我们就在那坐了很大一阵子。后来爬墙开始了……最后我找到 L 君的时候，白体恤上就全是泥巴脚印子了。然后紧接着的校运动会，L 君是学生会的人，自然要负责纪律啊什么东西。然后我在学校里瞎溜达，去了趟小卖部买了瓶水给他。</p><p>　　后来我大概就知道了。这件事情没有什么好遗憾的，我想。或许正是因为当时我选择下降，才会有上升的机会。我想这样子也就够了。我是一个阴沉的人，平时就喜欢翻翻杂书，周末也不会有什么交际，思想也总是混乱消极的很；然而 L 君是一个完全不一样的人，很积极、主动，在同学间也很受欢迎。我想，这样也就够了。他是一个很有意思的人，我觉得，这个机会给他比握在手里更好一点。当然，这也是瞎想，可能不论我是不是做了那个决定，他都会上升一级。但是并没有什么遗憾的，我有着一个朋友，突然自己觉得非常难受的时候可以倾诉，可以站在那里一言不发的听着自己的抱怨，或者听我平时的漫无边际的空话，我觉得已经很好了。这样看来，我稍稍远一点，他会有机会结交更多的人、认识更多的朋友、看见更多的世界。后来我甚至有点庆幸发生了这样子的事情，虽然我并没有觉得自己发挥了什么作用。但是看见他后来过得很好，我也就释怀了。</p><p>　　再后来，高一下分文理，于是又有了一次调整班级的机会。当时我的成绩出奇的好，于是没什么疑问的可以到 L 君的班级。我的班主任希望我过去，他觉得我可能在那边可能会有更好地发挥。我后来还是放弃了，呆在了原来的班级，我觉得这样就可以了。后来又陆陆续续发生了不少有意思的事情，但是整个故事差不多交代清楚了。至于我中间的心情变化，是很难用形容词之类的描述的。如果希望更真切地知道我当时的想法的话，或许可以在这些句子的构造，以及叙事的节奏里略知一二吧。所以我的懊恼就是这样，无来由的生出又消失，最后甚至这样子很完满。所以所谓这种感情，我怕我是真难得体会一次了。我自以为这一个问题我是回答了。</p><p>　　然后我试一下回答第二个吧。这个答案就相对随意了，因为我的答案自身就是随意的。这里重述一下前提是不考虑生计问题，也就是也足量但不保证丰裕的资金，我是这样理解的。如果让我选的话，如果假设我有那么一点点文学或者音乐的才能的话，我想做一个流浪歌手在各地走走。就是到处走走，先把中国走一遍，走累了就在就近的城市歇一歇，看看当地的博物馆、非遗什么的，就一间小旅馆里面写写歌，作作诗，最好的话是有个能力写一个长篇小说。然后思考一些无关紧要的琐碎问题，学习我感兴趣的科目和知识。如果在一个地方呆的厌烦了，就继续走。中国走完了就沿着中东的方向往西走，去一趟埃及，然后往上走去欧洲。把欧洲差不多都走一圈，走累的就找个民俗呆着，继续写诗写小说，学习以及游览。北欧这些地方我要多呆一会，看看北极光什么的。然后继续到处走。</p><p>　　如果能活得久一些，就走完了全球还能勉强回到中国，我差不多也就累了，就去云南贵州四川交界的那个泸沽湖里呆着看日出日落，写写旅行记录以及回忆录，把自己所见所闻都写下来。偶尔去其他城市拜会拜会老朋友。然后等待那个时刻的到来就可以了。</p><p>　　这样看来这个答案是够自私了，我没有提到自己的父母、妻儿家庭、朋友和社会事业什么的。我想平时回家看看，在家里带一些时日就可以了。家庭的话我并不想考虑，这并不是我理想生活的一部分，我是个浪荡的人，并不想连累其他的人过上这种漂泊的生活，并且我是一个习惯自由的人——看起来很是一个没责任心的人说的话了。以及朋友，或许我有提到，既然是旅行，到一个地方就拜访当地的朋友。当然并不会又很多。社会事业？这是一个很难的问题了。它本就与漂泊的方式格格不入。如果存在那么个清闲一点的工作，比如一年都某个高校里呆个三四个月讲讲课，然后其他时候就自由地到处走走、学习自己想学的东西，这样最好不过了，不过难得有这样的机会吧。如果以什么责任心或者别的来指责我，我也是会心虚的。因为在这种生活里，责任心没有什么容身之地，我也觉得苦恼。</p><p>　　这样，我觉得我的第二个问题也回答了，虽然觉得可能自己回答的不是你想听的内容？但是我尽力表达了自己的意思。倘若为这个选择遗憾的话，我也觉得遗憾，但人生就是一个稍纵即逝的东西。有形的事物终将凋亡。</p><p>　　然后我来回答一下第一个问题吧。猎人、农夫、铁匠、木匠、神职人员、外科医生、天体物理学家、小说家、桥梁工程师、幼儿园老师。这个是没有采用先后的，如果要排个先后的话，估计是农夫和猎人占首，神职人员和天体物理学家，然后是幼儿园教师和小说家，其馀的话看着办吧。总之既然有十个席位，那谁先谁后就不重要了。至于原因，相当主观了。不过既然是个问题，也许可以对人的性格分个类吧？或者判断一个人的决策能力？我还是大致说一下自己的原因吧：农夫和猎人，满足或是需要，并且这两个的新环境生存能力很强，适合开荒；然后是神职人员使留下的人保有生存的希望，科学家尽量留存人类世界遗留的智慧；幼儿园老师和小说家担当教育的职责。其馀的就是保证可以有屋子住，可以有好的工具使用，可以排除简单的病痛。这样就足够了。至于其他没有上榜的人，原因不一一赘述了。至此我认为这三个问题算是解决掉了。至于你是否满意，我就并不清楚了，我尽量保持真诚就可以了。</p><p>　　然后猜想着你的上一封信是有书籍推荐之类的东西。我试着也推荐一些吧，可惜最近读的书是真不多，而且很多还不令人感到满意。可能之后都会这样了，毕竟也越来越忙了。这里我还是推荐一点吧。《荒原狼》，虽然感觉你很可能读过，我还是列在了这里，对它有一种特殊的感情。也许是代入感？如果没有读过的话，请试一下吧，应当是不会失望的。音乐的话，我并不是太敢使用这种形式推荐出去。说实话，我平时惯于听的音乐都不太开朗，阴郁的小调占了大部分。欢腾的曲子也莫过于贝九了。所以我试着在这里不推荐古典乐，先推荐一个《归乡》吧。本来是火影的一个配乐，高梨康治谱曲，不太好描述，可能听了就知道了？本来不是个看动漫的人，但是火影是个例外。很难说明原因，都看了多少遍了。总觉得有一些特殊的情愫吧。虽然我没听什么歌，还是推荐一点点吧？David Bowie 的<em>Five Years</em>， Ashram 的 For My Sun 以及 Tamino 的 Habibi。这样子，你估计就知道我平时听音乐的风格了吧？</p><p>　　然后，说起这个，现在也可以反问你我这里回答的第一个（懊恼）和第二个问题（没有生存压力）啦。我也有那么一些兴趣吧。至于第三个，你肯定正经地想过了，所以我得换一个。所以，既然我这里讲了一些关于我的朋友的事，请你也稍微说一说你的朋友吧？如果可以的话？</p><p>　　最后的遗憾是不知道你的上一封信里写了一些什么。我是挺想知道的，这样子我的回信里也可以有一些评述。可惜遗失掉了。现在希望的是这一封就不要遗失吧？最后愿笃志，找到自己的那本书。这次，就这样吧。</p><p>　　顺颂清安</p><p>　　廙水</p><p>作于 2019 年 3 月 3 日。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给三弟的信</title>
      <link href="/2019/02/26/essay/letter/%E7%BB%99%E4%B8%89%E5%BC%9F%E7%9A%84%E5%8E%BB%E4%BF%A1/"/>
      <url>/2019/02/26/essay/letter/%E7%BB%99%E4%B8%89%E5%BC%9F%E7%9A%84%E5%8E%BB%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">Sorry, password needed.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="72fff1012231b5871b6b561f6493b5824eadb42119e5cc17f318f25ad12eb99e">8144f56efd693c6b52f918ba14052d30e187e09e1796f5d24845830e100d850e813284e1e4f27fb7a17b520000639e3fe11260150f738dafa19c2a484a6093b37cb2e03c1826502862a66bed0f8b3f8c49d5e2f86b9b0cddb25ea358b848b5ad4df97aed595cc703b1b26db84ad561fd6013d587f975a7437844a6b3ed3d784f3c434c51b15031f7e1e5c26d8592d9452583f942a2927354ca805f30ca9f364fc6a0b8bd7118c02302471b51b3d527f623d67b8c32f5b5aed541dcefa36082e1b5ff2bd97770da695839dc0b122fa11503829790d752a69afe306c172192013ff7d42a6658b996b05ffdca27375a89eb7bff2147121c3c70af040adc69e6404e76ba1e4d147205406f9a76389fbfd1cddec5d6f5c74415fa92cfbe653e99594eb480798a30dcfd3a59fddcbf9030fc675977a60e087eb93792cc92052ea47a9535e0b9a0904518f3ea993d9f9cbaed842db5687734177b4a65ad814b8d34f420929a00013ec8a8e192d237f650557559427b42663cc0c767be55297da79253dedf25984ef14d42a6050b59ff63e537ee132e21ea63930ad5b2b6eafae608a3ee72c4e376b1232502380d0cce3f4de6cf5c16483cb17f2b001c013926638db3c0022655fa1ebb8a1772b961bfa423a65772e66530d43490a3e484e1035b4622347065f2012b2358a18d08271f781a76ff2a03b3dbdfa23ecded659cfbb2e7d8582e05de9da19d4e9a2b6b79c5baaa04a59a3711b6d50a63fd91bea23a3804bd434d654dc36b1cb6f6969917c5761802fb3922748cba4e0777a37ea6dc676e895cda4d16338a558e9df691fd14e970a2106e5fcde97e8b52e5bc2a2d33559642143263d4edb1c3fb34d87cd7d0bdf28e44ec972f1d551e49e0c4d2b337155dd5293ebea1057df285dfda2ea448efd85b121b20083878afa5cadd0b7d7a02c32c92fdc0c1a75f4ce8ee521d39309b3845e02efdbfc43e6cf9bb094e355b7236144c3e64d20dc91edc70f317e2c23f822ad2ae4b037f736ca4ccb7c7b7286cb086a633111fc238c84880163f34215f820d91d39226108134b5920f6ba6fc589f3aec8f2339b1bba540755004c488ccea1939ea36f713322a3970726ee99967ecf3748ce86851405480ebb4a0249f2533bb883417a64a9a81ef6002122820948582311c1b2378b0f33d07a5f694409447636c16ee4f40699b39b4a64563c9f862431f9c4a9ffe059a7086e93e663ba885b2b8c4b7996d48ebc406d8cad458d953bdb9ac5123b0d84aae5e0d6d649814ff737e9c20ac9c2cad4f2782b778d6ce62e9cb0402c4e15addc505b8f0c46c949cd4e931a7e49fa7056c53d535c7d148359685e8326ae010f66c5292a2d5298a55d8e05434187e70d3922dae120db5ab9ab605b07f425891100e2f01c121b92a2681a47e94bc9f320e3d6c19a14df8b990192689d0944ba60809f9f7eeef8ffd381b7db399ffa61673fffadf4d0957717c89e980e102f091e4665ceec899c4c304ae0f67875387b4e5d0e522d6fd771f0b9e25f83fd72993f34b6cad8891c492a740cb4f0c57d61c85dc53553359a21cc599ce3490fca5b312ca3af150619ebcb96908bf629056ff56a860ee548af60c12ed4e002d0ae5e98351f0ff41fbd28a4bd4f085c6a90acf20f4dc17f15f12bb9a3eccba5f92e718370f3a6e9ef7b423605eca17b744a6aa8f728a5063725a4bb5da71b4cd35b60c01f2d8ce3200ac4526977d455e9d99c904b32f4861883652e95b6a29493f0782641077e49ddd907cc7bde64d68ee0e7eac560cd0c0b5a9f36ea26a10993837eca2031bfc518b4b17230f59508a91eae6c48f24cab30386dcdd98f7ec81270840b2805f35e006b1a6b10a6831dde46aabdc060a6138b147a87f80d137b1dcafc8afba3b20a8fb2111c0a31a55f03efc9e3f3da9bb1c6f22f47d3a7055d64478722cbf5724515eeae6728e84c65883c5349172c9c71726b400e1e4ddb27b95ab3e3a63386ef4969d472cec8bba05c923721a1b39985dbc380abd6ffe3381c722b15caf58ce6b4830330c2e87a69e00dfccc9e8bf9283b28fc5c0a7fc54eff56a79dd59d8d50bbad1388a698e790e7635b096c650069b1baf2160ae26d0e963d2a6876063e5eea349910b80e35ce088fe370e0673618cb5292e5854cb6e181d82d2f61862c9a79b6e75e440fb984c3d69cb3b9dec7afc6593cc12dc1303f0f03e77496050ed06752c16fbc33fd2059ae0e4b4b4eff4dcb02586ac97184c675223f2c273e89674890368e27fe6e9f5f9503f627fa0098fd0de506efaf4498b154c0742fc2acb8da931828c56283dce3980b8d2782153c9c19e9b60fbad4d00de7b654698df8062b6d50b13d1eca2573061cd77d1e582099f713db62d0875cbd20a9c885bbb3577911df7c5adf393ff8ca7846175ef99e0341c7301b51bd5d0c70833cce7fa5e908b1b28bd14dd3eba0d7c190b97ca78377d88e42440fcf742d7bbd2763565a34c22db5c021e0e0e7c4f17b9bfac0fb3e3a454d2348ee61417a337aa4c1e899cd602bfa0b5214f8dcb3fd26b42cd298b535347823da28c06b580b1064921abafee32f4465b8a2ab864d3fe8aa48040e13fc58f853275ac9326b2d0916a5928e97def1805ed14d465165a5f2ef853bd477440b41df63f0cc6528687f1db0e115ff5cea27f71bc09dbac26655732272a7e6688c18c7063b774a08933193f3b693c5f7846ee5ebf6c5d37284c99e582d1f28cc694852eb4d1fcdf197cb0ccb8cee63e09d6f38b7c9123f3a863c827c2ee91f88959f51f91f4770f983dd2904708045bed05d5313deed0889f392c0995e884704a030f4bf8a84859a78711882cfdbeb2cb15ae88894c51f3ec4eb52e0cc39286468a22c02198df8f02d7b5d772eb34edfb4aa08653be3619adff1e3f97bf67b5cce38f8aa2bf10eea4f1bd0468f792134661908c3555292c4c54d83eec740978ed5697b183801e0a352afaf3e0a978440f010b39602a055d2085c2718dd6458b50ae5803120d81fb5ff084e9f5bc0af001c6ec1316047a3fd14da3d705023072527cc283e6fb8dc64bd2479310aa989304ddc09a8776d754e1e824e233c9fb1a8cbf7ea31d6ddac6e0c3b261c29b7ec5f47055b3755ae11c01a56e4f60a8da497bff1da73972da9f9f49bdbc372812b36f88417ac9eb3980ba9da70ca3136a6e1d2ddcfa9d2c63f7fdc2cdcb3f3a7109895fe219c0b9c24a63c8f38730d3036ccb2482b3ac55ed2258b644e0ea3bfa4265dc805a02b7a106c3f97c750126fec858da6eb9cc92e6ebd1e9182247806ac9bce701bc74dbaf6993c7c6f429531a48ec69295cd87a14d95f059931d778eb3d483d1a11898e9e723e9badbe56cef843d0f242722d10f75123c379716d3f7a719e3ae924dc4781126095d537849f141300674f2c6b9a252f2865d6f63b2b37f393eeebbe773b285804276e65299345779066b60352ec21dea66b7569db01a07916575190f46afc98d2007e8d7dbd5395d7ed30cd8db6d6570b91cecd11f70619fe284166bf08689eb088993fc4d9d2f049110c08568c90c413f369a079029504787fdb395336f615d21dc16649224d7182232deb8bc085e765b2fcec05a2528cb996c9a642102efd8e353bc946ad5e9087d022c1035b5cf5ded739809b2f2dec84d0cadd110da7f10af46fa44619e2c07ef95bb9aba2040f26d48259302514ecf52340bad346956785ee6af96618e2c7cdfacd89dc3017c35c0b7556330d7e68e0930e9abf428764877fc33a4561dc28595dc8363408cefc13c9b48d426ee8249551663bfea11828d44c7db529e965481972119460ea143f0ed93f2b3d164120b0cbddfa0b964e5a6cfbdf0b9e22eed7f736e7ad19366afe8f5cadbcbfadcf2e9a5847ed4b52af3466eefd419db30667fd87a82fe411c7fa2a58be42eee3818bc402b2c37ea0be29e680d09834d7943d8de6875b57b178c9f961e4db9094d19eeb27102344a1e17a76f1e8eae1599a5704f1ea015fb7cac628206abc3deeff2a57a2aa20cf6b407b6b4b04d09f3f848af0605fb047997a1ca5a6848c6ad37670e16520dbe17ec5b313ff3c631f0c1a50104501bc954e2930ded98086a09aa29b418631b42ee3d860b41355a24e8feb73ae674090d04b4f6313c31e9248458a2941dfc2715d000b9b406f4b9c75ad2e64b6452a1de572d6609204087a55be519ff3d5d1e4ba3ef47e9b504689876b56259e4f9a74a2141a86592ab091534ba7817e2fe60cab840e024f57d1d8660605eab9e0f460e2321844ef00990f309f9791494893727af9e161c557ef9c58e7095f2f585dd90dc7770e33164fc65f5308b0ec1dd638fac80b756e41c083f093713b3f5b8e3f1874b687d13d7c2737719655077828485bee15fe1773deac4f767b05487a896c3b9c414850bcd3488dd8cdd1ecab442c4f069cba3a86d1db71dc161764546510d1bc997355449b939e9fac808ff0959044665699908cf1888672c369c022409940cf540dc17fd28158a03d9a79b9be637de192f42e59293f9243b3614bee58c10d290766d08d0a5376c90d30089afdc540320e5b3dceb1473602ee53157dba8f1ce5ee66de54b4970b7eac1940b92ca143a5a02bafba9297f4c0c04912d6a202be56e5328025ee8813b3af5ae00765c53b217d4dcaacaa8f239419f26c4410152ea9a5b2caf3edeb5eb5f462a462c36d430cd5056bd35116986888d67359d8b9b18eaf5993fb02d893d02828dae7594d16f1496f123b599b2c1bf5e35723341d04230b9ac8a3e826448ff38465f38186030bd4b40131230e3a31571841af988fab5dc6f934b52101471f4b68d4a0b95e5887ccac64eca63c7e7e5d39f12dc47c0dc70dfa46a072e9024c20e89da4fed4a6180cfa301f1f34794ed662c09e106ad4ccdd20ce29e762b87cefc7a2393ae6ecce17cc07d083e8472ec159a2edf1a1b4946907599e832871663b57ba998bac33c9428542afd6c68c4e9ce0ab7cbc010faa50e2f438fda3068e8bce228285ebbcb45548242be301a8ba277eac6867b4d98d8ece9d2437fc738ab43371aae345b7123eea1264ab11dd0ebf5e69b64a6b033a782b0969aad248ab41abb0465902b667110bc7a1fea17147dc0699e0c501dfc015721bf7fd0c7cb54335992f69a0062908482c1630da7118dcbb6697025b913997a2dc9118e4aacbd61b6a1a8257897e7abade21aa911a66a2b9afbdbf340f9d6d9939862cbb199299df4aec5fb52b56ac40c645513e455e633218ed3e3ed1afa5057952cae0a6df1a6821f8c865607802b18abc06b78cd9fc560a4bfb150dc1ca75cd8e389c25ed1010cce64e04a82adf56a94ba8da76bda18e18faf5b32b16758ee97ddbcf3696fd6f01e042c16d7e9510417532f1c5bc19d21f3bbab9bad37b38c8e445bdeb8794ca63029ee1f6ba7fe56302702701343a1029a757bd57432065f16e6543e9b4d313adbbab4ca5edba8d2b69c0a0075cc247b0cbd20cb98bc69e7f9b3c3b7c717d2f2f5dad2811419aa0336224361aece6f1e031296f8e654d7210d5b9ba3535db58e8b9049a962d200005929e9c64cf8410e448b8c596b00ae92d3be12badcd1b3471b7eec4e0f7b6b445c26a02649ff61070a231aea90b0650715d543be4e8797b8a5a93661662e7becd0226154d86b4cfe1e88dcd0d231a672675157e59ba7f6fdfbf3d41eeed0362f2e2f1e079818b00db33708fa16f1fc5c59b630686165a9d1d7f29b0280e6d68b4c44ebf0ef89f80bada80f25b6f86f483fdcdbaa830372780b42b454776dd58bf6de8a65b38c8365485d163fd5a3c78f16e46f8d9bb9f002d25e2f3e677cd4bc1e7e4b6111c27d28c331e1771164583f13e1582e3c5b9fe684c9196b254b68dd4ea9ac7bb6933f195f227aa451ab7f0cc10ed97a4916a55a4cb22ee8bf733c80ef3ab6d7d69ec1b8350183ce127901d4541cb80b4990042a48be648a32aff01875e4dc8ca1180967788fba407852ae690c6d192aa672d7f93fbc9470f55ce0b526cf04b3ddb7a37624de08347f762679e21e9cfa42cf53d86ae230c7525ff8dedfa372aa626b76d05926441a70eada8491959f98bc571010b8046d1325f384f3a6e08b9e4d100e05bd4f6f676c8d5e6f2fe072ff415e497c41c590ca1fe409123f09bd811d405453294ee5ab98a7249eeece58cbf5d38d9008d82062ffd441f4df3a576b4a04f9928da35ea0d191e5b623c70dcffd2dcfd688f3ccb08bb996aa85265d084fe360b05388f715426c5ca3ad41bacebbed86e659aa4539a368b9fc4e13de4d6631840e98fa841d5eb84649a1bd6c427e1af22a494811338bcd578ebb08ed725bdf31cb53f349e5ea7b0c9ceec8a7b8712f3e9b75bdc15bc7a04c6cc046d1a03829372c19641728229fe4326b71dc08c3facfd8c2e08cfe8bf5071cfc60717cc2a93c69ceebdb4d805ca37b26e023e6cf58caa227dcd4c53beed4d9524d159e5be8737d9611977fd739768a7a21b4ea279d68f944e79207786300991faa4a5b7f793dea1f3b46d917731251c34965796c37e56e7f74df72405eb47b8ab481fb944e7dfaf5e630c56e180b9756c9d4cfc8c9461be595df153ffcc78f1f7f3772e79a406891e1d66a7dfce7e0ec748ac05c8f03961e7c184f35fe4ee36f81b08e58b140a09d834089711d6bc4e71f5761cc5e69c399629fb31bd0f7b2cf5dc99c5d166bd8e297d74e16334046774bfdb6cc2b403fee4ed7db0ae063ec1a905886229c0d8c52e9f8014dd9c661702d77b714ebc5cf220f24f7905e55bc40f0c6af2826a2c21efbe50bda87b0f24ef4cc52f80931df4eddc5396ace09758d89ab79391d9f6a00566ffcff0e2433da340fbe923ebc194be690c296e57b2d08c221a64a763071c3979f221ee815d94af2b0317fe015341ed2e955fd869be42a379b8a5eef2ee72ae6d7d0b6341f4697804cb6e27287990bfb4fa33a55e7ade5346bcc95d3d91b32bfecec1a4a4ace5e4eb26912235a2811d8cab037a23ea9d28be1bc3e8502cf8b9f127cf22ebba379b84ca139e8b8b27e0e2e0a8641e70bf65cb2c0128b30cc1598bb2713e2ecb0afff97538dc9d0e86b7e0681aa6c2182d3dcf5887e0b3fdc611fc5297a8bd5e46e8c037c6f58ed09a7a9396d90c505c8ad51462ebb3eba1f1bca9bac79e1eb3c160836c8619a1e0976264094e3f4349887becd8abb6b41d1a285800609fd2d34b4944e83e36df8ad1672be3ca0344826ec0ec30cbe0ad2ecc5f0034ac2fad9d37354a0da6569964b37d6a44b771188e62e814e75ecc494491139a9499a08a628164dc7a520da830ae9ff46ce8702cb737c6c70b0eb5469328c06069689af4c89d6e24f15b3a820ae88b7292ac4426733c4b13fc7d2cad7b03450e862dc4185d28fc39af8da8ffe040be361aeb88f321fe2cf9110885f57a8bb7505479f18774b26a79f2cb8e5b05c402311b18ebe86aaa46a9fffd2f509a90af2f3ecdfc82c3b3f8b7d58ee509ae1e27c05be1cf016e09409d1e7b33aa2b453a634bc7dacd419aa58e74aaeb0bbc31d623e73d2e0816b7cfa241c9a23ee1551ee2f369cf3782981b2140513d76f92a93c6a160954ea1261e16e5cf867e0eb7d2333375cac0220d655a86761b3b271a1bd63ccb226c5ffd19934fc9ddb62ea7da788c7d26a3be24d7e54b1b2b1dc4f43c9bf61251ef07f188acc7910bc078a81b5d2b1268fe8e06ddb07c8abaa932a9a13a0cee5d192bf5b82b64503b6127732870d11688baa3d646a0c49b88216ac23c36c18366d3cf1671f0b188169664282642cdc9ef1fdaa5a824f0968a97834b709f4306d96def41b7dbf50a4b9c014a7d7f75a0e2a5b230c105ce45337ed715519229a84b5e7f7651b8465fb84c1a6854f2ca6b7ec67fb8987c0391c999a43bcabec7f45ce1e4ef7d9413b3ec5392d013d2a42b80fb625697163c52cd887aa541f94da6925dbad48ded8a758a5590ed70cfcbfae96e856b244269f28722c75d8d93137c577f5aa3b03931b1d1317d5a565b40eb7775f38debfbea18687436fc8818f2c2dbc108f99fc90e8930cea7ca62524b2cb6c5558791722fc0a21f48d9c14107cb4251c27ae3a6b090ef3c89c338789c46417032b909d8619873e9c1ec3a84610d92432112b1017374c296759b561c77e2b672201d34bc42e00799ab7cfc70b104386b23b939b5bddfe53f51627ef742bd9d395342cd96a09b5d8041e5f879c64523e3ef61ea20b864c230ce04a6467aea521624685029c62b541479ada7290791a5d7897cc4fa77753f08c16623d3cbbd6132d349a7ce4749e90efa9064181777630226b080798085e760c3a89bd2c4523eb71d4063229a478d6ab87c360e27005e3444ad8327f7481331ae7b60fb6fbb0ea6d8244cb4817e1ece158e43c36a42b6c0ff94745f4f47d67dd9d44b11db3da207514fda7aab9babaefbeab1aae2974f5de25f0aecefc73147621e04738fe923018978710573a39f7a1c7cc9f853802792f03915c6ef06da8c6cc41e5f50b84f9a2b5d67e3a33d2b452b9598e78df8bd626969ca5c845ff6bd47c6367d2c43ed9580f999cabd42bc198feb6db59ab93cac74337812d990db75898f4d25e54dc4bdfd8135f709c26cb6cb537d054483cd326b40416cae5279c6d68acca28d0308385c403c2a581049965203b16628b4fc3eaf0516151d613f0e5607890d40db5d1dc97c37f475eb1b54fdc9d2c0673524bf281b9b3aae64ca8f93f3773ca55f95ba05ce62b94ba03e8ce1fad48968744279c89d9a32ea3cf04de30e6461339d46d2709f80602b382f69872c2afd1790eba663ead49cf59d8ba05f993a92f6adac58e7344f3fb81014d1e55ede7f1e4b193380338ea8001d5c662442623d1d7ed01b49b0404ac30959f8207f7a43a2353c2bae3f672eab59bde59fbae1b467149df9e7161fbd15a70bf7d48d72adbd38fd075f4d260ec0c1274feda2985804c2cdfe2ddf068b5628135b766ba53d163aaedcb445efedde23427ec7aca1b2632fc11c168eeb13bab726528dfb94f8ef2bf582f427c3c746125f9b57a05e7756e11b2ccfa06ed176323e344def7640f712a16cc8c297f7a2de15a7d96233ef5f5da3f6071aa8b1589f4fb5681bc7d0263a05b5aab18f9db46be38cac44f8a135fbae5ddc15c70022ca9c2367dc7d5efdc050d80602816b521137da83d75111417941d45445809bfa8a7da866112afd3d675246f17b1f0b5c9aebb2b99b2393169cd0c3a14a4b1864982be70366f7b3f35efd02a7e74e868debe26dff7626065035f8478771f19588cfcf46da8f9de1a71b60caf5f338dbddb643e220a0d960910cbad74c5f9355e11c20c228d1cdd66223db48f23a5d922ec2552d83d7ac6bd8910e2b4a059d108572f94b43420731dc4db9fcb98ea5f824a7191474e9635d305b58d33ab717216dfeb5633af6ef250b458472ae31d259ce3e914c220d2b72b46c91e8d1eb01cb135a380da399afb685c73f3b4c82f9ed2960c98b7509bbc8c97043e4f3bcba39a41075ed12f2cdbe6fd4bf81853accc736933efccda9039ad74cff44cf5294cf524a0a1d54360b2c4e5442b4855dd831c7865878c6230e020aedae02625a9738f164fe41418e0caac2924e390bf796c3287696dcfd7847722d044118e5618d331b23be477a60a9eb8d3118d7826e7b251660438d5f88b1e45e3ade4041bcff933eaf811679c43515329852246f22775c0af9219ec0d0340fd82b213672e51b4354ed4efc066757cbd835a6884f7966a4cc9b077a527e383bfbcfa648165bcff1e475fa98dfb3c9d372effe6be4ac2b4f3cd1dfe3aece1729a55a80e986a166cc692a28e5f25d617c666672c7f1857daa0221a13286104f3a08d69ae405c9d1b9fba020f27aab7e40ccf3ae7b2e8b5b2cfa1b300f657a798d5aaec9654ee85fe9341b70772c812b0bf532bd79e42fa66d3c5c22a8a7e98c7f2dcb6afaee37f40b0721036cbb575e3a39cc07189f5cc068202b6e71fcea929244bfa9cd5a4f2cdffa66a4f6c27a13ab8832fbf34a9faf150bb0e0c44b478af2bf4ed66076cd281789dd1cc11280c3c2777e74f0b1bb3ad3d22eb2e53470f883c72009aa1462d1cd46cca6d75bb16b8638152c23023f4e2c2c6910f89c7b6665a47ce7e3edf012791df0d00ea9bf248d59dabe101780d15b199d1270a460d19836e2c1cf7c6248fe0f3748282eb19935a58bb908df63d4a0e0c112bdf21af024490d302bc08e8a45c7d84edaf5e60c095fe3f4f19fd6ee973bde1bda704300d1cd82cf59d69c5f6c8b2faffda63d0756c18d2b80d567daa6192825ddea43ac7c59a5c8e5c951baf2e9e00fa952ea7f48e0bfe9bdd8e668853f0fd7aba4a42a711d5fac4841fe98796f75f14d4da8c6efc5f64e98f707eba6afbe4e3aead74ad9efdf142f7d65c5147510e701225ca5737c0b97b19c11a138658cc5ea81034753437a3da08f5295f61511e792606e083232aa421050ba70bdb98c9ecf1199e0ec24531394a09bfc9428505873cfbb4710c3c9f8efda1e70cb9c81949ad9ea1f65b8e222058ca28d282c56f2cb81f8da1f5b63a9e6df116dc77797ff955ba63f77c04dc91e5262778dee90c5e5acca5647a8ecfbce0fae5648e8b518d34c3e360d2f796889b84b137db4dfdc2144271bac7dfd105e62caf1bc576530503dc8787947d2e7c71cd4b035472426bb5727fe7b139a5782389ad2147cbcc4328a46a2d14cfef3db719fa0075b5414217782ba427c077dfb406247fb8a2c47865b0cbc8d26be08b9b02493d49f050a7a2c859b696d10e5fb00c47441b0efb779109dd101b33717dee34a4f10cc7981d4cd32c9be1bf85b78298d95b3c2a7426269e367090e2f99903d9e2ec820857b7152e7ea4858a62b21ec40f92d84c17fe2485af754e5801dd7d050e008bd87575c9e3af3e22ca54dbb86174cf1285ab093d65b1d8f946d1a6a596dd4934bf8e68421af1172484eafb47f48d28ea8171b062cc56bbd42d9004e35513865a70ebb923bf97db229b3eb6d20e0b80fc9bc2dd7219836f23bd8530e4699d1e4e24a880d7b4e7e90d6b77849ad625de710387a0ad622bf0fdeecb0eb3a559f9b0b223fa6de363ad50fb93075adfa00bd6b22c2929b3e0d2127b475e477c25da86dfb127103fd8334b42b3f2970936ab0ae4eab2cdef066ab2d4760e5001f5d0ec3a4b76b341e0162810109fbb77e4487aca92d7e877d9cda613befa38d437ee10fa1b25eaad22cd9ea2e8d66b4c003ce0f77b357e9c13c28222c912698537363543074ef0526e40d572b2c28190cdc9ea1821a54cb0b57d30c29b9b66afd8441ba3735fa8e932bfe5fa7faa303b73772a63973e3286f3d3de01fbe3a54503652c41092d4756d9eb11ce5512375a0e5d0d4209cd5d960c4f016fea08d369ee3576b6e8749a1a8542281caba608e7f603d058f38969e59252d67fc7c2c9dbd0012e9456e56a9a9d0a232cfa808a2da936756133296c76721cea6b6f134ed38dac84d65520ea58b3bd13a00ad61248aae270933f81ee2927644fa35ebb07a99791c5240727a0ef45d4df3133ed25975b3e87304b9340735c416f4e3bd5f228c029186fb61e720cfc18351a9562fe2e5a2a79389d64ffd42dc0e1d6c1d8723ac54cd2c2205ab71a5490391a3cbee2bbf5e2231f17e629cf295f8fcf21e9f181de4107d57f32ac82b4e966d3708fdd57e742057e11ae958a322721b8e35e14d4d7c54e776797f7ad913294f6c1d952f6f28a2467a5d8e4319f57edad169c02a84ef6c57f2a760480c436716fe1f3d679818498e6468eb660bbf34e10ffe74c0cd78ab872dd55d97bc3ca735a79d1282c075670cba3a031c98a297084489b9c4774d822cc90f20deb132276f245ffb0da638e2d060dc5aa7a85ec5dad4476b0d18b35239d95c3fb2048804050893c2544f4ea797c84267520bc6462bbd9fd32e9b6cc02271f5d3fbe8705db98369ed0454176aeeab835842a7f25da2f3749f74c1ca68d6ec57213ccaac28db12d2d77df6f53dd91dc1e061fe003a9123e5478f909aea6ef276f202439893436175e9005302bcd9469706250e7000dec344f3e38894fd9723cce76c22e6bb927dc32a835dfb9963f23d1ae4346568ed7e308278294d8ca0d24f2b50f3f2458ef7aabd72b3818f09a1ffbb7d6f0b1c7465ef783c06202cfbab843e0f1331011c0ad0da1e1114cfa2b307cda6eebeb99e669f322b0b046d3bcf06b74f7733db1626382b3bccfe327d0f127fb783273291f3b6a3fe3deb8f73769071b5ad91628fab46b6f8c4220a8c1c8772d5f7cba0da241700efe327cb2cd5dcf2d693be2b085bfc057d926384a06bc92e8f39f294b3d6875b3048b60c62f080313e8f1ebed72017ca0295b79b5151aab42ccef0c91b386089a1508af426d5ef6ab2d5b01bc43b076543ee3581e8347770999cdb03d6cec3e1e521926a5c3589f0ed784450e58f31da8b7eeee59241d2dc418d2a145bda20659919da1ede927d8b1aa590cf716b1692ab051443656723ee528b4288a43b772ffc67a7cb990dfa31dced34a70ec7c569b4ab5c203d2ae05eb54fef73a431e8160bafebef4d1c53f22a175f000c0478df89773b2ca87ce2bcb9b9fe5dfb0ededccd73e8d08d39f568049d1b3c7b10ef29170e1e5e0b1b7494e376018fe17684be9139e7c7d8cc3d220ae9d3e5004b7998a5c7fac3259ca3c72611a65b659a474d2224eb754a8a3811a65718618075bfedaea0b34220333d16fa73903aab791a32a0aebedc322dd8cdeed5c59c12e7cdab42521fc2596721510e93ad749d2eeaf2ab19d71982dd5f8518abc205c8bf4a961195c061327762bda4f44c568a632b5a2027b1c004b29e50d06dd0e874b29b320472b5b351f620bfac1ae017ca6248ff361c19b55879ab7d032d3ac7bdbb2badbbf7f84c788c4a0bbfd3680abd95242061365fcc257508b4ef383fd1e561fbd98e5ef7a19d92fc4b4c4c74a7e158c659fd7470478e9a50fa0a48b8fd7a8447721c9357397dcf2da4141a40c6ae28be0a62b30adc6ef94bf9af842d9a514f02c1321cf1274ab6a46af8d740ec5811199b8e6559bf853bcc71a3c43323e6da4051251e01c671381ff0df18b351cf4bc786f936c88ede687955bf7e89410b9c71be3e1373983c1b135d61736a5964ff2b546866c3d97365b8a5a007a0153c8b2cc80f83c77ba4bbb611fa4941ea11bbd54239dd001d06a0d5eabc1bb3ad41871e0d241f35c230c6fea29f9e6d587b1959f98f02e4dab521b6d6350cfebae33613d7e3aeff4c7005f0dd44bd195cdbcac7581a1d16903f6b0a02c1eb16266ce7c97b7532f0859463fa40f7e9ad37828294c1964d23bb2706922788501dc244310495c42087e3d526658fa4e60ba5f140e694f1a6e8e4d98996c625eed8f27b2a9152989ddce5810363414f3a590893e742670865db46bc1048aef46b6282c3b2f3f39a579458c97afc12597d27c72fa2f947bf8de47f421a33fbc6582864bc317604eb28155ba68825546661e7b79c1d2a01aa936ef340534497834fbec9f1bf843b87579aa3bd581da9b716d6245fcd99bb8ac725519a0645dd0f5a34a9b831124023f76a001a8f78aca8d3a0cddf6c0f3a7c7002f2863f13bf5cf1b5924f7c4c139254965a173bbdb3d48a46e5a34ccdf0babc3cd94ae60289fa99145520d377a29fb41c9a502dd1234b177cdc4cc874aba0e98300a7712bc44d66086584b197bea606b8a42c1a2cff5222eee9b536147f21f8cd96cea8abff98494ce2ba5ea2d76254bcc4bc20f22e525ee9339bac957dfdc9e3953fea51943df9c4b37b0fdaee127480885fc036de88f0ea776c329f6c85deb462a54342483406bb58ae7e59251cec722e0594cae1905b52dde493831092f5e23a4ded1a4b585e19a2b6ee93c442bc700aa17736817eb679b77b8e173cb7abdf39d9a0a28fa7d148ddd61ba805355aaa4eae7ce186fd3c3dff9a9c3974a8f135ce3fddadf23f25f8228fe4a9153e2652969ac4bf54e8c9aa8c4111b1ca7d977bc64e2c84155e4f3bea081f0bab29f5c1dbcfc713e29de32a0c96e40bb16e651e7defd812af5d5371065f1924bee239945f508334da45a3db0c0663d0a212f456d0ac39e76140a8981cee072e8f47868b8661448ae97beb6bc9d02865883da9d03b2ab23aa9c831aed52ebbe32e902b8531ba83a13ba17479e32af05bc2ac9856c1806acd104def8a49b21a0955d29e9c27a7decbe42bfb73b7a88ca21df0a40c43803d8027abc9ded2a89b63ca03007162cd2d3b9a2c2813861379702aaec9cea5be3c1aa2261de6f07f3a5b91a0ab4ceca1ad4bc85e785be31182ca326c58091d04fc087fb5b27f98e0f3cb7dac15f8c07a85d0a3b30eea8d395ed6b0c5a170b00f4dbf98ce4889ee9620351c8e30940f13aaf6f69dbc773841d0b121e4d3d3fa52708ccbc782d5bce5364a586fc7d1d7a9a2546ad227e759db9ef128a01eac478791deb529a972ef0913f8dc2dd357db38c8a004fd70111ac7badb6ddd27c30fc481e3725d12cc68e19986aae5f891e5a2e0f46f438c077fc6a874e4b49f72f2b2018a1425fff3c9268714e18d17e7cf927ca99815c1b218166a0705acf9f91dd5355514125ecefadb7356be75709ecd03e15cdf9a63f3be3e4c6e698dbe2ffa6983b6b99c32fae1bb04e75a9b30ac01b95cb1e147a5c9789129a18abffa1bccb6b24982f1fcbf00b30ab77e588c10796f814580ee62f88d04c499b0ed0070ced3852d40cfb9d9d9244b2b88b56557995122829446bb4b57a60f35a6dbed84ab1d1ca462e649df81b5e608e0b247991c640b98d613aed925693b8c64acac0e5425259a44622320e65f748886d1bd6c3a7f0d3828484d1e2262e9746d8c988c1569ffbf12cdf6a8e4ceff03e51ccf90fc3cf181b056e09c590353d2</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>落日记</title>
      <link href="/2019/02/17/essay/%E8%90%BD%E6%97%A5%E8%AE%B0/"/>
      <url>/2019/02/17/essay/%E8%90%BD%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-uBbJNRvT" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="17685905" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>应邀写的一篇稀里糊涂的日记，权当是好玩吧。写作的时间已经不可追溯了，大概是在大一下开学的时候。粗粗地记录了一下报道的事情。</p><a id="more"></a><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>&#160; &#160; &#160; &#160;太阳本来升的高高的，但是上海根本看不见。地上带有一些雨的印子。“明天是要下雨。”WU 君看着地上约 10 厘米的蚯蚓这么说。他们热乎的谈着篮球，什么三分啦，全明星啦。“这个投篮大赛是真的没意思”。F 君及 H 君聊得很是投机。我刚刚想的那一段是什么曲子里的来着？第几乐章？“有人可以从中线投到篮筐的吗？”“在空中连续投三个栏是什么意思”。表述不对。过了正大体育馆的门，然后是 WU 君寝室的门，然后是 C 君寝室的岔口。每周必有的罗森晚宴。哈，和 WU 君及 C 君都谈过的 2 的根号二次方的故事。“去年的特别好看……”，谁？然而名字我已经记不到了。然后是 H 君的寝室门口。“你们拐一下吧，能多聊一会。”“那能从中场投到篮框是真的厉害。”H 君已经离开了讨论。“是，NBA 的运动员和我们不是一个等级的。”“你系统是多少级的。”出寝室的时候 F 君如此问。　</p><p>　　“哎？你这么早到啦？”“还好吧。”出去吃早餐的时候刚刚碰见 F 君。“W 先生仍未出现……”然后去把教材买了。昨天溜达的太久，从这里到光华楼，再回来。于是我忘了。一定记着，不然教材会没有的。然而知识的门紧闭着是在早餐之后被发觉的。昨天我疑心食堂换了师傅，我该和 C 君说一下，毕竟是有趣的事。C 君还没到，C 君报到怎么办？不，等我先检验一下。于是和昨天的内容一样。蛋饼同昨日一般软，肉包却已是很久以前的味道。也许师傅换了一半，也许改良了一下，也许时日已长。其实应当买生煎的，好久没吃过了。生煎那里没有豆浆，不，不要排两次队。Lament, lethal…vital?不，不对。Nomadic, romantic。到我了。昨天师傅说点包子请指明种类。“肉包。”L 君提到的日记的事情，我应该用什么东西记一下？不然就忘完了嘛。馅泛黑色，酱油依然多，是上学期的 genre。看着豆浆盖里的泡泡。我也许拿了一批豆浆的最后一杯，豆浆也许是最少的。我昨天应当把第十章看完，然而还有一本书。对，我的书该还了。先还了再借出来。嗯！是恰空，我收藏过没有：没有，演奏者：不明。那上面写着巴赫。但是《韦洛克》不需要了。等会记着去买教材。对，是要记下来，我昨天什么没买齐来着。手机掏出来。洗发露……我没和 F 君说我昨天借用了一下，但是应该干了。和燕麦片。走吧，看看教材。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>&#160; &#160; &#160; &#160;今天应当是没有太阳了，“你报道去吗？”“不是的，买教材，你去不去买教材？”“你等我一会。”“一会是多久？”“十分钟。”“好。”手上有个扳手，刚刚做什么去了来着？不会借个扳手这么久的。那回去吧。合着节奏的敲击声的声音，为什么阿尔蒂夫尼的回礼是放屁显得费解。“扳手比锤子好用。”“不会吧？”“他还可以把弯的钉子扳正。”“好吧。”他的床板现在看起来结实了。等等，我要还书。让我先把书放进包里。我缺哪几本书？模电是紫色的。“你们什么班的？”“找模电。”我正找不到来着。那里，果然紫的。还有一本 C++的书。外面没有了，里面有几本，绝版了。绝版了为什么还当教材，有老师喜欢。果然有两本，红色的。我想起了《C++ primer》。一共 100.8.“好，支付宝在哪里？”哦，看见了，两毛钱。支付在哪里？哦，看见了，另一个码。“有红包可以领”老板说着，“72”。为什么便宜一点？对，他模电的辅导书没拿。帮他拿一本，多少钱来着？50.不是五折。“支付宝到账一佰……”。　　</p><p>　　“元宵节快乐哈，回去就给你打钱，[笑脸]。”“你这个寒假都听了些什么？”“有一首恰空特别好，维塔利的。”“喔喔，我知道，我听了一个寒假的平均律。”我看着手里的手机屏幕亮了又灭，F 君应该是开始睡午觉了，我该不该提醒一下？不了，Z 君挺高兴的样子。我们愉快地谈起赋格，我突然想起刚看完的第十章。“我给你看一个有趣的东西。”我搜索着《尤利西斯的注释》，并不在书架上，在书包里。啊，我忘记还书了，算了，明天去。我把书拎出来给 Z 君看，Z 君兴味盎然。于是平均率的声音从 Z 君的手机里传出来。于是 Strauss.R 的曲子从我的手机里传出来。于是莫钢的声音从 Z 君的手机里传出来。于是勋伯格月光下的比埃罗从我的手机里传出来。于是萨蒂某我不知道的曲子从 Z 君的手机里传出来。于是萨拉萨蒂的流浪者之歌从我的手机里传出来。“揉弦和颤音有什么区别？是手用的不一样吗？”我不知道，我可以查查。“帮我把琴拿过来吧，我正好在练揉弦。”我两天多没练琴了。上学期甚至更长。“那我先回去了。”“好”。F 君呼吸的声音涌进之后的沉默。我把琴放了回去。　　</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>&#160; &#160; &#160; &#160;“你去报道了吗？08:07”“没，在超市买东西，要帮忙带东西吗”“带两瓶矿泉水吧”“那你马上回来再去报道？”“是”“报道不是还早吗”“OK 那我等你一块吧”“嗯”。“GPA Tool 为什么已经下不了了 18:33”WU 君。等会，等会再回复，直接发给他。我的日记才开头。“[分享]各 DBG 简评 18:19”LY 君。等会，等会再回复他，他怕不是掉进了这个坑。“您的快递已签收。”　　</p><p>　　他好像开始研究多人游戏的打法了。我真的想看会书，去报到以前的那一章的最后几道题没有做出来。“我这个月要吃土了。”“我已经把我的女朋友拉进坑了。”不行，三缺一。“我现在正在给我初中的同学安利。”我这个月要吃土了……　　</p><p>　　“我系统是 7.0.0 的，三星系统升级一向比较保守，你应该是 8.0.0 的。”“我看下。”蓝厂的 apex，真的可怕。“你知不知道知乎被下架了？”拿进来外卖的 F 君如此问。“不知道。”“据说是讨论任期的事情。”“真是可怕……”耳机重新戴上。是莫扎特的小步舞曲？不是，是三重奏。“你知不知道 MWC2018 大会上 vivo 的 APEX？845，真正全面屏，连前置摄像头都没有，甚至有 HIFI 芯片……”于是我们走到了食堂。其实我想吃全家的。出门时我如是想，但毕竟时间还长。走到了难以抉择的三岔路口。“中午吃什么？”“我随便。”于是我迈上了右转的道路。“二楼吧。”于是我收敛了我的腿，迈上了上升的阶梯。阳光普照炒饭，我一直想吃来着。“阳光普照炒饭。”8 元。“我以为是黄金蛋炒饭…你看过《中华小当家》没有？”“你看过《神厨小福贵》没有。”于是迈上童年之路。路上有着游戏王的事，预言的事，反转的事，大反派的事。然后…“你看过《死神》？”“对啊，六年级开始看的，烂尾时伤心好久。”于是迈上讨论《死神》的小径，童年里的讨论者开始向寝室方向进发。　　</p><p>　　洗发露。于是开始向着学校外不远的超市移动。但是我的储值卡昨天就用完了。酸奶没有我要的口味，只能提着原味回寝室。我还是去学校里的超市吧，也许便宜一点。不，我已经走了一段距离了。骑车吗？不，那种东西会滑出来，而且车是湿的。燕麦片只有那种很大包的，那只能拿一瓶洗发露了。然后我的手机响了。　　</p><p>　　为何变成奥斯卡金曲些了。不行，我休息一下。　　</p><p>　　好了，现在是肖斯塔科维奇了。　　</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>&#160; &#160; &#160; &#160;为什么这个表情老是打不开，昨天是这样，前天是这样，这样都好久了。我是挺想给对面发一个滑稽的，不知道为什么这么突然喜欢上这个老游戏。啊？这个肖斯塔里面有人在唱歌？这么如痴如醉地买了这么多扩充包。网上说是 dpi 的问题，也有说是隐藏底栏的问题，我都试试吧。于是手机进入了反复调整重启的状态。太阳从来没出现过，但是天就开始黑了，该吃饭了。我的手机屏幕一会亮一会黑，不行，这个底栏太大了。重启。GALAXY S8。嗯，这个合适了，那个菜我没见过。“今天有汤圆。”对，我刚刚看见了。对，今天是元宵节。“我这儿元宵十五上物理课”一个不辨男女的头像。L 君。不要急啊，正在写啊。“汤圆在那边。”“不，就吃饭。”我想试试那个新菜。像是土豆。“我要那个土豆。”果然是甜的，也确实是土豆。里面的肉有股快餐店的味道？食堂或许真的来了新的师傅。那边有个同学的头发挺长的，眼睛都看不见了。我以前也这样，我以后也这样。再过几个月？　　</p><p>　　门口碰见了阿姨在浇水。“阿姨好。”“哎，你好，有你的快递。”浇的什么？蒜？“阿姨这是蒜吗？”“是，蒜发芽了就…你吃汤圆没有？”“没，我们那边不吃汤圆的。”我现在是在干什么来着。阿姨整理着一些快递的包裹。嗯，我是来领快递，我都忘了的。“你把那个表填了。”为什么要填这么多，原来不是只签字的么。也许还在放假的阶段。我抱着我的箱子继续向上攀登。</p><p>　　“是盖个章就可以走了吗？”H 君问辅导员先生。“是呀，盖个章，签个字就能走了。”“早知道我让个同学帮我办了，我能多睡几天懒觉。那延迟报道怎么办？”辅导员旁边站的是哪位？是他的女朋友？他女朋友长什么样的，我记不得了。上学期指导形势与政治来着。不，我不知道，不知道就不要乱说。那我们可以回去了。“话说我们组上学期讨论要聚餐的，趁没开学聚聚啊。”“晚上约了高中同学。”大家都忙啊，然而热闹是他们的，我……“你了解笔记本电脑吗？”“不，不清楚，在攒钱买，估计大二换。”我突然感到有人拍我，“嗨，新年快乐！”是 H 君。“嗨，好久不见。”“上海真是冷，来了就盖个章，早知道多睡几天。”“早来两天也挺……”“学校也真是的，如果晚开学两天，我妈绝对会多留我两天的，我等会问一下怎么延迟报道。”上海和成都温度没什么差别。哪里都一样。我想起了哈尔滨的三弟。愿安好吧。养生，现在也有 0 摄氏度了，没这么冷了。　　</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>&#160; &#160; &#160; &#160;这教材居然是哈工大的，果然……那那本程序语言呢？看起来特别厉害。原来是斯坦福的老教材。上学期那个教材是真的不像话，这本也许会比较有趣，网上评价还蛮好的。“去吃饭吗？”“我把床收好就去。”于是我开始计算偏导数。翻到昨天那一处。“x 与 y 的地位是平等的。”我记得我折了一下。对，是这里了。　　</p><p>　　“我找到了，不知道你有没有兴趣，我这里刚好有《死神》的一个游戏，PSP 移植的，刚好我还有模拟器，你要我考给你。”我应当继续看我 Python 的课，第五节看了一半了。“好，你给我嘛。”我饶有兴趣地看他玩了一小会，我的手机提醒来了。对，是看那个课的时间了。“你先玩着，我去看看书。”等等。微信。我们班有了个新同学？难道是今天……？不，不重要。耳机带上没多久，敲键盘的声音听不见了。对，他还在自己的座位上，但是应该是没玩了。一节课仍没看完，有敲门的声音。W 君到啦？不，里面探出 Z 君的头。“你烫头发了。”Z 君与 F 君攀谈起来。过了一会，他进了我的寝室。“你在干什么？你剪头发啦？”午饭那个同学头发确实挺长的。我把包挪出来给 Z 君一个位子。书包里有什么？</p><p>　　我不知道。这么多问题自问自答有什么好的。“汇了 2000 元哈，元宵节快乐[微笑]。”我不知道，元宵节应该是个团圆的日子吧。我在昨天看见了月亮，成都是不可能看见月亮的。但是上海的月亮异常的清晰，它是那么的圆，那么的白，像绕成环的抽纸，像漂白的太阳在污水里燃烧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bonjour</title>
      <link href="/2019/01/01/essay/Bonjour/"/>
      <url>/2019/01/01/essay/Bonjour/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>    <div id="aplayer-JIwBXmFB" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="465469873" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p>這是 Joseph 的博客。也許你在其他地方幾乎聽不見他的聲音。但是這裡可能會留存一些，我是說可能。當然，很感謝你可以找到這個地方。</p><a id="more"></a><p>但是有幾個麻煩的問題需要解決。</p><h2 id="Joseph爲什麼寫博客？"><a href="#Joseph爲什麼寫博客？" class="headerlink" title="Joseph爲什麼寫博客？"></a>Joseph爲什麼寫博客？</h2><p>正如前面提到的，也許在大多數情況下，這個博客的主人都會保持沉默。或許有一些特殊的理由，但他自己也不知道。或許是他希望可以和別人分享一些小小的東西，當這些東西在心裡產生了巨大的重量，以致於他需要排泄出來。</p><p>或者他只是簡單地希望一小部分人——很小的一部分人知道這個鬼鬼祟祟的人在想一些什麼，或者干一些什麼。當然，這樣解釋並不是很合理，大部分人閱讀信息的目的也許並不是爲了了解其他人，而是爲了更好地理解自己。所以下一個問題是：</p><h2 id="Joseph的博客寫給誰？"><a href="#Joseph的博客寫給誰？" class="headerlink" title="Joseph的博客寫給誰？"></a>Joseph的博客寫給誰？</h2><p>這個問題同樣是難以回答的。因爲大部分人應該都意識不到這個網址的存在，Joseph 自己也不知道這個衝動將要維持多久。同時他不知道可能會有興趣看這些雜七雜八的人在哪裡。但是無論是誰，一定是 Joseph 的朋友們吧，不論他們曾否蒙面。</p><p>但是很大意義上，這個博客是 Joseph 寫給自己的。現代人缺乏一種自我溝通的方式，也變得健忘。也許他只是打算用這種方式讓一些片段的思維可以保留的更遠一點而已，讓以後的自己可以知道他原來在這個星期天的下午在思考一些什麼樣的東西，讀了一些什麼樣的書，給出了什麼樣的評價，學習了一些什麼樣的技術。如此就可以了。</p><p>當然，我歡迎我的其他朋友。很高興我們可以在這裡碰面，並且一些人或許願意多停留一會，多來幾次聽這個稀里糊塗的人的絮絮叨叨。我很感謝你們。但是你們可以在這裡找到一些什麼呢？</p><h2 id="Joseph在這裡寫一些什麼？"><a href="#Joseph在這裡寫一些什麼？" class="headerlink" title="Joseph在這裡寫一些什麼？"></a>Joseph在這裡寫一些什麼？</h2><p>他原本的初衷是想做一些永久的，私人的筆記。然而這個野心迅速就擴大了。也許這裡將變成一個半公開的思維的儲存地。會有很多混亂的言語進入其中。但很有可能的，這裡面是一些關於文字、音樂、思考、科技的東西，但是除此之外可能會夾雜一些隨意的筆記，那種散漫的，毫無目的的簡短文字。我知道你懂我的意思。當然，初衷：一些學習的筆記。</p><h2 id="如何聯繫Joseph？如果你想聊幾句？"><a href="#如何聯繫Joseph？如果你想聊幾句？" class="headerlink" title="如何聯繫Joseph？如果你想聊幾句？"></a>如何聯繫Joseph？如果你想聊幾句？</h2><p>嗯，他並不想讓他的讀者們在文章下面拉拉雜雜的討論自己拉拉雜雜的文字，所以？郵件聯繫他吧。他也許會很快回覆你，也許不會。這個幾率可能和那一天出太陽沒有相關。總之他一定會回復的。如果有一些有意思的話題，他希望更深入的探討，他也許會寫一封公開信，當然在徵得同意之後。</p><p>總之就是如此了，我很感謝你們的到來。讓我覺得這裡有那麼一點點的人情味。再次感謝。祝好。</p><h2 id="P-S-如果你是第一次來到這裡"><a href="#P-S-如果你是第一次來到這裡" class="headerlink" title="P.S. 如果你是第一次來到這裡"></a>P.S. 如果你是第一次來到這裡</h2><p><strong>關於字體</strong></p><p>本來 Joseph 打算將 Blog 的字體統一爲自己常常使用瀏覽器時設定的字體，但似乎對於字體的客制化沒有非常好的方案。使用將字體掛在網路上的方法，每一次刷新需要從網站上拉取字體文件導致訪問體驗驟降。這在 Joseph 看來是不能忍受的延遲（這關乎美感），於是最後還是砍掉了使用特殊的字體。</p><p>現在的字體設定將會使用查看網頁的設備自己的字體庫，如果在設備中恰巧擁有同樣的字體，它會以正確的方式呈現。如果你們有興趣的話，可以主動在自己的設備上安裝相同的字體。這是通往這個字體 [源樣明體] 的<a href="https://github.com/ButTaiwan/genyo-font" target="_blank" rel="noopener">Link</a>。你們可以通過點擊這個<a href="https://josep-h.gitee.io/images/GenYoMinTW-Medium.ttf">Link</a>進行主動下載安裝。（這個流程在 Windows 系統下非常容易。）以下是這個字體的效果：</p><center><img src="/images/font_example.jpg" width="80%" height="80%" /></center>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
